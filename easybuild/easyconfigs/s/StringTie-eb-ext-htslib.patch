diff -ruN stringtie.orig/htslib/bcf_sr_sort.c stringtie/htslib/bcf_sr_sort.c
--- stringtie.orig/htslib/bcf_sr_sort.c	2024-02-28 13:57:39.701246126 +0100
+++ stringtie/htslib/bcf_sr_sort.c	1970-01-01 01:00:00.000000000 +0100
@@ -1,685 +0,0 @@
-/*
-    Copyright (C) 2017-2019 Genome Research Ltd.
-
-    Author: Petr Danecek <pd3@sanger.ac.uk>
-
-    Permission is hereby granted, free of charge, to any person obtaining a copy
-    of this software and associated documentation files (the "Software"), to deal
-    in the Software without restriction, including without limitation the rights
-    to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
-    copies of the Software, and to permit persons to whom the Software is
-    furnished to do so, subject to the following conditions:
-
-    The above copyright notice and this permission notice shall be included in
-    all copies or substantial portions of the Software.
-
-    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
-    IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
-    FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
-    AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
-    LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
-    OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
-    THE SOFTWARE.
-*/
-
-#define HTS_BUILDING_LIBRARY // Enables HTSLIB_EXPORT, see htslib/hts_defs.h
-#include <config.h>
-
-#include <assert.h>
-#include <strings.h>
-
-#include "bcf_sr_sort.h"
-#include "htslib/khash_str2int.h"
-#include "htslib/kbitset.h"
-
-#define SR_REF   1
-#define SR_SNP   2
-#define SR_INDEL 4
-#define SR_OTHER 8
-#define SR_SCORE(srt,a,b) (srt)->score[((a)<<4)|(b)]
-
-// Logical AND
-static inline int kbs_logical_and(kbitset_t *bs1, kbitset_t *bs2)
-{
-    // General case, bitsets of unequal size:
-    //  int i, n = bs1->n < bs2->n ? bs1->n : bs2->n;
-    int i, n = bs1->n;
-
-    for (i=0; i<n; i++) if ( bs1->b[i] & bs2->b[i] ) return 1;
-    return 0;
-}
-
-// Bitwise OR, dst will be modified, src will be left unchanged
-static inline void kbs_bitwise_or(kbitset_t *dst, kbitset_t *src)
-{
-    int i;
-    for (i=0; i<dst->n; i++) dst->b[i] |= src->b[i];
-}
-
-
-static void bcf_sr_init_scores(sr_sort_t *srt)
-{
-    int i,jbit,kbit;
-
-    // lower number = lower priority, zero means forbidden
-
-    if ( srt->pair & BCF_SR_PAIR_ANY ) srt->pair |= (BCF_SR_PAIR_SNPS | BCF_SR_PAIR_INDELS | BCF_SR_PAIR_SNP_REF | BCF_SR_PAIR_INDEL_REF);
-    if ( srt->pair & BCF_SR_PAIR_SNPS ) SR_SCORE(srt,SR_SNP,SR_SNP) = 3;
-    if ( srt->pair & BCF_SR_PAIR_INDELS ) SR_SCORE(srt,SR_INDEL,SR_INDEL) = 3;
-    if ( srt->pair & BCF_SR_PAIR_SNP_REF )
-    {
-        SR_SCORE(srt,SR_SNP,SR_REF) = 2;
-        SR_SCORE(srt,SR_REF,SR_SNP) = 2;
-    }
-    if ( srt->pair & BCF_SR_PAIR_INDEL_REF )
-    {
-        SR_SCORE(srt,SR_INDEL,SR_REF) = 2;
-        SR_SCORE(srt,SR_REF,SR_INDEL) = 2;
-    }
-    if ( srt->pair & BCF_SR_PAIR_ANY )
-    {
-        for (i=0; i<256; i++)
-            if ( !srt->score[i] ) srt->score[i] = 1;
-    }
-
-    // set all combinations
-    for (i=0; i<256; i++)
-    {
-        if ( srt->score[i] ) continue;      // already set
-        int max = 0;
-        for (jbit=0; jbit<4; jbit++)        // high bits
-        {
-            int j = 1<<jbit;
-            if ( !(i & (j<<4)) ) continue;
-            for (kbit=0; kbit<4; kbit++)    // low bits
-            {
-                int k = 1<<kbit;
-                if ( !(i & k) ) continue;
-                if ( max < SR_SCORE(srt,j,k) ) max = SR_SCORE(srt,j,k);
-            }
-        }
-        srt->score[i] = max;
-    }
-}
-static int multi_is_exact(var_t *avar, var_t *bvar)
-{
-    if ( avar->nalt != bvar->nalt ) return 0;
-
-    int alen = strlen(avar->str);
-    int blen = strlen(bvar->str);
-    if ( alen != blen ) return 0;
-
-    char *abeg = avar->str;
-    while ( *abeg )
-    {
-        char *aend = abeg;
-        while ( *aend && *aend!=',' ) aend++;
-
-        char *bbeg = bvar->str;
-        while ( *bbeg )
-        {
-            char *bend = bbeg;
-            while ( *bend && *bend!=',' ) bend++;
-            if ( bend - bbeg == aend - abeg && !strncasecmp(abeg,bbeg,bend-bbeg) ) break;
-            bbeg = *bend ? bend+1 : bend;
-        }
-        if ( !*bbeg ) return 0;
-
-        abeg = *aend ? aend+1 : aend;
-    }
-    return 1;
-}
-static int multi_is_subset(var_t *avar, var_t *bvar)
-{
-    char *abeg = avar->str;
-    while ( *abeg )
-    {
-        char *aend = abeg;
-        while ( *aend && *aend!=',' ) aend++;
-
-        char *bbeg = bvar->str;
-        while ( *bbeg )
-        {
-            char *bend = bbeg;
-            while ( *bend && *bend!=',' ) bend++;
-            if ( bend - bbeg == aend - abeg && !strncasecmp(abeg,bbeg,bend-bbeg) ) return 1;
-            bbeg = *bend ? bend+1 : bend;
-        }
-        abeg = *aend ? aend+1 : aend;
-    }
-    return 0;
-}
-static uint32_t pairing_score(sr_sort_t *srt, int ivset, int jvset)
-{
-    varset_t *iv = &srt->vset[ivset];
-    varset_t *jv = &srt->vset[jvset];
-
-    // Restrictive logic: the strictest type from a group is selected,
-    // so that, for example, snp+ref does not lead to the inclusion of an indel
-    int i,j;
-    uint32_t min = UINT32_MAX;
-    for (i=0; i<iv->nvar; i++)
-    {
-        var_t *ivar = &srt->var[iv->var[i]];
-        for (j=0; j<jv->nvar; j++)
-        {
-            var_t *jvar = &srt->var[jv->var[j]];
-            if ( srt->pair & BCF_SR_PAIR_EXACT )
-            {
-                if ( ivar->type != jvar->type ) continue;
-                if ( !strcmp(ivar->str,jvar->str) ) return UINT32_MAX;  // exact match, best possibility
-                if ( multi_is_exact(ivar,jvar) ) return UINT32_MAX; // identical alleles
-                continue;
-            }
-            if ( ivar->type==jvar->type && !strcmp(ivar->str,jvar->str) ) return UINT32_MAX;  // exact match, best possibility
-            if ( ivar->type & jvar->type && multi_is_subset(ivar,jvar) ) return UINT32_MAX; // one of the alleles is identical
-
-            uint32_t score = SR_SCORE(srt,ivar->type,jvar->type);
-            if ( !score ) return 0;     // some of the varsets in the two groups are not compatible, will not pair
-            if ( min>score ) min = score;
-        }
-    }
-    if ( srt->pair & BCF_SR_PAIR_EXACT ) return 0;
-
-    assert( min!=UINT32_MAX );
-
-    uint32_t cnt = 0;
-    for (i=0; i<iv->nvar; i++) cnt += srt->var[iv->var[i]].nvcf;
-    for (j=0; j<jv->nvar; j++) cnt += srt->var[jv->var[j]].nvcf;
-
-    return (1u<<(28+min)) + cnt;
-}
-static void remove_vset(sr_sort_t *srt, int jvset)
-{
-    if ( jvset+1 < srt->nvset )
-    {
-        varset_t tmp = srt->vset[jvset];
-        memmove(&srt->vset[jvset], &srt->vset[jvset+1], sizeof(varset_t)*(srt->nvset - jvset - 1));
-        srt->vset[srt->nvset-1] = tmp;
-
-        int *jmat = srt->pmat + jvset*srt->ngrp;
-        memmove(jmat, &jmat[srt->ngrp],sizeof(int)*(srt->nvset - jvset - 1)*srt->ngrp);
-
-        memmove(&srt->cnt[jvset], &srt->cnt[jvset+1], sizeof(int)*(srt->nvset - jvset - 1));
-    }
-    srt->nvset--;
-}
-static int merge_vsets(sr_sort_t *srt, int ivset, int jvset)
-{
-    int i,j;
-    if ( ivset > jvset ) { i = ivset; ivset = jvset; jvset = i; }
-
-    varset_t *iv = &srt->vset[ivset];
-    varset_t *jv = &srt->vset[jvset];
-
-    kbs_bitwise_or(iv->mask,jv->mask);
-
-    i = iv->nvar;
-    iv->nvar += jv->nvar;
-    hts_expand(int, iv->nvar, iv->mvar, iv->var);
-    for (j=0; j<jv->nvar; j++,i++) iv->var[i] = jv->var[j];
-
-    int *imat = srt->pmat + ivset*srt->ngrp;
-    int *jmat = srt->pmat + jvset*srt->ngrp;
-    for (i=0; i<srt->ngrp; i++) imat[i] += jmat[i];
-    srt->cnt[ivset] += srt->cnt[jvset];
-
-    remove_vset(srt, jvset);
-
-    return ivset;
-}
-
-static int push_vset(sr_sort_t *srt, int ivset)
-{
-    varset_t *iv = &srt->vset[ivset];
-    int i,j;
-    for (i=0; i<srt->sr->nreaders; i++)
-    {
-        vcf_buf_t *buf = &srt->vcf_buf[i];
-        buf->nrec++;
-        hts_expand(bcf1_t*,buf->nrec,buf->mrec,buf->rec);
-        buf->rec[buf->nrec-1] = NULL;
-    }
-    for (i=0; i<iv->nvar; i++)
-    {
-        var_t *var = &srt->var[ iv->var[i] ];
-        for (j=0; j<var->nvcf; j++)
-        {
-            int jvcf = var->vcf[j];
-            vcf_buf_t *buf = &srt->vcf_buf[jvcf];
-            buf->rec[buf->nrec-1] = var->rec[j];
-        }
-    }
-    remove_vset(srt, ivset);
-    return 0; // FIXME: check for errs in this function
-}
-
-static int cmpstringp(const void *p1, const void *p2)
-{
-    return strcmp(* (char * const *) p1, * (char * const *) p2);
-}
-
-#if DEBUG_VSETS
-void debug_vsets(sr_sort_t *srt)
-{
-    int i,j,k;
-    for (i=0; i<srt->nvset; i++)
-    {
-        fprintf(stderr,"dbg_vset %d:", i);
-        for (j=0; j<srt->vset[i].mask->n; j++) fprintf(stderr,"%c%lu",j==0?' ':':',srt->vset[i].mask->b[j]);
-        fprintf(stderr,"\t");
-        for (j=0; j<srt->vset[i].nvar; j++)
-        {
-            var_t *var = &srt->var[srt->vset[i].var[j]];
-            fprintf(stderr,"\t%s",var->str);
-            for (k=0; k<var->nvcf; k++)
-                fprintf(stderr,"%c%d", k==0?':':',',var->vcf[k]);
-        }
-        fprintf(stderr,"\n");
-    }
-}
-#endif
-
-#if DEBUG_VBUF
-void debug_vbuf(sr_sort_t *srt)
-{
-    int i, j;
-    for (j=0; j<srt->vcf_buf[0].nrec; j++)
-    {
-        fprintf(stderr,"dbg_vbuf %d:\t", j);
-        for (i=0; i<srt->sr->nreaders; i++)
-        {
-            vcf_buf_t *buf = &srt->vcf_buf[i];
-            fprintf(stderr,"\t%"PRIhts_pos, buf->rec[j] ? buf->rec[j]->pos+1 : 0);
-        }
-        fprintf(stderr,"\n");
-    }
-}
-#endif
-
-static char *grp_create_key(sr_sort_t *srt)
-{
-    if ( !srt->str.l ) return strdup("");
-    int i;
-    hts_expand(char*,srt->noff,srt->mcharp,srt->charp);
-    for (i=0; i<srt->noff; i++)
-    {
-        srt->charp[i] = srt->str.s + srt->off[i];
-        if ( i>0 ) srt->charp[i][-1] = 0;
-    }
-    qsort(srt->charp, srt->noff, sizeof(*srt->charp), cmpstringp);
-    char *ret = (char*) malloc(srt->str.l + 1), *ptr = ret;
-    for (i=0; i<srt->noff; i++)
-    {
-        int len = strlen(srt->charp[i]);
-        memcpy(ptr, srt->charp[i], len);
-        ptr += len + 1;
-        ptr[-1] = i+1==srt->noff ? 0 : ';';
-    }
-    return ret;
-}
-int bcf_sr_sort_set_active(sr_sort_t *srt, int idx)
-{
-    hts_expand(int,idx+1,srt->mactive,srt->active);
-    srt->nactive = 1;
-    srt->active[srt->nactive - 1] = idx;
-    return 0; // FIXME: check for errs in this function
-}
-int bcf_sr_sort_add_active(sr_sort_t *srt, int idx)
-{
-    hts_expand(int,idx+1,srt->mactive,srt->active);
-    srt->nactive++;
-    srt->active[srt->nactive - 1] = idx;
-    return 0; // FIXME: check for errs in this function
-}
-static int bcf_sr_sort_set(bcf_srs_t *readers, sr_sort_t *srt, const char *chr, hts_pos_t min_pos)
-{
-    if ( !srt->grp_str2int )
-    {
-        // first time here, initialize
-        if ( !srt->pair )
-        {
-            if ( readers->collapse==COLLAPSE_NONE ) readers->collapse = BCF_SR_PAIR_EXACT;
-            bcf_sr_set_opt(readers, BCF_SR_PAIR_LOGIC, readers->collapse);
-        }
-        bcf_sr_init_scores(srt);
-        srt->grp_str2int = khash_str2int_init();
-        srt->var_str2int = khash_str2int_init();
-    }
-    int k;
-    khash_t(str2int) *hash;
-    hash = srt->grp_str2int;
-    for (k=0; k < kh_end(hash); k++)
-        if ( kh_exist(hash,k) ) free((char*)kh_key(hash,k));
-    hash = srt->var_str2int;
-    for (k=0; k < kh_end(hash); k++)
-        if ( kh_exist(hash,k) ) free((char*)kh_key(hash,k));
-    kh_clear(str2int, srt->grp_str2int);
-    kh_clear(str2int, srt->var_str2int);
-    srt->ngrp = srt->nvar = srt->nvset = 0;
-
-    grp_t grp;
-    memset(&grp,0,sizeof(grp_t));
-
-    // group VCFs into groups, each with a unique combination of variants in the duplicate lines
-    int ireader,ivar,irec,igrp,ivset,iact;
-    for (ireader=0; ireader<readers->nreaders; ireader++) srt->vcf_buf[ireader].nrec = 0;
-    for (iact=0; iact<srt->nactive; iact++)
-    {
-        ireader = srt->active[iact];
-        bcf_sr_t *reader = &readers->readers[ireader];
-        int rid   = bcf_hdr_name2id(reader->header, chr);
-        grp.nvar  = 0;
-        hts_expand(int,reader->nbuffer,srt->moff,srt->off);
-        srt->noff  = 0;
-        srt->str.l = 0;
-        for (irec=1; irec<=reader->nbuffer; irec++)
-        {
-            bcf1_t *line = reader->buffer[irec];
-            if ( line->rid!=rid || line->pos!=min_pos ) break;
-
-            if ( srt->str.l ) kputc(';',&srt->str);
-            srt->off[srt->noff++] = srt->str.l;
-            size_t beg = srt->str.l;
-            for (ivar=1; ivar<line->n_allele; ivar++)
-            {
-                if ( ivar>1 ) kputc(',',&srt->str);
-                kputs(line->d.allele[0],&srt->str);
-                kputc('>',&srt->str);
-                kputs(line->d.allele[ivar],&srt->str);
-            }
-            if ( line->n_allele==1 )
-            {
-                kputs(line->d.allele[0],&srt->str);
-                kputsn(">.",2,&srt->str);
-            }
-
-            // Create new variant or attach to existing one. But careful, there can be duplicate
-            // records with the same POS,REF,ALT (e.g. in dbSNP-b142)
-            char *var_str = beg + srt->str.s;
-            int ret, var_idx = 0, var_end = srt->str.l;
-            while ( 1 )
-            {
-                ret = khash_str2int_get(srt->var_str2int, var_str, &ivar);
-                if ( ret==-1 ) break;
-
-                var_t *var = &srt->var[ivar];
-                if ( var->vcf[var->nvcf-1] != ireader ) break;
-
-                srt->str.l = var_end;
-                kputw(var_idx, &srt->str);
-                var_str = beg + srt->str.s;
-                var_idx++;
-            }
-            if ( ret==-1 )
-            {
-                ivar = srt->nvar++;
-                hts_expand0(var_t,srt->nvar,srt->mvar,srt->var);
-                srt->var[ivar].nvcf = 0;
-                khash_str2int_set(srt->var_str2int, strdup(var_str), ivar);
-                free(srt->var[ivar].str);   // possible left-over from the previous position
-            }
-            var_t *var = &srt->var[ivar];
-            var->nalt = line->n_allele - 1;
-            var->type = bcf_get_variant_types(line);
-            srt->str.s[var_end] = 0;
-            if ( ret==-1 )
-                var->str = strdup(var_str);
-
-            int mvcf = var->mvcf;
-            var->nvcf++;
-            hts_expand0(int*, var->nvcf, var->mvcf, var->vcf);
-            if ( mvcf != var->mvcf ) var->rec = (bcf1_t **) realloc(var->rec,sizeof(bcf1_t*)*var->mvcf);
-            var->vcf[var->nvcf-1] = ireader;
-            var->rec[var->nvcf-1] = line;
-
-            grp.nvar++;
-            hts_expand(var_t,grp.nvar,grp.mvar,grp.var);
-            grp.var[grp.nvar-1] = ivar;
-        }
-        char *grp_key = grp_create_key(srt);
-        int ret = khash_str2int_get(srt->grp_str2int, grp_key, &igrp);
-        if ( ret==-1 )
-        {
-            igrp = srt->ngrp++;
-            hts_expand0(grp_t, srt->ngrp, srt->mgrp, srt->grp);
-            free(srt->grp[igrp].var);
-            srt->grp[igrp] = grp;
-            srt->grp[igrp].key = grp_key;
-            khash_str2int_set(srt->grp_str2int, grp_key, igrp);
-            memset(&grp,0,sizeof(grp_t));
-        }
-        else
-            free(grp_key);
-        srt->grp[igrp].nvcf++;
-    }
-    free(grp.var);
-
-    // initialize bitmask - which groups is the variant present in
-    for (ivar=0; ivar<srt->nvar; ivar++)
-    {
-        if ( kbs_resize(&srt->var[ivar].mask, srt->ngrp) < 0 )
-        {
-            fprintf(stderr, "[%s:%d %s] kbs_resize failed\n", __FILE__,__LINE__,__func__);
-            exit(1);
-        }
-        kbs_clear(srt->var[ivar].mask);
-    }
-    for (igrp=0; igrp<srt->ngrp; igrp++)
-    {
-        for (ivar=0; ivar<srt->grp[igrp].nvar; ivar++)
-        {
-            int i = srt->grp[igrp].var[ivar];
-            kbs_insert(srt->var[i].mask, igrp);
-        }
-    }
-
-    // create the initial list of variant sets
-    for (ivar=0; ivar<srt->nvar; ivar++)
-    {
-        ivset = srt->nvset++;
-        hts_expand0(varset_t, srt->nvset, srt->mvset, srt->vset);
-
-        varset_t *vset = &srt->vset[ivset];
-        vset->nvar = 1;
-        hts_expand0(var_t, vset->nvar, vset->mvar, vset->var);
-        vset->var[vset->nvar-1] = ivar;
-        var_t *var  = &srt->var[ivar];
-        vset->cnt   = var->nvcf;
-        if ( kbs_resize(&vset->mask, srt->ngrp) < 0 )
-        {
-            fprintf(stderr, "[%s:%d %s] kbs_resize failed\n", __FILE__,__LINE__,__func__);
-            exit(1);
-        }
-        kbs_clear(vset->mask);
-        kbs_bitwise_or(vset->mask, var->mask);
-
-        int type = 0;
-        if ( var->type==VCF_REF ) type |= SR_REF;
-        else
-        {
-            if ( var->type & VCF_SNP ) type |= SR_SNP;
-            if ( var->type & VCF_MNP ) type |= SR_SNP;
-            if ( var->type & VCF_INDEL ) type |= SR_INDEL;
-            if ( var->type & VCF_OTHER ) type |= SR_OTHER;
-        }
-        var->type = type;
-    }
-#if DEBUG_VSETS
-    debug_vsets(srt);
-#endif
-
-    // initialize the pairing matrix
-    hts_expand(int, srt->ngrp*srt->nvset, srt->mpmat, srt->pmat);
-    hts_expand(int, srt->nvset, srt->mcnt, srt->cnt);
-    memset(srt->pmat, 0, sizeof(*srt->pmat)*srt->ngrp*srt->nvset);
-    for (ivset=0; ivset<srt->nvset; ivset++)
-    {
-        varset_t *vset = &srt->vset[ivset];
-        for (igrp=0; igrp<srt->ngrp; igrp++) srt->pmat[ivset*srt->ngrp+igrp] = 0;
-        srt->cnt[ivset] = vset->cnt;
-    }
-
-    // pair the lines
-    while ( srt->nvset )
-    {
-#if DEBUG_VSETS
-    fprintf(stderr,"\n");
-    debug_vsets(srt);
-#endif
-
-        int imax = 0;
-        for (ivset=1; ivset<srt->nvset; ivset++)
-            if ( srt->cnt[imax] < srt->cnt[ivset] ) imax = ivset;
-
-        int ipair = -1;
-        uint32_t max_score = 0;
-        for (ivset=0; ivset<srt->nvset; ivset++)
-        {
-            if ( kbs_logical_and(srt->vset[imax].mask,srt->vset[ivset].mask) ) continue;   // cannot be merged
-            uint32_t score = pairing_score(srt, imax, ivset);
-            // fprintf(stderr,"score: %d %d, logic=%d \t..\t %u\n", imax,ivset,srt->pair,score);
-            if ( max_score < score ) { max_score = score; ipair = ivset; }
-        }
-
-        // merge rows creating a new variant set this way
-        if ( ipair!=-1 && ipair!=imax )
-        {
-            imax = merge_vsets(srt, imax, ipair);
-            continue;
-        }
-
-        push_vset(srt, imax);
-    }
-
-    srt->chr = chr;
-    srt->pos = min_pos;
-
-    return 0;  // FIXME: check for errs in this function
-}
-
-int bcf_sr_sort_next(bcf_srs_t *readers, sr_sort_t *srt, const char *chr, hts_pos_t min_pos)
-{
-    int i,j;
-    assert( srt->nactive>0 );
-
-    if ( srt->nsr != readers->nreaders )
-    {
-        srt->sr = readers;
-        if ( srt->nsr < readers->nreaders )
-        {
-            srt->vcf_buf = (vcf_buf_t*) realloc(srt->vcf_buf,readers->nreaders*sizeof(vcf_buf_t));
-            memset(srt->vcf_buf + srt->nsr, 0, sizeof(vcf_buf_t)*(readers->nreaders - srt->nsr));
-            if ( srt->msr < srt->nsr ) srt->msr = srt->nsr;
-        }
-        srt->nsr = readers->nreaders;
-        srt->chr = NULL;
-    }
-    if ( srt->nactive == 1 )
-    {
-        if ( readers->nreaders>1 )
-            memset(readers->has_line, 0, readers->nreaders*sizeof(*readers->has_line));
-        bcf_sr_t *reader = &readers->readers[srt->active[0]];
-        assert( reader->buffer[1]->pos==min_pos );
-        bcf1_t *tmp = reader->buffer[0];
-        for (j=1; j<=reader->nbuffer; j++) reader->buffer[j-1] = reader->buffer[j];
-        reader->buffer[ reader->nbuffer ] = tmp;
-        reader->nbuffer--;
-        readers->has_line[srt->active[0]] = 1;
-        return 1;
-    }
-    if ( !srt->chr || srt->pos!=min_pos || strcmp(srt->chr,chr) ) bcf_sr_sort_set(readers, srt, chr, min_pos);
-
-    if ( !srt->vcf_buf[0].nrec ) return 0;
-
-#if DEBUG_VBUF
-    debug_vbuf(srt);
-#endif
-
-    int nret = 0;
-    for (i=0; i<srt->sr->nreaders; i++)
-    {
-        vcf_buf_t *buf = &srt->vcf_buf[i];
-
-        if ( buf->rec[0] )
-        {
-            bcf_sr_t *reader = &srt->sr->readers[i];
-            for (j=1; j<=reader->nbuffer; j++)
-                if ( reader->buffer[j] == buf->rec[0] ) break;
-
-            assert( j<=reader->nbuffer );
-
-            bcf1_t *tmp = reader->buffer[0];
-            reader->buffer[0] = reader->buffer[j++];
-            for (; j<=reader->nbuffer; j++) reader->buffer[j-1] = reader->buffer[j];
-            reader->buffer[ reader->nbuffer ] = tmp;
-            reader->nbuffer--;
-
-            nret++;
-            srt->sr->has_line[i] = 1;
-        }
-        else
-            srt->sr->has_line[i] = 0;
-
-        buf->nrec--;
-        if ( buf->nrec > 0 )
-            memmove(buf->rec, &buf->rec[1], buf->nrec*sizeof(bcf1_t*));
-    }
-    return nret;
-}
-void bcf_sr_sort_remove_reader(bcf_srs_t *readers, sr_sort_t *srt, int i)
-{
-    //vcf_buf is allocated only in bcf_sr_sort_next
-    //So, a call to bcf_sr_add_reader() followed immediately by bcf_sr_remove_reader()
-    //would cause the program to crash in this segment
-    if (srt->vcf_buf)
-    {
-        free(srt->vcf_buf[i].rec);
-        if ( i+1 < srt->nsr )
-            memmove(&srt->vcf_buf[i], &srt->vcf_buf[i+1], (srt->nsr - i - 1)*sizeof(vcf_buf_t));
-        memset(srt->vcf_buf + srt->nsr - 1, 0, sizeof(vcf_buf_t));
-    }
-}
-sr_sort_t *bcf_sr_sort_init(sr_sort_t *srt)
-{
-    if ( !srt ) return calloc(1,sizeof(sr_sort_t));
-    memset(srt,0,sizeof(sr_sort_t));
-    return srt;
-}
-void bcf_sr_sort_reset(sr_sort_t *srt)
-{
-    srt->chr = NULL;
-}
-void bcf_sr_sort_destroy(sr_sort_t *srt)
-{
-    free(srt->active);
-    if ( srt->var_str2int ) khash_str2int_destroy_free(srt->var_str2int);
-    if ( srt->grp_str2int ) khash_str2int_destroy_free(srt->grp_str2int);
-    int i;
-    for (i=0; i<srt->nsr; i++) free(srt->vcf_buf[i].rec);
-    free(srt->vcf_buf);
-    for (i=0; i<srt->mvar; i++)
-    {
-        free(srt->var[i].str);
-        free(srt->var[i].vcf);
-        free(srt->var[i].rec);
-        kbs_destroy(srt->var[i].mask);
-    }
-    free(srt->var);
-    for (i=0; i<srt->mgrp; i++)
-        free(srt->grp[i].var);
-    free(srt->grp);
-    for (i=0; i<srt->mvset; i++)
-    {
-        kbs_destroy(srt->vset[i].mask);
-        free(srt->vset[i].var);
-    }
-    free(srt->vset);
-    free(srt->str.s);
-    free(srt->off);
-    free(srt->charp);
-    free(srt->cnt);
-    free(srt->pmat);
-    memset(srt,0,sizeof(*srt));
-}
-
diff -ruN stringtie.orig/htslib/bcf_sr_sort.h stringtie/htslib/bcf_sr_sort.h
--- stringtie.orig/htslib/bcf_sr_sort.h	2024-02-28 13:57:39.701246126 +0100
+++ stringtie/htslib/bcf_sr_sort.h	1970-01-01 01:00:00.000000000 +0100
@@ -1,108 +0,0 @@
-/*
-    Copyright (C) 2017 Genome Research Ltd.
-
-    Author: Petr Danecek <pd3@sanger.ac.uk>
-
-    Permission is hereby granted, free of charge, to any person obtaining a copy
-    of this software and associated documentation files (the "Software"), to deal
-    in the Software without restriction, including without limitation the rights
-    to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
-    copies of the Software, and to permit persons to whom the Software is
-    furnished to do so, subject to the following conditions:
-
-    The above copyright notice and this permission notice shall be included in
-    all copies or substantial portions of the Software.
-
-    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
-    IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
-    FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
-    AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
-    LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
-    OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
-    THE SOFTWARE.
-*/
-
-/*
-    Reorder duplicate lines so that compatible variant types are
-    returned together by bcf_sr_next_line()
-
-    - readers grouped by variants. Even with many readers there will be
-      typically only several groups
-
-*/
-
-#ifndef BCF_SR_SORT_H
-#define BCF_SR_SORT_H
-
-#include "htslib/synced_bcf_reader.h"
-#include "htslib/kbitset.h"
-
-typedef struct
-{
-    int nrec, mrec;
-    bcf1_t **rec;
-}
-vcf_buf_t;
-
-typedef struct
-{
-    char *str;      // "A>C" for biallelic records or "A>C,A>CC" for multiallelic records
-    int type;       // VCF_SNP, VCF_REF, etc.
-    int nalt;       // number of alternate alleles in this record
-    int nvcf, mvcf, *vcf;   // the list of readers with the same variants
-    bcf1_t **rec;           // list of VCF records in the readers
-    kbitset_t *mask;        // which groups contain the variant
-}
-var_t;
-
-typedef struct
-{
-    char *key;              // only for debugging
-    int nvar, mvar, *var;   // the variants and their type
-    int nvcf;               // number of readers with the same variants
-}
-grp_t;
-
-typedef struct
-{
-    int nvar, mvar, *var;   // list of compatible variants that can be output together
-    int cnt;                // number of readers in this group
-    kbitset_t *mask;        // which groups are populated in this set (replace with expandable bitmask)
-}
-varset_t;
-
-typedef struct
-{
-    uint8_t score[256];
-    int nvar, mvar;
-    var_t *var;             // list of all variants from all readers
-    int nvset, mvset;
-    int mpmat, *pmat;       // pairing matrix, i-th vset and j-th group accessible as i*ngrp+j
-    int ngrp, mgrp;
-    int mcnt, *cnt;         // number of VCF covered by a varset
-    grp_t *grp;             // list of VCF representatives, each with a unique combination of duplicate lines
-    varset_t *vset;         // list of variant sets - combinations of compatible variants across multiple groups ready for output
-    vcf_buf_t *vcf_buf;     // records sorted in output order, for each VCF
-    bcf_srs_t *sr;
-    void *grp_str2int;
-    void *var_str2int;
-    kstring_t str;
-    int moff, noff, *off, mcharp;
-    char **charp;
-    const char *chr;
-    hts_pos_t pos;
-    int nsr, msr;
-    int pair;
-    int nactive, mactive, *active;  // list of readers with lines at the current pos
-}
-sr_sort_t;
-
-sr_sort_t *bcf_sr_sort_init(sr_sort_t *srt);
-void bcf_sr_sort_reset(sr_sort_t *srt);
-int bcf_sr_sort_next(bcf_srs_t *readers, sr_sort_t *srt, const char *chr, hts_pos_t pos);
-int bcf_sr_sort_set_active(sr_sort_t *srt, int i);
-int bcf_sr_sort_add_active(sr_sort_t *srt, int i);
-void bcf_sr_sort_destroy(sr_sort_t *srt);
-void bcf_sr_sort_remove_reader(bcf_srs_t *readers, sr_sort_t *srt, int i);
-
-#endif
diff -ruN stringtie.orig/htslib/bgzf.c stringtie/htslib/bgzf.c
--- stringtie.orig/htslib/bgzf.c	2024-02-28 13:57:39.701246126 +0100
+++ stringtie/htslib/bgzf.c	1970-01-01 01:00:00.000000000 +0100
@@ -1,2560 +0,0 @@
-/* The MIT License
-
-   Copyright (c) 2008 Broad Institute / Massachusetts Institute of Technology
-                 2011, 2012 Attractive Chaos <attractor@live.co.uk>
-   Copyright (C) 2009, 2013-2020 Genome Research Ltd
-
-   Permission is hereby granted, free of charge, to any person obtaining a copy
-   of this software and associated documentation files (the "Software"), to deal
-   in the Software without restriction, including without limitation the rights
-   to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
-   copies of the Software, and to permit persons to whom the Software is
-   furnished to do so, subject to the following conditions:
-
-   The above copyright notice and this permission notice shall be included in
-   all copies or substantial portions of the Software.
-
-   THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
-   IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
-   FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
-   AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
-   LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
-   OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
-   THE SOFTWARE.
-*/
-
-#define HTS_BUILDING_LIBRARY // Enables HTSLIB_EXPORT, see htslib/hts_defs.h
-#include <config.h>
-
-#include <stdio.h>
-#include <stdlib.h>
-#include <string.h>
-#include <errno.h>
-#include <unistd.h>
-#include <assert.h>
-#include <pthread.h>
-#include <sys/types.h>
-#include <inttypes.h>
-#include <zlib.h>
-
-#ifdef HAVE_LIBDEFLATE
-#include <libdeflate.h>
-#endif
-
-#include "htslib/hts.h"
-#include "htslib/bgzf.h"
-#include "htslib/hfile.h"
-#include "htslib/thread_pool.h"
-#include "htslib/hts_endian.h"
-#include "cram/pooled_alloc.h"
-#include "hts_internal.h"
-
-#ifndef EFTYPE
-#define EFTYPE ENOEXEC
-#endif
-
-#define BGZF_CACHE
-#define BGZF_MT
-
-#define BLOCK_HEADER_LENGTH 18
-#define BLOCK_FOOTER_LENGTH 8
-
-
-/* BGZF/GZIP header (specialized from RFC 1952; little endian):
- +---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
- | 31|139|  8|  4|              0|  0|255|      6| 66| 67|      2|BLK_LEN|
- +---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
-  BGZF extension:
-                ^                              ^   ^   ^
-                |                              |   |   |
-               FLG.EXTRA                     XLEN  B   C
-
-  BGZF format is compatible with GZIP. It limits the size of each compressed
-  block to 2^16 bytes and adds and an extra "BC" field in the gzip header which
-  records the size.
-
-*/
-static const uint8_t g_magic[19] = "\037\213\010\4\0\0\0\0\0\377\6\0\102\103\2\0\0\0";
-
-#ifdef BGZF_CACHE
-typedef struct {
-    int size;
-    uint8_t *block;
-    int64_t end_offset;
-} cache_t;
-
-#include "htslib/khash.h"
-KHASH_MAP_INIT_INT64(cache, cache_t)
-#endif
-
-struct bgzf_cache_t {
-    khash_t(cache) *h;
-    khint_t last_pos;
-};
-
-#ifdef BGZF_MT
-
-typedef struct bgzf_job {
-    BGZF *fp;
-    unsigned char comp_data[BGZF_MAX_BLOCK_SIZE];
-    size_t comp_len;
-    unsigned char uncomp_data[BGZF_MAX_BLOCK_SIZE];
-    size_t uncomp_len;
-    int errcode;
-    int64_t block_address;
-    int hit_eof;
-} bgzf_job;
-
-enum mtaux_cmd {
-    NONE = 0,
-    SEEK,
-    SEEK_DONE,
-    HAS_EOF,
-    HAS_EOF_DONE,
-    CLOSE,
-};
-
-// When multi-threaded bgzf_tell won't work, so we delay the hts_idx_push
-// until we've written the last block.
-typedef struct {
-    hts_pos_t beg, end;
-    int tid, is_mapped;  // args for hts_idx_push
-    uint64_t offset, block_number;
-} hts_idx_cache_entry;
-
-typedef struct {
-    int nentries, mentries; // used and allocated
-    hts_idx_cache_entry *e; // hts_idx elements
-} hts_idx_cache_t;
-
-typedef struct bgzf_mtaux_t {
-    // Memory pool for bgzf_job structs, to avoid many malloc/free
-    pool_alloc_t *job_pool;
-    bgzf_job *curr_job;
-
-    // Thread pool
-    int n_threads;
-    int own_pool;
-    hts_tpool *pool;
-
-    // Output queue holding completed bgzf_jobs
-    hts_tpool_process *out_queue;
-
-    // I/O thread.
-    pthread_t io_task;
-    pthread_mutex_t job_pool_m;
-    int jobs_pending; // number of jobs waiting
-    int flush_pending;
-    void *free_block;
-    int hit_eof;  // r/w entirely within main thread
-
-    // Message passing to the reader thread; eg seek requests
-    int errcode;
-    uint64_t block_address;
-    int eof;
-    pthread_mutex_t command_m; // Set whenever fp is being updated
-    pthread_cond_t command_c;
-    enum mtaux_cmd command;
-
-    // For multi-threaded on-the-fly indexing. See bgzf_idx_push below.
-    pthread_mutex_t idx_m;
-    hts_idx_t *hts_idx;
-    uint64_t block_number, block_written;
-    hts_idx_cache_t idx_cache;
-} mtaux_t;
-#endif
-
-typedef struct
-{
-    uint64_t uaddr;  // offset w.r.t. uncompressed data
-    uint64_t caddr;  // offset w.r.t. compressed data
-}
-bgzidx1_t;
-
-struct bgzidx_t
-{
-    int noffs, moffs;       // the size of the index, n:used, m:allocated
-    bgzidx1_t *offs;        // offsets
-    uint64_t ublock_addr;   // offset of the current block (uncompressed data)
-};
-
-/*
- * Buffers up arguments to hts_idx_push for later use, once we've written all bar
- * this block.  This is necessary when multiple blocks are in flight (threading)
- * and fp->block_address isn't known at the time of call as we have in-flight
- * blocks that haven't yet been compressed.
- *
- * NB: this only matters when we're indexing on the fly (writing).
- * Normal indexing is threaded reads, but we already know block sizes
- * so it's a simpler process
- *
- * Returns 0 on success,
- *        -1 on failure
- */
-int bgzf_idx_push(BGZF *fp, hts_idx_t *hidx, int tid, hts_pos_t beg, hts_pos_t end, uint64_t offset, int is_mapped) {
-    hts_idx_cache_entry *e;
-    mtaux_t *mt = fp->mt;
-
-    if (!mt)
-        return hts_idx_push(hidx, tid, beg, end, offset, is_mapped);
-
-    // Early check for out of range positions which would fail in hts_idx_push()
-    if (hts_idx_check_range(hidx, tid, beg, end) < 0)
-        return -1;
-
-    pthread_mutex_lock(&mt->idx_m);
-
-    mt->hts_idx = hidx;
-    hts_idx_cache_t *ic = &mt->idx_cache;
-
-    if (ic->nentries >= ic->mentries) {
-        int new_sz = ic->mentries ? ic->mentries*2 : 1024;
-        if (!(e = realloc(ic->e, new_sz * sizeof(*ic->e)))) {
-            pthread_mutex_unlock(&mt->idx_m);
-            return -1;
-        }
-        ic->e = e;
-        ic->mentries = new_sz;
-    }
-
-    e = &ic->e[ic->nentries++];
-    e->tid = tid;
-    e->beg = beg;
-    e->end = end;
-    e->is_mapped = is_mapped;
-    e->offset = offset & 0xffff;
-    e->block_number = mt->block_number;
-
-    pthread_mutex_unlock(&mt->idx_m);
-
-    return 0;
-}
-
-/*
- * bgzf analogue to hts_idx_amend_last.
- *
- * This is needed when multi-threading and writing indices on the fly.
- * At the point of writing a record we know the virtual offset for start
- * and end, but that end virtual offset may be the end of the current
- * block.  In standard indexing our end virtual offset becomes the start
- * of the next block.  Thus to ensure bit for bit compatibility we
- * detect this boundary case and fix it up here.
- *
- * In theory this has no behavioural change, but it also works around
- * a bug elsewhere which causes bgzf_read to return 0 when our offset
- * is the end of a block rather than the start of the next.
- */
-void bgzf_idx_amend_last(BGZF *fp, hts_idx_t *hidx, uint64_t offset) {
-    mtaux_t *mt = fp->mt;
-    if (!mt) {
-        hts_idx_amend_last(hidx, offset);
-        return;
-    }
-
-    pthread_mutex_lock(&mt->idx_m);
-    hts_idx_cache_t *ic = &mt->idx_cache;
-    if (ic->nentries > 0) {
-        hts_idx_cache_entry *e = &ic->e[ic->nentries-1];
-        if ((offset & 0xffff) == 0 && e->offset != 0) {
-            // bumped to next block number
-            e->offset = 0;
-            e->block_number++;
-        }
-    }
-    pthread_mutex_unlock(&mt->idx_m);
-}
-
-static int bgzf_idx_flush(BGZF *fp) {
-    mtaux_t *mt = fp->mt;
-
-    if (!mt->idx_cache.e) {
-        mt->block_written++;
-        return 0;
-    }
-
-    pthread_mutex_lock(&mt->idx_m);
-
-    hts_idx_cache_entry *e = mt->idx_cache.e;
-    int i;
-
-    assert(mt->idx_cache.nentries == 0 || mt->block_written <= e[0].block_number);
-
-    for (i = 0; i < mt->idx_cache.nentries && e[i].block_number == mt->block_written; i++) {
-        if (hts_idx_push(mt->hts_idx, e[i].tid, e[i].beg, e[i].end,
-                         (mt->block_address << 16) + e[i].offset,
-                         e[i].is_mapped) < 0) {
-            pthread_mutex_unlock(&mt->idx_m);
-            return -1;
-        }
-    }
-
-    memmove(&e[0], &e[i], (mt->idx_cache.nentries - i) * sizeof(*e));
-    mt->idx_cache.nentries -= i;
-    mt->block_written++;
-
-    pthread_mutex_unlock(&mt->idx_m);
-    return 0;
-}
-
-void bgzf_index_destroy(BGZF *fp);
-int bgzf_index_add_block(BGZF *fp);
-static int mt_destroy(mtaux_t *mt);
-
-static inline void packInt16(uint8_t *buffer, uint16_t value)
-{
-    buffer[0] = value;
-    buffer[1] = value >> 8;
-}
-
-static inline int unpackInt16(const uint8_t *buffer)
-{
-    return buffer[0] | buffer[1] << 8;
-}
-
-static inline void packInt32(uint8_t *buffer, uint32_t value)
-{
-    buffer[0] = value;
-    buffer[1] = value >> 8;
-    buffer[2] = value >> 16;
-    buffer[3] = value >> 24;
-}
-
-static void razf_info(hFILE *hfp, const char *filename)
-{
-    uint64_t usize, csize;
-    off_t sizes_pos;
-
-    if (filename == NULL || strcmp(filename, "-") == 0) filename = "FILE";
-
-    // RAZF files end with USIZE,CSIZE stored as big-endian uint64_t
-    if ((sizes_pos = hseek(hfp, -16, SEEK_END)) < 0) goto no_sizes;
-    if (hread(hfp, &usize, 8) != 8 || hread(hfp, &csize, 8) != 8) goto no_sizes;
-    if (!ed_is_big()) ed_swap_8p(&usize), ed_swap_8p(&csize);
-    if (csize >= sizes_pos) goto no_sizes; // Very basic validity check
-
-    hts_log_error(
-"To decompress this file, use the following commands:\n"
-"    truncate -s %" PRIu64 " %s\n"
-"    gunzip %s\n"
-"The resulting uncompressed file should be %" PRIu64 " bytes in length.\n"
-"If you do not have a truncate command, skip that step (though gunzip will\n"
-"likely produce a \"trailing garbage ignored\" message, which can be ignored).",
-                  csize, filename, filename, usize);
-    return;
-
-no_sizes:
-    hts_log_error(
-"To decompress this file, use the following command:\n"
-"    gunzip %s\n"
-"This will likely produce a \"trailing garbage ignored\" message, which can\n"
-"usually be safely ignored.", filename);
-}
-
-static const char *bgzf_zerr(int errnum, z_stream *zs)
-{
-    static char buffer[32];
-
-    /* Return zs->msg if available.
-       zlib doesn't set this very reliably.  Looking at the source suggests
-       that it may get set to a useful message for deflateInit2, inflateInit2
-       and inflate when it returns Z_DATA_ERROR. For inflate with other
-       return codes, deflate, deflateEnd and inflateEnd it doesn't appear
-       to be useful.  For the likely non-useful cases, the caller should
-       pass NULL into zs. */
-
-    if (zs && zs->msg) return zs->msg;
-
-    // gzerror OF((gzFile file, int *errnum)
-    switch (errnum) {
-    case Z_ERRNO:
-        return strerror(errno);
-    case Z_STREAM_ERROR:
-        return "invalid parameter/compression level, or inconsistent stream state";
-    case Z_DATA_ERROR:
-        return "invalid or incomplete IO";
-    case Z_MEM_ERROR:
-        return "out of memory";
-    case Z_BUF_ERROR:
-        return "progress temporarily not possible, or in() / out() returned an error";
-    case Z_VERSION_ERROR:
-        return "zlib version mismatch";
-    case Z_NEED_DICT:
-        return "data was compressed using a dictionary";
-    case Z_OK: // 0: maybe gzgets error Z_NULL
-    default:
-        snprintf(buffer, sizeof(buffer), "[%d] unknown", errnum);
-        return buffer;  // FIXME: Not thread-safe.
-    }
-}
-
-static BGZF *bgzf_read_init(hFILE *hfpr, const char *filename)
-{
-    BGZF *fp;
-    uint8_t magic[18];
-    ssize_t n = hpeek(hfpr, magic, 18);
-    if (n < 0) return NULL;
-
-    fp = (BGZF*)calloc(1, sizeof(BGZF));
-    if (fp == NULL) return NULL;
-
-    fp->is_write = 0;
-    fp->uncompressed_block = malloc(2 * BGZF_MAX_BLOCK_SIZE);
-    if (fp->uncompressed_block == NULL) { free(fp); return NULL; }
-    fp->compressed_block = (char *)fp->uncompressed_block + BGZF_MAX_BLOCK_SIZE;
-    fp->is_compressed = (n==18 && magic[0]==0x1f && magic[1]==0x8b);
-    fp->is_gzip = ( !fp->is_compressed || ((magic[3]&4) && memcmp(&magic[12], "BC\2\0",4)==0) ) ? 0 : 1;
-    if (fp->is_compressed && (magic[3]&4) && memcmp(&magic[12], "RAZF", 4)==0) {
-        hts_log_error("Cannot decompress legacy RAZF format");
-        razf_info(hfpr, filename);
-        free(fp->uncompressed_block);
-        free(fp);
-        errno = EFTYPE;
-        return NULL;
-    }
-#ifdef BGZF_CACHE
-    if (!(fp->cache = malloc(sizeof(*fp->cache)))) {
-        free(fp->uncompressed_block);
-        free(fp);
-        return NULL;
-    }
-    if (!(fp->cache->h = kh_init(cache))) {
-        free(fp->uncompressed_block);
-        free(fp->cache);
-        free(fp);
-        return NULL;
-    }
-    fp->cache->last_pos = 0;
-#endif
-    return fp;
-}
-
-// get the compress level from the mode string: compress_level==-1 for the default level, -2 plain uncompressed
-static int mode2level(const char *mode)
-{
-    int i, compress_level = -1;
-    for (i = 0; mode[i]; ++i)
-        if (mode[i] >= '0' && mode[i] <= '9') break;
-    if (mode[i]) compress_level = (int)mode[i] - '0';
-    if (strchr(mode, 'u')) compress_level = -2;
-    return compress_level;
-}
-static BGZF *bgzf_write_init(const char *mode)
-{
-    BGZF *fp;
-    fp = (BGZF*)calloc(1, sizeof(BGZF));
-    if (fp == NULL) goto mem_fail;
-    fp->is_write = 1;
-    int compress_level = mode2level(mode);
-    if ( compress_level==-2 )
-    {
-        fp->is_compressed = 0;
-        return fp;
-    }
-    fp->is_compressed = 1;
-
-    fp->uncompressed_block = malloc(2 * BGZF_MAX_BLOCK_SIZE);
-    if (fp->uncompressed_block == NULL) goto mem_fail;
-    fp->compressed_block = (char *)fp->uncompressed_block + BGZF_MAX_BLOCK_SIZE;
-
-    fp->compress_level = compress_level < 0? Z_DEFAULT_COMPRESSION : compress_level; // Z_DEFAULT_COMPRESSION==-1
-    if (fp->compress_level > 9) fp->compress_level = Z_DEFAULT_COMPRESSION;
-    if ( strchr(mode,'g') )
-    {
-        // gzip output
-        fp->is_gzip = 1;
-        fp->gz_stream = (z_stream*)calloc(1,sizeof(z_stream));
-        if (fp->gz_stream == NULL) goto mem_fail;
-        fp->gz_stream->zalloc = NULL;
-        fp->gz_stream->zfree  = NULL;
-        fp->gz_stream->msg    = NULL;
-
-        int ret = deflateInit2(fp->gz_stream, fp->compress_level, Z_DEFLATED, 15|16, 8, Z_DEFAULT_STRATEGY);
-        if (ret!=Z_OK) {
-            hts_log_error("Call to deflateInit2 failed: %s", bgzf_zerr(ret, fp->gz_stream));
-            goto fail;
-        }
-    }
-    return fp;
-
-mem_fail:
-    hts_log_error("%s", strerror(errno));
-
-fail:
-    if (fp != NULL) {
-        free(fp->uncompressed_block);
-        free(fp->gz_stream);
-        free(fp);
-    }
-    return NULL;
-}
-
-BGZF *bgzf_open(const char *path, const char *mode)
-{
-    BGZF *fp = 0;
-    assert(compressBound(BGZF_BLOCK_SIZE) < BGZF_MAX_BLOCK_SIZE);
-    if (strchr(mode, 'r')) {
-        hFILE *fpr;
-        if ((fpr = hopen(path, mode)) == 0) return 0;
-        fp = bgzf_read_init(fpr, path);
-        if (fp == 0) { hclose_abruptly(fpr); return NULL; }
-        fp->fp = fpr;
-    } else if (strchr(mode, 'w') || strchr(mode, 'a')) {
-        hFILE *fpw;
-        if ((fpw = hopen(path, mode)) == 0) return 0;
-        fp = bgzf_write_init(mode);
-        if (fp == NULL) return NULL;
-        fp->fp = fpw;
-    }
-    else { errno = EINVAL; return 0; }
-
-    fp->is_be = ed_is_big();
-    return fp;
-}
-
-BGZF *bgzf_dopen(int fd, const char *mode)
-{
-    BGZF *fp = 0;
-    assert(compressBound(BGZF_BLOCK_SIZE) < BGZF_MAX_BLOCK_SIZE);
-    if (strchr(mode, 'r')) {
-        hFILE *fpr;
-        if ((fpr = hdopen(fd, mode)) == 0) return 0;
-        fp = bgzf_read_init(fpr, NULL);
-        if (fp == 0) { hclose_abruptly(fpr); return NULL; } // FIXME this closes fd
-        fp->fp = fpr;
-    } else if (strchr(mode, 'w') || strchr(mode, 'a')) {
-        hFILE *fpw;
-        if ((fpw = hdopen(fd, mode)) == 0) return 0;
-        fp = bgzf_write_init(mode);
-        if (fp == NULL) return NULL;
-        fp->fp = fpw;
-    }
-    else { errno = EINVAL; return 0; }
-
-    fp->is_be = ed_is_big();
-    return fp;
-}
-
-BGZF *bgzf_hopen(hFILE *hfp, const char *mode)
-{
-    BGZF *fp = NULL;
-    assert(compressBound(BGZF_BLOCK_SIZE) < BGZF_MAX_BLOCK_SIZE);
-    if (strchr(mode, 'r')) {
-        fp = bgzf_read_init(hfp, NULL);
-        if (fp == NULL) return NULL;
-    } else if (strchr(mode, 'w') || strchr(mode, 'a')) {
-        fp = bgzf_write_init(mode);
-        if (fp == NULL) return NULL;
-    }
-    else { errno = EINVAL; return 0; }
-
-    fp->fp = hfp;
-    fp->is_be = ed_is_big();
-    return fp;
-}
-
-#ifdef HAVE_LIBDEFLATE
-int bgzf_compress(void *_dst, size_t *dlen, const void *src, size_t slen, int level)
-{
-    if (slen == 0) {
-        // EOF block
-        if (*dlen < 28) return -1;
-        memcpy(_dst, "\037\213\010\4\0\0\0\0\0\377\6\0\102\103\2\0\033\0\3\0\0\0\0\0\0\0\0\0", 28);
-        *dlen = 28;
-        return 0;
-    }
-
-    uint8_t *dst = (uint8_t*)_dst;
-
-    if (level == 0) {
-        // Uncompressed data
-        if (*dlen < slen+5 + BLOCK_HEADER_LENGTH + BLOCK_FOOTER_LENGTH) return -1;
-        dst[BLOCK_HEADER_LENGTH] = 1; // BFINAL=1, BTYPE=00; see RFC1951
-        u16_to_le(slen,  &dst[BLOCK_HEADER_LENGTH+1]); // length
-        u16_to_le(~slen, &dst[BLOCK_HEADER_LENGTH+3]); // ones-complement length
-        memcpy(dst + BLOCK_HEADER_LENGTH+5, src, slen);
-        *dlen = slen+5 + BLOCK_HEADER_LENGTH + BLOCK_FOOTER_LENGTH;
-
-    } else {
-        level = level > 0 ? level : 6; // libdeflate doesn't honour -1 as default
-        // NB levels go up to 12 here.
-        struct libdeflate_compressor *z = libdeflate_alloc_compressor(level);
-        if (!z) return -1;
-
-        // Raw deflate
-        size_t clen =
-            libdeflate_deflate_compress(z, src, slen,
-                                        dst + BLOCK_HEADER_LENGTH,
-                                        *dlen - BLOCK_HEADER_LENGTH - BLOCK_FOOTER_LENGTH);
-
-        if (clen <= 0) {
-            hts_log_error("Call to libdeflate_deflate_compress failed");
-            libdeflate_free_compressor(z);
-            return -1;
-        }
-
-        *dlen = clen + BLOCK_HEADER_LENGTH + BLOCK_FOOTER_LENGTH;
-
-        libdeflate_free_compressor(z);
-    }
-
-    // write the header
-    memcpy(dst, g_magic, BLOCK_HEADER_LENGTH); // the last two bytes are a place holder for the length of the block
-    packInt16(&dst[16], *dlen - 1); // write the compressed length; -1 to fit 2 bytes
-
-    // write the footer
-    uint32_t crc = libdeflate_crc32(0, src, slen);
-    packInt32((uint8_t*)&dst[*dlen - 8], crc);
-    packInt32((uint8_t*)&dst[*dlen - 4], slen);
-    return 0;
-}
-
-#else
-
-int bgzf_compress(void *_dst, size_t *dlen, const void *src, size_t slen, int level)
-{
-    uint32_t crc;
-    z_stream zs;
-    uint8_t *dst = (uint8_t*)_dst;
-
-    if (level == 0) {
-        // Uncompressed data
-        if (*dlen < slen+5 + BLOCK_HEADER_LENGTH + BLOCK_FOOTER_LENGTH) return -1;
-        dst[BLOCK_HEADER_LENGTH] = 1; // BFINAL=1, BTYPE=00; see RFC1951
-        u16_to_le(slen,  &dst[BLOCK_HEADER_LENGTH+1]); // length
-        u16_to_le(~slen, &dst[BLOCK_HEADER_LENGTH+3]); // ones-complement length
-        memcpy(dst + BLOCK_HEADER_LENGTH+5, src, slen);
-        *dlen = slen+5 + BLOCK_HEADER_LENGTH + BLOCK_FOOTER_LENGTH;
-    } else {
-        // compress the body
-        zs.zalloc = NULL; zs.zfree = NULL;
-        zs.msg = NULL;
-        zs.next_in  = (Bytef*)src;
-        zs.avail_in = slen;
-        zs.next_out = dst + BLOCK_HEADER_LENGTH;
-        zs.avail_out = *dlen - BLOCK_HEADER_LENGTH - BLOCK_FOOTER_LENGTH;
-        int ret = deflateInit2(&zs, level, Z_DEFLATED, -15, 8, Z_DEFAULT_STRATEGY); // -15 to disable zlib header/footer
-        if (ret!=Z_OK) {
-            hts_log_error("Call to deflateInit2 failed: %s", bgzf_zerr(ret, &zs));
-            return -1;
-        }
-        if ((ret = deflate(&zs, Z_FINISH)) != Z_STREAM_END) {
-            hts_log_error("Deflate operation failed: %s", bgzf_zerr(ret, ret == Z_DATA_ERROR ? &zs : NULL));
-            return -1;
-        }
-        if ((ret = deflateEnd(&zs)) != Z_OK) {
-            hts_log_error("Call to deflateEnd failed: %s", bgzf_zerr(ret, NULL));
-            return -1;
-        }
-        *dlen = zs.total_out + BLOCK_HEADER_LENGTH + BLOCK_FOOTER_LENGTH;
-    }
-
-    // write the header
-    memcpy(dst, g_magic, BLOCK_HEADER_LENGTH); // the last two bytes are a place holder for the length of the block
-    packInt16(&dst[16], *dlen - 1); // write the compressed length; -1 to fit 2 bytes
-    // write the footer
-    crc = crc32(crc32(0L, NULL, 0L), (Bytef*)src, slen);
-    packInt32((uint8_t*)&dst[*dlen - 8], crc);
-    packInt32((uint8_t*)&dst[*dlen - 4], slen);
-    return 0;
-}
-#endif // HAVE_LIBDEFLATE
-
-static int bgzf_gzip_compress(BGZF *fp, void *_dst, size_t *dlen, const void *src, size_t slen, int level)
-{
-    uint8_t *dst = (uint8_t*)_dst;
-    z_stream *zs = fp->gz_stream;
-    int flush = slen ? Z_PARTIAL_FLUSH : Z_FINISH;
-    zs->next_in   = (Bytef*)src;
-    zs->avail_in  = slen;
-    zs->next_out  = dst;
-    zs->avail_out = *dlen;
-    int ret = deflate(zs, flush);
-    if (ret == Z_STREAM_ERROR) {
-        hts_log_error("Deflate operation failed: %s", bgzf_zerr(ret, NULL));
-        return -1;
-    }
-    if (zs->avail_in != 0) {
-        hts_log_error("Deflate block too large for output buffer");
-        return -1;
-    }
-    *dlen = *dlen - zs->avail_out;
-    return 0;
-}
-
-// Deflate the block in fp->uncompressed_block into fp->compressed_block. Also adds an extra field that stores the compressed block length.
-static int deflate_block(BGZF *fp, int block_length)
-{
-    size_t comp_size = BGZF_MAX_BLOCK_SIZE;
-    int ret;
-    if ( !fp->is_gzip )
-        ret = bgzf_compress(fp->compressed_block, &comp_size, fp->uncompressed_block, block_length, fp->compress_level);
-    else
-        ret = bgzf_gzip_compress(fp, fp->compressed_block, &comp_size, fp->uncompressed_block, block_length, fp->compress_level);
-
-    if ( ret != 0 )
-    {
-        hts_log_debug("Compression error %d", ret);
-        fp->errcode |= BGZF_ERR_ZLIB;
-        return -1;
-    }
-    fp->block_offset = 0;
-    return comp_size;
-}
-
-#ifdef HAVE_LIBDEFLATE
-
-static int bgzf_uncompress(uint8_t *dst, size_t *dlen,
-                           const uint8_t *src, size_t slen,
-                           uint32_t expected_crc) {
-    struct libdeflate_decompressor *z = libdeflate_alloc_decompressor();
-    if (!z) {
-        hts_log_error("Call to libdeflate_alloc_decompressor failed");
-        return -1;
-    }
-
-    int ret = libdeflate_deflate_decompress(z, src, slen, dst, *dlen, dlen);
-    libdeflate_free_decompressor(z);
-
-    if (ret != LIBDEFLATE_SUCCESS) {
-        hts_log_error("Inflate operation failed: %d", ret);
-        return -1;
-    }
-
-    uint32_t crc = libdeflate_crc32(0, (unsigned char *)dst, *dlen);
-    if (crc != expected_crc) {
-        hts_log_error("CRC32 checksum mismatch");
-        return -2;
-    }
-
-    return 0;
-}
-
-#else
-
-static int bgzf_uncompress(uint8_t *dst, size_t *dlen,
-                           const uint8_t *src, size_t slen,
-                           uint32_t expected_crc) {
-    z_stream zs = {
-        .zalloc = NULL,
-        .zfree = NULL,
-        .msg = NULL,
-        .next_in = (Bytef*)src,
-        .avail_in = slen,
-        .next_out = (Bytef*)dst,
-        .avail_out = *dlen
-    };
-
-    int ret = inflateInit2(&zs, -15);
-    if (ret != Z_OK) {
-        hts_log_error("Call to inflateInit2 failed: %s", bgzf_zerr(ret, &zs));
-        return -1;
-    }
-    if ((ret = inflate(&zs, Z_FINISH)) != Z_STREAM_END) {
-        hts_log_error("Inflate operation failed: %s", bgzf_zerr(ret, ret == Z_DATA_ERROR ? &zs : NULL));
-        if ((ret = inflateEnd(&zs)) != Z_OK) {
-            hts_log_warning("Call to inflateEnd failed: %s", bgzf_zerr(ret, NULL));
-        }
-        return -1;
-    }
-    if ((ret = inflateEnd(&zs)) != Z_OK) {
-        hts_log_error("Call to inflateEnd failed: %s", bgzf_zerr(ret, NULL));
-        return -1;
-    }
-    *dlen = *dlen - zs.avail_out;
-
-    uint32_t crc = crc32(crc32(0L, NULL, 0L), (unsigned char *)dst, *dlen);
-    if (crc != expected_crc) {
-        hts_log_error("CRC32 checksum mismatch");
-        return -2;
-    }
-
-    return 0;
-}
-#endif // HAVE_LIBDEFLATE
-
-// Inflate the block in fp->compressed_block into fp->uncompressed_block
-static int inflate_block(BGZF* fp, int block_length)
-{
-    size_t dlen = BGZF_MAX_BLOCK_SIZE;
-    uint32_t crc = le_to_u32((uint8_t *)fp->compressed_block + block_length-8);
-    int ret = bgzf_uncompress(fp->uncompressed_block, &dlen,
-                              (Bytef*)fp->compressed_block + 18,
-                              block_length - 18, crc);
-    if (ret < 0) {
-        if (ret == -2)
-            fp->errcode |= BGZF_ERR_CRC;
-        else
-            fp->errcode |= BGZF_ERR_ZLIB;
-        return -1;
-    }
-
-    return dlen;
-}
-
-// Decompress the next part of a non-blocked GZIP file.
-// Return the number of uncompressed bytes read, 0 on EOF, or a negative number on error.
-// Will fill the output buffer unless the end of the GZIP file is reached.
-static int inflate_gzip_block(BGZF *fp)
-{
-    // we will set this to true when we detect EOF, so we don't bang against the EOF more than once per call
-    int input_eof = 0;
-
-    // write to the part of the output buffer after block_offset
-    fp->gz_stream->next_out = (Bytef*)fp->uncompressed_block + fp->block_offset;
-    fp->gz_stream->avail_out = BGZF_MAX_BLOCK_SIZE - fp->block_offset;
-
-    while ( fp->gz_stream->avail_out != 0 ) {
-        // until we fill the output buffer (or hit EOF)
-
-        if ( !input_eof && fp->gz_stream->avail_in == 0 ) {
-            // we are out of input data in the buffer. Get more.
-            fp->gz_stream->next_in = fp->compressed_block;
-            int ret = hread(fp->fp, fp->compressed_block, BGZF_BLOCK_SIZE);
-            if ( ret < 0 ) {
-                // hread had an error. Pass it on.
-                return ret;
-            }
-            fp->gz_stream->avail_in = ret;
-            if ( fp->gz_stream->avail_in < BGZF_BLOCK_SIZE ) {
-                // we have reached EOF but the decompressor hasn't necessarily
-                input_eof = 1;
-            }
-        }
-
-        fp->gz_stream->msg = NULL;
-        // decompress as much data as we can
-        int ret = inflate(fp->gz_stream, Z_SYNC_FLUSH);
-
-        if ( (ret < 0 && ret != Z_BUF_ERROR) || ret == Z_NEED_DICT ) {
-            // an error occurred, other than running out of space
-            hts_log_error("Inflate operation failed: %s", bgzf_zerr(ret, ret == Z_DATA_ERROR ? fp->gz_stream : NULL));
-            fp->errcode |= BGZF_ERR_ZLIB;
-            return -1;
-        } else if ( ret == Z_STREAM_END ) {
-            // we finished a GZIP member
-
-            // scratch for peeking to see if the file is over
-            char c;
-            if (fp->gz_stream->avail_in > 0 || hpeek(fp->fp, &c, 1) == 1) {
-                // there is more data; try and read another GZIP member in the remaining data
-                int reset_ret = inflateReset(fp->gz_stream);
-                if (reset_ret != Z_OK) {
-                    hts_log_error("Call to inflateReset failed: %s", bgzf_zerr(reset_ret, NULL));
-                    fp->errcode |= BGZF_ERR_ZLIB;
-                    return -1;
-                }
-            } else {
-                // we consumed all the input data and hit Z_STREAM_END
-                // so stop looping, even if we never fill the output buffer
-                break;
-            }
-        } else if ( ret == Z_BUF_ERROR && input_eof && fp->gz_stream->avail_out > 0 ) {
-            // the gzip file has ended prematurely
-            hts_log_error("Gzip file truncated");
-            fp->errcode |= BGZF_ERR_IO;
-            return -1;
-        }
-    }
-
-    // when we get here, the buffer is full or there is an EOF after a complete gzip member
-    return BGZF_MAX_BLOCK_SIZE - fp->gz_stream->avail_out;
-}
-
-// Returns: 0 on success (BGZF header); -1 on non-BGZF GZIP header; -2 on error
-static int check_header(const uint8_t *header)
-{
-    if ( header[0] != 31 || header[1] != 139 || header[2] != 8 ) return -2;
-    return ((header[3] & 4) != 0
-            && unpackInt16((uint8_t*)&header[10]) == 6
-            && header[12] == 'B' && header[13] == 'C'
-            && unpackInt16((uint8_t*)&header[14]) == 2) ? 0 : -1;
-}
-
-#ifdef BGZF_CACHE
-static void free_cache(BGZF *fp)
-{
-    khint_t k;
-    if (fp->is_write) return;
-    khash_t(cache) *h = fp->cache->h;
-    for (k = kh_begin(h); k < kh_end(h); ++k)
-        if (kh_exist(h, k)) free(kh_val(h, k).block);
-    kh_destroy(cache, h);
-    free(fp->cache);
-}
-
-static int load_block_from_cache(BGZF *fp, int64_t block_address)
-{
-    khint_t k;
-    cache_t *p;
-
-    khash_t(cache) *h = fp->cache->h;
-    k = kh_get(cache, h, block_address);
-    if (k == kh_end(h)) return 0;
-    p = &kh_val(h, k);
-    if (fp->block_length != 0) fp->block_offset = 0;
-    fp->block_address = block_address;
-    fp->block_length = p->size;
-    memcpy(fp->uncompressed_block, p->block, p->size);
-    if ( hseek(fp->fp, p->end_offset, SEEK_SET) < 0 )
-    {
-        // todo: move the error up
-        hts_log_error("Could not hseek to %" PRId64, p->end_offset);
-        exit(1);
-    }
-    return p->size;
-}
-
-static void cache_block(BGZF *fp, int size)
-{
-    int ret;
-    khint_t k, k_orig;
-    uint8_t *block = NULL;
-    cache_t *p;
-    //fprintf(stderr, "Cache block at %llx\n", (int)fp->block_address);
-    khash_t(cache) *h = fp->cache->h;
-    if (BGZF_MAX_BLOCK_SIZE >= fp->cache_size) return;
-    if (fp->block_length < 0 || fp->block_length > BGZF_MAX_BLOCK_SIZE) return;
-    if ((kh_size(h) + 1) * BGZF_MAX_BLOCK_SIZE > (uint32_t)fp->cache_size) {
-        /* Remove uniformly from any position in the hash by a simple
-         * round-robin approach.  An alternative strategy would be to
-         * remove the least recently accessed block, but the round-robin
-         * removal is simpler and is not expected to have a big impact
-         * on performance */
-        if (fp->cache->last_pos >= kh_end(h)) fp->cache->last_pos = kh_begin(h);
-        k_orig = k = fp->cache->last_pos;
-        if (++k >= kh_end(h)) k = kh_begin(h);
-        while (k != k_orig) {
-            if (kh_exist(h, k))
-                break;
-            if (++k == kh_end(h))
-                k = kh_begin(h);
-        }
-        fp->cache->last_pos = k;
-
-        if (k != k_orig) {
-            block = kh_val(h, k).block;
-            kh_del(cache, h, k);
-        }
-    } else {
-        block = (uint8_t*)malloc(BGZF_MAX_BLOCK_SIZE);
-    }
-    if (!block) return;
-    k = kh_put(cache, h, fp->block_address, &ret);
-    if (ret <= 0) { // kh_put failed, or in there already (shouldn't happen)
-        free(block);
-        return;
-    }
-    p = &kh_val(h, k);
-    p->size = fp->block_length;
-    p->end_offset = fp->block_address + size;
-    p->block = block;
-    memcpy(p->block, fp->uncompressed_block, p->size);
-}
-#else
-static void free_cache(BGZF *fp) {}
-static int load_block_from_cache(BGZF *fp, int64_t block_address) {return 0;}
-static void cache_block(BGZF *fp, int size) {}
-#endif
-
-/*
- * Absolute htell in this compressed file.
- *
- * Do not confuse with the external bgzf_tell macro which returns the virtual
- * offset.
- */
-static off_t bgzf_htell(BGZF *fp) {
-    if (fp->mt) {
-        pthread_mutex_lock(&fp->mt->job_pool_m);
-        off_t pos = fp->block_address + fp->block_clength;
-        pthread_mutex_unlock(&fp->mt->job_pool_m);
-        return pos;
-    } else {
-        return htell(fp->fp);
-    }
-}
-
-int bgzf_read_block(BGZF *fp)
-{
-    hts_tpool_result *r;
-
-    if (fp->mt) {
-    again:
-        if (fp->mt->hit_eof) {
-            // Further reading at EOF will always return 0
-            fp->block_length = 0;
-            return 0;
-        }
-        r = hts_tpool_next_result_wait(fp->mt->out_queue);
-        bgzf_job *j = r ? (bgzf_job *)hts_tpool_result_data(r) : NULL;
-
-        if (!j || j->errcode == BGZF_ERR_MT) {
-            if (!fp->mt->free_block) {
-                fp->uncompressed_block = malloc(2 * BGZF_MAX_BLOCK_SIZE);
-                if (fp->uncompressed_block == NULL) return -1;
-                fp->compressed_block = (char *)fp->uncompressed_block + BGZF_MAX_BLOCK_SIZE;
-            } // else it's already allocated with malloc, maybe even in-use.
-            if (mt_destroy(fp->mt) < 0)
-                fp->errcode = BGZF_ERR_IO;
-            fp->mt = NULL;
-            hts_tpool_delete_result(r, 0);
-
-            goto single_threaded;
-        }
-
-        if (j->errcode) {
-            fp->errcode = j->errcode;
-            hts_log_error("BGZF decode jobs returned error %d "
-                          "for block offset %"PRId64,
-                          j->errcode, j->block_address);
-            return -1;
-        }
-
-        if (j->hit_eof) {
-            if (!fp->last_block_eof && !fp->no_eof_block) {
-                fp->no_eof_block = 1;
-                hts_log_warning("EOF marker is absent. The input is probably truncated");
-            }
-            fp->mt->hit_eof = 1;
-        }
-
-        // Zero length blocks in the middle of a file are (wrongly)
-        // considered as EOF by many callers.  We work around this by
-        // trying again to see if we hit a genuine EOF.
-        if (!j->hit_eof && j->uncomp_len == 0) {
-            fp->last_block_eof = 1;
-            hts_tpool_delete_result(r, 0);
-            goto again;
-        }
-
-        // block_length=0 and block_offset set by bgzf_seek.
-        if (fp->block_length != 0) fp->block_offset = 0;
-        if (!j->hit_eof) fp->block_address = j->block_address;
-        fp->block_clength = j->comp_len;
-        fp->block_length = j->uncomp_len;
-        // bgzf_read() can change fp->block_length
-        fp->last_block_eof = (fp->block_length == 0);
-
-        if ( j->uncomp_len && j->fp->idx_build_otf )
-        {
-            bgzf_index_add_block(j->fp);
-            j->fp->idx->ublock_addr += j->uncomp_len;
-        }
-
-        // Steal the data block as it's quicker than a memcpy.
-        // We just need to make sure we delay the pool free.
-        if (fp->mt->curr_job) {
-            pthread_mutex_lock(&fp->mt->job_pool_m);
-            pool_free(fp->mt->job_pool, fp->mt->curr_job);
-            pthread_mutex_unlock(&fp->mt->job_pool_m);
-        }
-        fp->uncompressed_block = j->uncomp_data;
-        fp->mt->curr_job = j;
-        if (fp->mt->free_block) {
-            free(fp->mt->free_block); // clear up last non-mt block
-            fp->mt->free_block = NULL;
-        }
-
-        hts_tpool_delete_result(r, 0);
-        return 0;
-    }
-
-    uint8_t header[BLOCK_HEADER_LENGTH], *compressed_block;
-    int count, size, block_length, remaining;
-
- single_threaded:
-    size = 0;
-
-    int64_t block_address;
-    block_address = bgzf_htell(fp);
-
-    // Reading an uncompressed file
-    if ( !fp->is_compressed )
-    {
-        count = hread(fp->fp, fp->uncompressed_block, BGZF_MAX_BLOCK_SIZE);
-        if (count < 0)  // Error
-        {
-            hts_log_error("Failed to read uncompressed data "
-                          "at offset %"PRId64"%s%s",
-                          block_address, errno ? ": " : "", strerror(errno));
-            fp->errcode |= BGZF_ERR_IO;
-            return -1;
-        }
-        else if (count == 0)  // EOF
-        {
-            fp->block_length = 0;
-            return 0;
-        }
-        if (fp->block_length != 0) fp->block_offset = 0;
-        fp->block_address = block_address;
-        fp->block_length = count;
-        return 0;
-    }
-
-    // Reading compressed file
-    if ( fp->is_gzip && fp->gz_stream ) // is this is an initialized gzip stream?
-    {
-        count = inflate_gzip_block(fp);
-        if ( count<0 )
-        {
-            hts_log_error("Reading GZIP stream failed at offset %"PRId64,
-                          block_address);
-            fp->errcode |= BGZF_ERR_ZLIB;
-            return -1;
-        }
-        fp->block_length = count;
-        fp->block_address = block_address;
-        return 0;
-    }
-    if (fp->cache_size && load_block_from_cache(fp, block_address)) return 0;
-
-    // loop to skip empty bgzf blocks
-    while (1)
-    {
-        count = hread(fp->fp, header, sizeof(header));
-        if (count == 0) { // no data read
-            if (!fp->last_block_eof && !fp->no_eof_block && !fp->is_gzip) {
-                fp->no_eof_block = 1;
-                hts_log_warning("EOF marker is absent. The input is probably truncated");
-            }
-            fp->block_length = 0;
-            return 0;
-        }
-        int ret = 0;
-        if ( count != sizeof(header) || (ret=check_header(header))==-2 )
-        {
-            fp->errcode |= BGZF_ERR_HEADER;
-            hts_log_error("%s BGZF header at offset %"PRId64,
-                          ret ? "Invalid" : "Failed to read",
-                          block_address);
-            return -1;
-        }
-        if ( ret==-1 )
-        {
-            // GZIP, not BGZF
-            uint8_t *cblock = (uint8_t*)fp->compressed_block;
-            memcpy(cblock, header, sizeof(header));
-            count = hread(fp->fp, cblock+sizeof(header), BGZF_BLOCK_SIZE - sizeof(header)) + sizeof(header);
-
-            fp->is_gzip = 1;
-            fp->gz_stream = (z_stream*) calloc(1,sizeof(z_stream));
-            // Set up zlib, using a window size of 15, and its built-in GZIP header processing (+16).
-            int ret = inflateInit2(fp->gz_stream, 15 + 16);
-            if (ret != Z_OK)
-            {
-                hts_log_error("Call to inflateInit2 failed: %s", bgzf_zerr(ret, fp->gz_stream));
-                fp->errcode |= BGZF_ERR_ZLIB;
-                return -1;
-            }
-            fp->gz_stream->avail_in = count;
-            fp->gz_stream->next_in  = cblock;
-            count = inflate_gzip_block(fp);
-            if ( count<0 )
-            {
-                hts_log_error("Reading GZIP stream failed at offset %"PRId64,
-                              block_address);
-                fp->errcode |= BGZF_ERR_ZLIB;
-                return -1;
-            }
-            fp->block_length = count;
-            fp->block_address = block_address;
-            if ( fp->idx_build_otf ) return -1; // cannot build index for gzip
-            return 0;
-        }
-        size = count;
-        block_length = unpackInt16((uint8_t*)&header[16]) + 1; // +1 because when writing this number, we used "-1"
-        if (block_length < BLOCK_HEADER_LENGTH)
-        {
-            hts_log_error("Invalid BGZF block length at offset %"PRId64,
-                          block_address);
-            fp->errcode |= BGZF_ERR_HEADER;
-            return -1;
-        }
-        compressed_block = (uint8_t*)fp->compressed_block;
-        memcpy(compressed_block, header, BLOCK_HEADER_LENGTH);
-        remaining = block_length - BLOCK_HEADER_LENGTH;
-        count = hread(fp->fp, &compressed_block[BLOCK_HEADER_LENGTH], remaining);
-        if (count != remaining) {
-            hts_log_error("Failed to read BGZF block data at offset %"PRId64
-                          " expected %d bytes; hread returned %d",
-                          block_address, remaining, count);
-            fp->errcode |= BGZF_ERR_IO;
-            return -1;
-        }
-        size += count;
-        if ((count = inflate_block(fp, block_length)) < 0) {
-            hts_log_debug("Inflate block operation failed for "
-                          "block at offset %"PRId64": %s",
-                          block_address, bgzf_zerr(count, NULL));
-            fp->errcode |= BGZF_ERR_ZLIB;
-            return -1;
-        }
-        fp->last_block_eof = (count == 0);
-        if ( count ) break;     // otherwise an empty bgzf block
-        block_address = bgzf_htell(fp); // update for new block start
-    }
-    if (fp->block_length != 0) fp->block_offset = 0; // Do not reset offset if this read follows a seek.
-    fp->block_address = block_address;
-    fp->block_length = count;
-    if ( fp->idx_build_otf )
-    {
-        bgzf_index_add_block(fp);
-        fp->idx->ublock_addr += count;
-    }
-    cache_block(fp, size);
-    return 0;
-}
-
-ssize_t bgzf_read(BGZF *fp, void *data, size_t length)
-{
-    ssize_t bytes_read = 0;
-    uint8_t *output = (uint8_t*)data;
-    if (length <= 0) return 0;
-    assert(fp->is_write == 0);
-    while (bytes_read < length) {
-        int copy_length, available = fp->block_length - fp->block_offset;
-        uint8_t *buffer;
-        if (available <= 0) {
-            int ret = bgzf_read_block(fp);
-            if (ret != 0) {
-                hts_log_error("Read block operation failed with error %d after %zd of %zu bytes", fp->errcode, bytes_read, length);
-                fp->errcode |= BGZF_ERR_ZLIB;
-                return -1;
-            }
-            available = fp->block_length - fp->block_offset;
-            if (available == 0) {
-                if (fp->block_length == 0)
-                    break; // EOF
-
-                // Offset was at end of block (see commit e9863a0)
-                fp->block_address = bgzf_htell(fp);
-                fp->block_offset = fp->block_length = 0;
-                continue;
-            } else if (available < 0) {
-                // Block offset was set to an invalid coordinate
-                hts_log_error("BGZF block offset %d set beyond block size %d",
-                              fp->block_offset, fp->block_length);
-                fp->errcode |= BGZF_ERR_MISUSE;
-                return -1;
-            }
-        }
-        copy_length = length - bytes_read < available? length - bytes_read : available;
-        buffer = (uint8_t*)fp->uncompressed_block;
-        memcpy(output, buffer + fp->block_offset, copy_length);
-        fp->block_offset += copy_length;
-        output += copy_length;
-        bytes_read += copy_length;
-
-        // For raw gzip streams this avoids short reads.
-        if (fp->block_offset == fp->block_length) {
-            fp->block_address = bgzf_htell(fp);
-            fp->block_offset = fp->block_length = 0;
-        }
-    }
-
-    fp->uncompressed_address += bytes_read;
-
-    return bytes_read;
-}
-
-// -1 for EOF, -2 for error, 0-255 for byte.
-int bgzf_peek(BGZF *fp) {
-    int available = fp->block_length - fp->block_offset;
-    if (available <= 0) {
-        if (bgzf_read_block(fp) < 0) {
-            hts_log_error("Read block operation failed with error %d", fp->errcode);
-            fp->errcode = BGZF_ERR_ZLIB;
-            return -2;
-        }
-    }
-    available = fp->block_length - fp->block_offset;
-    if (available)
-        return ((unsigned char *)fp->uncompressed_block)[fp->block_offset];
-
-    return -1;
-}
-
-ssize_t bgzf_raw_read(BGZF *fp, void *data, size_t length)
-{
-    ssize_t ret = hread(fp->fp, data, length);
-    if (ret < 0) fp->errcode |= BGZF_ERR_IO;
-    return ret;
-}
-
-#ifdef BGZF_MT
-
-/* Function to clean up when jobs are discarded (e.g. during seek)
- * This works for results too, as results are the same struct with
- * decompressed data stored in it. */
-static void job_cleanup(void *arg) {
-    bgzf_job *j = (bgzf_job *)arg;
-    mtaux_t *mt = j->fp->mt;
-    pthread_mutex_lock(&mt->job_pool_m);
-    pool_free(mt->job_pool, j);
-    pthread_mutex_unlock(&mt->job_pool_m);
-}
-
-static void *bgzf_encode_func(void *arg) {
-    bgzf_job *j = (bgzf_job *)arg;
-
-    j->comp_len = BGZF_MAX_BLOCK_SIZE;
-    int ret = bgzf_compress(j->comp_data, &j->comp_len,
-                            j->uncomp_data, j->uncomp_len,
-                            j->fp->compress_level);
-    if (ret != 0)
-        j->errcode |= BGZF_ERR_ZLIB;
-
-    return arg;
-}
-
-// Optimisation for compression level 0 (uncompressed deflate blocks)
-// Avoids memcpy of the data from uncompressed to compressed buffer.
-static void *bgzf_encode_level0_func(void *arg) {
-    bgzf_job *j = (bgzf_job *)arg;
-    uint32_t crc;
-    j->comp_len = j->uncomp_len + BLOCK_HEADER_LENGTH + BLOCK_FOOTER_LENGTH + 5;
-
-    // Data will have already been copied in to
-    // j->comp_data + BLOCK_HEADER_LENGTH + 5
-
-    // Add preamble
-    memcpy(j->comp_data, g_magic, BLOCK_HEADER_LENGTH);
-    u16_to_le(j->comp_len-1, j->comp_data + 16);
-
-    // Deflate uncompressed data header
-    j->comp_data[BLOCK_HEADER_LENGTH] = 1; // BFINAL=1, BTYPE=00; see RFC1951
-    u16_to_le(j->uncomp_len, j->comp_data + BLOCK_HEADER_LENGTH + 1);
-    u16_to_le(~j->uncomp_len, j->comp_data + BLOCK_HEADER_LENGTH + 3);
-
-    // Trailer (CRC, uncompressed length)
-#ifdef HAVE_LIBDEFLATE
-    crc = libdeflate_crc32(0, j->comp_data + BLOCK_HEADER_LENGTH + 5,
-                           j->uncomp_len);
-#else
-    crc = crc32(crc32(0L, NULL, 0L),
-                (Bytef*)j->comp_data + BLOCK_HEADER_LENGTH + 5, j->uncomp_len);
-#endif
-    u32_to_le(crc, j->comp_data +  j->comp_len - 8);
-    u32_to_le(j->uncomp_len, j->comp_data + j->comp_len - 4);
-
-    return arg;
-}
-
-// Our input block has already been decoded by bgzf_mt_read_block().
-// We need to split that into a fetch block (compressed) and make this
-// do the actual decompression step.
-static void *bgzf_decode_func(void *arg) {
-    bgzf_job *j = (bgzf_job *)arg;
-
-    j->uncomp_len = BGZF_MAX_BLOCK_SIZE;
-    uint32_t crc = le_to_u32((uint8_t *)j->comp_data + j->comp_len-8);
-    int ret = bgzf_uncompress(j->uncomp_data, &j->uncomp_len,
-                              j->comp_data+18, j->comp_len-18, crc);
-    if (ret != 0)
-        j->errcode |= BGZF_ERR_ZLIB;
-
-    return arg;
-}
-
-/*
- * Nul function so we can dispatch a job with the correct serial
- * to mark failure or to indicate an empty read (EOF).
- */
-static void *bgzf_nul_func(void *arg) { return arg; }
-
-/*
- * Takes compressed blocks off the results queue and calls hwrite to
- * punt them to the output stream.
- *
- * Returns NULL when no more are left, or -1 on error
- */
-static void *bgzf_mt_writer(void *vp) {
-    BGZF *fp = (BGZF *)vp;
-    mtaux_t *mt = fp->mt;
-    hts_tpool_result *r;
-
-    if (fp->idx_build_otf) {
-        fp->idx->moffs = fp->idx->noffs = 1;
-        fp->idx->offs = (bgzidx1_t*) calloc(fp->idx->moffs, sizeof(bgzidx1_t));
-        if (!fp->idx->offs) goto err;
-    }
-
-    // Iterates until result queue is shutdown, where it returns NULL.
-    while ((r = hts_tpool_next_result_wait(mt->out_queue))) {
-        bgzf_job *j = (bgzf_job *)hts_tpool_result_data(r);
-        assert(j);
-
-        if (fp->idx_build_otf) {
-            fp->idx->noffs++;
-            if ( fp->idx->noffs > fp->idx->moffs )
-            {
-                fp->idx->moffs = fp->idx->noffs;
-                kroundup32(fp->idx->moffs);
-                fp->idx->offs = (bgzidx1_t*) realloc(fp->idx->offs, fp->idx->moffs*sizeof(bgzidx1_t));
-                if ( !fp->idx->offs ) goto err;
-            }
-            fp->idx->offs[ fp->idx->noffs-1 ].uaddr = fp->idx->offs[ fp->idx->noffs-2 ].uaddr + j->uncomp_len;
-            fp->idx->offs[ fp->idx->noffs-1 ].caddr = fp->idx->offs[ fp->idx->noffs-2 ].caddr + j->comp_len;
-        }
-
-        // Flush any cached hts_idx_push calls
-        if (bgzf_idx_flush(fp) < 0)
-            goto err;
-
-        if (hwrite(fp->fp, j->comp_data, j->comp_len) != j->comp_len)
-            goto err;
-
-        // Update our local block_address.  Cannot be fp->block_address due to no
-        // locking in bgzf_tell.
-        pthread_mutex_lock(&mt->idx_m);
-        mt->block_address += j->comp_len;
-        pthread_mutex_unlock(&mt->idx_m);
-
-        /*
-         * Periodically call hflush (which calls fsync when on a file).
-         * This avoids the fsync being done at the bgzf_close stage,
-         * which can sometimes cause significant delays.  As this is in
-         * a separate thread, spreading the sync delays throughout the
-         * program execution seems better.
-         * Frequency of 1/512 has been chosen by experimentation
-         * across local XFS, NFS and Lustre tests.
-         */
-        if (++mt->flush_pending % 512 == 0)
-            if (hflush(fp->fp) != 0)
-                goto err;
-
-
-        hts_tpool_delete_result(r, 0);
-
-        // Also updated by main thread
-        pthread_mutex_lock(&mt->job_pool_m);
-        pool_free(mt->job_pool, j);
-        mt->jobs_pending--;
-        pthread_mutex_unlock(&mt->job_pool_m);
-    }
-
-    if (hflush(fp->fp) != 0)
-        goto err;
-
-    hts_tpool_process_destroy(mt->out_queue);
-
-    return NULL;
-
- err:
-    hts_tpool_process_destroy(mt->out_queue);
-    return (void *)-1;
-}
-
-
-/*
- * Reads a compressed block of data using hread and dispatches it to
- * the thread pool for decompression.  This is the analogue of the old
- * non-threaded bgzf_read_block() function, but without modifying fp
- * in any way (except for the read offset).  All output goes via the
- * supplied bgzf_job struct.
- *
- * Returns NULL when no more are left, or -1 on error
- */
-int bgzf_mt_read_block(BGZF *fp, bgzf_job *j)
-{
-    uint8_t header[BLOCK_HEADER_LENGTH], *compressed_block;
-    int count, size = 0, block_length, remaining;
-
-    // NOTE: Guaranteed to be compressed as we block multi-threading in
-    // uncompressed mode.  However it may be gzip compression instead
-    // of bgzf.
-
-    // Reading compressed file
-    int64_t block_address;
-    block_address = htell(fp->fp);
-
-    if (fp->cache_size && load_block_from_cache(fp, block_address)) return 0;
-    count = hpeek(fp->fp, header, sizeof(header));
-    if (count == 0) // no data read
-        return -1;
-    int ret;
-    if ( count != sizeof(header) || (ret=check_header(header))==-2 )
-    {
-        j->errcode |= BGZF_ERR_HEADER;
-        return -1;
-    }
-    if (ret == -1) {
-        j->errcode |= BGZF_ERR_MT;
-        return -1;
-    }
-
-    count = hread(fp->fp, header, sizeof(header));
-    if (count != sizeof(header)) // no data read
-        return -1;
-
-    size = count;
-    block_length = unpackInt16((uint8_t*)&header[16]) + 1; // +1 because when writing this number, we used "-1"
-    if (block_length < BLOCK_HEADER_LENGTH) {
-        j->errcode |= BGZF_ERR_HEADER;
-        return -1;
-    }
-    compressed_block = (uint8_t*)j->comp_data;
-    memcpy(compressed_block, header, BLOCK_HEADER_LENGTH);
-    remaining = block_length - BLOCK_HEADER_LENGTH;
-    count = hread(fp->fp, &compressed_block[BLOCK_HEADER_LENGTH], remaining);
-    if (count != remaining) {
-        j->errcode |= BGZF_ERR_IO;
-        return -1;
-    }
-    size += count;
-    j->comp_len = block_length;
-    j->uncomp_len = BGZF_MAX_BLOCK_SIZE;
-    j->block_address = block_address;
-    j->fp = fp;
-    j->errcode = 0;
-
-    return 0;
-}
-
-
-static int bgzf_check_EOF_common(BGZF *fp)
-{
-    uint8_t buf[28];
-    off_t offset = htell(fp->fp);
-    if (hseek(fp->fp, -28, SEEK_END) < 0) {
-        if (errno == ESPIPE) { hclearerr(fp->fp); return 2; }
-#ifdef _WIN32
-        if (errno == EINVAL) { hclearerr(fp->fp); return 2; }
-#else
-        // Assume that EINVAL was due to the file being less than 28 bytes
-        // long, rather than being a random error return from an hfile backend.
-        // This should be reported as "no EOF block" rather than an error.
-        if (errno == EINVAL) { hclearerr(fp->fp); return 0; }
-#endif
-        return -1;
-    }
-    if ( hread(fp->fp, buf, 28) != 28 ) return -1;
-    if ( hseek(fp->fp, offset, SEEK_SET) < 0 ) return -1;
-    return (memcmp("\037\213\010\4\0\0\0\0\0\377\6\0\102\103\2\0\033\0\3\0\0\0\0\0\0\0\0\0", buf, 28) == 0)? 1 : 0;
-}
-
-/*
- * Checks EOF from the reader thread.
- */
-static void bgzf_mt_eof(BGZF *fp) {
-    mtaux_t *mt = fp->mt;
-
-    pthread_mutex_lock(&mt->job_pool_m);
-    mt->eof = bgzf_check_EOF_common(fp);
-    pthread_mutex_unlock(&mt->job_pool_m);
-    mt->command = HAS_EOF_DONE;
-    pthread_cond_signal(&mt->command_c);
-}
-
-
-/*
- * Performs the seek (called by reader thread).
- *
- * This simply drains the entire queue, throwing away blocks, seeks,
- * and starts it up again.  Brute force, but maybe sufficient.
- */
-static void bgzf_mt_seek(BGZF *fp) {
-    mtaux_t *mt = fp->mt;
-
-    hts_tpool_process_reset(mt->out_queue, 0);
-    pthread_mutex_lock(&mt->job_pool_m);
-    mt->errcode = 0;
-
-    if (hseek(fp->fp, mt->block_address, SEEK_SET) < 0)
-        mt->errcode = BGZF_ERR_IO;
-
-    pthread_mutex_unlock(&mt->job_pool_m);
-    mt->command = SEEK_DONE;
-    pthread_cond_signal(&mt->command_c);
-}
-
-static void *bgzf_mt_reader(void *vp) {
-    BGZF *fp = (BGZF *)vp;
-    mtaux_t *mt = fp->mt;
-
-restart:
-    pthread_mutex_lock(&mt->job_pool_m);
-    bgzf_job *j = pool_alloc(mt->job_pool);
-    pthread_mutex_unlock(&mt->job_pool_m);
-    if (!j) goto err;
-    j->errcode = 0;
-    j->comp_len = 0;
-    j->uncomp_len = 0;
-    j->hit_eof = 0;
-    j->fp = fp;
-
-    while (bgzf_mt_read_block(fp, j) == 0) {
-        // Dispatch
-        if (hts_tpool_dispatch3(mt->pool, mt->out_queue, bgzf_decode_func, j,
-                                job_cleanup, job_cleanup, 0) < 0) {
-            job_cleanup(j);
-            goto err;
-        }
-
-        // Check for command
-        pthread_mutex_lock(&mt->command_m);
-        switch (mt->command) {
-        case SEEK:
-            bgzf_mt_seek(fp);  // Sets mt->command to SEEK_DONE
-            pthread_mutex_unlock(&mt->command_m);
-            goto restart;
-
-        case HAS_EOF:
-            bgzf_mt_eof(fp);   // Sets mt->command to HAS_EOF_DONE
-            break;
-
-        case SEEK_DONE:
-        case HAS_EOF_DONE:
-            pthread_cond_signal(&mt->command_c);
-            break;
-
-        case CLOSE:
-            pthread_cond_signal(&mt->command_c);
-            pthread_mutex_unlock(&mt->command_m);
-            hts_tpool_process_destroy(mt->out_queue);
-            return NULL;
-
-        default:
-            break;
-        }
-        pthread_mutex_unlock(&mt->command_m);
-
-        // Allocate buffer for next block
-        pthread_mutex_lock(&mt->job_pool_m);
-        j = pool_alloc(mt->job_pool);
-        pthread_mutex_unlock(&mt->job_pool_m);
-        if (!j) {
-            hts_tpool_process_destroy(mt->out_queue);
-            return NULL;
-        }
-        j->errcode = 0;
-        j->comp_len = 0;
-        j->uncomp_len = 0;
-        j->hit_eof = 0;
-        j->fp = fp;
-    }
-
-    if (j->errcode == BGZF_ERR_MT) {
-        // Attempt to multi-thread decode a raw gzip stream cannot be done.
-        // We tear down the multi-threaded decoder and revert to the old code.
-        if (hts_tpool_dispatch3(mt->pool, mt->out_queue, bgzf_nul_func, j,
-                                job_cleanup, job_cleanup, 0) < 0) {
-            job_cleanup(j);
-            hts_tpool_process_destroy(mt->out_queue);
-            return NULL;
-        }
-        hts_tpool_process_ref_decr(mt->out_queue);
-        return &j->errcode;
-    }
-
-    // Dispatch an empty block so EOF is spotted.
-    // We also use this mechanism for returning errors, in which case
-    // j->errcode is set already.
-
-    j->hit_eof = 1;
-    if (hts_tpool_dispatch3(mt->pool, mt->out_queue, bgzf_nul_func, j,
-                            job_cleanup, job_cleanup, 0) < 0) {
-        job_cleanup(j);
-        hts_tpool_process_destroy(mt->out_queue);
-        return NULL;
-    }
-    if (j->errcode != 0) {
-        hts_tpool_process_destroy(mt->out_queue);
-        return &j->errcode;
-    }
-
-    // We hit EOF so can stop reading, but we may get a subsequent
-    // seek request.  In this case we need to restart the reader.
-    //
-    // To handle this we wait on a condition variable and then
-    // monitor the command. (This could be either seek or close.)
-    for (;;) {
-        pthread_mutex_lock(&mt->command_m);
-        if (mt->command == NONE)
-            pthread_cond_wait(&mt->command_c, &mt->command_m);
-        switch(mt->command) {
-        default:
-            pthread_mutex_unlock(&mt->command_m);
-            break;
-
-        case SEEK:
-            bgzf_mt_seek(fp);
-            pthread_mutex_unlock(&mt->command_m);
-            goto restart;
-
-        case HAS_EOF:
-            bgzf_mt_eof(fp);   // Sets mt->command to HAS_EOF_DONE
-            pthread_mutex_unlock(&mt->command_m);
-            break;
-
-        case SEEK_DONE:
-        case HAS_EOF_DONE:
-            pthread_cond_signal(&mt->command_c);
-            pthread_mutex_unlock(&mt->command_m);
-            break;
-
-        case CLOSE:
-            pthread_cond_signal(&mt->command_c);
-            pthread_mutex_unlock(&mt->command_m);
-            hts_tpool_process_destroy(mt->out_queue);
-            return NULL;
-        }
-    }
-
- err:
-    pthread_mutex_lock(&mt->command_m);
-    mt->command = CLOSE;
-    pthread_cond_signal(&mt->command_c);
-    pthread_mutex_unlock(&mt->command_m);
-    hts_tpool_process_destroy(mt->out_queue);
-    return NULL;
-}
-
-int bgzf_thread_pool(BGZF *fp, hts_tpool *pool, int qsize) {
-    // No gain from multi-threading when not compressed
-    if (!fp->is_compressed)
-        return 0;
-
-    mtaux_t *mt;
-    mt = (mtaux_t*)calloc(1, sizeof(mtaux_t));
-    if (!mt) return -1;
-    fp->mt = mt;
-
-    mt->pool = pool;
-    mt->n_threads = hts_tpool_size(pool);
-    if (!qsize)
-        qsize = mt->n_threads*2;
-    if (!(mt->out_queue = hts_tpool_process_init(mt->pool, qsize, 0)))
-        goto err;
-    hts_tpool_process_ref_incr(mt->out_queue);
-
-    mt->job_pool = pool_create(sizeof(bgzf_job));
-    if (!mt->job_pool)
-        goto err;
-
-    pthread_mutex_init(&mt->job_pool_m, NULL);
-    pthread_mutex_init(&mt->command_m, NULL);
-    pthread_mutex_init(&mt->idx_m, NULL);
-    pthread_cond_init(&mt->command_c, NULL);
-    mt->flush_pending = 0;
-    mt->jobs_pending = 0;
-    mt->free_block = fp->uncompressed_block; // currently in-use block
-    mt->block_address = fp->block_address;
-    pthread_create(&mt->io_task, NULL,
-                   fp->is_write ? bgzf_mt_writer : bgzf_mt_reader, fp);
-
-    return 0;
-
- err:
-    free(mt);
-    fp->mt = NULL;
-    return -1;
-}
-
-int bgzf_mt(BGZF *fp, int n_threads, int n_sub_blks)
-{
-    // No gain from multi-threading when not compressed
-    if (!fp->is_compressed || fp->is_gzip)
-        return 0;
-
-    if (n_threads < 1) return -1;
-    hts_tpool *p = hts_tpool_init(n_threads);
-    if (!p)
-        return -1;
-
-    if (bgzf_thread_pool(fp, p, 0) != 0) {
-        hts_tpool_destroy(p);
-        return -1;
-    }
-
-    fp->mt->own_pool = 1;
-
-    return 0;
-}
-
-static int mt_destroy(mtaux_t *mt)
-{
-    int ret = 0;
-
-    // Tell the reader to shut down
-    pthread_mutex_lock(&mt->command_m);
-    mt->command = CLOSE;
-    pthread_cond_signal(&mt->command_c);
-    hts_tpool_wake_dispatch(mt->out_queue); // unstick the reader
-    pthread_mutex_unlock(&mt->command_m);
-
-    // Check for thread worker failure, indicated by is_shutdown returning 2
-    // It's possible really late errors might be missed, but we can live with
-    // that.
-    ret = -(hts_tpool_process_is_shutdown(mt->out_queue) > 1);
-    // Destroying the queue first forces the writer to exit.
-    // mt->out_queue is reference counted, so destroy gets called in both
-    // this and the IO threads.  The last to do it will clean up.
-    hts_tpool_process_destroy(mt->out_queue);
-
-    // IO thread will now exit.  Wait for it and perform final clean-up.
-    // If it returned non-NULL, it was not happy.
-    void *retval = NULL;
-    pthread_join(mt->io_task, &retval);
-    ret = retval != NULL ? -1 : ret;
-
-    pthread_mutex_destroy(&mt->job_pool_m);
-    pthread_mutex_destroy(&mt->command_m);
-    pthread_mutex_destroy(&mt->idx_m);
-    pthread_cond_destroy(&mt->command_c);
-    if (mt->curr_job)
-        pool_free(mt->job_pool, mt->curr_job);
-
-    if (mt->own_pool)
-        hts_tpool_destroy(mt->pool);
-
-    pool_destroy(mt->job_pool);
-
-    if (mt->idx_cache.e)
-        free(mt->idx_cache.e);
-
-    free(mt);
-    fflush(stderr);
-
-    return ret;
-}
-
-static int mt_queue(BGZF *fp)
-{
-    mtaux_t *mt = fp->mt;
-
-    mt->block_number++;
-
-    // Also updated by writer thread
-    pthread_mutex_lock(&mt->job_pool_m);
-    bgzf_job *j = pool_alloc(mt->job_pool);
-    if (j) mt->jobs_pending++;
-    pthread_mutex_unlock(&mt->job_pool_m);
-    if (!j) return -1;
-
-    j->fp = fp;
-    j->errcode = 0;
-    j->uncomp_len  = fp->block_offset;
-    if (fp->compress_level == 0) {
-        memcpy(j->comp_data + BLOCK_HEADER_LENGTH + 5, fp->uncompressed_block,
-               j->uncomp_len);
-        if (hts_tpool_dispatch3(mt->pool, mt->out_queue,
-                                bgzf_encode_level0_func, j,
-                                job_cleanup, job_cleanup, 0) < 0) {
-            goto fail;
-        }
-    } else {
-        memcpy(j->uncomp_data, fp->uncompressed_block, j->uncomp_len);
-
-        // Need non-block vers & job_pending?
-        if (hts_tpool_dispatch3(mt->pool, mt->out_queue, bgzf_encode_func, j,
-                                job_cleanup, job_cleanup, 0) < 0) {
-            goto fail;
-        }
-    }
-
-    fp->block_offset = 0;
-    return 0;
-
- fail:
-    job_cleanup(j);
-    pthread_mutex_lock(&mt->job_pool_m);
-    mt->jobs_pending--;
-    pthread_mutex_unlock(&mt->job_pool_m);
-    return -1;
-}
-
-static int mt_flush_queue(BGZF *fp)
-{
-    mtaux_t *mt = fp->mt;
-
-    // Drain the encoder jobs.
-    // We cannot use hts_tpool_flush here as it can cause deadlock if
-    // the queue is full up of decoder tasks.  The best solution would
-    // be to have one input queue per type of job, but we don't right now.
-    //hts_tpool_flush(mt->pool);
-    pthread_mutex_lock(&mt->job_pool_m);
-    int shutdown = 0;
-    while (mt->jobs_pending != 0) {
-        if ((shutdown = hts_tpool_process_is_shutdown(mt->out_queue)))
-            break;
-        pthread_mutex_unlock(&mt->job_pool_m);
-        usleep(10000); // FIXME: replace by condition variable
-        pthread_mutex_lock(&mt->job_pool_m);
-    }
-    pthread_mutex_unlock(&mt->job_pool_m);
-
-    if (shutdown)
-        return -1;
-
-    // Wait on bgzf_mt_writer to drain the queue
-    if (hts_tpool_process_flush(mt->out_queue) != 0)
-        return -1;
-
-    return (fp->errcode == 0)? 0 : -1;
-}
-
-static int lazy_flush(BGZF *fp)
-{
-    if (fp->mt)
-        return fp->block_offset ? mt_queue(fp) : 0;
-    else
-        return bgzf_flush(fp);
-}
-
-#else  // ~ #ifdef BGZF_MT
-
-int bgzf_mt(BGZF *fp, int n_threads, int n_sub_blks)
-{
-    return 0;
-}
-
-static inline int lazy_flush(BGZF *fp)
-{
-    return bgzf_flush(fp);
-}
-
-#endif // ~ #ifdef BGZF_MT
-
-int bgzf_flush(BGZF *fp)
-{
-    if (!fp->is_write) return 0;
-#ifdef BGZF_MT
-    if (fp->mt) {
-        int ret = 0;
-        if (fp->block_offset) ret = mt_queue(fp);
-        if (!ret) ret = mt_flush_queue(fp);
-
-        // We maintain mt->block_address when threading as the
-        // main code can call bgzf_tell without any locks.
-        // (The result from tell are wrong, but we only care about the last
-        // 16-bits worth except for the final flush process.
-        pthread_mutex_lock(&fp->mt->idx_m);
-        fp->block_address = fp->mt->block_address;
-        pthread_mutex_unlock(&fp->mt->idx_m);
-
-        return ret;
-    }
-#endif
-    while (fp->block_offset > 0) {
-        int block_length;
-        if ( fp->idx_build_otf )
-        {
-            bgzf_index_add_block(fp);
-            fp->idx->ublock_addr += fp->block_offset;
-        }
-        block_length = deflate_block(fp, fp->block_offset);
-        if (block_length < 0) {
-            hts_log_debug("Deflate block operation failed: %s", bgzf_zerr(block_length, NULL));
-            return -1;
-        }
-        if (hwrite(fp->fp, fp->compressed_block, block_length) != block_length) {
-            hts_log_error("File write failed (wrong size)");
-            fp->errcode |= BGZF_ERR_IO; // possibly truncated file
-            return -1;
-        }
-        fp->block_address += block_length;
-    }
-    return 0;
-}
-
-int bgzf_flush_try(BGZF *fp, ssize_t size)
-{
-    if (fp->block_offset + size > BGZF_BLOCK_SIZE) return lazy_flush(fp);
-    return 0;
-}
-
-ssize_t bgzf_write(BGZF *fp, const void *data, size_t length)
-{
-    if ( !fp->is_compressed ) {
-        size_t push = length + (size_t) fp->block_offset;
-        fp->block_offset = push % BGZF_MAX_BLOCK_SIZE;
-        fp->block_address += (push - fp->block_offset);
-        return hwrite(fp->fp, data, length);
-    }
-
-    const uint8_t *input = (const uint8_t*)data;
-    ssize_t remaining = length;
-    assert(fp->is_write);
-    while (remaining > 0) {
-        uint8_t* buffer = (uint8_t*)fp->uncompressed_block;
-        int copy_length = BGZF_BLOCK_SIZE - fp->block_offset;
-        if (copy_length > remaining) copy_length = remaining;
-        memcpy(buffer + fp->block_offset, input, copy_length);
-        fp->block_offset += copy_length;
-        input += copy_length;
-        remaining -= copy_length;
-        if (fp->block_offset == BGZF_BLOCK_SIZE) {
-            if (lazy_flush(fp) != 0) return -1;
-        }
-    }
-    return length - remaining;
-}
-
-ssize_t bgzf_block_write(BGZF *fp, const void *data, size_t length)
-{
-    if ( !fp->is_compressed ) {
-        size_t push = length + (size_t) fp->block_offset;
-        fp->block_offset = push % BGZF_MAX_BLOCK_SIZE;
-        fp->block_address += (push - fp->block_offset);
-        return hwrite(fp->fp, data, length);
-    }
-
-    const uint8_t *input = (const uint8_t*)data;
-    ssize_t remaining = length;
-    assert(fp->is_write);
-    uint64_t current_block; //keep track of current block
-    uint64_t ublock_size; // amount of uncompressed data to be fed into next block
-    while (remaining > 0) {
-        current_block = fp->idx->moffs - fp->idx->noffs;
-        ublock_size = current_block + 1 < fp->idx->moffs ? fp->idx->offs[current_block+1].uaddr-fp->idx->offs[current_block].uaddr : BGZF_MAX_BLOCK_SIZE;
-        uint8_t* buffer = (uint8_t*)fp->uncompressed_block;
-        int copy_length = ublock_size - fp->block_offset;
-        if (copy_length > remaining) copy_length = remaining;
-        memcpy(buffer + fp->block_offset, input, copy_length);
-        fp->block_offset += copy_length;
-        input += copy_length;
-        remaining -= copy_length;
-        if (fp->block_offset == ublock_size) {
-            if (lazy_flush(fp) != 0) return -1;
-            if (fp->idx->noffs > 0)
-                fp->idx->noffs--;  // decrement noffs to track the blocks
-        }
-    }
-    return length - remaining;
-}
-
-
-ssize_t bgzf_raw_write(BGZF *fp, const void *data, size_t length)
-{
-    ssize_t ret = hwrite(fp->fp, data, length);
-    if (ret < 0) fp->errcode |= BGZF_ERR_IO;
-    return ret;
-}
-
-// Helper function for tidying up fp->mt and setting errcode
-static void bgzf_close_mt(BGZF *fp) {
-    if (fp->mt) {
-        if (!fp->mt->free_block)
-            fp->uncompressed_block = NULL;
-        if (mt_destroy(fp->mt) < 0)
-            fp->errcode = BGZF_ERR_IO;
-    }
-}
-
-int bgzf_close(BGZF* fp)
-{
-    int ret, block_length;
-    if (fp == 0) return -1;
-    if (fp->is_write && fp->is_compressed) {
-        if (bgzf_flush(fp) != 0) {
-            bgzf_close_mt(fp);
-            return -1;
-        }
-        fp->compress_level = -1;
-        block_length = deflate_block(fp, 0); // write an empty block
-        if (block_length < 0) {
-            hts_log_debug("Deflate block operation failed: %s", bgzf_zerr(block_length, NULL));
-            bgzf_close_mt(fp);
-            return -1;
-        }
-        if (hwrite(fp->fp, fp->compressed_block, block_length) < 0
-            || hflush(fp->fp) != 0) {
-            hts_log_error("File write failed");
-            fp->errcode |= BGZF_ERR_IO;
-            return -1;
-        }
-    }
-
-    bgzf_close_mt(fp);
-
-    if ( fp->is_gzip )
-    {
-        if (fp->gz_stream == NULL) ret = Z_OK;
-        else if (!fp->is_write) ret = inflateEnd(fp->gz_stream);
-        else ret = deflateEnd(fp->gz_stream);
-        if (ret != Z_OK) {
-            hts_log_error("Call to inflateEnd/deflateEnd failed: %s", bgzf_zerr(ret, NULL));
-        }
-        free(fp->gz_stream);
-    }
-    ret = hclose(fp->fp);
-    if (ret != 0) return -1;
-    bgzf_index_destroy(fp);
-    free(fp->uncompressed_block);
-    free_cache(fp);
-    ret = fp->errcode ? -1 : 0;
-    free(fp);
-    return ret;
-}
-
-void bgzf_set_cache_size(BGZF *fp, int cache_size)
-{
-    if (fp && fp->mt) return; // Not appropriate when multi-threading
-    if (fp && fp->cache) fp->cache_size = cache_size;
-}
-
-int bgzf_check_EOF(BGZF *fp) {
-    int has_eof;
-
-    if (fp->mt) {
-        pthread_mutex_lock(&fp->mt->command_m);
-        // fp->mt->command state transitions should be:
-        // NONE -> HAS_EOF -> HAS_EOF_DONE -> NONE
-        // (HAS_EOF -> HAS_EOF_DONE happens in bgzf_mt_reader thread)
-        if (fp->mt->command != CLOSE)
-            fp->mt->command = HAS_EOF;
-        pthread_cond_signal(&fp->mt->command_c);
-        hts_tpool_wake_dispatch(fp->mt->out_queue);
-        do {
-            if (fp->mt->command == CLOSE) {
-                // possible error in bgzf_mt_reader
-                pthread_mutex_unlock(&fp->mt->command_m);
-                return 0;
-            }
-            pthread_cond_wait(&fp->mt->command_c, &fp->mt->command_m);
-            switch (fp->mt->command) {
-            case HAS_EOF_DONE: break;
-            case HAS_EOF:
-                // Resend signal intended for bgzf_mt_reader()
-                pthread_cond_signal(&fp->mt->command_c);
-                break;
-            case CLOSE:
-                continue;
-            default:
-                abort();  // Should not get to any other state
-            }
-        } while (fp->mt->command != HAS_EOF_DONE);
-        fp->mt->command = NONE;
-        has_eof = fp->mt->eof;
-        pthread_mutex_unlock(&fp->mt->command_m);
-    } else {
-        has_eof = bgzf_check_EOF_common(fp);
-    }
-
-    fp->no_eof_block = (has_eof == 0);
-
-    return has_eof;
-}
-
-static inline int64_t bgzf_seek_common(BGZF* fp,
-                                       int64_t block_address, int block_offset)
-{
-    if (fp->mt) {
-        // The reader runs asynchronous and does loops of:
-        //    Read block
-        //    Check & process command
-        //    Dispatch decode job
-        //
-        // Once at EOF it then switches to loops of
-        //    Wait for command
-        //    Process command (possibly switching back to above loop).
-        //
-        // To seek we therefore send the reader thread a SEEK command,
-        // waking it up if blocked in dispatch and signalling if
-        // waiting for a command.  We then wait for the response so we
-        // know the seek succeeded.
-        pthread_mutex_lock(&fp->mt->command_m);
-        fp->mt->hit_eof = 0;
-        // fp->mt->command state transitions should be:
-        // NONE -> SEEK -> SEEK_DONE -> NONE
-        // (SEEK -> SEEK_DONE happens in bgzf_mt_reader thread)
-        fp->mt->command = SEEK;
-        fp->mt->block_address = block_address;
-        pthread_cond_signal(&fp->mt->command_c);
-        hts_tpool_wake_dispatch(fp->mt->out_queue);
-        do {
-            pthread_cond_wait(&fp->mt->command_c, &fp->mt->command_m);
-            switch (fp->mt->command) {
-            case SEEK_DONE: break;
-            case SEEK:
-                // Resend signal intended for bgzf_mt_reader()
-                pthread_cond_signal(&fp->mt->command_c);
-                break;
-            default:
-                abort();  // Should not get to any other state
-            }
-        } while (fp->mt->command != SEEK_DONE);
-        fp->mt->command = NONE;
-
-        fp->block_length = 0;  // indicates current block has not been loaded
-        fp->block_address = block_address;
-        fp->block_offset = block_offset;
-
-        pthread_mutex_unlock(&fp->mt->command_m);
-    } else {
-        if (hseek(fp->fp, block_address, SEEK_SET) < 0) {
-            fp->errcode |= BGZF_ERR_IO;
-            return -1;
-        }
-        fp->block_length = 0;  // indicates current block has not been loaded
-        fp->block_address = block_address;
-        fp->block_offset = block_offset;
-    }
-
-    return 0;
-}
-
-int64_t bgzf_seek(BGZF* fp, int64_t pos, int where)
-{
-    if (fp->is_write || where != SEEK_SET || fp->is_gzip) {
-        fp->errcode |= BGZF_ERR_MISUSE;
-        return -1;
-    }
-
-    // This is a flag to indicate we've jumped elsewhere in the stream, to act
-    // as a hint to any other code which is wrapping up bgzf for its own
-    // purposes.  We may not be able to tell when seek happens as it can be
-    // done on our behalf, eg by the iterator.
-    //
-    // This is never cleared here.  Any tool that needs to handle it is also
-    // responsible for clearing it.
-    fp->seeked = pos;
-
-    return bgzf_seek_common(fp, pos >> 16, pos & 0xFFFF);
-}
-
-int bgzf_is_bgzf(const char *fn)
-{
-    uint8_t buf[16];
-    int n;
-    hFILE *fp;
-    if ((fp = hopen(fn, "r")) == 0) return 0;
-    n = hread(fp, buf, 16);
-    if (hclose(fp) < 0) return 0;
-    if (n != 16) return 0;
-    return check_header(buf) == 0? 1 : 0;
-}
-
-int bgzf_compression(BGZF *fp)
-{
-    return (!fp->is_compressed)? no_compression : (fp->is_gzip)? gzip : bgzf;
-}
-
-int bgzf_getc(BGZF *fp)
-{
-    if (fp->block_offset+1 < fp->block_length) {
-        fp->uncompressed_address++;
-        return ((unsigned char*)fp->uncompressed_block)[fp->block_offset++];
-    }
-
-    int c;
-    if (fp->block_offset >= fp->block_length) {
-        if (bgzf_read_block(fp) != 0) return -2; /* error */
-        if (fp->block_length == 0) return -1; /* end-of-file */
-    }
-    c = ((unsigned char*)fp->uncompressed_block)[fp->block_offset++];
-    if (fp->block_offset == fp->block_length) {
-        fp->block_address = bgzf_htell(fp);
-        fp->block_offset = 0;
-        fp->block_length = 0;
-    }
-    fp->uncompressed_address++;
-    return c;
-}
-
-int bgzf_getline(BGZF *fp, int delim, kstring_t *str)
-{
-    int l, state = 0;
-    str->l = 0;
-    do {
-        if (fp->block_offset >= fp->block_length) {
-            if (bgzf_read_block(fp) != 0) { state = -2; break; }
-            if (fp->block_length == 0) { state = -1; break; }
-        }
-        unsigned char *buf = fp->uncompressed_block;
-        for (l = fp->block_offset; l < fp->block_length && buf[l] != delim; ++l);
-        if (l < fp->block_length) state = 1;
-        l -= fp->block_offset;
-        if (ks_expand(str, l + 2) < 0) { state = -3; break; }
-        memcpy(str->s + str->l, buf + fp->block_offset, l);
-        str->l += l;
-        fp->block_offset += l + 1;
-        if (fp->block_offset >= fp->block_length) {
-            fp->block_address = bgzf_htell(fp);
-            fp->block_offset = 0;
-            fp->block_length = 0;
-        }
-    } while (state == 0);
-    if (str->l == 0 && state < 0) return state;
-    fp->uncompressed_address += str->l + 1;
-    if ( delim=='\n' && str->l>0 && str->s[str->l-1]=='\r' ) str->l--;
-    str->s[str->l] = 0;
-    return str->l;
-}
-
-void bgzf_index_destroy(BGZF *fp)
-{
-    if ( !fp->idx ) return;
-    free(fp->idx->offs);
-    free(fp->idx);
-    fp->idx = NULL;
-    fp->idx_build_otf = 0;
-}
-
-int bgzf_index_build_init(BGZF *fp)
-{
-    bgzf_index_destroy(fp);
-    fp->idx = (bgzidx_t*) calloc(1,sizeof(bgzidx_t));
-    if ( !fp->idx ) return -1;
-    fp->idx_build_otf = 1;  // build index on the fly
-    return 0;
-}
-
-int bgzf_index_add_block(BGZF *fp)
-{
-    fp->idx->noffs++;
-    if ( fp->idx->noffs > fp->idx->moffs )
-    {
-        fp->idx->moffs = fp->idx->noffs;
-        kroundup32(fp->idx->moffs);
-        fp->idx->offs = (bgzidx1_t*) realloc(fp->idx->offs, fp->idx->moffs*sizeof(bgzidx1_t));
-        if ( !fp->idx->offs ) return -1;
-    }
-    fp->idx->offs[ fp->idx->noffs-1 ].uaddr = fp->idx->ublock_addr;
-    fp->idx->offs[ fp->idx->noffs-1 ].caddr = fp->block_address;
-    return 0;
-}
-
-static inline int hwrite_uint64(uint64_t x, hFILE *f)
-{
-    if (ed_is_big()) x = ed_swap_8(x);
-    if (hwrite(f, &x, sizeof(x)) != sizeof(x)) return -1;
-    return 0;
-}
-
-static char * get_name_suffix(const char *bname, const char *suffix)
-{
-    size_t len = strlen(bname) + strlen(suffix) + 1;
-    char *buff = malloc(len);
-    if (!buff) return NULL;
-    snprintf(buff, len, "%s%s", bname, suffix);
-    return buff;
-}
-
-int bgzf_index_dump_hfile(BGZF *fp, struct hFILE *idx, const char *name)
-{
-    // Note that the index contains one extra record when indexing files opened
-    // for reading. The terminating record is not present when opened for writing.
-    // This is not a bug.
-
-    int i;
-
-    if (!fp->idx) {
-        hts_log_error("Called for BGZF handle with no index");
-        errno = EINVAL;
-        return -1;
-    }
-
-    if (bgzf_flush(fp) != 0) return -1;
-
-    // discard the entry marking the end of the file
-    if (fp->mt && fp->idx)
-        fp->idx->noffs--;
-
-    if (hwrite_uint64(fp->idx->noffs - 1, idx) < 0) goto fail;
-    for (i=1; i<fp->idx->noffs; i++)
-    {
-        if (hwrite_uint64(fp->idx->offs[i].caddr, idx) < 0) goto fail;
-        if (hwrite_uint64(fp->idx->offs[i].uaddr, idx) < 0) goto fail;
-    }
-    return 0;
-
- fail:
-    hts_log_error("Error writing to %s : %s", name ? name : "index", strerror(errno));
-    return -1;
-}
-
-int bgzf_index_dump(BGZF *fp, const char *bname, const char *suffix)
-{
-    const char *name = bname, *msg = NULL;
-    char *tmp = NULL;
-    hFILE *idx = NULL;
-
-    if (!fp->idx) {
-        hts_log_error("Called for BGZF handle with no index");
-        errno = EINVAL;
-        return -1;
-    }
-
-    if ( suffix )
-    {
-        tmp = get_name_suffix(bname, suffix);
-        if ( !tmp ) return -1;
-        name = tmp;
-    }
-
-    idx = hopen(name, "wb");
-    if ( !idx ) {
-        msg = "Error opening";
-        goto fail;
-    }
-
-    if (bgzf_index_dump_hfile(fp, idx, name) != 0) goto fail;
-
-    if (hclose(idx) < 0)
-    {
-        idx = NULL;
-        msg = "Error on closing";
-        goto fail;
-    }
-
-    free(tmp);
-    return 0;
-
- fail:
-    if (msg != NULL) {
-        hts_log_error("%s %s : %s", msg, name, strerror(errno));
-    }
-    if (idx) hclose_abruptly(idx);
-    free(tmp);
-    return -1;
-}
-
-static inline int hread_uint64(uint64_t *xptr, hFILE *f)
-{
-    if (hread(f, xptr, sizeof(*xptr)) != sizeof(*xptr)) return -1;
-    if (ed_is_big()) ed_swap_8p(xptr);
-    return 0;
-}
-
-int bgzf_index_load_hfile(BGZF *fp, struct hFILE *idx, const char *name)
-{
-    fp->idx = (bgzidx_t*) calloc(1,sizeof(bgzidx_t));
-    if (fp->idx == NULL) goto fail;
-    uint64_t x;
-    if (hread_uint64(&x, idx) < 0) goto fail;
-
-    fp->idx->noffs = fp->idx->moffs = x + 1;
-    fp->idx->offs  = (bgzidx1_t*) malloc(fp->idx->moffs*sizeof(bgzidx1_t));
-    if (fp->idx->offs == NULL) goto fail;
-    fp->idx->offs[0].caddr = fp->idx->offs[0].uaddr = 0;
-
-    int i;
-    for (i=1; i<fp->idx->noffs; i++)
-    {
-        if (hread_uint64(&fp->idx->offs[i].caddr, idx) < 0) goto fail;
-        if (hread_uint64(&fp->idx->offs[i].uaddr, idx) < 0) goto fail;
-    }
-
-    return 0;
-
- fail:
-    hts_log_error("Error reading %s : %s", name ? name : "index", strerror(errno));
-    if (fp->idx) {
-        free(fp->idx->offs);
-        free(fp->idx);
-        fp->idx = NULL;
-    }
-    return -1;
-}
-
-int bgzf_index_load(BGZF *fp, const char *bname, const char *suffix)
-{
-    const char *name = bname, *msg = NULL;
-    char *tmp = NULL;
-    hFILE *idx = NULL;
-    if ( suffix )
-    {
-        tmp = get_name_suffix(bname, suffix);
-        if ( !tmp ) return -1;
-        name = tmp;
-    }
-
-    idx = hopen(name, "rb");
-    if ( !idx ) {
-        msg = "Error opening";
-        goto fail;
-    }
-
-    if (bgzf_index_load_hfile(fp, idx, name) != 0) goto fail;
-
-    if (hclose(idx) != 0) {
-        idx = NULL;
-        msg = "Error closing";
-        goto fail;
-    }
-
-    free(tmp);
-    return 0;
-
- fail:
-    if (msg != NULL) {
-        hts_log_error("%s %s : %s", msg, name, strerror(errno));
-    }
-    if (idx) hclose_abruptly(idx);
-    free(tmp);
-    return -1;
-}
-
-int bgzf_useek(BGZF *fp, off_t uoffset, int where)
-{
-    if (fp->is_write || where != SEEK_SET || fp->is_gzip) {
-        fp->errcode |= BGZF_ERR_MISUSE;
-        return -1;
-    }
-    if (uoffset >= fp->uncompressed_address - fp->block_offset &&
-        uoffset < fp->uncompressed_address + fp->block_length - fp->block_offset) {
-        // Can seek into existing data
-        fp->block_offset += uoffset - fp->uncompressed_address;
-        fp->uncompressed_address = uoffset;
-        return 0;
-    }
-    if ( !fp->is_compressed )
-    {
-        if (hseek(fp->fp, uoffset, SEEK_SET) < 0)
-        {
-            fp->errcode |= BGZF_ERR_IO;
-            return -1;
-        }
-        fp->block_length = 0;  // indicates current block has not been loaded
-        fp->block_address = uoffset;
-        fp->block_offset = 0;
-        if (bgzf_read_block(fp) < 0) {
-            fp->errcode |= BGZF_ERR_IO;
-            return -1;
-        }
-        fp->uncompressed_address = uoffset;
-        return 0;
-    }
-
-    if ( !fp->idx )
-    {
-        fp->errcode |= BGZF_ERR_IO;
-        return -1;
-    }
-
-    // binary search
-    int ilo = 0, ihi = fp->idx->noffs - 1;
-    while ( ilo<=ihi )
-    {
-        int i = (ilo+ihi)*0.5;
-        if ( uoffset < fp->idx->offs[i].uaddr ) ihi = i - 1;
-        else if ( uoffset >= fp->idx->offs[i].uaddr ) ilo = i + 1;
-        else break;
-    }
-    int i = ilo-1;
-    if (bgzf_seek_common(fp, fp->idx->offs[i].caddr, 0) < 0)
-        return -1;
-
-    if ( bgzf_read_block(fp) < 0 ) {
-        fp->errcode |= BGZF_ERR_IO;
-        return -1;
-    }
-    if ( uoffset - fp->idx->offs[i].uaddr > 0 )
-    {
-        fp->block_offset = uoffset - fp->idx->offs[i].uaddr;
-        assert( fp->block_offset <= fp->block_length );     // todo: skipped, unindexed, blocks
-    }
-    fp->uncompressed_address = uoffset;
-    return 0;
-}
-
-off_t bgzf_utell(BGZF *fp)
-{
-    return fp->uncompressed_address;    // currently maintained only when reading
-}
-
-/* prototype is in hfile_internal.h */
-struct hFILE *bgzf_hfile(struct BGZF *fp) {
-    return fp->fp;
-}
diff -ruN stringtie.orig/htslib/build_lib.sh stringtie/htslib/build_lib.sh
--- stringtie.orig/htslib/build_lib.sh	2024-02-28 13:57:39.701246126 +0100
+++ stringtie/htslib/build_lib.sh	1970-01-01 01:00:00.000000000 +0100
@@ -1,76 +0,0 @@
-#!/usr/bin/env bash
-## 
-
-if [[ "$1" == "clean" ]]; then
-  make clean
-  /bin/rm -f config.h
-  /bin/rm -rf xlibs
-  /bin/rm -rf lzma bzip2 libdeflate
-  /bin/rm -f *.tar.gz
-  exit
-fi
-
-pwd=$(pwd -P)
-prefix=$pwd/xlibs
-incdir=$prefix/include
-libdir=$prefix/lib
-mkdir -p $incdir
-mkdir -p $libdir
-
-# -- prepare libdeflate
-if [[ ! -d libdeflate ]]; then
- git clone https://github.com/ebiggers/libdeflate
- cd libdeflate
- git checkout '9b565afd996d8b798fc7b94cddcc7cfa49293050'
- cd ..
-fi
-if [[ ! -f $libdir/libdeflate.a ]]; then
-  cd libdeflate
-  MINGW=''
-  libdeflate=libdeflate.a
-  if [[ $(gcc -dumpmachine) == *mingw* ]]; then
-   MINGW=1
-   libdeflate=libdeflatestatic.lib
-  fi
-  make -j 2 $libdeflate || exit 1
-  cp $libdeflate $libdir/libdeflate.a
-  cp libdeflate.h $incdir/
-  cd ..
-fi
-
-bzip="bzip2-1.0.8"
-if [[ ! -d bzip2 ]]; then
-  curl -ksLO https://sourceware.org/pub/bzip2/$bzip.tar.gz || \
-    exec echo "Error: failed to fetch $bzip.tar.gz!"
-  tar -xzf $bzip.tar.gz || exec echo "Error: failed to unpack $bzip.tar.gz!"
-  /bin/rm -f $bzip.tar.gz
-  mv $bzip bzip2
-fi
-if [[ ! -f $libdir/libbz2.a ]]; then 
-  cd bzip2
-  make -j 4 libbz2.a
-  cp bzlib.h $incdir/
-  cp libbz2.a $libdir/
-  cd ..
-fi
-
-# -- prepare liblzma
-xz="xz-5.2.5"
-
-if [[ ! -d lzma ]]; then
-  curl -ksLO https://tukaani.org/xz/$xz.tar.gz || \
-   exec echo "Error: failed to fetch $xz.tar.gz !"
-  tar -xzf $xz.tar.gz || exec echo "Error: failed to unpack $xz.tar.gz !"
-  /bin/rm -f $xz.tar.gz
-  mv $xz lzma
-fi
-if [[ ! -f $libdir/liblzma.a ]]; then
-  cd lzma
-  ./configure --disable-shared -disable-xz -disable-xzdec --disable-lzmadec \
-   --disable-lzmainfo --disable-nls --prefix=$prefix
-  make -j 4
-  make install
-  cd ..
-fi
-
-make -j 4 lib-static
diff -ruN stringtie.orig/htslib/config.mk.in stringtie/htslib/config.mk.in
--- stringtie.orig/htslib/config.mk.in	2024-02-28 13:57:39.701246126 +0100
+++ stringtie/htslib/config.mk.in	1970-01-01 01:00:00.000000000 +0100
@@ -1,114 +0,0 @@
-#  Optional configure Makefile overrides for htslib.
-#
-#    Copyright (C) 2015-2017, 2019 Genome Research Ltd.
-#
-#    Author: John Marshall <jm18@sanger.ac.uk>
-#
-# Permission is hereby granted, free of charge, to any person obtaining a copy
-# of this software and associated documentation files (the "Software"), to deal
-# in the Software without restriction, including without limitation the rights
-# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
-# copies of the Software, and to permit persons to whom the Software is
-# furnished to do so, subject to the following conditions:
-#
-# The above copyright notice and this permission notice shall be included in
-# all copies or substantial portions of the Software.
-#
-# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
-# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
-# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
-# THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
-# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
-# FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
-# DEALINGS IN THE SOFTWARE.
-
-# This is @configure_input@
-#
-# If you use configure, this file overrides variables and augments rules
-# in the Makefile to reflect your configuration choices.  If you don't run
-# configure, the main Makefile contains suitable conservative defaults.
-
-prefix       = @prefix@
-exec_prefix  = @exec_prefix@
-bindir       = @bindir@
-includedir   = @includedir@
-libdir       = @libdir@
-libexecdir   = @libexecdir@
-datarootdir  = @datarootdir@
-mandir       = @mandir@
-
-CC     = @CC@
-RANLIB = @RANLIB@
-
-CPPFLAGS = @CPPFLAGS@
-CFLAGS   = @CFLAGS@
-LDFLAGS  = @LDFLAGS@
-LIBS     = @LIBS@
-
-PLATFORM   = @PLATFORM@
-PLUGIN_EXT = @PLUGIN_EXT@
-
-# The default Makefile enables some of the optional files, but we blank
-# them so they can be controlled by configure instead.
-NONCONFIGURE_OBJS =
-
-# Lowercase here indicates these are "local" to config.mk
-plugin_OBJS =
-noplugin_LDFLAGS =
-noplugin_LIBS =
-
-# ifeq/.../endif, +=, and target-specific variables are GNU Make-specific.
-# If you don't have GNU Make, comment out this conditional and note that
-# to enable libcurl you will need to implement the following elsewhere.
-ifeq "libcurl-@libcurl@" "libcurl-enabled"
-
-LIBCURL_LIBS = -lcurl
-
-plugin_OBJS += hfile_libcurl.o
-
-hfile_libcurl$(PLUGIN_EXT): LIBS += $(LIBCURL_LIBS)
-
-noplugin_LIBS += $(LIBCURL_LIBS)
-
-endif
-
-ifeq "gcs-@gcs@" "gcs-enabled"
-plugin_OBJS += hfile_gcs.o
-endif
-
-ifeq "s3-@s3@" "s3-enabled"
-plugin_OBJS += hfile_s3.o
-plugin_OBJS += hfile_s3_write.o
-
-CRYPTO_LIBS = @CRYPTO_LIBS@
-noplugin_LIBS += $(CRYPTO_LIBS)
-hfile_s3$(PLUGIN_EXT): LIBS += $(CRYPTO_LIBS)
-hfile_s3_write$(PLUGIN_EXT): LIBS += $(CRYPTO_LIBS) $(LIBCURL_LIBS)
-endif
-
-ifeq "plugins-@enable_plugins@" "plugins-yes"
-
-plugindir  = @plugindir@
-pluginpath = @pluginpath@
-
-LIBHTS_OBJS += plugin.o
-PLUGIN_OBJS += $(plugin_OBJS)
-
-plugin.o plugin.pico: ALL_CPPFLAGS += -DPLUGINPATH=\"$(pluginpath)\"
-
-# When built as separate plugins, these record their version themselves.
-hfile_gcs.o hfile_gcs.pico: version.h
-hfile_libcurl.o hfile_libcurl.pico: version.h
-hfile_s3.o hfile_s3.pico: version.h
-hfile_s3_write.o hfile_s3_write.pico: version.h
-
-# Windows DLL plugins depend on the import library, built as a byproduct.
-$(plugin_OBJS:.o=.cygdll): cyghts-$(LIBHTS_SOVERSION).dll
-
-else
-
-LIBHTS_OBJS += $(plugin_OBJS)
-LDFLAGS += $(noplugin_LDFLAGS)
-LIBS += $(noplugin_LIBS)
-
-endif
diff -ruN stringtie.orig/htslib/configure.ac stringtie/htslib/configure.ac
--- stringtie.orig/htslib/configure.ac	2024-02-28 13:57:39.701246126 +0100
+++ stringtie/htslib/configure.ac	1970-01-01 01:00:00.000000000 +0100
@@ -1,473 +0,0 @@
-# Configure script for htslib, a C library for high-throughput sequencing data.
-#
-#    Copyright (C) 2015-2021 Genome Research Ltd.
-#
-#    Author: John Marshall <jm18@sanger.ac.uk>
-#
-# Permission is hereby granted, free of charge, to any person obtaining a copy
-# of this software and associated documentation files (the "Software"), to deal
-# in the Software without restriction, including without limitation the rights
-# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
-# copies of the Software, and to permit persons to whom the Software is
-# furnished to do so, subject to the following conditions:
-#
-# The above copyright notice and this permission notice shall be included in
-# all copies or substantial portions of the Software.
-#
-# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
-# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
-# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
-# THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
-# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
-# FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
-# DEALINGS IN THE SOFTWARE.
-
-dnl Process this file with autoconf to produce a configure script
-AC_INIT([HTSlib], m4_esyscmd_s([./version.sh 2>/dev/null]),
-        [samtools-help@lists.sourceforge.net], [], [http://www.htslib.org/])
-AC_PREREQ(2.63)  dnl This version introduced 4-argument AC_CHECK_HEADER
-AC_CONFIG_SRCDIR(hts.c)
-AC_CONFIG_HEADERS(config.h)
-
-m4_include([m4/hts_prog_cc_warnings.m4])
-m4_include([m4/hts_hide_dynamic_syms.m4])
-m4_include([m4/pkg.m4])
-
-dnl Copyright notice to be copied into the generated configure script
-AC_COPYRIGHT([Portions copyright (C) 2020-2021 Genome Research Ltd.
-
-This configure script is free software: you are free to change and
-redistribute it.  There is NO WARRANTY, to the extent permitted by law.])
-
-dnl Notes to be copied (by autoheader) into the generated config.h.in
-AH_TOP([/* If you use configure, this file provides @%:@defines reflecting your
-   configuration choices.  If you have not run configure, suitable
-   conservative defaults will be used.
-
-   Autoheader adds a number of items to this template file that are not
-   used by HTSlib: STDC_HEADERS and most HAVE_*_H header file defines
-   are immaterial, as we assume standard ISO C headers and facilities;
-   the PACKAGE_* defines are unused and are overridden by the more
-   accurate PACKAGE_VERSION as computed by the Makefile.  */])
-
-dnl Variant of AC_MSG_ERROR that ensures subsequent make(1) invocations fail
-dnl until the configuration error is resolved and configure is run again.
-AC_DEFUN([MSG_ERROR],
-  [cat > config.mk <<'EOF'
-ifneq ($(MAKECMDGOALS),distclean)
-$(error Resolve configure error first)
-endif
-EOF
-   AC_MSG_ERROR([$1], [$2])])
-
-AC_PROG_CC
-AC_PROG_RANLIB
-
-dnl Turn on compiler warnings, if possible
-HTS_PROG_CC_WARNINGS
-dnl Flags to treat warnings as errors.  These need to be applied to CFLAGS
-dnl later as they can interfere with some of the tests (notably AC_SEARCH_LIBS)
-HTS_PROG_CC_WERROR(hts_late_cflags)
-
-dnl Avoid chicken-and-egg problem where pkg-config supplies the
-dnl PKG_PROG_PKG_CONFIG macro, but we want to use it to check
-dnl for pkg-config...
-m4_ifdef([PKG_PROG_PKG_CONFIG], [PKG_PROG_PKG_CONFIG], [PKG_CONFIG=""])
-
-need_crypto=no
-pc_requires=
-static_LDFLAGS=$LDFLAGS
-static_LIBS='-lpthread -lz -lm'
-private_LIBS=$LDFLAGS
-
-AC_ARG_ENABLE([bz2],
-  [AS_HELP_STRING([--disable-bz2],
-                  [omit support for BZ2-compressed CRAM files])],
-  [], [enable_bz2=yes])
-
-AC_ARG_ENABLE([gcs],
-  [AS_HELP_STRING([--enable-gcs],
-                  [support Google Cloud Storage URLs])],
-  [], [enable_gcs=check])
-
-AC_SYS_LARGEFILE
-
-AC_ARG_ENABLE([libcurl],
-  [AS_HELP_STRING([--enable-libcurl],
-                  [enable libcurl-based support for http/https/etc URLs])],
-  [], [enable_libcurl=check])
-
-AC_ARG_ENABLE([lzma],
-  [AS_HELP_STRING([--disable-lzma],
-                  [omit support for LZMA-compressed CRAM files])],
-  [], [enable_lzma=yes])
-
-AC_ARG_ENABLE([plugins],
-  [AS_HELP_STRING([--enable-plugins],
-                  [enable separately-compiled plugins for file access])],
-  [], [enable_plugins=no])
-AC_SUBST(enable_plugins)
-
-AC_ARG_WITH([external-htscodecs],
-  [AS_HELP_STRING([--with-external-htscodecs],
-                  [get htscodecs functions from a shared library])],
-  [], [with_external_htscodecs=no])
-AC_SUBST(with_external_htscodecs)
-
-AC_ARG_WITH([libdeflate],
-  [AS_HELP_STRING([--with-libdeflate],
-                  [use libdeflate for faster crc and deflate algorithms])],
-  [], [with_libdeflate=check])
-
-AC_ARG_WITH([plugin-dir],
-  [AS_HELP_STRING([--with-plugin-dir=DIR],
-                  [plugin installation location [LIBEXECDIR/htslib]])],
-  [case $withval in
-     yes|no) MSG_ERROR([no directory specified for --with-plugin-dir]) ;;
-   esac],
-   [with_plugin_dir='$(libexecdir)/htslib'])
-AC_SUBST([plugindir], $with_plugin_dir)
-
-AC_ARG_WITH([plugin-path],
-  [AS_HELP_STRING([--with-plugin-path=PATH],
-                  [default HTS_PATH plugin search path [PLUGINDIR]])],
-  [case $withval in
-     yes) MSG_ERROR([no path specified for --with-plugin-path]) ;;
-     no)  with_plugin_path= ;;
-   esac],
-  [with_plugin_path=$with_plugin_dir])
-AC_SUBST([pluginpath], $with_plugin_path)
-
-AC_ARG_ENABLE([s3],
-  [AS_HELP_STRING([--enable-s3],
-                  [support Amazon AWS S3 URLs])],
-  [], [enable_s3=check])
-
-basic_host=${host_alias:-unknown-`uname -s`}
-AC_MSG_CHECKING([shared library type for $basic_host])
-case $basic_host in
-  *-cygwin* | *-CYGWIN*)
-    host_result="Cygwin DLL"
-    PLATFORM=CYGWIN
-    PLUGIN_EXT=.cygdll
-    ;;
-  *-darwin* | *-Darwin*)
-    host_result="Darwin dylib"
-    PLATFORM=Darwin
-    PLUGIN_EXT=.bundle
-    ;;
-  *-msys* | *-MSYS* | *-mingw* | *-MINGW*)
-    host_result="MSYS dll"
-    PLATFORM=MSYS
-    PLUGIN_EXT=.dll
-    # This also sets __USE_MINGW_ANSI_STDIO which in turn makes PRId64,
-    # %lld and %z printf formats work.  It also enforces the snprintf to
-    # be C99 compliant so it returns the correct values (in kstring.c).
-    CPPFLAGS="$CPPFLAGS -D_XOPEN_SOURCE=600"
-    ;;
-  *)
-    host_result="plain .so"
-    PLATFORM=default
-    PLUGIN_EXT=.so
-    ;;
-esac
-AC_MSG_RESULT([$host_result])
-AC_SUBST([PLATFORM])
-
-dnl Try to get more control over which symbols are exported in the shared
-dnl library.
-HTS_HIDE_DYNAMIC_SYMBOLS
-
-dnl FIXME This pulls in dozens of standard header checks
-AC_FUNC_MMAP
-AC_CHECK_FUNCS([gmtime_r fsync drand48 srand48_deterministic])
-
-# Darwin has a dubious fdatasync() symbol, but no declaration in <unistd.h>
-AC_CHECK_DECL([fdatasync(int)], [AC_CHECK_FUNCS(fdatasync)])
-
-if test $enable_plugins != no; then
-  AC_SEARCH_LIBS([dlsym], [dl], [],
-    [MSG_ERROR([dlsym() not found
-
-Plugin support requires dynamic linking facilities from the operating system.
-Either configure with --disable-plugins or resolve this error to build HTSlib.])])
-  # Check if the compiler understands -rdynamic 
-  # TODO Test whether this is required and/or needs tweaking per-platform
-  HTS_TEST_CC_C_LD_FLAG([-rdynamic],[rdynamic_flag])
-  AS_IF([test x"$rdynamic_flag" != "xno"],
-    [LDFLAGS="$LDFLAGS $rdynamic_flag"
-     static_LDFLAGS="$static_LDFLAGS $rdynamic_flag"])
-  case "$ac_cv_search_dlsym" in
-    -l*) static_LIBS="$static_LIBS $ac_cv_search_dlsym" ;;
-  esac
-  AC_DEFINE([ENABLE_PLUGINS], 1, [Define if HTSlib should enable plugins.])
-  AC_SUBST([PLUGIN_EXT])
-  AC_DEFINE_UNQUOTED([PLUGIN_EXT], ["$PLUGIN_EXT"],
-                     [Platform-dependent plugin filename extension.])
-fi
-
-AC_SEARCH_LIBS([log], [m], [],
-  [MSG_ERROR([log() not found
-
-HTSLIB requires a working floating-point math library.
-FAILED.  This error must be resolved in order to build HTSlib successfully.])])
-
-zlib_devel=ok
-dnl Set a trivial non-empty INCLUDES to avoid excess default includes tests
-AC_CHECK_HEADER([zlib.h], [], [zlib_devel=missing], [;])
-AC_CHECK_LIB(z, inflate,  [], [zlib_devel=missing])
-
-if test $zlib_devel != ok; then
-  MSG_ERROR([zlib development files not found
-
-HTSlib uses compression routines from the zlib library <http://zlib.net>.
-Building HTSlib requires zlib development files to be installed on the build
-machine; you may need to ensure a package such as zlib1g-dev (on Debian or
-Ubuntu Linux) or zlib-devel (on RPM-based Linux distributions or Cygwin)
-is installed.
-
-FAILED.  This error must be resolved in order to build HTSlib successfully.])
-fi
-
-dnl connect() etc. fns are in libc on linux, but libsocket on illumos/Solaris
-AC_SEARCH_LIBS([recv], [socket ws2_32], [
-if test "$ac_cv_search_recv" != "none required"
-then
-  static_LIBS="$static_LIBS $ac_cv_search_recv"
-fi], [MSG_ERROR([unable to find the recv() function])])
-
-if test "$enable_bz2" != no; then
-  bz2_devel=ok
-  AC_CHECK_HEADER([bzlib.h], [], [bz2_devel=missing], [;])
-  AC_CHECK_LIB([bz2], [BZ2_bzBuffToBuffCompress], [], [bz2_devel=missing])
-  if test $bz2_devel != ok; then
-    MSG_ERROR([libbzip2 development files not found
-
-The CRAM format may use bzip2 compression, which is implemented in HTSlib
-by using compression routines from libbzip2 <http://www.bzip.org/>.
-
-Building HTSlib requires libbzip2 development files to be installed on the
-build machine; you may need to ensure a package such as libbz2-dev (on Debian
-or Ubuntu Linux) or bzip2-devel (on RPM-based Linux distributions or Cygwin)
-is installed.
-
-Either configure with --disable-bz2 (which will make some CRAM files
-produced elsewhere unreadable) or resolve this error to build HTSlib.])
-  fi
-dnl Unfortunately the 'bzip2' package-cfg module is not standard.
-dnl Redhat/Fedora has it; Debian/Ubuntu does not.
-  if test -n "$PKG_CONFIG" && "$PKG_CONFIG" --exists bzip2; then
-     pc_requires="$pc_requires bzip2"
-  else
-     private_LIBS="$private_LIBS -lbz2"
-  fi
-  static_LIBS="$static_LIBS -lbz2"
-fi
-
-if test "$enable_lzma" != no; then
-  lzma_devel=ok
-  AC_CHECK_HEADERS([lzma.h], [], [lzma_devel=header-missing], [;])
-  AC_CHECK_LIB([lzma], [lzma_easy_buffer_encode], [], [lzma_devel=missing])
-  if test $lzma_devel = missing; then
-    MSG_ERROR([liblzma development files not found
-
-The CRAM format may use LZMA2 compression, which is implemented in HTSlib
-by using compression routines from liblzma <http://tukaani.org/xz/>.
-
-Building HTSlib requires liblzma development files to be installed on the
-build machine; you may need to ensure a package such as liblzma-dev (on Debian
-or Ubuntu Linux), xz-devel (on RPM-based Linux distributions or Cygwin), or
-xz (via Homebrew on macOS) is installed; or build XZ Utils from source.
-
-Either configure with --disable-lzma (which will make some CRAM files
-produced elsewhere unreadable) or resolve this error to build HTSlib.])
-  fi
-  pc_requires="$pc_requires liblzma"
-  static_LIBS="$static_LIBS -llzma"
-fi
-
-AS_IF([test "x$with_external_htscodecs" != "xno"],
-  [libhtscodecs=ok
-   AC_CHECK_HEADER([htscodecs/rANS_static4x16.h],[],
-                   [libhtscodecs='missing header'],[;])
-   AC_CHECK_LIB([htscodecs],[rans_compress_bound_4x16],
-                [:],[libhtscodecs='missing library'])
-   AS_IF([test "$libhtscodecs" = "ok"],
-     [AC_DEFINE([HAVE_EXTERNAL_LIBHTSCODECS], 1, [Define if using an external libhtscodecs])
-      LIBS="-lhtscodecs $LIBS"
-      private_LIBS="-lhtscodecs $private_LIBS"
-      static_LIBS="-lhtscodecs $static_LIBS"
-      selected_htscodecs_mk="htscodecs_external.mk"],
-      [MSG_ERROR([libhtscodecs development files not found: $libhtscodecs
-
-You asked to use an external htscodecs library, but do not have the
-required header / library files.  You either need to supply these and
-if necessary set CPPFLAGS and LDFLAGS so the compiler can find them;
-or configure using --without-external-htscodecs to build the required
-functions from the htscodecs submodule.
-])])],
-  [AC_MSG_CHECKING([whether htscodecs files are present])
-   AS_IF([test -e "$srcdir/htscodecs/htscodecs/rANS_static4x16.h"],
-     [AC_MSG_RESULT([yes])
-      selected_htscodecs_mk="htscodecs_bundled.mk"],
-     [AC_MSG_RESULT([no])
-      AS_IF([test -e "$srcdir/.git"],
-        [MSG_ERROR([htscodecs submodule files not present.
-
-HTSlib uses some functions from the htscodecs project, which is normally
-included as a submodule.  Try running:
-
-  git submodule update --init --recursive
-
-in  the top-level htslib directory to update it, and then re-run configure.
-])],
-        [MSG_ERROR([htscodecs submodule files not present.
-
-You have an incomplete distribution.  Please try downloading one of the
-official releases from https://www.htslib.org
-])])])])
-AC_SUBST([selected_htscodecs_mk])
-
-AS_IF([test "x$with_libdeflate" != "xno"],
-  [libdeflate=ok
-   AC_CHECK_HEADER([libdeflate.h],[],[libdeflate='missing header'],[;])
-   AC_CHECK_LIB([deflate], [libdeflate_deflate_compress],[:],[libdeflate='missing library'])
-   AS_IF([test "$libdeflate" = "ok"],
-    [AC_DEFINE([HAVE_LIBDEFLATE], 1, [Define if libdeflate is available.])
-     LIBS="-ldeflate $LIBS"
-     private_LIBS="$private_LIBS -ldeflate"
-     static_LIBS="$static_LIBS -ldeflate"],
-    [AS_IF([test "x$with_libdeflate" != "xcheck"],
-       [MSG_ERROR([libdeflate development files not found: $libdeflate
-
-You requested libdeflate, but do not have the required header / library
-files.  The source for libdeflate is available from
-<https://github.com/ebiggers/libdeflate>.  You may have to adjust
-search paths in CPPFLAGS and/or LDFLAGS if the header and library
-are not currently on them.
-
-Either configure with --without-libdeflate or resolve this error to build
-HTSlib.])])])])
-
-libcurl=disabled
-if test "$enable_libcurl" != no; then
-  AC_CHECK_LIB([curl], [curl_easy_pause],
-    [AC_DEFINE([HAVE_LIBCURL], 1, [Define if libcurl file access is enabled.])
-     libcurl=enabled],
-    [AC_CHECK_LIB([curl], [curl_easy_init],
-       [message="library is too old (7.18+ required)"],
-       [message="library not found"])
-     case "$enable_libcurl" in
-       check) AC_MSG_WARN([libcurl not enabled: $message]) ;;
-       *) MSG_ERROR([libcurl $message
-
-Support for HTTPS and other SSL-based URLs requires routines from the libcurl
-library <http://curl.se/libcurl/>.  Building HTSlib with libcurl enabled
-requires libcurl development files to be installed on the build machine; you
-may need to ensure a package such as libcurl4-{gnutls,nss,openssl}-dev (on
-Debian or Ubuntu Linux) or libcurl-devel (on RPM-based Linux distributions
-or Cygwin) is installed.
-
-Either configure with --disable-libcurl or resolve this error to build HTSlib.])
-       ;;
-     esac])
-dnl -lcurl is only needed for static linking if hfile_libcurl is not a plugin
-  if test "$libcurl" = enabled ; then
-    if test "$enable_plugins" != yes ; then
-      static_LIBS="$static_LIBS -lcurl"
-    fi
-  fi
-fi
-AC_SUBST([libcurl])
-
-gcs=disabled
-if test "$enable_gcs" != no; then
-  if test $libcurl = enabled; then
-    AC_DEFINE([ENABLE_GCS], 1, [Define if HTSlib should enable GCS support.])
-    gcs=enabled
-  else
-    case "$enable_gcs" in
-      check) AC_MSG_WARN([GCS support not enabled: requires libcurl support]) ;;
-      *) MSG_ERROR([GCS support not enabled
-
-Support for Google Cloud Storage URLs requires libcurl support to be enabled
-in HTSlib.  Configure with --enable-libcurl in order to use GCS URLs.])
-      ;;
-    esac
-  fi
-fi
-AC_SUBST([gcs])
-
-s3=disabled
-if test "$enable_s3" != no; then
-  if test $libcurl = enabled; then
-    s3=enabled
-    need_crypto="$enable_s3"
-  else
-    case "$enable_s3" in
-      check) AC_MSG_WARN([S3 support not enabled: requires libcurl support]) ;;
-      *) MSG_ERROR([S3 support not enabled
-
-Support for Amazon AWS S3 URLs requires libcurl support to be enabled
-in HTSlib.  Configure with --enable-libcurl in order to use S3 URLs.])
-      ;;
-    esac
-  fi
-fi
-
-CRYPTO_LIBS=
-if test $need_crypto != no; then
-  AC_CHECK_FUNC([CCHmac],
-    [AC_DEFINE([HAVE_COMMONCRYPTO], 1,
-               [Define if you have the Common Crypto library.])],
-    [save_LIBS=$LIBS
-     AC_SEARCH_LIBS([HMAC], [crypto],
-       [AC_DEFINE([HAVE_HMAC], 1, [Define if you have libcrypto-style HMAC().])
-        case "$ac_cv_search_HMAC" in
-          -l*) CRYPTO_LIBS=$ac_cv_search_HMAC ;;
-        esac],
-     [case "$need_crypto" in
-     check) AC_MSG_WARN([S3 support not enabled: requires SSL development files])
-         s3=disabled ;;
-     *) MSG_ERROR([SSL development files not found
-
-Support for AWS S3 URLs requires routines from an SSL library.  Building
-HTSlib with libcurl enabled requires SSL development files to be installed
-on the build machine; you may need to ensure a package such as libgnutls-dev,
-libnss3-dev, or libssl-dev (on Debian or Ubuntu Linux, corresponding to the
-libcurl4-*-dev package installed), or openssl-devel (on RPM-based Linux
-distributions or Cygwin) is installed.
-
-Either configure with --disable-s3 or resolve this error to build HTSlib.]) ;;
-       esac])
-     LIBS=$save_LIBS])
-dnl Only need to add to static_LIBS if not building as a plugin
-  if test "$enable_plugins" != yes ; then
-     static_LIBS="$static_LIBS $CRYPTO_LIBS"
-  fi
-fi
-
-dnl Look for regcomp in various libraries (needed on windows/mingw).
-AC_SEARCH_LIBS(regcomp, regex, [libregex=needed], [])
-
-dnl Look for PTHREAD_MUTEX_RECURSIVE.
-dnl This is normally in pthread.h except on some broken glibc implementations.
-AC_CHECK_DECL(PTHREAD_MUTEX_RECURSIVE, [], [AC_DEFINE([_XOPEN_SOURCE],[600], [Needed for PTHREAD_MUTEX_RECURSIVE])], [[#include <pthread.h>]])
-
-if test "$s3" = enabled ; then
-   AC_DEFINE([ENABLE_S3], 1, [Define if HTSlib should enable S3 support.])
-fi
-
-dnl Apply value from HTS_PROG_CC_WERROR (if set)
-AS_IF([test "x$hts_late_cflags" != x],[CFLAGS="$CFLAGS $hts_late_cflags"])
-
-AC_SUBST([s3])
-AC_SUBST([CRYPTO_LIBS])
-
-AC_SUBST([pc_requires])
-AC_SUBST([private_LIBS])
-AC_SUBST([static_LDFLAGS])
-AC_SUBST([static_LIBS])
-
-AC_CONFIG_FILES([config.mk htscodecs.mk htslib.pc.tmp:htslib.pc.in])
-AC_OUTPUT
diff -ruN stringtie.orig/htslib/cram/cram_codecs.c stringtie/htslib/cram/cram_codecs.c
--- stringtie.orig/htslib/cram/cram_codecs.c	2024-02-28 13:57:39.701246126 +0100
+++ stringtie/htslib/cram/cram_codecs.c	1970-01-01 01:00:00.000000000 +0100
@@ -1,4035 +0,0 @@
-/*
-Copyright (c) 2012-2021 Genome Research Ltd.
-Author: James Bonfield <jkb@sanger.ac.uk>
-
-Redistribution and use in source and binary forms, with or without
-modification, are permitted provided that the following conditions are met:
-
-   1. Redistributions of source code must retain the above copyright notice,
-this list of conditions and the following disclaimer.
-
-   2. Redistributions in binary form must reproduce the above copyright notice,
-this list of conditions and the following disclaimer in the documentation
-and/or other materials provided with the distribution.
-
-   3. Neither the names Genome Research Ltd and Wellcome Trust Sanger
-Institute nor the names of its contributors may be used to endorse or promote
-products derived from this software without specific prior written permission.
-
-THIS SOFTWARE IS PROVIDED BY GENOME RESEARCH LTD AND CONTRIBUTORS "AS IS" AND
-ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
-WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
-DISCLAIMED. IN NO EVENT SHALL GENOME RESEARCH LTD OR CONTRIBUTORS BE LIABLE
-FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
-DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
-SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
-CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
-OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
-OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-*/
-
-/*
- * FIXME: add checking of cram_external_type to return NULL on unsupported
- * {codec,type} tuples.
- */
-
-#define HTS_BUILDING_LIBRARY // Enables HTSLIB_EXPORT, see htslib/hts_defs.h
-#include <config.h>
-
-#include <stdlib.h>
-#include <string.h>
-#include <assert.h>
-#include <limits.h>
-#include <stdint.h>
-#include <errno.h>
-#include <stddef.h>
-
-#include "../htslib/hts_endian.h"
-
-#if defined(HAVE_EXTERNAL_LIBHTSCODECS)
-#include <htscodecs/varint.h>
-#include <htscodecs/pack.h>
-#include <htscodecs/rle.h>
-#else
-#include "../htscodecs/htscodecs/varint.h"
-#include "../htscodecs/htscodecs/pack.h"
-#include "../htscodecs/htscodecs/rle.h"
-#endif
-
-#include "cram.h"
-
-/*
- * ---------------------------------------------------------------------------
- * Block bit-level I/O functions.
- * All defined static here to promote easy inlining by the compiler.
- */
-
-#if 0
-/* Get a single bit, MSB first */
-static signed int get_bit_MSB(cram_block *block) {
-    unsigned int val;
-
-    if (block->byte > block->alloc)
-        return -1;
-
-    val = block->data[block->byte] >> block->bit;
-    if (--block->bit == -1) {
-        block->bit = 7;
-        block->byte++;
-        //printf("(%02X)", block->data[block->byte]);
-    }
-
-    //printf("-B%d-", val&1);
-
-    return val & 1;
-}
-#endif
-
-/*
- * Count number of successive 0 and 1 bits
- */
-static int get_one_bits_MSB(cram_block *block) {
-    int n = 0, b;
-    if (block->byte >= block->uncomp_size)
-        return -1;
-    do {
-        b = block->data[block->byte] >> block->bit;
-        if (--block->bit == -1) {
-            block->bit = 7;
-            block->byte++;
-            if (block->byte == block->uncomp_size && (b&1))
-                return -1;
-        }
-        n++;
-    } while (b&1);
-
-    return n-1;
-}
-
-static int get_zero_bits_MSB(cram_block *block) {
-    int n = 0, b;
-    if (block->byte >= block->uncomp_size)
-        return -1;
-    do {
-        b = block->data[block->byte] >> block->bit;
-        if (--block->bit == -1) {
-            block->bit = 7;
-            block->byte++;
-            if (block->byte == block->uncomp_size && !(b&1))
-                return -1;
-        }
-        n++;
-    } while (!(b&1));
-
-    return n-1;
-}
-
-#if 0
-/* Stores a single bit */
-static void store_bit_MSB(cram_block *block, unsigned int bit) {
-    if (block->byte >= block->alloc) {
-        block->alloc = block->alloc ? block->alloc*2 : 1024;
-        block->data = realloc(block->data, block->alloc);
-    }
-
-    if (bit)
-        block->data[block->byte] |= (1 << block->bit);
-
-    if (--block->bit == -1) {
-        block->bit = 7;
-        block->byte++;
-        block->data[block->byte] = 0;
-    }
-}
-#endif
-
-#if 0
-/* Rounds to the next whole byte boundary first */
-static void store_bytes_MSB(cram_block *block, char *bytes, int len) {
-    if (block->bit != 7) {
-        block->bit = 7;
-        block->byte++;
-    }
-
-    while (block->byte + len >= block->alloc) {
-        block->alloc = block->alloc ? block->alloc*2 : 1024;
-        block->data = realloc(block->data, block->alloc);
-    }
-
-    memcpy(&block->data[block->byte], bytes, len);
-    block->byte += len;
-}
-#endif
-
-/* Local optimised copy for inlining */
-static inline int64_t get_bits_MSB(cram_block *block, int nbits) {
-    uint64_t val = 0;
-    int i;
-
-#if 0
-    // Fits within the current byte */
-    if (nbits <= block->bit+1) {
-        val = (block->data[block->byte]>>(block->bit-(nbits-1))) & ((1<<nbits)-1);
-        if ((block->bit -= nbits) == -1) {
-            block->bit = 7;
-            block->byte++;
-        }
-        return val;
-    }
-
-    // partial first byte
-    val = block->data[block->byte] & ((1<<(block->bit+1))-1);
-    nbits -= block->bit+1;
-    block->bit = 7;
-    block->byte++;
-
-    // whole middle bytes
-    while (nbits >= 8) {
-        val = (val << 8) | block->data[block->byte++];
-        nbits -= 8;
-    }
-
-    val <<= nbits;
-    val |= (block->data[block->byte]>>(block->bit-(nbits-1))) & ((1<<nbits)-1);
-    block->bit -= nbits;
-    return val;
-#endif
-
-#if 0
-    /* Inefficient implementation! */
-    //printf("{");
-    for (i = 0; i < nbits; i++)
-        //val = (val << 1) | get_bit_MSB(block);
-        GET_BIT_MSB(block, val);
-#endif
-
-#if 1
-    /* Combination of 1st two methods */
-    if (nbits <= block->bit+1) {
-        val = (block->data[block->byte]>>(block->bit-(nbits-1))) & ((1<<nbits)-1);
-        if ((block->bit -= nbits) == -1) {
-            block->bit = 7;
-            block->byte++;
-        }
-        return val;
-    }
-
-    switch(nbits) {
-//  case 15: GET_BIT_MSB(block, val); // fall through
-//  case 14: GET_BIT_MSB(block, val); // fall through
-//  case 13: GET_BIT_MSB(block, val); // fall through
-//  case 12: GET_BIT_MSB(block, val); // fall through
-//  case 11: GET_BIT_MSB(block, val); // fall through
-//  case 10: GET_BIT_MSB(block, val); // fall through
-//  case  9: GET_BIT_MSB(block, val); // fall through
-    case  8: GET_BIT_MSB(block, val); // fall through
-    case  7: GET_BIT_MSB(block, val); // fall through
-    case  6: GET_BIT_MSB(block, val); // fall through
-    case  5: GET_BIT_MSB(block, val); // fall through
-    case  4: GET_BIT_MSB(block, val); // fall through
-    case  3: GET_BIT_MSB(block, val); // fall through
-    case  2: GET_BIT_MSB(block, val); // fall through
-    case  1: GET_BIT_MSB(block, val);
-        break;
-
-    default:
-        for (i = 0; i < nbits; i++)
-            //val = (val << 1) | get_bit_MSB(block);
-            GET_BIT_MSB(block, val);
-    }
-#endif
-
-    //printf("=0x%x}", val);
-
-    return val;
-}
-
-/*
- * Can store up to 24-bits worth of data encoded in an integer value
- * Possibly we'd want to have a less optimal store_bits function when dealing
- * with nbits > 24, but for now we assume the codes generated are never
- * that big. (Given this is only possible with 121392 or more
- * characters with exactly the correct frequency distribution we check
- * for it elsewhere.)
- */
-static int store_bits_MSB(cram_block *block, uint64_t val, int nbits) {
-    //fprintf(stderr, " store_bits: %02x %d\n", val, nbits);
-
-    /*
-     * Use slow mode until we tweak the huffman generator to never generate
-     * codes longer than 24-bits.
-     */
-    unsigned int mask;
-
-    if (block->byte+8 >= block->alloc) {
-        if (block->byte) {
-            block->alloc *= 2;
-            block->data = realloc(block->data, block->alloc + 8);
-            if (!block->data)
-                return -1;
-        } else {
-            block->alloc = 1024;
-            block->data = realloc(block->data, block->alloc + 8);
-            if (!block->data)
-                return -1;
-            block->data[0] = 0; // initialise first byte of buffer
-        }
-    }
-
-    /* fits in current bit-field */
-    if (nbits <= block->bit+1) {
-        block->data[block->byte] |= (val << (block->bit+1-nbits));
-        if ((block->bit-=nbits) == -1) {
-            block->bit = 7;
-            block->byte++;
-            block->data[block->byte] = 0;
-        }
-        return 0;
-    }
-
-    block->data[block->byte] |= (val >> (nbits -= block->bit+1));
-    block->bit = 7;
-    block->byte++;
-    block->data[block->byte] = 0;
-
-    mask = 1<<(nbits-1);
-    do {
-        if (val & mask)
-            block->data[block->byte] |= (1 << block->bit);
-        if (--block->bit == -1) {
-            block->bit = 7;
-            block->byte++;
-            block->data[block->byte] = 0;
-        }
-        mask >>= 1;
-    } while(--nbits);
-
-    return 0;
-}
-
-/*
- * Returns the next 'size' bytes from a block, or NULL if insufficient
- * data left.This is just a pointer into the block data and not an
- * allocated object, so do not free the result.
- */
-static char *cram_extract_block(cram_block *b, int size) {
-    char *cp = (char *)b->data + b->idx;
-    b->idx += size;
-    if (b->idx > b->uncomp_size)
-        return NULL;
-
-    return cp;
-}
-
-/*
- * ---------------------------------------------------------------------------
- * EXTERNAL
- *
- * In CRAM 3.0 and earlier, E_EXTERNAL use the data type to determine the
- * size of the object being returned.  This type is hard coded in the
- * spec document (changing from uint32 to uint64 requires a spec change)
- * and there is no data format introspection so implementations have
- * to determine which size to use based on version numbers.   It also
- * doesn't support signed data.
- *
- * With CRAM 4.0 onwards the size and sign of the data is no longer stated
- * explicitly in the specification.  Instead EXTERNAL is replaced by three
- * new encodings, for bytes and signed / unsigned integers which used a
- * variable sized encoding.
- *
- * For simplicity we use the same encode and decode functions for
- * bytes (CRAM4) and external (CRAM3). Given we already had code to
- * replace codec + type into a function pointer it makes little
- * difference how we ended up at that function.  However we disallow
- * this codec to operate on integer data for CRAM4 onwards.
- */
-int cram_external_decode_int(cram_slice *slice, cram_codec *c,
-                             cram_block *in, char *out, int *out_size) {
-    char *cp;
-    cram_block *b;
-
-    /* Find the external block */
-    b = cram_get_block_by_id(slice, c->u.external.content_id);
-    if (!b)
-        return *out_size?-1:0;
-
-    cp = (char *)b->data + b->idx;
-    // E_INT and E_LONG are guaranteed single item queries
-    int err = 0;
-    *(int32_t *)out = c->vv->varint_get32(&cp, (char *)b->data + b->uncomp_size, &err);
-    b->idx = cp - (char *)b->data;
-    *out_size = 1;
-
-    return err ? -1 : 0;
-}
-
-int cram_external_decode_long(cram_slice *slice, cram_codec *c,
-                              cram_block *in, char *out, int *out_size) {
-    char *cp;
-    cram_block *b;
-
-    /* Find the external block */
-    b = cram_get_block_by_id(slice, c->u.external.content_id);
-    if (!b)
-        return *out_size?-1:0;
-
-    cp = (char *)b->data + b->idx;
-    // E_INT and E_LONG are guaranteed single item queries
-    int err = 0;
-    *(int64_t *)out = c->vv->varint_get64(&cp, (char *)b->data + b->uncomp_size, &err);
-    b->idx = cp - (char *)b->data;
-    *out_size = 1;
-
-    return err ? -1 : 0;
-}
-
-int cram_external_decode_char(cram_slice *slice, cram_codec *c,
-                              cram_block *in, char *out,
-                              int *out_size) {
-    char *cp;
-    cram_block *b;
-
-    /* Find the external block */
-    b = cram_get_block_by_id(slice, c->u.external.content_id);
-    if (!b)
-        return *out_size?-1:0;
-
-    cp = cram_extract_block(b, *out_size);
-    if (!cp)
-        return -1;
-
-    if (out)
-        memcpy(out, cp, *out_size);
-    return 0;
-}
-
-static int cram_external_decode_block(cram_slice *slice, cram_codec *c,
-                                      cram_block *in, char *out_,
-                                      int *out_size) {
-    char *cp;
-    cram_block *out = (cram_block *)out_;
-    cram_block *b = NULL;
-
-    /* Find the external block */
-    b = cram_get_block_by_id(slice, c->u.external.content_id);
-    if (!b)
-        return *out_size?-1:0;
-
-    cp = cram_extract_block(b, *out_size);
-    if (!cp)
-        return -1;
-
-    BLOCK_APPEND(out, cp, *out_size);
-    return 0;
-
- block_err:
-    return -1;
-}
-
-void cram_external_decode_free(cram_codec *c) {
-    if (c)
-        free(c);
-}
-
-
-int cram_external_decode_size(cram_slice *slice, cram_codec *c) {
-    cram_block *b;
-
-    /* Find the external block */
-    b = cram_get_block_by_id(slice, c->u.external.content_id);
-    if (!b)
-        return -1;
-
-    return b->uncomp_size;
-}
-
-cram_block *cram_external_get_block(cram_slice *slice, cram_codec *c) {
-    return cram_get_block_by_id(slice, c->u.external.content_id);
-}
-
-cram_codec *cram_external_decode_init(cram_block_compression_hdr *hdr,
-                                      char *data, int size,
-                                      enum cram_encoding codec,
-                                      enum cram_external_type option,
-                                      int version, varint_vec *vv) {
-    cram_codec *c = NULL;
-    char *cp = data;
-
-    if (size < 1)
-        goto malformed;
-
-    if (!(c = malloc(sizeof(*c))))
-        return NULL;
-
-    c->codec  = E_EXTERNAL;
-    if (CRAM_MAJOR_VERS(version) >= 4) {
-        // Version 4 does not permit integer data to be encoded as a
-        // series of bytes.  This is used purely for bytes, either
-        // singular or declared as arrays
-        switch (codec) {
-        case E_EXTERNAL:
-            if (option == E_BYTE_ARRAY_BLOCK)
-                c->decode = cram_external_decode_block;
-            else if (option == E_BYTE || option == E_BYTE_ARRAY)
-                c->decode = cram_external_decode_char;
-            else
-                return NULL;
-            break;
-        default:
-            return NULL;
-        }
-    } else {
-        // CRAM 3 and earlier encodes integers as EXTERNAL.  We need
-        // use the option field to indicate the input data format so
-        // we know which serialisation format to use.
-        if (option == E_INT)
-            c->decode = cram_external_decode_int;
-        else if (option == E_LONG)
-            c->decode = cram_external_decode_long;
-        else if (option == E_BYTE_ARRAY || option == E_BYTE)
-            c->decode = cram_external_decode_char;
-        else
-            c->decode = cram_external_decode_block;
-    }
-    c->free   = cram_external_decode_free;
-    c->size   = cram_external_decode_size;
-    c->get_block = cram_external_get_block;
-
-    c->u.external.content_id = vv->varint_get32(&cp, data+size, NULL);
-
-    if (cp - data != size)
-        goto malformed;
-
-    c->u.external.type = option;
-
-    return c;
-
- malformed:
-    hts_log_error("Malformed external header stream");
-    free(c);
-    return NULL;
-}
-
-int cram_external_encode_int(cram_slice *slice, cram_codec *c,
-                             char *in, int in_size) {
-    uint32_t *i32 = (uint32_t *)in;
-    return c->vv->varint_put32_blk(c->out, *i32) >= 0 ? 0 : -1;
-}
-
-int cram_external_encode_sint(cram_slice *slice, cram_codec *c,
-                             char *in, int in_size) {
-    int32_t *i32 = (int32_t *)in;
-    return c->vv->varint_put32s_blk(c->out, *i32) >= 0 ? 0 : -1;
-}
-
-int cram_external_encode_long(cram_slice *slice, cram_codec *c,
-                             char *in, int in_size) {
-    uint64_t *i64 = (uint64_t *)in;
-    return c->vv->varint_put64_blk(c->out, *i64) >= 0 ? 0 : -1;
-}
-
-int cram_external_encode_slong(cram_slice *slice, cram_codec *c,
-                               char *in, int in_size) {
-    int64_t *i64 = (int64_t *)in;
-    return c->vv->varint_put64s_blk(c->out, *i64) >= 0 ? 0 : -1;
-}
-
-int cram_external_encode_char(cram_slice *slice, cram_codec *c,
-                              char *in, int in_size) {
-    BLOCK_APPEND(c->out, in, in_size);
-    return 0;
-
- block_err:
-    return -1;
-}
-
-void cram_external_encode_free(cram_codec *c) {
-    if (!c)
-        return;
-    free(c);
-}
-
-int cram_external_encode_store(cram_codec *c, cram_block *b, char *prefix,
-                               int version) {
-    char tmp[99], *tp = tmp, *tpend = tmp+99;
-    int len = 0, r = 0, n;
-
-    if (prefix) {
-        size_t l = strlen(prefix);
-        BLOCK_APPEND(b, prefix, l);
-        len += l;
-    }
-
-    tp += c->vv->varint_put32(tp, tpend, c->u.e_external.content_id);
-    len += (n = c->vv->varint_put32_blk(b, c->codec)); r |= n;
-    len += (n = c->vv->varint_put32_blk(b, tp-tmp));   r |= n;
-    BLOCK_APPEND(b, tmp, tp-tmp);
-    len += tp-tmp;
-
-    if (r > 0)
-        return len;
-
- block_err:
-    return -1;
-}
-
-cram_codec *cram_external_encode_init(cram_stats *st,
-                                      enum cram_encoding codec,
-                                      enum cram_external_type option,
-                                      void *dat,
-                                      int version, varint_vec *vv) {
-    cram_codec *c;
-
-    c = malloc(sizeof(*c));
-    if (!c)
-        return NULL;
-    c->codec = E_EXTERNAL;
-    c->free = cram_external_encode_free;
-    if (CRAM_MAJOR_VERS(version) >= 4) {
-        // Version 4 does not permit integer data to be encoded as a
-        // series of bytes.  This is used purely for bytes, either
-        // singular or declared as arrays
-        switch (codec) {
-        case E_EXTERNAL:
-            if (option != E_BYTE && option != E_BYTE_ARRAY)
-                return NULL;
-            c->encode = cram_external_encode_char;
-            break;
-        default:
-            return NULL;
-        }
-    } else {
-        // CRAM 3 and earlier encodes integers as EXTERNAL.  We need
-        // use the option field to indicate the input data format so
-        // we know which serialisation format to use.
-        if (option == E_INT)
-            c->encode = cram_external_encode_int;
-        else if (option == E_LONG)
-            c->encode = cram_external_encode_long;
-        else if (option == E_BYTE_ARRAY || option == E_BYTE)
-            c->encode = cram_external_encode_char;
-        else
-            abort();
-    }
-    c->store = cram_external_encode_store;
-    c->flush = NULL;
-
-    c->u.e_external.content_id = (size_t)dat;
-
-    return c;
-}
-
-/*
- * ---------------------------------------------------------------------------
- * VARINT
- *
- * In CRAM 3.0 and earlier, E_EXTERNAL stored both integers in ITF8
- * format as well as bytes.  In CRAM 4 EXTERNAL is only for bytes and
- * byte arrays, with two dedicated encodings for integers:
- * VARINT_SIGNED and VARINT_UNSIGNED.  These also differ a little to
- * EXTERNAL with the addition of an offset field, meaning we can store
- * values in, say, the range -2 to 1 million without needing to use
- * a signed zig-zag transformation.
- */
-int cram_varint_decode_int(cram_slice *slice, cram_codec *c,
-                           cram_block *in, char *out, int *out_size) {
-    char *cp;
-    cram_block *b;
-
-    /* Find the data block */
-    b = cram_get_block_by_id(slice, c->u.varint.content_id);
-    if (!b)
-        return *out_size?-1:0;
-
-    cp = (char *)b->data + b->idx;
-    // E_INT and E_LONG are guaranteed single item queries
-    int err = 0;
-    *(int32_t *)out = c->vv->varint_get32(&cp,
-                                          (char *)b->data + b->uncomp_size,
-                                          &err) + c->u.varint.offset;
-    b->idx = cp - (char *)b->data;
-    *out_size = 1;
-
-    return err ? -1 : 0;
-}
-
-int cram_varint_decode_sint(cram_slice *slice, cram_codec *c,
-                            cram_block *in, char *out, int *out_size) {
-    char *cp;
-    cram_block *b;
-
-    /* Find the data block */
-    b = cram_get_block_by_id(slice, c->u.varint.content_id);
-    if (!b)
-        return *out_size?-1:0;
-
-    cp = (char *)b->data + b->idx;
-    // E_INT and E_LONG are guaranteed single item queries
-    int err = 0;
-    *(int32_t *)out = c->vv->varint_get32s(&cp,
-                                           (char *)b->data + b->uncomp_size,
-                                           &err) + c->u.varint.offset;
-    b->idx = cp - (char *)b->data;
-    *out_size = 1;
-
-    return err ? -1 : 0;
-}
-
-int cram_varint_decode_long(cram_slice *slice, cram_codec *c,
-                            cram_block *in, char *out, int *out_size) {
-    char *cp;
-    cram_block *b;
-
-    /* Find the data block */
-    b = cram_get_block_by_id(slice, c->u.varint.content_id);
-    if (!b)
-        return *out_size?-1:0;
-
-    cp = (char *)b->data + b->idx;
-    // E_INT and E_LONG are guaranteed single item queries
-    int err = 0;
-    *(int64_t *)out = c->vv->varint_get64(&cp,
-                                          (char *)b->data + b->uncomp_size,
-                                          &err) + c->u.varint.offset;
-    b->idx = cp - (char *)b->data;
-    *out_size = 1;
-
-    return err ? -1 : 0;
-}
-
-int cram_varint_decode_slong(cram_slice *slice, cram_codec *c,
-                             cram_block *in, char *out, int *out_size) {
-    char *cp;
-    cram_block *b;
-
-    /* Find the data block */
-    b = cram_get_block_by_id(slice, c->u.varint.content_id);
-    if (!b)
-        return *out_size?-1:0;
-
-    cp = (char *)b->data + b->idx;
-    // E_INT and E_LONG are guaranteed single item queries
-    int err = 0;
-    *(int64_t *)out = c->vv->varint_get64s(&cp,
-                                           (char *)b->data + b->uncomp_size,
-                                           &err) + c->u.varint.offset;
-    b->idx = cp - (char *)b->data;
-    *out_size = 1;
-
-    return err ? -1 : 0;
-}
-
-void cram_varint_decode_free(cram_codec *c) {
-    if (c)
-        free(c);
-}
-
-int cram_varint_decode_size(cram_slice *slice, cram_codec *c) {
-    cram_block *b;
-
-    /* Find the data block */
-    b = cram_get_block_by_id(slice, c->u.varint.content_id);
-    if (!b)
-        return -1;
-
-    return b->uncomp_size;
-}
-
-cram_block *cram_varint_get_block(cram_slice *slice, cram_codec *c) {
-    return cram_get_block_by_id(slice, c->u.varint.content_id);
-}
-
-cram_codec *cram_varint_decode_init(cram_block_compression_hdr *hdr,
-                                    char *data, int size,
-                                    enum cram_encoding codec,
-                                    enum cram_external_type option,
-                                    int version, varint_vec *vv) {
-    cram_codec *c;
-    char *cp = data, *cp_end = data+size;
-
-    if (!(c = malloc(sizeof(*c))))
-        return NULL;
-
-    c->codec  = codec;
-
-    // Function pointer choice is theoretically by codec type.
-    // Given we have some vars as int32 and some as int64 we
-    // use option too for sizing, although on disk format
-    // does not change.
-    switch(codec) {
-    case E_VARINT_UNSIGNED:
-        c->decode = (option == E_INT)
-            ? cram_varint_decode_int
-            : cram_varint_decode_long;
-        break;
-    case E_VARINT_SIGNED:
-        c->decode = (option == E_INT)
-            ? cram_varint_decode_sint
-            : cram_varint_decode_slong;
-        break;
-    default:
-        return NULL;
-    }
-
-    c->free   = cram_varint_decode_free;
-    c->size   = cram_varint_decode_size;
-    c->get_block = cram_varint_get_block;
-
-    c->u.varint.content_id = vv->varint_get32 (&cp, cp_end, NULL);
-    c->u.varint.offset     = vv->varint_get64s(&cp, cp_end, NULL);
-
-    if (cp - data != size) {
-        fprintf(stderr, "Malformed varint header stream\n");
-        free(c);
-        return NULL;
-    }
-
-    c->u.varint.type = option;
-
-    return c;
-}
-
-int cram_varint_encode_int(cram_slice *slice, cram_codec *c,
-                           char *in, int in_size) {
-    uint32_t *i32 = (uint32_t *)in;
-    return c->vv->varint_put32_blk(c->out, *i32 - c->u.varint.offset) >= 0
-        ? 0 : -1;
-}
-
-int cram_varint_encode_sint(cram_slice *slice, cram_codec *c,
-                            char *in, int in_size) {
-    int32_t *i32 = (int32_t *)in;
-    return c->vv->varint_put32s_blk(c->out, *i32 - c->u.varint.offset) >= 0
-        ? 0 : -1;
-}
-
-int cram_varint_encode_long(cram_slice *slice, cram_codec *c,
-                            char *in, int in_size) {
-    uint64_t *i64 = (uint64_t *)in;
-    return c->vv->varint_put64_blk(c->out, *i64 - c->u.varint.offset) >= 0
-        ? 0 : -1;
-}
-
-int cram_varint_encode_slong(cram_slice *slice, cram_codec *c,
-                             char *in, int in_size) {
-    int64_t *i64 = (int64_t *)in;
-    return c->vv->varint_put64s_blk(c->out, *i64 - c->u.varint.offset) >= 0
-        ? 0 : -1;
-}
-
-void cram_varint_encode_free(cram_codec *c) {
-    if (!c)
-        return;
-    free(c);
-}
-
-int cram_varint_encode_store(cram_codec *c, cram_block *b, char *prefix,
-                             int version) {
-    char tmp[99], *tp = tmp;
-    int len = 0;
-
-    if (prefix) {
-        size_t l = strlen(prefix);
-        BLOCK_APPEND(b, prefix, l);
-        len += l;
-    }
-
-    tp += c->vv->varint_put32 (tp, NULL, c->u.e_varint.content_id);
-    tp += c->vv->varint_put64s(tp, NULL, c->u.e_varint.offset);
-    len += c->vv->varint_put32_blk(b, c->codec);
-    len += c->vv->varint_put32_blk(b, tp-tmp);
-    BLOCK_APPEND(b, tmp, tp-tmp);
-    len += tp-tmp;
-
-    return len;
-
- block_err:
-    return -1;
-}
-
-cram_codec *cram_varint_encode_init(cram_stats *st,
-                                    enum cram_encoding codec,
-                                    enum cram_external_type option,
-                                    void *dat,
-                                    int version, varint_vec *vv) {
-    cram_codec *c;
-
-    if (!(c = malloc(sizeof(*c))))
-        return NULL;
-
-    c->u.e_varint.offset = 0;
-    if (st) {
-        // Marginal difference so far! Not worth the hassle?
-        if (st->min_val < 0 && st->min_val >= -127
-            && st->max_val / -st->min_val > 100) {
-            c->u.e_varint.offset = -st->min_val;
-            codec = E_VARINT_UNSIGNED;
-        } else if (st->min_val > 0) {
-            c->u.e_varint.offset = -st->min_val;
-        }
-    }
-
-    c->codec = codec;
-    c->free = cram_varint_encode_free;
-
-    // Function pointer choice is theoretically by codec type.
-    // Given we have some vars as int32 and some as int64 we
-    // use option too for sizing, although on disk format
-    // does not change.
-    switch (codec) {
-    case E_VARINT_UNSIGNED:
-        c->encode = (option == E_INT)
-            ? cram_varint_encode_int
-            : cram_varint_encode_long;
-        break;
-    case E_VARINT_SIGNED:
-        c->encode = (option == E_INT)
-            ? cram_varint_encode_sint
-            : cram_varint_encode_slong;
-        break;
-    default:
-        return NULL;
-    }
-    c->store = cram_varint_encode_store;
-    c->flush = NULL;
-
-    c->u.e_varint.content_id = (size_t)dat;
-
-    return c;
-}
-/*
- * ---------------------------------------------------------------------------
- * CONST_BYTE and CONST_INT
- */
-int cram_const_decode_byte(cram_slice *slice, cram_codec *c,
-                           cram_block *in, char *out, int *out_size) {
-    int i, n;
-
-    for (i = 0, n = *out_size; i < n; i++)
-        out[i] = c->u.xconst.val;
-
-    return 0;
-}
-
-int cram_const_decode_int(cram_slice *slice, cram_codec *c,
-                          cram_block *in, char *out, int *out_size) {
-    int32_t *out_i = (int32_t *)out;
-    int i, n;
-
-    for (i = 0, n = *out_size; i < n; i++)
-        out_i[i] = c->u.xconst.val;
-
-    return 0;
-}
-
-int cram_const_decode_long(cram_slice *slice, cram_codec *c,
-                           cram_block *in, char *out, int *out_size) {
-    int64_t *out_i = (int64_t *)out;
-    int i, n;
-
-    for (i = 0, n = *out_size; i < n; i++)
-        out_i[i] = c->u.xconst.val;
-
-    return 0;
-}
-
-void cram_const_decode_free(cram_codec *c) {
-    if (c)
-        free(c);
-}
-
-int cram_const_decode_size(cram_slice *slice, cram_codec *c) {
-    return 0;
-}
-
-cram_codec *cram_const_decode_init(cram_block_compression_hdr *hdr,
-                                   char *data, int size,
-                                   enum cram_encoding codec,
-                                   enum cram_external_type option,
-                                   int version, varint_vec *vv) {
-    cram_codec *c;
-    char *cp = data;
-
-    if (!(c = malloc(sizeof(*c))))
-        return NULL;
-
-    c->codec  = codec;
-    if (codec == E_CONST_BYTE)
-        c->decode = cram_const_decode_byte;
-    else if (option == E_INT)
-        c->decode = cram_const_decode_int;
-    else
-        c->decode = cram_const_decode_long;
-    c->free   = cram_const_decode_free;
-    c->size   = cram_const_decode_size;
-    c->get_block = NULL;
-
-    c->u.xconst.val = vv->varint_get64s(&cp, data+size, NULL);
-
-    if (cp - data != size) {
-        fprintf(stderr, "Malformed const header stream\n");
-        free(c);
-        return NULL;
-    }
-
-    return c;
-}
-
-int cram_const_encode(cram_slice *slice, cram_codec *c,
-                      char *in, int in_size) {
-    return 0;
-}
-
-int cram_const_encode_store(cram_codec *c, cram_block *b, char *prefix,
-                            int version) {
-    char tmp[99], *tp = tmp;
-    int len = 0;
-
-    if (prefix) {
-        size_t l = strlen(prefix);
-        BLOCK_APPEND(b, prefix, l);
-        len += l;
-    }
-
-    tp += c->vv->varint_put64s(tp, NULL, c->u.xconst.val);
-    len += c->vv->varint_put32_blk(b, c->codec);
-    len += c->vv->varint_put32_blk(b, tp-tmp);
-    BLOCK_APPEND(b, tmp, tp-tmp);
-    len += tp-tmp;
-
-    return len;
-
- block_err:
-    return -1;
-}
-
-cram_codec *cram_const_encode_init(cram_stats *st,
-                                   enum cram_encoding codec,
-                                   enum cram_external_type option,
-                                   void *dat,
-                                   int version, varint_vec *vv) {
-    cram_codec *c;
-
-    if (!(c = malloc(sizeof(*c))))
-        return NULL;
-
-    c->codec = codec;
-    c->free = cram_const_decode_free; // as as decode
-    c->encode = cram_const_encode; // a nop
-    c->store = cram_const_encode_store;
-    c->flush = NULL;
-    c->u.e_xconst.val = st->min_val;
-
-    return c;
-}
-
-/*
- * ---------------------------------------------------------------------------
- * BETA
- */
-int cram_beta_decode_long(cram_slice *slice, cram_codec *c, cram_block *in, char *out, int *out_size) {
-    int64_t *out_i = (int64_t *)out;
-    int i, n = *out_size;
-
-    if (c->u.beta.nbits) {
-        if (cram_not_enough_bits(in, c->u.beta.nbits * n))
-            return -1;
-
-        for (i = 0; i < n; i++)
-            out_i[i] = get_bits_MSB(in, c->u.beta.nbits) - c->u.beta.offset;
-    } else {
-        for (i = 0; i < n; i++)
-            out_i[i] = -c->u.beta.offset;
-    }
-
-    return 0;
-}
-
-int cram_beta_decode_int(cram_slice *slice, cram_codec *c, cram_block *in, char *out, int *out_size) {
-    int32_t *out_i = (int32_t *)out;
-    int i, n = *out_size;
-
-    if (c->u.beta.nbits) {
-        if (cram_not_enough_bits(in, c->u.beta.nbits * n))
-            return -1;
-
-        for (i = 0; i < n; i++)
-            out_i[i] = get_bits_MSB(in, c->u.beta.nbits) - c->u.beta.offset;
-    } else {
-        for (i = 0; i < n; i++)
-            out_i[i] = -c->u.beta.offset;
-    }
-
-    return 0;
-}
-
-int cram_beta_decode_char(cram_slice *slice, cram_codec *c, cram_block *in, char *out, int *out_size) {
-    int i, n = *out_size;
-
-
-    if (c->u.beta.nbits) {
-        if (cram_not_enough_bits(in, c->u.beta.nbits * n))
-            return -1;
-
-        if (out)
-            for (i = 0; i < n; i++)
-                out[i] = get_bits_MSB(in, c->u.beta.nbits) - c->u.beta.offset;
-        else
-            for (i = 0; i < n; i++)
-                get_bits_MSB(in, c->u.beta.nbits);
-    } else {
-        if (out)
-            for (i = 0; i < n; i++)
-                out[i] = -c->u.beta.offset;
-    }
-
-    return 0;
-}
-
-void cram_beta_decode_free(cram_codec *c) {
-    if (c)
-        free(c);
-}
-
-cram_codec *cram_beta_decode_init(cram_block_compression_hdr *hdr,
-                                  char *data, int size,
-                                  enum cram_encoding codec,
-                                  enum cram_external_type option,
-                                  int version, varint_vec *vv) {
-    cram_codec *c;
-    char *cp = data;
-
-    if (!(c = malloc(sizeof(*c))))
-        return NULL;
-
-    c->codec  = E_BETA;
-    if (option == E_INT || option == E_SINT)
-        c->decode = cram_beta_decode_int;
-    else if (option == E_LONG || option == E_SLONG)
-        c->decode = cram_beta_decode_long;
-    else if (option == E_BYTE_ARRAY || option == E_BYTE)
-        c->decode = cram_beta_decode_char;
-    else {
-        hts_log_error("BYTE_ARRAYs not supported by this codec");
-        free(c);
-        return NULL;
-    }
-    c->free   = cram_beta_decode_free;
-
-    c->u.beta.nbits = -1;
-    c->u.beta.offset = vv->varint_get32(&cp, data + size, NULL);
-    if (cp < data + size) // Ensure test below works
-        c->u.beta.nbits  = vv->varint_get32(&cp, data + size, NULL);
-
-    if (cp - data != size
-        || c->u.beta.nbits < 0 || c->u.beta.nbits > 8 * sizeof(int)) {
-        hts_log_error("Malformed beta header stream");
-        free(c);
-        return NULL;
-    }
-
-    return c;
-}
-
-int cram_beta_encode_store(cram_codec *c, cram_block *b,
-                           char *prefix, int version) {
-    int len = 0, r = 0, n;
-
-    if (prefix) {
-        size_t l = strlen(prefix);
-        BLOCK_APPEND(b, prefix, l);
-        len += l;
-    }
-
-    len += (n = c->vv->varint_put32_blk(b, c->codec)); r |= n;
-    // codec length
-    len += (n = c->vv->varint_put32_blk(b, c->vv->varint_size(c->u.e_beta.offset)
-                                         + c->vv->varint_size(c->u.e_beta.nbits)));
-    r |= n;
-    len += (n = c->vv->varint_put32_blk(b, c->u.e_beta.offset)); r |= n;
-    len += (n = c->vv->varint_put32_blk(b, c->u.e_beta.nbits));  r |= n;
-
-    if (r > 0) return len;
-
- block_err:
-    return -1;
-}
-
-int cram_beta_encode_long(cram_slice *slice, cram_codec *c,
-                          char *in, int in_size) {
-    int64_t *syms = (int64_t *)in;
-    int i, r = 0;
-
-    for (i = 0; i < in_size; i++)
-        r |= store_bits_MSB(c->out, syms[i] + c->u.e_beta.offset,
-                            c->u.e_beta.nbits);
-
-    return r;
-}
-
-int cram_beta_encode_int(cram_slice *slice, cram_codec *c,
-                         char *in, int in_size) {
-    int *syms = (int *)in;
-    int i, r = 0;
-
-    for (i = 0; i < in_size; i++)
-        r |= store_bits_MSB(c->out, syms[i] + c->u.e_beta.offset,
-                            c->u.e_beta.nbits);
-
-    return r;
-}
-
-int cram_beta_encode_char(cram_slice *slice, cram_codec *c,
-                          char *in, int in_size) {
-    unsigned char *syms = (unsigned char *)in;
-    int i, r = 0;
-
-    for (i = 0; i < in_size; i++)
-        r |= store_bits_MSB(c->out, syms[i] + c->u.e_beta.offset,
-                            c->u.e_beta.nbits);
-
-    return r;
-}
-
-void cram_beta_encode_free(cram_codec *c) {
-    if (c) free(c);
-}
-
-cram_codec *cram_beta_encode_init(cram_stats *st,
-                                  enum cram_encoding codec,
-                                  enum cram_external_type option,
-                                  void *dat,
-                                  int version, varint_vec *vv) {
-    cram_codec *c;
-    int min_val, max_val, len = 0;
-    int64_t range;
-
-    c = malloc(sizeof(*c));
-    if (!c)
-        return NULL;
-    c->codec  = E_BETA;
-    c->free   = cram_beta_encode_free;
-    if (option == E_INT || option == E_SINT)
-        c->encode = cram_beta_encode_int;
-    else if (option == E_LONG || option == E_SLONG)
-        c->encode = cram_beta_encode_long;
-    else
-        c->encode = cram_beta_encode_char;
-    c->store  = cram_beta_encode_store;
-    c->flush = NULL;
-
-    if (dat) {
-        min_val = ((int *)dat)[0];
-        max_val = ((int *)dat)[1];
-    } else {
-        min_val = INT_MAX;
-        max_val = INT_MIN;
-        int i;
-        for (i = 0; i < MAX_STAT_VAL; i++) {
-            if (!st->freqs[i])
-                continue;
-            if (min_val > i)
-                min_val = i;
-            max_val = i;
-        }
-        if (st->h) {
-            khint_t k;
-
-            for (k = kh_begin(st->h); k != kh_end(st->h); k++) {
-                if (!kh_exist(st->h, k))
-                    continue;
-
-                i = kh_key(st->h, k);
-                if (min_val > i)
-                    min_val = i;
-                if (max_val < i)
-                    max_val = i;
-            }
-        }
-    }
-
-    assert(max_val >= min_val);
-    c->u.e_beta.offset = -min_val;
-    range = (int64_t) max_val - min_val;
-    while (range) {
-        len++;
-        range >>= 1;
-    }
-    c->u.e_beta.nbits = len;
-
-    return c;
-}
-
-/*
- * ---------------------------------------------------------------------------
- * XPACK: Packing multiple values into a single byte.  A fast transform that
- * reduces time taken by entropy encoder and may also improve compression.
- *
- * This also has the additional requirement that the data series is not
- * interleaved with another, permitting efficient encoding and decoding
- * of all elements enmasse instead of needing to only extract the bits
- * necessary per item.
- */
-int cram_xpack_decode_long(cram_slice *slice, cram_codec *c, cram_block *in, char *out, int *out_size) {
-    int64_t *out_i = (int64_t *)out;
-    int i, n = *out_size;
-
-    if (c->u.xpack.nbits) {
-        for (i = 0; i < n; i++)
-            out_i[i] = c->u.xpack.rmap[get_bits_MSB(in, c->u.xpack.nbits)];
-    } else {
-        for (i = 0; i < n; i++)
-            out_i[i] = c->u.xpack.rmap[0];
-    }
-
-    return 0;
-}
-
-int cram_xpack_decode_int(cram_slice *slice, cram_codec *c, cram_block *in, char *out, int *out_size) {
-    int32_t *out_i = (int32_t *)out;
-    int i, n = *out_size;
-
-    if (c->u.xpack.nbits) {
-        if (cram_not_enough_bits(in, c->u.xpack.nbits * n))
-            return -1;
-
-        for (i = 0; i < n; i++)
-            out_i[i] = c->u.xpack.rmap[get_bits_MSB(in, c->u.xpack.nbits)];
-    } else {
-        for (i = 0; i < n; i++)
-            out_i[i] = c->u.xpack.rmap[0];
-    }
-
-    return 0;
-}
-
-static int cram_xpack_decode_expand_char(cram_slice *slice, cram_codec *c) {
-    cram_block *b = slice->block_by_id[512 + c->codec_id];
-    if (b)
-        return 0;
-
-    // get sub-codec data.
-    cram_block *sub_b = c->u.xpack.sub_codec->get_block(slice, c->u.xpack.sub_codec);
-    if (!sub_b)
-        return -1;
-
-    // Allocate local block to expand into
-    b = slice->block_by_id[512 + c->codec_id] = cram_new_block(0, 0);
-    if (!b)
-        return -1;
-    int n = sub_b->uncomp_size * 8/c->u.xpack.nbits;
-    BLOCK_GROW(b, n);
-    b->uncomp_size = n;
-
-    uint8_t p[256];
-    int z;
-    for (z = 0; z < 256; z++)
-        p[z] = c->u.xpack.rmap[z];
-    hts_unpack(sub_b->data, sub_b->uncomp_size, b->data, b->uncomp_size,
-               8 / c->u.xpack.nbits, p);
-
-    return 0;
-
- block_err:
-    return -1;
-}
-
-int cram_xpack_decode_char(cram_slice *slice, cram_codec *c, cram_block *in, char *out, int *out_size) {
-    // FIXME: we need to ban data-series interleaving in the spec for this to work.
-
-    // Remember this may be called when threaded and multi-slice per container.
-    // Hence one cram_codec instance, multiple slices, multiple blocks.
-    // We therefore have to cache appropriate block info in slice and not codec.
-    //    b = cram_get_block_by_id(slice, c->external.content_id);
-    if (c->u.xpack.nval > 1) {
-        cram_xpack_decode_expand_char(slice, c);
-        cram_block *b = slice->block_by_id[512 + c->codec_id];
-        if (!b)
-            return -1;
-
-        if (out)
-            memcpy(out, b->data + b->byte, *out_size);
-        b->byte += *out_size;
-    } else {
-        memset(out, c->u.xpack.rmap[0], *out_size);
-    }
-
-    return 0;
-}
-
-void cram_xpack_decode_free(cram_codec *c) {
-    if (!c) return;
-
-    if (c->u.xpack.sub_codec)
-        c->u.xpack.sub_codec->free(c->u.xpack.sub_codec);
-
-    //free(slice->block_by_id[512 + c->codec_id]);
-    //slice->block_by_id[512 + c->codec_id] = 0;
-
-    free(c);
-}
-
-int cram_xpack_decode_size(cram_slice *slice, cram_codec *c) {
-    cram_xpack_decode_expand_char(slice, c);
-    return slice->block_by_id[512 + c->codec_id]->uncomp_size;
-}
-
-cram_block *cram_xpack_get_block(cram_slice *slice, cram_codec *c) {
-    cram_xpack_decode_expand_char(slice, c);
-    return slice->block_by_id[512 + c->codec_id];
-}
-
-cram_codec *cram_xpack_decode_init(cram_block_compression_hdr *hdr,
-                                   char *data, int size,
-                                   enum cram_encoding codec,
-                                   enum cram_external_type option,
-                                   int version, varint_vec *vv) {
-    cram_codec *c;
-    char *cp = data;
-    char *endp = data+size;
-
-    if (!(c = calloc(1, sizeof(*c))))
-        return NULL;
-
-    c->codec  = E_XPACK;
-    if (option == E_LONG)
-        c->decode = cram_xpack_decode_long;
-    else if (option == E_INT)
-        c->decode = cram_xpack_decode_int;
-    else if (option == E_BYTE_ARRAY || option == E_BYTE)
-        c->decode = cram_xpack_decode_char;
-    else {
-        fprintf(stderr, "BYTE_ARRAYs not supported by this codec\n");
-        goto malformed;
-    }
-    c->free = cram_xpack_decode_free;
-    c->size = cram_xpack_decode_size;
-    c->get_block = cram_xpack_get_block;
-
-    c->u.xpack.nbits = vv->varint_get32(&cp, endp, NULL);
-    c->u.xpack.nval  = vv->varint_get32(&cp, endp, NULL);
-    if (c->u.xpack.nbits >= 8  || c->u.xpack.nbits < 0 ||
-        c->u.xpack.nval  > 256 || c->u.xpack.nval < 0)
-        goto malformed;
-    int i;
-    for (i = 0; i < c->u.xpack.nval; i++) {
-        uint32_t v = vv->varint_get32(&cp, endp, NULL);
-        if (v >= 256)
-            goto malformed;
-        c->u.xpack.rmap[i] = v; // reverse map: e.g 0-3 to P,A,C,K
-    }
-
-    int encoding = vv->varint_get32(&cp, endp, NULL);
-    int sub_size = vv->varint_get32(&cp, endp, NULL);
-    if (sub_size < 0 || endp - cp < sub_size)
-        goto malformed;
-    c->u.xpack.sub_codec = cram_decoder_init(hdr, encoding, cp, sub_size,
-                                             option, version, vv);
-    if (c->u.xpack.sub_codec == NULL)
-        goto malformed;
-    cp += sub_size;
-
-    if (cp - data != size
-        || c->u.xpack.nbits < 0 || c->u.xpack.nbits > 8 * sizeof(int64_t)) {
-    malformed:
-        fprintf(stderr, "Malformed xpack header stream\n");
-        cram_xpack_decode_free(c);
-        return NULL;
-    }
-
-    return c;
-}
-
-int cram_xpack_encode_flush(cram_codec *c) {
-    // Pack the buffered up data
-    int meta_len;
-    uint64_t out_len;
-    uint8_t out_meta[1024];
-    uint8_t *out = hts_pack(BLOCK_DATA(c->out), BLOCK_SIZE(c->out),
-                            out_meta, &meta_len, &out_len);
-
-    // We now need to pass this through the next layer of transform
-    if (c->u.e_xpack.sub_codec->encode(NULL, // also indicates flush incoming
-                                     c->u.e_xpack.sub_codec,
-                                     (char *)out, out_len))
-        return -1;
-
-    int r = 0;
-    if (c->u.e_xpack.sub_codec->flush)
-        r = c->u.e_xpack.sub_codec->flush(c->u.e_xpack.sub_codec);
-
-    free(out);
-    return r;
-}
-
-int cram_xpack_encode_store(cram_codec *c, cram_block *b,
-                            char *prefix, int version) {
-    int len = 0, r = 0, n;
-
-    if (prefix) {
-        size_t l = strlen(prefix);
-        BLOCK_APPEND(b, prefix, l);
-        len += l;
-    }
-
-    // Store sub-codec
-    cram_codec *tc = c->u.e_xpack.sub_codec;
-    cram_block *tb = cram_new_block(0, 0);
-    if (!tb)
-        return -1;
-    int len2 = tc->store(tc, tb, NULL, version);
-
-    len += (n = c->vv->varint_put32_blk(b, c->codec)); r |= n;
-
-    // codec length
-    int len1 = 0, i;
-    for (i = 0; i < c->u.e_xpack.nval; i++)
-        len1 += (n = c->vv->varint_size(c->u.e_xpack.rmap[i])), r |= n;
-    len += (n = c->vv->varint_put32_blk(b, c->vv->varint_size(c->u.e_xpack.nbits)
-                                        +  c->vv->varint_size(c->u.e_xpack.nval)
-                                        + len1 + len2)); r |= n;
-
-    // The map and sub-codec
-    len += (n = c->vv->varint_put32_blk(b, c->u.e_xpack.nbits)); r |= n;
-    len += (n = c->vv->varint_put32_blk(b, c->u.e_xpack.nval));  r |= n;
-    for (i = 0; i < c->u.e_xpack.nval; i++)
-        len += (n = c->vv->varint_put32_blk(b, c->u.e_xpack.rmap[i])), r |= n;
-
-    BLOCK_APPEND(b, BLOCK_DATA(tb), BLOCK_SIZE(tb));
-
-    cram_free_block(tb);
-
-    return r > 0 ? len + len2 : -1;
-
- block_err:
-    return -1;
-}
-
-// Same as cram_beta_encode_long
-int cram_xpack_encode_long(cram_slice *slice, cram_codec *c,
-                           char *in, int in_size) {
-    int64_t *syms = (int64_t *)in;
-    int i, r = 0;
-
-    for (i = 0; i < in_size; i++)
-        r |= store_bits_MSB(c->out, c->u.e_xpack.map[syms[i]], c->u.e_xpack.nbits);
-
-    return r;
-}
-
-int cram_xpack_encode_int(cram_slice *slice, cram_codec *c,
-                          char *in, int in_size) {
-    int *syms = (int *)in;
-    int i, r = 0;
-
-    for (i = 0; i < in_size; i++)
-        r |= store_bits_MSB(c->out, c->u.e_xpack.map[syms[i]], c->u.e_xpack.nbits);
-
-    return r;
-}
-
-int cram_xpack_encode_char(cram_slice *slice, cram_codec *c,
-                           char *in, int in_size) {
-    BLOCK_APPEND(c->out, in, in_size);
-    return 0;
-
- block_err:
-    return -1;
-}
-
-void cram_xpack_encode_free(cram_codec *c) {
-    if (!c) return;
-
-    if (c->u.e_xpack.sub_codec)
-        c->u.e_xpack.sub_codec->free(c->u.e_xpack.sub_codec);
-
-    cram_free_block(c->out);
-
-    free(c);
-}
-
-cram_codec *cram_xpack_encode_init(cram_stats *st,
-                                   enum cram_encoding codec,
-                                   enum cram_external_type option,
-                                   void *dat,
-                                   int version, varint_vec *vv) {
-    cram_codec *c;
-
-    if (!(c = malloc(sizeof(*c))))
-        return NULL;
-
-    c->codec  = E_XPACK;
-    c->free   = cram_xpack_encode_free;
-    if (option == E_LONG)
-        c->encode = cram_xpack_encode_long;
-    else if (option == E_INT)
-        c->encode = cram_xpack_encode_int;
-    else
-        c->encode = cram_xpack_encode_char;
-    c->store  = cram_xpack_encode_store;
-    c->flush  = cram_xpack_encode_flush;
-
-    cram_xpack_encoder *e = (cram_xpack_encoder *)dat;
-    c->u.e_xpack.nbits = e->nbits;
-    c->u.e_xpack.nval = e->nval;
-    c->u.e_xpack.sub_codec = cram_encoder_init(e->sub_encoding, NULL,
-                                               E_BYTE_ARRAY, e->sub_codec_dat,
-                                               version, vv);
-
-    // Initialise fwd and rev maps
-    memcpy(c->u.e_xpack.map, e->map, sizeof(e->map)); // P,A,C,K to 0,1,2,3
-    int i, n;
-    for (i = n = 0; i < 256; i++)
-        if (e->map[i] != -1)
-            c->u.e_xpack.rmap[n++] = i;               // 0,1,2,3 to P,A,C,K
-    if (n != e->nval) {
-        fprintf(stderr, "Incorrectly specified number of map items in PACK\n");
-        return NULL;
-    }
-
-    return c;
-}
-
-/*
- * ---------------------------------------------------------------------------
- * XDELTA: subtract successive values, zig-zag to turn +/- to + only,
- * and then var-int encode the result.
- *
- * This also has the additional requirement that the data series is not
- * interleaved with another, permitting efficient encoding and decoding
- * of all elements enmasse instead of needing to only extract the bits
- * necessary per item.
- */
-
-static uint8_t  zigzag8 (int8_t  x) { return (x << 1) ^ (x >>  7); }
-static uint16_t zigzag16(int16_t x) { return (x << 1) ^ (x >> 15); }
-static uint32_t zigzag32(int32_t x) { return (x << 1) ^ (x >> 31); }
-
-//static int8_t  unzigzag8 (uint8_t  x) { return (x >> 1) ^ -(x & 1); }
-static int16_t unzigzag16(uint16_t x) { return (x >> 1) ^ -(x & 1); }
-static int32_t unzigzag32(uint32_t x) { return (x >> 1) ^ -(x & 1); }
-
-int cram_xdelta_decode_long(cram_slice *slice, cram_codec *c, cram_block *in, char *out, int *out_size) {
-    return -1;
-}
-
-int cram_xdelta_decode_int(cram_slice *slice, cram_codec *c, cram_block *in, char *out, int *out_size) {
-    // Slow value-by-value method for now
-    uint32_t *out32 = (uint32_t *)out;
-    int i;
-    for (i = 0; i < *out_size; i++) {
-        uint32_t v;
-        int one = 1;
-        if (c->u.e_xdelta.sub_codec->decode(slice, c->u.e_xdelta.sub_codec, in,
-                                          (char *)&v, &one) < 0)
-            return -1;
-        uint32_t d = unzigzag32(v);
-        c->u.xdelta.last = out32[i] = d + c->u.xdelta.last;
-    }
-
-    return 0;
-}
-
-static int cram_xdelta_decode_expand_char(cram_slice *slice, cram_codec *c) {
-    return -1;
-}
-
-int cram_xdelta_decode_char(cram_slice *slice, cram_codec *c, cram_block *in, char *out, int *out_size) {
-    return -1;
-}
-
-static inline int16_t le_int2(int16_t i) {
-    int16_t s;
-    i16_to_le(i, (uint8_t *)&s);
-    return s;
-}
-
-int cram_xdelta_decode_block(cram_slice *slice, cram_codec *c, cram_block *in,
-                             char *out_, int *out_size) {
-    cram_block *out = (cram_block *)out_;
-    cram_block *b = c->u.e_xdelta.sub_codec->get_block(slice, c->u.e_xdelta.sub_codec);
-    int i = 0;
-
-    const int w = c->u.xdelta.word_size;
-    uint32_t npad = (w - *out_size%w)%w;
-    uint32_t out_sz = *out_size + npad;
-    c->u.xdelta.last = 0;  // reset for each new array
-
-    for (i = 0; i < out_sz; i += w) {
-        uint16_t v;
-        // Need better interface
-        char *cp = (char *)b->data + b->byte;
-        char *cp_end = (char *)b->data + b->uncomp_size;
-        int err = 0;
-        v = c->vv->varint_get32(&cp, cp_end, &err);
-        if (err)
-            return -1;
-        b->byte = cp - (char *)b->data;
-
-        switch(w) {
-        case 2: {
-            int16_t d = unzigzag16(v), z;
-            c->u.xdelta.last = d + c->u.xdelta.last;
-            z = le_int2(c->u.xdelta.last);
-            BLOCK_APPEND(out, &z, 2-npad);
-            npad = 0;
-            break;
-        }
-        default:
-            fprintf(stderr, "Unsupported word size by XDELTA\n");
-            return -1;
-        }
-    }
-
-    return 0;
-
- block_err:
-    return -1;
-}
-
-void cram_xdelta_decode_free(cram_codec *c) {
-    if (!c) return;
-
-    if (c->u.xdelta.sub_codec)
-        c->u.xdelta.sub_codec->free(c->u.xdelta.sub_codec);
-
-    free(c);
-}
-
-int cram_xdelta_decode_size(cram_slice *slice, cram_codec *c) {
-    cram_xdelta_decode_expand_char(slice, c);
-    return slice->block_by_id[512 + c->codec_id]->uncomp_size;
-}
-
-cram_block *cram_xdelta_get_block(cram_slice *slice, cram_codec *c) {
-    cram_xdelta_decode_expand_char(slice, c);
-    return slice->block_by_id[512 + c->codec_id];
-}
-
-cram_codec *cram_xdelta_decode_init(cram_block_compression_hdr *hdr,
-                                    char *data, int size,
-                                    enum cram_encoding codec,
-                                    enum cram_external_type option,
-                                    int version, varint_vec *vv) {
-    cram_codec *c;
-    char *cp = data;
-    char *endp = data+size;
-
-    if (!(c = calloc(1, sizeof(*c))))
-        return NULL;
-
-    c->codec  = E_XDELTA;
-    if (option == E_LONG)
-        c->decode = cram_xdelta_decode_long;
-    else if (option == E_INT)
-        c->decode = cram_xdelta_decode_int;
-    else if (option == E_BYTE_ARRAY || option == E_BYTE)
-        c->decode = cram_xdelta_decode_char;
-    else if (option == E_BYTE_ARRAY_BLOCK) {
-        option = E_BYTE_ARRAY;
-        c->decode = cram_xdelta_decode_block;
-    } else
-        return NULL;
-    c->free = cram_xdelta_decode_free;
-    c->size = cram_xdelta_decode_size;
-    c->get_block = cram_xdelta_get_block;
-
-    c->u.xdelta.word_size = vv->varint_get32(&cp, endp, NULL);
-    c->u.xdelta.last = 0;
-
-    int encoding = vv->varint_get32(&cp, endp, NULL);
-    int sub_size = vv->varint_get32(&cp, endp, NULL);
-    if (sub_size < 0 || endp - cp < sub_size)
-        goto malformed;
-    c->u.xdelta.sub_codec = cram_decoder_init(hdr, encoding, cp, sub_size,
-                                              option, version, vv);
-    if (c->u.xdelta.sub_codec == NULL)
-        goto malformed;
-    cp += sub_size;
-
-    if (cp - data != size) {
-    malformed:
-        fprintf(stderr, "Malformed xdelta header stream\n");
-        cram_xdelta_decode_free(c);
-        return NULL;
-    }
-
-    return c;
-}
-
-int cram_xdelta_encode_flush(cram_codec *c) {
-    int r = -1;
-    cram_block *b = cram_new_block(0, 0);
-    if (!b)
-        return -1;
-
-    switch (c->u.e_xdelta.word_size) {
-    case 2: {
-        // Delta + zigzag transform.
-        // Subtracting two 8-bit values has a 9-bit result (-255 to 255).
-        // However think of it as turning a wheel clockwise or anti-clockwise.
-        // If it has 256 gradations then a -ve rotation followed by a +ve
-        // rotation of the same amount reverses it regardless.
-        //
-        // Similarly the zig-zag transformation doesn't invent any extra bits,
-        // so the entire thing can be done in-situ.  This may permit faster
-        // SIMD loops if we break apart the steps.
-
-        // uint16_t last = 0, d;
-        // for (i = 0; i < n; i++) {
-        //     d = io[i] - last;
-        //     last = io[i];
-        //     io[i] = zigzag16(vd);
-        // }
-
-        // --- vs ---
-
-        // for (i = n-1; i >= 1; i--)
-        //     io[i] -= io[i-1];
-        // for (i = 0; i < n; i++)
-        //     io[i] = zigzag16(io[i]);
-
-        // varint: need array variant for speed here.
-        // With zig-zag
-        int i, n = BLOCK_SIZE(c->out)/2;;
-        uint16_t *dat = (uint16_t *)BLOCK_DATA(c->out), last = 0;
-
-        if (n*2 < BLOCK_SIZE(c->out)) {
-            // half word
-            last = *(uint8_t *)dat;
-            c->vv->varint_put32_blk(b, zigzag16(last));
-            dat = (uint16_t *)(((uint8_t *)dat)+1);
-        }
-
-        for (i = 0; i < n; i++) {
-            uint16_t d = dat[i] - last; // possibly unaligned
-            last = dat[i];
-            c->vv->varint_put32_blk(b, zigzag16(d));
-        }
-
-        break;
-    }
-
-    case 4: {
-        int i, n = BLOCK_SIZE(c->out)/4;;
-        uint32_t *dat = (uint32_t *)BLOCK_DATA(c->out), last = 0;
-
-        for (i = 0; i < n; i++) {
-            uint32_t d = dat[i] - last;
-            last = dat[i];
-            c->vv->varint_put32_blk(b, zigzag32(d));
-        }
-
-        break;
-    }
-
-    case 1: {
-        int i, n = BLOCK_SIZE(c->out);;
-        uint8_t *dat = (uint8_t *)BLOCK_DATA(c->out), last = 0;
-
-        for (i = 0; i < n; i++) {
-            uint32_t d = dat[i] - last;
-            last = dat[i];
-            c->vv->varint_put32_blk(b, zigzag8(d));
-        }
-
-        break;
-    }
-
-    default:
-        goto err;
-    }
-
-    if (c->u.e_xdelta.sub_codec->encode(NULL, c->u.e_xdelta.sub_codec,
-                                      (char *)b->data, b->byte))
-        goto err;
-
-    r = 0;
-
- err:
-    cram_free_block(b);
-    return r;
-
-}
-
-int cram_xdelta_encode_store(cram_codec *c, cram_block *b,
-                            char *prefix, int version) {
-    int len = 0, r = 0, n;
-
-    if (prefix) {
-        size_t l = strlen(prefix);
-        BLOCK_APPEND(b, prefix, l);
-        len += l;
-    }
-
-    // Store sub-codec
-    cram_codec *tc = c->u.e_xdelta.sub_codec;
-    cram_block *tb = cram_new_block(0, 0);
-    if (!tb)
-        return -1;
-    int len2 = tc->store(tc, tb, NULL, version);
-
-    len += (n = c->vv->varint_put32_blk(b, c->codec)); r |= n;
-
-    // codec length
-    len += (n = c->vv->varint_put32_blk(b, c->vv->varint_size(c->u.e_xdelta.word_size)
-                                        + len2)); r |= n;
-
-    // This and sub-codec
-    len += (n = c->vv->varint_put32_blk(b, c->u.e_xdelta.word_size)); r |= n;
-    BLOCK_APPEND(b, BLOCK_DATA(tb), BLOCK_SIZE(tb));
-
-    cram_free_block(tb);
-
-    return r > 0 ? len + len2 : -1;
-
- block_err:
-    return -1;
-}
-
-// Same as cram_beta_encode_long
-int cram_xdelta_encode_long(cram_slice *slice, cram_codec *c,
-                           char *in, int in_size) {
-    return -1;
-}
-
-int cram_xdelta_encode_int(cram_slice *slice, cram_codec *c,
-                          char *in, int in_size) {
-    return -1;
-}
-
-int cram_xdelta_encode_char(cram_slice *slice, cram_codec *c,
-                           char *in, int in_size) {
-    char *dat = malloc(in_size*5), *cp = dat, *cp_end = dat + in_size*5;
-    if (!dat)
-        return -1;
-
-    c->u.e_xdelta.last = 0; // reset for each new array
-    switch(c->u.e_xdelta.word_size) {
-    case 2: {
-        int i, part;
-
-        part = in_size%2;
-        if (part) {
-            uint16_t z = in[0];
-            c->u.e_xdelta.last = le_int2(z);
-            cp += c->vv->varint_put32(cp, cp_end, zigzag16(c->u.e_xdelta.last));
-        }
-
-        uint16_t *in16 = (uint16_t *)(in+part);
-        for (i = 0; i < in_size/2; i++) {
-            uint16_t d = le_int2(in16[i]) - c->u.e_xdelta.last;
-            c->u.e_xdelta.last = le_int2(in16[i]);
-            cp += c->vv->varint_put32(cp, cp_end, zigzag16(d));
-        }
-
-        break;
-    }
-    }
-    if (c->u.e_xdelta.sub_codec->encode(slice, c->u.e_xdelta.sub_codec,
-                                      (char *)dat, cp-dat)) {
-        free(dat);
-        return -1;
-    }
-
-    free(dat);
-    return 0;
-}
-
-void cram_xdelta_encode_free(cram_codec *c) {
-    if (!c) return;
-
-    if (c->u.e_xdelta.sub_codec)
-        c->u.e_xdelta.sub_codec->free(c->u.e_xdelta.sub_codec);
-
-    cram_free_block(c->out);
-
-    free(c);
-}
-
-cram_codec *cram_xdelta_encode_init(cram_stats *st,
-                                    enum cram_encoding codec,
-                                    enum cram_external_type option,
-                                    void *dat,
-                                    int version, varint_vec *vv) {
-    cram_codec *c;
-
-    if (!(c = malloc(sizeof(*c))))
-        return NULL;
-
-    c->codec  = E_XDELTA;
-    c->free   = cram_xdelta_encode_free;
-    if (option == E_LONG)
-        c->encode = cram_xdelta_encode_long;
-    else if (option == E_INT)
-        c->encode = cram_xdelta_encode_int;
-    else
-        c->encode = cram_xdelta_encode_char;
-    c->store  = cram_xdelta_encode_store;
-    c->flush  = cram_xdelta_encode_flush;
-
-    cram_xdelta_encoder *e = (cram_xdelta_encoder *)dat;
-    c->u.e_xdelta.word_size = e->word_size;
-    c->u.e_xdelta.last = 0;
-    c->u.e_xdelta.sub_codec = cram_encoder_init(e->sub_encoding, NULL,
-                                                E_BYTE_ARRAY,
-                                                e->sub_codec_dat,
-                                                version, vv);
-
-    return c;
-}
-
-/*
- * ---------------------------------------------------------------------------
- * XRLE
- *
- * This also has the additional requirement that the data series is not
- * interleaved with another, permitting efficient encoding and decoding
- * of all elements enmasse instead of needing to only extract the bits
- * necessary per item.
- */
-int cram_xrle_decode_long(cram_slice *slice, cram_codec *c, cram_block *in, char *out, int *out_size) {
-    // TODO if and when needed
-    return -1;
-}
-
-int cram_xrle_decode_int(cram_slice *slice, cram_codec *c, cram_block *in, char *out, int *out_size) {
-    // TODO if and when needed
-    return -1;
-}
-
-// Expands an XRLE transform and caches result in slice->block_by_id[]
-static int cram_xrle_decode_expand_char(cram_slice *slice, cram_codec *c) {
-    cram_block *b = slice->block_by_id[512 + c->codec_id];
-    if (b)
-        return 0;
-
-    b = slice->block_by_id[512 + c->codec_id] = cram_new_block(0, 0);
-    if (!b)
-        return -1;
-    cram_block *lit_b = c->u.xrle.lit_codec->get_block(slice, c->u.xrle.lit_codec);
-    if (!lit_b)
-        return -1;
-    unsigned char *lit_dat = lit_b->data;
-    unsigned int lit_sz = lit_b->uncomp_size;
-    unsigned int len_sz = c->u.xrle.len_codec->size(slice, c->u.xrle.len_codec);
-
-    cram_block *len_b = c->u.xrle.len_codec->get_block(slice, c->u.xrle.len_codec);
-    if (!len_b)
-        return -1;
-    unsigned char *len_dat = len_b->data;
-
-    uint8_t rle_syms[256];
-    int rle_nsyms = 0;
-    int i;
-    for (i = 0; i < 256; i++) {
-        if (c->u.xrle.rep_score[i] > 0)
-            rle_syms[rle_nsyms++] = i;
-    }
-
-    uint64_t out_sz;
-    int nb = var_get_u64(len_dat, len_dat+len_sz, &out_sz);
-    if (!(b->data = malloc(out_sz)))
-        return -1;
-    rle_decode(lit_dat, lit_sz,
-               len_dat+nb, len_sz-nb,
-               rle_syms, rle_nsyms,
-               b->data, &out_sz);
-    b->uncomp_size = out_sz;
-
-    return 0;
-}
-
-int cram_xrle_decode_size(cram_slice *slice, cram_codec *c) {
-    cram_xrle_decode_expand_char(slice, c);
-    return slice->block_by_id[512 + c->codec_id]->uncomp_size;
-}
-
-cram_block *cram_xrle_get_block(cram_slice *slice, cram_codec *c) {
-    cram_xrle_decode_expand_char(slice, c);
-    return slice->block_by_id[512 + c->codec_id];
-}
-
-int cram_xrle_decode_char(cram_slice *slice, cram_codec *c, cram_block *in, char *out, int *out_size) {
-    int n = *out_size;
-
-    cram_xrle_decode_expand_char(slice, c);
-    cram_block *b = slice->block_by_id[512 + c->codec_id];
-
-    memcpy(out, b->data + b->idx, n);
-    b->idx += n;
-    return 0;
-
-    // Old code when not cached
-    while (n > 0) {
-        if (c->u.xrle.cur_len == 0) {
-            unsigned char lit;
-            int one = 1;
-            if (c->u.xrle.lit_codec->decode(slice, c->u.xrle.lit_codec, in,
-                                          (char *)&lit, &one) < 0)
-                return -1;
-            c->u.xrle.cur_lit = lit;
-
-            if (c->u.xrle.rep_score[lit] > 0) {
-                if (c->u.xrle.len_codec->decode(slice, c->u.xrle.len_codec, in,
-                                              (char *)&c->u.xrle.cur_len, &one) < 0)
-                    return -1;
-            } // else cur_len still zero
-            //else fprintf(stderr, "%d\n", lit);
-
-            c->u.xrle.cur_len++;
-        }
-
-        if (n >= c->u.xrle.cur_len) {
-            memset(out, c->u.xrle.cur_lit, c->u.xrle.cur_len);
-            out += c->u.xrle.cur_len;
-            n -= c->u.xrle.cur_len;
-            c->u.xrle.cur_len = 0;
-        } else {
-            memset(out, c->u.xrle.cur_lit, n);
-            out += n;
-            c->u.xrle.cur_len -= n;
-            n = 0;
-        }
-    }
-
-    return 0;
-}
-
-void cram_xrle_decode_free(cram_codec *c) {
-    if (!c) return;
-
-    if (c->u.xrle.len_codec)
-        c->u.xrle.len_codec->free(c->u.xrle.len_codec);
-
-    if (c->u.xrle.lit_codec)
-        c->u.xrle.lit_codec->free(c->u.xrle.lit_codec);
-
-    free(c);
-}
-
-cram_codec *cram_xrle_decode_init(cram_block_compression_hdr *hdr,
-                                  char *data, int size,
-                                  enum cram_encoding codec,
-                                  enum cram_external_type option,
-                                  int version, varint_vec *vv) {
-    cram_codec *c;
-    char *cp = data;
-    char *endp = data+size;
-    int err = 0;
-
-    if (!(c = calloc(1, sizeof(*c))))
-        return NULL;
-
-    c->codec  = E_XRLE;
-    if (option == E_LONG)
-        c->decode = cram_xrle_decode_long;
-    else if (option == E_INT)
-        c->decode = cram_xrle_decode_int;
-    else if (option == E_BYTE_ARRAY || option == E_BYTE)
-        c->decode = cram_xrle_decode_char;
-    else {
-        fprintf(stderr, "BYTE_ARRAYs not supported by this codec\n");
-        free(c);
-        return NULL;
-    }
-    c->free   = cram_xrle_decode_free;
-    c->size   = cram_xrle_decode_size;
-    c->get_block = cram_xrle_get_block;
-    c->u.xrle.cur_len = 0;
-    c->u.xrle.cur_lit = -1;
-
-    // RLE map
-    int i, j, nrle = vv->varint_get32(&cp, endp, &err);
-    memset(c->u.xrle.rep_score, 0, 256*sizeof(*c->u.xrle.rep_score));
-    for (i = 0; i < nrle && i < 256; i++) {
-        j = vv->varint_get32(&cp, endp, &err);
-        if (j >= 0 && j < 256)
-            c->u.xrle.rep_score[j] = 1;
-    }
-
-    // Length and literal sub encodings
-    c->u.xrle.len_encoding = vv->varint_get32(&cp, endp, &err);
-    int sub_size = vv->varint_get32(&cp, endp, &err);
-    if (sub_size < 0 || endp - cp < sub_size)
-        goto malformed;
-    c->u.xrle.len_codec = cram_decoder_init(hdr, c->u.xrle.len_encoding,
-                                            cp, sub_size, E_INT, version, vv);
-    if (c->u.xrle.len_codec == NULL)
-        goto malformed;
-    cp += sub_size;
-
-    c->u.xrle.lit_encoding = vv->varint_get32(&cp, endp, &err);
-    sub_size = vv->varint_get32(&cp, endp, &err);
-    if (sub_size < 0 || endp - cp < sub_size)
-        goto malformed;
-    c->u.xrle.lit_codec = cram_decoder_init(hdr, c->u.xrle.lit_encoding,
-                                            cp, sub_size, option, version, vv);
-    if (c->u.xrle.lit_codec == NULL)
-        goto malformed;
-    cp += sub_size;
-
-    if (err)
-        goto malformed;
-
-    return c;
-
- malformed:
-    fprintf(stderr, "Malformed xrle header stream\n");
-    cram_xrle_decode_free(c);
-    return NULL;
-}
-
-int cram_xrle_encode_flush(cram_codec *c) {
-    uint8_t *out_lit, *out_len;
-    uint64_t out_lit_size, out_len_size;
-    uint8_t rle_syms[256];
-    int rle_nsyms = 0, i;
-
-    for (i = 0; i < 256; i++)
-        if (c->u.e_xrle.rep_score[i] > 0)
-            rle_syms[rle_nsyms++] = i;
-
-    if (!c->u.e_xrle.to_flush) {
-        c->u.e_xrle.to_flush = (char *)BLOCK_DATA(c->out);
-        c->u.e_xrle.to_flush_size = BLOCK_SIZE(c->out);
-    }
-
-    out_len = malloc(c->u.e_xrle.to_flush_size+8);
-    if (!out_len)
-        return -1;
-
-    int nb = var_put_u64(out_len, NULL, c->u.e_xrle.to_flush_size);
-
-    out_lit = rle_encode((uint8_t *)c->u.e_xrle.to_flush, c->u.e_xrle.to_flush_size,
-                         out_len+nb, &out_len_size,
-                         rle_syms, &rle_nsyms,
-                         NULL, &out_lit_size);
-    out_len_size += nb;
-
-
-    // TODO: can maybe "gift" the sub codec the data block, to remove
-    // one level of memcpy.
-    if (c->u.e_xrle.len_codec->encode(NULL,
-                                      c->u.e_xrle.len_codec,
-                                      (char *)out_len, out_len_size))
-        return -1;
-
-    if (c->u.e_xrle.lit_codec->encode(NULL,
-                                      c->u.e_xrle.lit_codec,
-                                      (char *)out_lit, out_lit_size))
-        return -1;
-
-    free(out_len);
-    free(out_lit);
-
-    return 0;
-}
-
-int cram_xrle_encode_store(cram_codec *c, cram_block *b,
-                            char *prefix, int version) {
-    int len = 0, r = 0, n;
-    cram_codec *tc;
-    cram_block *b_rle, *b_len, *b_lit;
-
-    if (prefix) {
-        size_t l = strlen(prefix);
-        BLOCK_APPEND(b, prefix, l);
-        len += l;
-    }
-
-    // List of symbols to RLE
-    b_rle = cram_new_block(0, 0);
-    if (!b_rle)
-        return -1;
-    int i, nrle = 0, len1 = 0;
-    for (i = 0; i < 256; i++) {
-        if (c->u.e_xrle.rep_score[i] > 0) {
-            nrle++;
-            len1 += (n = c->vv->varint_put32_blk(b_rle,i)); r |= n;
-        }
-    }
-
-    // Store length and literal sub-codecs to get encoded length
-    tc = c->u.e_xrle.len_codec;
-    b_len = cram_new_block(0, 0);
-    if (!b_len)
-        return -1;
-    int len2 = tc->store(tc, b_len, NULL, version);
-
-    tc = c->u.e_xrle.lit_codec;
-    b_lit = cram_new_block(0, 0);
-    if (!b_lit)
-        return -1;
-    int len3 = tc->store(tc, b_lit, NULL, version);
-
-    len += (n = c->vv->varint_put32_blk(b, c->codec)); r |= n;
-    len += (n = c->vv->varint_put32_blk(b, len1 + len2 + len3
-                                        + c->vv->varint_size(nrle))); r |= n;
-    len += (n = c->vv->varint_put32_blk(b, nrle)); r |= n;
-    BLOCK_APPEND(b, BLOCK_DATA(b_rle), BLOCK_SIZE(b_rle));
-    BLOCK_APPEND(b, BLOCK_DATA(b_len), BLOCK_SIZE(b_len));
-    BLOCK_APPEND(b, BLOCK_DATA(b_lit), BLOCK_SIZE(b_lit));
-
-    cram_free_block(b_rle);
-    cram_free_block(b_len);
-    cram_free_block(b_lit);
-
-    if (r > 0)
-        return len + len1 + len2 + len3;
-
- block_err:
-    return -1;
-}
-
-int cram_xrle_encode_long(cram_slice *slice, cram_codec *c,
-                           char *in, int in_size) {
-    // TODO if and when needed
-    return -1;
-}
-
-int cram_xrle_encode_int(cram_slice *slice, cram_codec *c,
-                          char *in, int in_size) {
-    // TODO if and when needed
-    return -1;
-}
-
-int cram_xrle_encode_char(cram_slice *slice, cram_codec *c,
-                          char *in, int in_size) {
-    if (c->u.e_xrle.to_flush) {
-        if (!c->out && !(c->out = cram_new_block(0, 0)))
-            return -1;
-        BLOCK_APPEND(c->out, c->u.e_xrle.to_flush, c->u.e_xrle.to_flush_size);
-        c->u.e_xrle.to_flush = NULL;
-        c->u.e_xrle.to_flush_size = 0;
-    }
-
-    if (c->out && BLOCK_SIZE(c->out) > 0) {
-        // Gathering data
-        BLOCK_APPEND(c->out, in, in_size);
-        return 0;
-    }
-
-    // else cache copy of the data we're about to send to flush instead.
-    c->u.e_xrle.to_flush = in;
-    c->u.e_xrle.to_flush_size = in_size;
-    return 0;
-
- block_err:
-    return -1;
-}
-
-void cram_xrle_encode_free(cram_codec *c) {
-    if (!c) return;
-
-    if (c->u.e_xrle.len_codec)
-        c->u.e_xrle.len_codec->free(c->u.e_xrle.len_codec);
-    if (c->u.e_xrle.lit_codec)
-        c->u.e_xrle.lit_codec->free(c->u.e_xrle.lit_codec);
-
-    cram_free_block(c->out);
-
-    free(c);
-}
-
-cram_codec *cram_xrle_encode_init(cram_stats *st,
-                                  enum cram_encoding codec,
-                                  enum cram_external_type option,
-                                  void *dat,
-                                  int version, varint_vec *vv) {
-    cram_codec *c;
-
-    if (!(c = malloc(sizeof(*c))))
-        return NULL;
-
-    c->codec  = E_XRLE;
-    c->free   = cram_xrle_encode_free;
-    if (option == E_LONG)
-        c->encode = cram_xrle_encode_long;
-    else if (option == E_INT)
-        c->encode = cram_xrle_encode_int;
-    else
-        c->encode = cram_xrle_encode_char;
-    c->store  = cram_xrle_encode_store;
-    c->flush  = cram_xrle_encode_flush;
-
-    cram_xrle_encoder *e = (cram_xrle_encoder *)dat;
-
-    c->u.e_xrle.len_codec = cram_encoder_init(e->len_encoding, NULL,
-                                              E_BYTE, e->len_dat,
-                                              version, vv);
-    c->u.e_xrle.lit_codec = cram_encoder_init(e->lit_encoding, NULL,
-                                              E_BYTE, e->lit_dat,
-                                              version, vv);
-    c->u.e_xrle.cur_lit = -1;
-    c->u.e_xrle.cur_len = -1;
-    c->u.e_xrle.to_flush = NULL;
-    c->u.e_xrle.to_flush_size = 0;
-
-    memcpy(c->u.e_xrle.rep_score, e->rep_score, 256*sizeof(*c->u.e_xrle.rep_score));
-
-    return c;
-}
-
-/*
- * ---------------------------------------------------------------------------
- * SUBEXP
- */
-int cram_subexp_decode(cram_slice *slice, cram_codec *c, cram_block *in, char *out, int *out_size) {
-    int32_t *out_i = (int32_t *)out;
-    int n, count;
-    int k = c->u.subexp.k;
-
-    for (count = 0, n = *out_size; count < n; count++) {
-        int i = 0, tail;
-        int val;
-
-        /* Get number of 1s */
-        //while (get_bit_MSB(in) == 1) i++;
-        i = get_one_bits_MSB(in);
-        if (i < 0 || cram_not_enough_bits(in, i > 0 ? i + k - 1 : k))
-            return -1;
-        /*
-         * Val is
-         * i > 0:  2^(k+i-1) + k+i-1 bits
-         * i = 0:  k bits
-         */
-        if (i) {
-            tail = i + k-1;
-            val = 0;
-            while (tail) {
-                //val = val<<1; val |= get_bit_MSB(in);
-                GET_BIT_MSB(in, val);
-                tail--;
-            }
-            val += 1 << (i + k-1);
-        } else {
-            tail = k;
-            val = 0;
-            while (tail) {
-                //val = val<<1; val |= get_bit_MSB(in);
-                GET_BIT_MSB(in, val);
-                tail--;
-            }
-        }
-
-        out_i[count] = val - c->u.subexp.offset;
-    }
-
-    return 0;
-}
-
-void cram_subexp_decode_free(cram_codec *c) {
-    if (c)
-        free(c);
-}
-
-cram_codec *cram_subexp_decode_init(cram_block_compression_hdr *hdr,
-                                    char *data, int size,
-                                    enum cram_encoding codec,
-                                    enum cram_external_type option,
-                                    int version, varint_vec *vv) {
-    cram_codec *c;
-    char *cp = data;
-
-    if (option != E_INT) {
-        hts_log_error("This codec only supports INT encodings");
-        return NULL;
-    }
-
-    if (!(c = malloc(sizeof(*c))))
-        return NULL;
-
-    c->codec  = E_SUBEXP;
-    c->decode = cram_subexp_decode;
-    c->free   = cram_subexp_decode_free;
-    c->u.subexp.k = -1;
-
-    c->u.subexp.offset = vv->varint_get32(&cp, data + size, NULL);
-    c->u.subexp.k      = vv->varint_get32(&cp, data + size, NULL);
-
-    if (cp - data != size || c->u.subexp.k < 0) {
-        hts_log_error("Malformed subexp header stream");
-        free(c);
-        return NULL;
-    }
-
-    return c;
-}
-
-/*
- * ---------------------------------------------------------------------------
- * GAMMA
- */
-int cram_gamma_decode(cram_slice *slice, cram_codec *c, cram_block *in, char *out, int *out_size) {
-    int32_t *out_i = (int32_t *)out;
-    int i, n;
-
-    for (i = 0, n = *out_size; i < n; i++) {
-        int nz = 0;
-        int val;
-        //while (get_bit_MSB(in) == 0) nz++;
-        nz = get_zero_bits_MSB(in);
-        if (cram_not_enough_bits(in, nz))
-            return -1;
-        val = 1;
-        while (nz > 0) {
-            //val <<= 1; val |= get_bit_MSB(in);
-            GET_BIT_MSB(in, val);
-            nz--;
-        }
-
-        out_i[i] = val - c->u.gamma.offset;
-    }
-
-    return 0;
-}
-
-void cram_gamma_decode_free(cram_codec *c) {
-    if (c)
-        free(c);
-}
-
-cram_codec *cram_gamma_decode_init(cram_block_compression_hdr *hdr,
-                                   char *data, int size,
-                                   enum cram_encoding codec,
-                                   enum cram_external_type option,
-                                   int version, varint_vec *vv) {
-    cram_codec *c = NULL;
-    char *cp = data;
-
-    if (option != E_INT) {
-        hts_log_error("This codec only supports INT encodings");
-        return NULL;
-    }
-
-    if (size < 1)
-        goto malformed;
-
-    if (!(c = malloc(sizeof(*c))))
-        return NULL;
-
-    c->codec  = E_GAMMA;
-    c->decode = cram_gamma_decode;
-    c->free   = cram_gamma_decode_free;
-
-    c->u.gamma.offset = vv->varint_get32(&cp, data+size, NULL);
-
-    if (cp - data != size)
-        goto malformed;
-
-    return c;
-
- malformed:
-    hts_log_error("Malformed gamma header stream");
-    free(c);
-    return NULL;
-}
-
-/*
- * ---------------------------------------------------------------------------
- * HUFFMAN
- */
-
-static int code_sort(const void *vp1, const void *vp2) {
-    const cram_huffman_code *c1 = (const cram_huffman_code *)vp1;
-    const cram_huffman_code *c2 = (const cram_huffman_code *)vp2;
-
-    if (c1->len != c2->len)
-        return c1->len - c2->len;
-    else
-        return c1->symbol < c2->symbol ? -1 : (c1->symbol > c2->symbol ? 1 : 0);
-}
-
-void cram_huffman_decode_free(cram_codec *c) {
-    if (!c)
-        return;
-
-    if (c->u.huffman.codes)
-        free(c->u.huffman.codes);
-    free(c);
-}
-
-int cram_huffman_decode_null(cram_slice *slice, cram_codec *c,
-                             cram_block *in, char *out, int *out_size) {
-    return -1;
-}
-
-int cram_huffman_decode_char0(cram_slice *slice, cram_codec *c,
-                              cram_block *in, char *out, int *out_size) {
-    int i, n;
-
-    if (!out)
-        return 0;
-
-    /* Special case of 0 length codes */
-    for (i = 0, n = *out_size; i < n; i++) {
-        out[i] = c->u.huffman.codes[0].symbol;
-    }
-    return 0;
-}
-
-int cram_huffman_decode_char(cram_slice *slice, cram_codec *c,
-                             cram_block *in, char *out, int *out_size) {
-    int i, n, ncodes = c->u.huffman.ncodes;
-    const cram_huffman_code * const codes = c->u.huffman.codes;
-
-    for (i = 0, n = *out_size; i < n; i++) {
-        int idx = 0;
-        int val = 0, len = 0, last_len = 0;
-
-        for (;;) {
-            int dlen = codes[idx].len - last_len;
-            if (cram_not_enough_bits(in, dlen))
-                return -1;
-
-            //val <<= dlen;
-            //val  |= get_bits_MSB(in, dlen);
-            //last_len = (len += dlen);
-
-            last_len = (len += dlen);
-            for (; dlen; dlen--) GET_BIT_MSB(in, val);
-
-            idx = val - codes[idx].p;
-            if (idx >= ncodes || idx < 0)
-                return -1;
-
-            if (codes[idx].code == val && codes[idx].len == len) {
-                if (out) out[i] = codes[idx].symbol;
-                break;
-            }
-        }
-    }
-
-    return 0;
-}
-
-int cram_huffman_decode_int0(cram_slice *slice, cram_codec *c,
-                             cram_block *in, char *out, int *out_size) {
-    int32_t *out_i = (int32_t *)out;
-    int i, n;
-    const cram_huffman_code * const codes = c->u.huffman.codes;
-
-    /* Special case of 0 length codes */
-    for (i = 0, n = *out_size; i < n; i++) {
-        out_i[i] = codes[0].symbol;
-    }
-    return 0;
-}
-
-int cram_huffman_decode_int(cram_slice *slice, cram_codec *c,
-                            cram_block *in, char *out, int *out_size) {
-    int32_t *out_i = (int32_t *)out;
-    int i, n, ncodes = c->u.huffman.ncodes;
-    const cram_huffman_code * const codes = c->u.huffman.codes;
-
-    for (i = 0, n = *out_size; i < n; i++) {
-        int idx = 0;
-        int val = 0, len = 0, last_len = 0;
-
-        // Now one bit at a time for remaining checks
-        for (;;) {
-            int dlen = codes[idx].len - last_len;
-            if (cram_not_enough_bits(in, dlen))
-                return -1;
-
-            //val <<= dlen;
-            //val  |= get_bits_MSB(in, dlen);
-            //last_len = (len += dlen);
-
-            last_len = (len += dlen);
-            for (; dlen; dlen--) GET_BIT_MSB(in, val);
-
-            idx = val - codes[idx].p;
-            if (idx >= ncodes || idx < 0)
-                return -1;
-
-            if (codes[idx].code == val && codes[idx].len == len) {
-                out_i[i] = codes[idx].symbol;
-                break;
-            }
-        }
-    }
-
-    return 0;
-}
-
-int cram_huffman_decode_long0(cram_slice *slice, cram_codec *c,
-                              cram_block *in, char *out, int *out_size) {
-    int64_t *out_i = (int64_t *)out;
-    int i, n;
-    const cram_huffman_code * const codes = c->u.huffman.codes;
-
-    /* Special case of 0 length codes */
-    for (i = 0, n = *out_size; i < n; i++) {
-        out_i[i] = codes[0].symbol;
-    }
-    return 0;
-}
-
-int cram_huffman_decode_long(cram_slice *slice, cram_codec *c,
-                             cram_block *in, char *out, int *out_size) {
-    int64_t *out_i = (int64_t *)out;
-    int i, n, ncodes = c->u.huffman.ncodes;
-    const cram_huffman_code * const codes = c->u.huffman.codes;
-
-    for (i = 0, n = *out_size; i < n; i++) {
-        int idx = 0;
-        int val = 0, len = 0, last_len = 0;
-
-        // Now one bit at a time for remaining checks
-        for (;;) {
-            int dlen = codes[idx].len - last_len;
-            if (cram_not_enough_bits(in, dlen))
-                return -1;
-
-            //val <<= dlen;
-            //val  |= get_bits_MSB(in, dlen);
-            //last_len = (len += dlen);
-
-            last_len = (len += dlen);
-            for (; dlen; dlen--) GET_BIT_MSB(in, val);
-
-            idx = val - codes[idx].p;
-            if (idx >= ncodes || idx < 0)
-                return -1;
-
-            if (codes[idx].code == val && codes[idx].len == len) {
-                out_i[i] = codes[idx].symbol;
-                break;
-            }
-        }
-    }
-
-    return 0;
-}
-
-/*
- * Initialises a huffman decoder from an encoding data stream.
- */
-cram_codec *cram_huffman_decode_init(cram_block_compression_hdr *hdr,
-                                     char *data, int size,
-                                     enum cram_encoding codec,
-                                     enum cram_external_type option,
-                                     int version, varint_vec *vv) {
-    int32_t ncodes = 0, i, j;
-    char *cp = data, *data_end = &data[size];
-    cram_codec *h;
-    cram_huffman_code *codes = NULL;
-    int32_t val, last_len, max_len = 0;
-    uint32_t max_val; // needs one more bit than val
-    const int max_code_bits = sizeof(val) * 8 - 1;
-    int err = 0;
-
-    if (option == E_BYTE_ARRAY_BLOCK) {
-        hts_log_error("BYTE_ARRAYs not supported by this codec");
-        return NULL;
-    }
-
-    ncodes = vv->varint_get32(&cp, data_end, &err);
-    if (ncodes < 0) {
-        hts_log_error("Invalid number of symbols in huffman stream");
-        return NULL;
-    }
-    if (ncodes >= SIZE_MAX / sizeof(*codes)) {
-        errno = ENOMEM;
-        return NULL;
-    }
-
-    h = calloc(1, sizeof(*h));
-    if (!h)
-        return NULL;
-
-    h->codec  = E_HUFFMAN;
-    h->free   = cram_huffman_decode_free;
-
-    h->u.huffman.ncodes = ncodes;
-    h->u.huffman.option = option;
-    if (ncodes) {
-        codes = h->u.huffman.codes = malloc(ncodes * sizeof(*codes));
-        if (!codes) {
-            free(h);
-            return NULL;
-        }
-    } else {
-        codes = h->u.huffman.codes = NULL;
-    }
-
-    /* Read symbols and bit-lengths */
-    if (option == E_LONG) {
-        for (i = 0; i < ncodes; i++)
-            codes[i].symbol = vv->varint_get64(&cp, data_end, &err);
-    } else if (option == E_INT || option == E_BYTE) {
-        for (i = 0; i < ncodes; i++)
-            codes[i].symbol = vv->varint_get32(&cp, data_end, &err);
-    } else {
-        goto malformed;
-    }
-
-    if (err)
-        goto malformed;
-
-    i = vv->varint_get32(&cp, data_end, &err);
-    if (i != ncodes)
-        goto malformed;
-
-    if (ncodes == 0) {
-        /* NULL huffman stream.  Ensure it returns an error if
-           anything tries to use it. */
-        h->decode = cram_huffman_decode_null;
-        return h;
-    }
-
-    for (i = 0; i < ncodes; i++) {
-        codes[i].len = vv->varint_get32(&cp, data_end, &err);
-        if (err)
-            break;
-        if (codes[i].len < 0) {
-            hts_log_error("Huffman code length (%d) is negative", codes[i].len);
-            goto malformed;
-        }
-        if (max_len < codes[i].len)
-            max_len = codes[i].len;
-    }
-    if (err || cp - data != size || max_len >= ncodes)
-        goto malformed;
-
-    /* 31 is max. bits available in val */
-    if (max_len > max_code_bits) {
-        hts_log_error("Huffman code length (%d) is greater "
-                      "than maximum supported (%d)", max_len, max_code_bits);
-        goto malformed;
-    }
-
-    /* Sort by bit length and then by symbol value */
-    qsort(codes, ncodes, sizeof(*codes), code_sort);
-
-    /* Assign canonical codes */
-    val = -1, last_len = 0, max_val = 0;
-    for (i = 0; i < ncodes; i++) {
-        val++;
-        if (val > max_val)
-            goto malformed;
-
-        if (codes[i].len > last_len) {
-            val <<= (codes[i].len - last_len);
-            last_len = codes[i].len;
-            max_val = (1U << codes[i].len) - 1;
-        }
-        codes[i].code = val;
-    }
-
-    /*
-     * Compute the next starting point, offset by the i'th value.
-     * For example if codes 10, 11, 12, 13 are 30, 31, 32, 33 then
-     * codes[10..13].p = 30 - 10.
-     */
-    last_len = 0;
-    for (i = j = 0; i < ncodes; i++) {
-        if (codes[i].len > last_len) {
-            j = codes[i].code - i;
-            last_len = codes[i].len;
-        }
-        codes[i].p = j;
-    }
-
-    // puts("==HUFF LEN==");
-    // for (i = 0; i <= last_len+1; i++) {
-    //     printf("len %d=%d prefix %d\n", i, h->u.huffman.lengths[i], h->u.huffman.prefix[i]);
-    // }
-    // puts("===HUFFMAN CODES===");
-    // for (i = 0; i < ncodes; i++) {
-    //     int j;
-    //     printf("%d: %d %d %d ", i, codes[i].symbol, codes[i].len, codes[i].code);
-    //     j = codes[i].len;
-    //     while (j) {
-    //         putchar(codes[i].code & (1 << --j) ? '1' : '0');
-    //     }
-    //     printf(" %d\n", codes[i].code);
-    // }
-
-    if (option == E_BYTE || option == E_BYTE_ARRAY) {
-        if (h->u.huffman.codes[0].len == 0)
-            h->decode = cram_huffman_decode_char0;
-        else
-            h->decode = cram_huffman_decode_char;
-    } else if (option == E_LONG || option == E_SLONG) {
-        if (h->u.huffman.codes[0].len == 0)
-            h->decode = cram_huffman_decode_long0;
-        else
-            h->decode = cram_huffman_decode_long;
-    } else if (option == E_INT || option == E_SINT || option == E_BYTE) {
-        if (h->u.huffman.codes[0].len == 0)
-            h->decode = cram_huffman_decode_int0;
-        else
-            h->decode = cram_huffman_decode_int;
-    } else {
-        return NULL;
-    }
-
-    return (cram_codec *)h;
-
- malformed:
-    hts_log_error("Malformed huffman header stream");
-    free(codes);
-    free(h);
-    return NULL;
-}
-
-int cram_huffman_encode_char0(cram_slice *slice, cram_codec *c,
-                              char *in, int in_size) {
-    return 0;
-}
-
-int cram_huffman_encode_char(cram_slice *slice, cram_codec *c,
-                             char *in, int in_size) {
-    int i, code, len, r = 0;
-    unsigned char *syms = (unsigned char *)in;
-
-    while (in_size--) {
-        int sym = *syms++;
-        if (sym >= -1 && sym < MAX_HUFF) {
-            i = c->u.e_huffman.val2code[sym+1];
-            assert(c->u.e_huffman.codes[i].symbol == sym);
-            code = c->u.e_huffman.codes[i].code;
-            len  = c->u.e_huffman.codes[i].len;
-        } else {
-            /* Slow - use a lookup table for when sym < MAX_HUFF? */
-            for (i = 0; i < c->u.e_huffman.nvals; i++) {
-                if (c->u.e_huffman.codes[i].symbol == sym)
-                    break;
-            }
-            if (i == c->u.e_huffman.nvals)
-                return -1;
-
-            code = c->u.e_huffman.codes[i].code;
-            len  = c->u.e_huffman.codes[i].len;
-        }
-
-        r |= store_bits_MSB(c->out, code, len);
-    }
-
-    return r;
-}
-
-int cram_huffman_encode_int0(cram_slice *slice, cram_codec *c,
-                             char *in, int in_size) {
-    return 0;
-}
-
-int cram_huffman_encode_int(cram_slice *slice, cram_codec *c,
-                            char *in, int in_size) {
-    int i, code, len, r = 0;
-    int *syms = (int *)in;
-
-    while (in_size--) {
-        int sym = *syms++;
-
-        if (sym >= -1 && sym < MAX_HUFF) {
-            i = c->u.e_huffman.val2code[sym+1];
-            assert(c->u.e_huffman.codes[i].symbol == sym);
-            code = c->u.e_huffman.codes[i].code;
-            len  = c->u.e_huffman.codes[i].len;
-        } else {
-            /* Slow - use a lookup table for when sym < MAX_HUFFMAN_SYM? */
-            for (i = 0; i < c->u.e_huffman.nvals; i++) {
-                if (c->u.e_huffman.codes[i].symbol == sym)
-                    break;
-            }
-            if (i == c->u.e_huffman.nvals)
-                return -1;
-
-            code = c->u.e_huffman.codes[i].code;
-            len  = c->u.e_huffman.codes[i].len;
-        }
-
-        r |= store_bits_MSB(c->out, code, len);
-    }
-
-    return r;
-}
-
-int cram_huffman_encode_long0(cram_slice *slice, cram_codec *c,
-                              char *in, int in_size) {
-    return 0;
-}
-
-int cram_huffman_encode_long(cram_slice *slice, cram_codec *c,
-                             char *in, int in_size) {
-    int i, code, len, r = 0;
-    int64_t *syms = (int64_t *)in;
-
-    while (in_size--) {
-        int sym = *syms++;
-
-        if (sym >= -1 && sym < MAX_HUFF) {
-            i = c->u.e_huffman.val2code[sym+1];
-            assert(c->u.e_huffman.codes[i].symbol == sym);
-            code = c->u.e_huffman.codes[i].code;
-            len  = c->u.e_huffman.codes[i].len;
-        } else {
-            /* Slow - use a lookup table for when sym < MAX_HUFFMAN_SYM? */
-            for (i = 0; i < c->u.e_huffman.nvals; i++) {
-                if (c->u.e_huffman.codes[i].symbol == sym)
-                    break;
-            }
-            if (i == c->u.e_huffman.nvals)
-                return -1;
-
-            code = c->u.e_huffman.codes[i].code;
-            len  = c->u.e_huffman.codes[i].len;
-        }
-
-        r |= store_bits_MSB(c->out, code, len);
-    }
-
-    return r;
-}
-
-void cram_huffman_encode_free(cram_codec *c) {
-    if (!c)
-        return;
-
-    if (c->u.e_huffman.codes)
-        free(c->u.e_huffman.codes);
-    free(c);
-}
-
-/*
- * Encodes a huffman tree.
- * Returns number of bytes written.
- */
-int cram_huffman_encode_store(cram_codec *c, cram_block *b, char *prefix,
-                              int version) {
-    int i, len = 0, r = 0, n;
-    cram_huffman_code *codes = c->u.e_huffman.codes;
-    /*
-     * Up to code length 127 means 2.5e+26 bytes of data required (worst
-     * case huffman tree needs symbols with freqs matching the Fibonacci
-     * series). So guaranteed 1 byte per code.
-     *
-     * Symbols themselves could be 5 bytes (eg -1 is 5 bytes in itf8).
-     *
-     * Therefore 6*ncodes + 5 + 5 + 1 + 5 is max memory
-     */
-    char *tmp = malloc(6*c->u.e_huffman.nvals+16);
-    char *tp = tmp, *tpend = tmp+6*c->u.e_huffman.nvals+16;
-
-    if (!tmp)
-        return -1;
-
-    if (prefix) {
-        size_t l = strlen(prefix);
-        BLOCK_APPEND(b, prefix, l);
-        len += l;
-    }
-
-    tp += c->vv->varint_put32(tp, tpend, c->u.e_huffman.nvals);
-    if (c->u.e_huffman.option == E_LONG) {
-        for (i = 0; i < c->u.e_huffman.nvals; i++) {
-            tp += c->vv->varint_put64(tp, tpend, codes[i].symbol);
-        }
-    } else if (c->u.e_huffman.option == E_SLONG) {
-        for (i = 0; i < c->u.e_huffman.nvals; i++) {
-            tp += c->vv->varint_put64s(tp, tpend, codes[i].symbol);
-        }
-    } else if (c->u.e_huffman.option == E_INT || c->u.e_huffman.option == E_BYTE) {
-        for (i = 0; i < c->u.e_huffman.nvals; i++) {
-            tp += c->vv->varint_put32(tp, tpend, codes[i].symbol);
-        }
-    } else if (c->u.e_huffman.option == E_SINT) {
-        for (i = 0; i < c->u.e_huffman.nvals; i++) {
-            tp += c->vv->varint_put32s(tp, tpend, codes[i].symbol);
-        }
-    } else {
-        return -1;
-    }
-
-    tp += c->vv->varint_put32(tp, tpend, c->u.e_huffman.nvals);
-    for (i = 0; i < c->u.e_huffman.nvals; i++)
-        tp += c->vv->varint_put32(tp, tpend, codes[i].len);
-
-    len += (n = c->vv->varint_put32_blk(b, c->codec)); r |= n;
-    len += (n = c->vv->varint_put32_blk(b, tp-tmp));   r |= n;
-    BLOCK_APPEND(b, tmp, tp-tmp);
-    len += tp-tmp;
-
-    free(tmp);
-
-    if (r > 0)
-        return len;
-
- block_err:
-    return -1;
-}
-
-cram_codec *cram_huffman_encode_init(cram_stats *st,
-                                     enum cram_encoding codec,
-                                     enum cram_external_type option,
-                                     void *dat,
-                                     int version, varint_vec *vv) {
-    int *vals = NULL, *freqs = NULL, *lens = NULL, code, len;
-    int *new_vals, *new_freqs;
-    int i, ntot = 0, max_val = 0, min_val = INT_MAX, k;
-    size_t nvals, vals_alloc = 0;
-    cram_codec *c;
-    cram_huffman_code *codes;
-
-    c = malloc(sizeof(*c));
-    if (!c)
-        return NULL;
-    c->codec = E_HUFFMAN;
-
-    /* Count number of unique symbols */
-    for (nvals = i = 0; i < MAX_STAT_VAL; i++) {
-        if (!st->freqs[i])
-            continue;
-        if (nvals >= vals_alloc) {
-            vals_alloc = vals_alloc ? vals_alloc*2 : 1024;
-            new_vals  = realloc(vals,  vals_alloc * sizeof(int));
-            if (!new_vals) goto nomem;
-            vals = new_vals;
-            new_freqs = realloc(freqs, vals_alloc * sizeof(int));
-            if (!new_freqs) goto nomem;
-            freqs = new_freqs;
-        }
-        vals[nvals] = i;
-        freqs[nvals] = st->freqs[i];
-        assert(st->freqs[i] > 0);
-        ntot += freqs[nvals];
-        if (max_val < i) max_val = i;
-        if (min_val > i) min_val = i;
-        nvals++;
-    }
-    if (st->h) {
-        khint_t k;
-
-        for (k = kh_begin(st->h); k != kh_end(st->h); k++) {
-            if (!kh_exist(st->h, k))
-                continue;
-            if (nvals >= vals_alloc) {
-                vals_alloc = vals_alloc ? vals_alloc*2 : 1024;
-                new_vals  = realloc(vals,  vals_alloc * sizeof(int));
-                if (!new_vals) goto nomem;
-                vals = new_vals;
-                new_freqs = realloc(freqs, vals_alloc * sizeof(int));
-                if (!new_freqs) goto nomem;
-                freqs = new_freqs;
-            }
-            vals[nvals]= kh_key(st->h, k);
-            freqs[nvals] = kh_val(st->h, k);
-            assert(freqs[nvals] > 0);
-            ntot += freqs[nvals];
-            if (max_val < i) max_val = i;
-            if (min_val > i) min_val = i;
-            nvals++;
-        }
-    }
-
-    assert(nvals > 0);
-
-    new_freqs = realloc(freqs, 2*nvals*sizeof(*freqs));
-    if (!new_freqs) goto nomem;
-    freqs = new_freqs;
-    lens = calloc(2*nvals, sizeof(*lens));
-    if (!lens) goto nomem;
-
-    /* Inefficient, use pointers to form chain so we can insert and maintain
-     * a sorted list? This is currently O(nvals^2) complexity.
-     */
-    for (;;) {
-        int low1 = INT_MAX, low2 = INT_MAX;
-        int ind1 = 0, ind2 = 0;
-        for (i = 0; i < nvals; i++) {
-            if (freqs[i] < 0)
-                continue;
-            if (low1 > freqs[i])
-                low2 = low1, ind2 = ind1, low1 = freqs[i], ind1 = i;
-            else if (low2 > freqs[i])
-                low2 = freqs[i], ind2 = i;
-        }
-        if (low2 == INT_MAX)
-            break;
-
-        freqs[nvals] = low1 + low2;
-        lens[ind1] = nvals;
-        lens[ind2] = nvals;
-        freqs[ind1] *= -1;
-        freqs[ind2] *= -1;
-        nvals++;
-    }
-    nvals = nvals/2+1;
-
-    /* Assign lengths */
-    for (i = 0; i < nvals; i++) {
-        int code_len = 0;
-        for (k = lens[i]; k; k = lens[k])
-            code_len++;
-        lens[i] = code_len;
-        freqs[i] *= -1;
-        //fprintf(stderr, "%d / %d => %d\n", vals[i], freqs[i], lens[i]);
-    }
-
-
-    /* Sort, need in a struct */
-    if (!(codes = malloc(nvals * sizeof(*codes))))
-        goto nomem;
-    for (i = 0; i < nvals; i++) {
-        codes[i].symbol = vals[i];
-        codes[i].len = lens[i];
-    }
-    qsort(codes, nvals, sizeof(*codes), code_sort);
-
-    /*
-     * Generate canonical codes from lengths.
-     * Sort by length.
-     * Start with 0.
-     * Every new code of same length is +1.
-     * Every new code of new length is +1 then <<1 per extra length.
-     *
-     * /\
-     * a/\
-     * /\/\
-     * bcd/\
-     *    ef
-     *
-     * a 1  0
-     * b 3  4 (0+1)<<2
-     * c 3  5
-     * d 3  6
-     * e 4  14  (6+1)<<1
-     * f 5  15
-     */
-    code = 0; len = codes[0].len;
-    for (i = 0; i < nvals; i++) {
-        while (len != codes[i].len) {
-            code<<=1;
-            len++;
-        }
-        codes[i].code = code++;
-
-        if (codes[i].symbol >= -1 && codes[i].symbol < MAX_HUFF)
-            c->u.e_huffman.val2code[codes[i].symbol+1] = i;
-
-        //fprintf(stderr, "sym %d, code %d, len %d\n",
-        //      codes[i].symbol, codes[i].code, codes[i].len);
-    }
-
-    free(lens);
-    free(vals);
-    free(freqs);
-
-    c->u.e_huffman.codes = codes;
-    c->u.e_huffman.nvals = nvals;
-    c->u.e_huffman.option = option;
-
-    c->free = cram_huffman_encode_free;
-    if (option == E_BYTE || option == E_BYTE_ARRAY) {
-        if (c->u.e_huffman.codes[0].len == 0)
-            c->encode = cram_huffman_encode_char0;
-        else
-            c->encode = cram_huffman_encode_char;
-    } else if (option == E_INT || option == E_SINT) {
-        if (c->u.e_huffman.codes[0].len == 0)
-            c->encode = cram_huffman_encode_int0;
-        else
-            c->encode = cram_huffman_encode_int;
-    } else if (option == E_LONG || option == E_SLONG) {
-        if (c->u.e_huffman.codes[0].len == 0)
-            c->encode = cram_huffman_encode_long0;
-        else
-            c->encode = cram_huffman_encode_long;
-    } else {
-        return NULL;
-    }
-    c->store = cram_huffman_encode_store;
-    c->flush = NULL;
-
-    return c;
-
- nomem:
-    hts_log_error("Out of memory");
-    free(vals);
-    free(freqs);
-    free(lens);
-    free(c);
-    return NULL;
-}
-
-/*
- * ---------------------------------------------------------------------------
- * BYTE_ARRAY_LEN
- */
-int cram_byte_array_len_decode(cram_slice *slice, cram_codec *c,
-                               cram_block *in, char *out,
-                               int *out_size) {
-    /* Fetch length */
-    int32_t len = 0, one = 1;
-    int r;
-
-    r = c->u.byte_array_len.len_codec->decode(slice, c->u.byte_array_len.len_codec,
-                                              in, (char *)&len, &one);
-    //printf("ByteArray Len=%d\n", len);
-
-    if (!r && c->u.byte_array_len.val_codec && len >= 0) {
-        r = c->u.byte_array_len.val_codec->decode(slice,
-                                                  c->u.byte_array_len.val_codec,
-                                                  in, out, &len);
-    } else {
-        return -1;
-    }
-
-    *out_size = len;
-
-    return r;
-}
-
-void cram_byte_array_len_decode_free(cram_codec *c) {
-    if (!c) return;
-
-    if (c->u.byte_array_len.len_codec)
-        c->u.byte_array_len.len_codec->free(c->u.byte_array_len.len_codec);
-
-    if (c->u.byte_array_len.val_codec)
-        c->u.byte_array_len.val_codec->free(c->u.byte_array_len.val_codec);
-
-    free(c);
-}
-
-cram_codec *cram_byte_array_len_decode_init(cram_block_compression_hdr *hdr,
-                                            char *data, int size,
-                                            enum cram_encoding codec,
-                                            enum cram_external_type option,
-                                            int version, varint_vec *vv) {
-    cram_codec *c;
-    char *cp   = data;
-    char *endp = data + size;
-
-    if (!(c = malloc(sizeof(*c))))
-        return NULL;
-
-    c->codec  = E_BYTE_ARRAY_LEN;
-    c->decode = cram_byte_array_len_decode;
-    c->free   = cram_byte_array_len_decode_free;
-    c->u.byte_array_len.len_codec = NULL;
-    c->u.byte_array_len.val_codec = NULL;
-
-    int encoding = vv->varint_get32(&cp, endp, NULL);
-    int sub_size = vv->varint_get32(&cp, endp, NULL);
-    if (sub_size < 0 || endp - cp < sub_size)
-        goto malformed;
-    c->u.byte_array_len.len_codec = cram_decoder_init(hdr, encoding, cp, sub_size,
-                                                      E_INT, version, vv);
-    if (c->u.byte_array_len.len_codec == NULL)
-        goto no_codec;
-    cp += sub_size;
-
-    encoding = vv->varint_get32(&cp, endp, NULL);
-    sub_size = vv->varint_get32(&cp, endp, NULL);
-    if (sub_size < 0 || endp - cp < sub_size)
-        goto malformed;
-    c->u.byte_array_len.val_codec = cram_decoder_init(hdr, encoding, cp, sub_size,
-                                                      option, version, vv);
-    if (c->u.byte_array_len.val_codec == NULL)
-        goto no_codec;
-    cp += sub_size;
-
-    if (cp - data != size)
-        goto malformed;
-
-    return c;
-
- malformed:
-    hts_log_error("Malformed byte_array_len header stream");
- no_codec:
-    cram_byte_array_len_decode_free(c);
-    return NULL;
-}
-
-int cram_byte_array_len_encode(cram_slice *slice, cram_codec *c,
-                               char *in, int in_size) {
-    int32_t i32 = in_size;
-    int r = 0;
-
-    r |= c->u.e_byte_array_len.len_codec->encode(slice,
-                                                 c->u.e_byte_array_len.len_codec,
-                                                 (char *)&i32, 1);
-    r |= c->u.e_byte_array_len.val_codec->encode(slice,
-                                                 c->u.e_byte_array_len.val_codec,
-                                                 in, in_size);
-    return r;
-}
-
-void cram_byte_array_len_encode_free(cram_codec *c) {
-    if (!c)
-        return;
-
-    if (c->u.e_byte_array_len.len_codec)
-        c->u.e_byte_array_len.len_codec->free(c->u.e_byte_array_len.len_codec);
-
-    if (c->u.e_byte_array_len.val_codec)
-        c->u.e_byte_array_len.val_codec->free(c->u.e_byte_array_len.val_codec);
-
-    free(c);
-}
-
-int cram_byte_array_len_encode_store(cram_codec *c, cram_block *b,
-                                     char *prefix, int version) {
-    int len = 0, len2, len3, r = 0, n;
-    cram_codec *tc;
-    cram_block *b_len = NULL, *b_val = NULL;
-
-    if (prefix) {
-        size_t l = strlen(prefix);
-        BLOCK_APPEND(b, prefix, l);
-        len += l;
-    }
-
-    tc = c->u.e_byte_array_len.len_codec;
-    b_len = cram_new_block(0, 0);
-    if (!b_len) goto block_err;
-    len2 = tc->store(tc, b_len, NULL, version);
-    if (len2 < 0) goto block_err;
-
-    tc = c->u.e_byte_array_len.val_codec;
-    b_val = cram_new_block(0, 0);
-    if (!b_val) goto block_err;
-    len3 = tc->store(tc, b_val, NULL, version);
-    if (len3 < 0) goto block_err;
-
-    len += (n = c->vv->varint_put32_blk(b, c->codec));  r |= n;
-    len += (n = c->vv->varint_put32_blk(b, len2+len3)); r |= n;
-    BLOCK_APPEND(b, BLOCK_DATA(b_len), BLOCK_SIZE(b_len));
-    BLOCK_APPEND(b, BLOCK_DATA(b_val), BLOCK_SIZE(b_val));
-
-    cram_free_block(b_len);
-    cram_free_block(b_val);
-
-    if (r > 0)
-        return len + len2 + len3;
-
- block_err:
-    if (b_len) cram_free_block(b_len);
-    if (b_val) cram_free_block(b_val);
-    return -1;
-}
-
-cram_codec *cram_byte_array_len_encode_init(cram_stats *st,
-                                            enum cram_encoding codec,
-                                            enum cram_external_type option,
-                                            void *dat,
-                                            int version, varint_vec *vv) {
-    cram_codec *c;
-    cram_byte_array_len_encoder *e = (cram_byte_array_len_encoder *)dat;
-
-    c = malloc(sizeof(*c));
-    if (!c)
-        return NULL;
-    c->codec = E_BYTE_ARRAY_LEN;
-    c->free = cram_byte_array_len_encode_free;
-    c->encode = cram_byte_array_len_encode;
-    c->store = cram_byte_array_len_encode_store;
-    c->flush = NULL;
-
-    c->u.e_byte_array_len.len_codec = cram_encoder_init(e->len_encoding,
-                                                        st, E_INT,
-                                                        e->len_dat,
-                                                        version, vv);
-    c->u.e_byte_array_len.val_codec = cram_encoder_init(e->val_encoding,
-                                                        NULL, E_BYTE_ARRAY,
-                                                        e->val_dat,
-                                                        version, vv);
-
-    if (!c->u.e_byte_array_len.len_codec ||
-        !c->u.e_byte_array_len.val_codec) {
-        cram_byte_array_len_encode_free(c);
-        return NULL;
-    }
-
-    return c;
-}
-
-/*
- * ---------------------------------------------------------------------------
- * BYTE_ARRAY_STOP
- */
-static int cram_byte_array_stop_decode_char(cram_slice *slice, cram_codec *c,
-                                            cram_block *in, char *out,
-                                            int *out_size) {
-    char *cp, ch;
-    cram_block *b = NULL;
-
-    b = cram_get_block_by_id(slice, c->u.byte_array_stop.content_id);
-    if (!b)
-        return *out_size?-1:0;
-
-    if (b->idx >= b->uncomp_size)
-        return -1;
-
-    cp = (char *)b->data + b->idx;
-    if (out) {
-        while ((ch = *cp) != (char)c->u.byte_array_stop.stop) {
-            if (cp - (char *)b->data >= b->uncomp_size)
-                return -1;
-            *out++ = ch;
-            cp++;
-        }
-    } else {
-        // Consume input, but produce no output
-        while ((ch = *cp) != (char)c->u.byte_array_stop.stop) {
-            if (cp - (char *)b->data >= b->uncomp_size)
-                return -1;
-            cp++;
-        }
-    }
-
-    *out_size = cp - (char *)(b->data + b->idx);
-    b->idx = cp - (char *)b->data + 1;
-
-    return 0;
-}
-
-int cram_byte_array_stop_decode_block(cram_slice *slice, cram_codec *c,
-                                      cram_block *in, char *out_,
-                                      int *out_size) {
-    cram_block *b;
-    cram_block *out = (cram_block *)out_;
-    unsigned char *cp, *cp_end;
-    unsigned char stop;
-
-    b = cram_get_block_by_id(slice, c->u.byte_array_stop.content_id);
-    if (!b)
-        return *out_size?-1:0;
-
-    if (b->idx >= b->uncomp_size)
-        return -1;
-    cp = b->data + b->idx;
-    cp_end = b->data + b->uncomp_size;
-
-    stop = c->u.byte_array_stop.stop;
-    if (cp_end - cp < out->alloc - out->byte) {
-        unsigned char *out_cp = BLOCK_END(out);
-        while (cp != cp_end && *cp != stop)
-            *out_cp++ = *cp++;
-        BLOCK_SIZE(out) = out_cp - BLOCK_DATA(out);
-    } else {
-        unsigned char *cp_start;
-        for (cp_start = cp; cp != cp_end && *cp != stop; cp++)
-            ;
-        BLOCK_APPEND(out, cp_start, cp - cp_start);
-        BLOCK_GROW(out, cp - cp_start);
-    }
-
-    *out_size = cp - (b->data + b->idx);
-    b->idx = cp - b->data + 1;
-
-    return 0;
-
- block_err:
-    return -1;
-}
-
-void cram_byte_array_stop_decode_free(cram_codec *c) {
-    if (!c) return;
-
-    free(c);
-}
-
-cram_codec *cram_byte_array_stop_decode_init(cram_block_compression_hdr *hdr,
-                                             char *data, int size,
-                                             enum cram_encoding codec,
-                                             enum cram_external_type option,
-                                             int version, varint_vec *vv) {
-    cram_codec *c = NULL;
-    unsigned char *cp = (unsigned char *)data;
-    int err = 0;
-
-    if (size < (CRAM_MAJOR_VERS(version) == 1 ? 5 : 2))
-        goto malformed;
-
-    if (!(c = malloc(sizeof(*c))))
-        return NULL;
-
-    c->codec  = E_BYTE_ARRAY_STOP;
-    switch (option) {
-    case E_BYTE_ARRAY_BLOCK:
-        c->decode = cram_byte_array_stop_decode_block;
-        break;
-    case E_BYTE_ARRAY:
-        c->decode = cram_byte_array_stop_decode_char;
-        break;
-    default:
-        hts_log_error("The byte_array_stop codec only supports BYTE_ARRAYs");
-        free(c);
-        return NULL;
-    }
-    c->free   = cram_byte_array_stop_decode_free;
-
-    c->u.byte_array_stop.stop = *cp++;
-    if (CRAM_MAJOR_VERS(version) == 1) {
-        c->u.byte_array_stop.content_id = cp[0] + (cp[1]<<8) + (cp[2]<<16)
-            + ((unsigned int) cp[3]<<24);
-        cp += 4;
-    } else {
-        c->u.byte_array_stop.content_id = vv->varint_get32((char **)&cp, data+size, &err);
-    }
-
-    if ((char *)cp - data != size || err)
-        goto malformed;
-
-    return c;
-
- malformed:
-    hts_log_error("Malformed byte_array_stop header stream");
-    free(c);
-    return NULL;
-}
-
-int cram_byte_array_stop_encode(cram_slice *slice, cram_codec *c,
-                                char *in, int in_size) {
-    BLOCK_APPEND(c->out, in, in_size);
-    BLOCK_APPEND_CHAR(c->out, c->u.e_byte_array_stop.stop);
-    return 0;
-
- block_err:
-    return -1;
-}
-
-void cram_byte_array_stop_encode_free(cram_codec *c) {
-    if (!c)
-        return;
-    free(c);
-}
-
-int cram_byte_array_stop_encode_store(cram_codec *c, cram_block *b,
-                                      char *prefix, int version) {
-    int len = 0;
-    char buf[20], *cp = buf;
-
-    if (prefix) {
-        size_t l = strlen(prefix);
-        BLOCK_APPEND(b, prefix, l);
-        len += l;
-    }
-
-    cp += c->vv->varint_put32(cp, buf+20, c->codec);
-
-    if (CRAM_MAJOR_VERS(version) == 1) {
-        cp += c->vv->varint_put32(cp, buf+20, 5);
-        *cp++ = c->u.e_byte_array_stop.stop;
-        *cp++ = (c->u.e_byte_array_stop.content_id >>  0) & 0xff;
-        *cp++ = (c->u.e_byte_array_stop.content_id >>  8) & 0xff;
-        *cp++ = (c->u.e_byte_array_stop.content_id >> 16) & 0xff;
-        *cp++ = (c->u.e_byte_array_stop.content_id >> 24) & 0xff;
-    } else {
-        cp += c->vv->varint_put32(cp, buf+20, 1 +
-                                  c->vv->varint_size(c->u.e_byte_array_stop.content_id));
-        *cp++ = c->u.e_byte_array_stop.stop;
-        cp += c->vv->varint_put32(cp, buf+20, c->u.e_byte_array_stop.content_id);
-    }
-
-    BLOCK_APPEND(b, buf, cp-buf);
-    len += cp-buf;
-
-    return len;
-
- block_err:
-    return -1;
-}
-
-cram_codec *cram_byte_array_stop_encode_init(cram_stats *st,
-                                             enum cram_encoding codec,
-                                             enum cram_external_type option,
-                                             void *dat,
-                                             int version, varint_vec *vv) {
-    cram_codec *c;
-
-    c = malloc(sizeof(*c));
-    if (!c)
-        return NULL;
-    c->codec = E_BYTE_ARRAY_STOP;
-    c->free = cram_byte_array_stop_encode_free;
-    c->encode = cram_byte_array_stop_encode;
-    c->store = cram_byte_array_stop_encode_store;
-    c->flush = NULL;
-
-    c->u.e_byte_array_stop.stop = ((int *)dat)[0];
-    c->u.e_byte_array_stop.content_id = ((int *)dat)[1];
-
-    return c;
-}
-
-/*
- * ---------------------------------------------------------------------------
- */
-
-const char *cram_encoding2str(enum cram_encoding t) {
-    switch (t) {
-    case E_NULL:            return "NULL";
-    case E_EXTERNAL:        return "EXTERNAL";
-    case E_GOLOMB:          return "GOLOMB";
-    case E_HUFFMAN:         return "HUFFMAN";
-    case E_BYTE_ARRAY_LEN:  return "BYTE_ARRAY_LEN";
-    case E_BYTE_ARRAY_STOP: return "BYTE_ARRAY_STOP";
-    case E_BETA:            return "BETA";
-    case E_SUBEXP:          return "SUBEXP";
-    case E_GOLOMB_RICE:     return "GOLOMB_RICE";
-    case E_GAMMA:           return "GAMMA";
-
-    case E_VARINT_UNSIGNED: return "VARINT_UNSIGNED";
-    case E_VARINT_SIGNED:   return "VARINT_SIGNED";
-    case E_CONST_BYTE:      return "CONST_BYTE";
-    case E_CONST_INT:       return "CONST_INT";
-
-    case E_NUM_CODECS:
-    default:                return "?";
-    }
-}
-
-static cram_codec *(*decode_init[])(cram_block_compression_hdr *hdr,
-                                    char *data,
-                                    int size,
-                                    enum cram_encoding codec,
-                                    enum cram_external_type option,
-                                    int version, varint_vec *vv) = {
-    // CRAM 3.0 valid codecs
-    NULL, // null codec
-    cram_external_decode_init,
-    NULL, // golomb
-    cram_huffman_decode_init,
-    cram_byte_array_len_decode_init,
-    cram_byte_array_stop_decode_init,
-    cram_beta_decode_init,
-    cram_subexp_decode_init,
-    NULL, // golomb rice
-    cram_gamma_decode_init,
-
-    // Gap between CRAM 3 and CRAM 4; 9 to 39 inclusive
-    NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL,
-    NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL,
-    NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL,
-
-    NULL,                      // was xbyte
-    cram_varint_decode_init,   // varint unsigned
-    cram_varint_decode_init,   // varint signed
-    cram_const_decode_init,    // const byte
-    cram_const_decode_init,    // const int
-
-    // Gap to CRAM 4 transfomrations; 45 to 49 inclusive
-    NULL, NULL, NULL, NULL, NULL,
-
-    NULL, // xhuffman
-    cram_xpack_decode_init,
-    cram_xrle_decode_init,
-    cram_xdelta_decode_init,
-};
-
-cram_codec *cram_decoder_init(cram_block_compression_hdr *hdr,
-                              enum cram_encoding codec,
-                              char *data, int size,
-                              enum cram_external_type option,
-                              int version, varint_vec *vv) {
-    if (codec >= E_NULL && codec < E_NUM_CODECS && decode_init[codec]) {
-        cram_codec *r = decode_init[codec](hdr, data, size, codec,
-                                           option, version, vv);
-        if (r) {
-            r->vv = vv;
-            r->codec_id = hdr->ncodecs++;
-        }
-        return r;
-    } else {
-        hts_log_error("Unimplemented codec of type %s", cram_encoding2str(codec));
-        return NULL;
-    }
-}
-
-static cram_codec *(*encode_init[])(cram_stats *stx,
-                                    enum cram_encoding codec,
-                                    enum cram_external_type option,
-                                    void *opt,
-                                    int version, varint_vec *vv) = {
-    // CRAM 3.0 valid codecs
-    NULL, // null codec
-    cram_external_encode_init, // int/bytes in cram 3, byte only in cram 4
-    NULL, // golomb
-    cram_huffman_encode_init,
-    cram_byte_array_len_encode_init,
-    cram_byte_array_stop_encode_init,
-    cram_beta_encode_init,
-    NULL, // subexponential (we support decode only)
-    NULL, // golomb rice
-    NULL, // gamma (we support decode only)
-
-    // Gap between CRAM 3 and CRAM 4; 9 to 39 inclusive
-    NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL,
-    NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL,
-    NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL,
-
-    NULL, // was xbyte
-    cram_varint_encode_init, // varint unsigned
-    cram_varint_encode_init, // varint signed
-    cram_const_encode_init,  // const byte
-    cram_const_encode_init,  // const int
-
-    // Gap to CRAM 4 transfomrations; 45 to 49 inclusive
-    NULL, NULL, NULL, NULL, NULL,
-
-    NULL, // xhuffman
-    cram_xpack_encode_init,
-    cram_xrle_encode_init,
-    cram_xdelta_encode_init,
-};
-
-cram_codec *cram_encoder_init(enum cram_encoding codec,
-                              cram_stats *st,
-                              enum cram_external_type option,
-                              void *dat,
-                              int version, varint_vec *vv) {
-    if (st && !st->nvals)
-        return NULL;
-
-    // cram_stats_encoding assumes integer data, but if option
-    // is E_BYTE then tweak the requested encoding.  This ought
-    // to be fixed in cram_stats_encoding instead.
-    if (option == E_BYTE || option == E_BYTE_ARRAY ||
-       option == E_BYTE_ARRAY_BLOCK) {
-       if (codec == E_VARINT_SIGNED || codec == E_VARINT_UNSIGNED)
-           codec = E_EXTERNAL;
-       else if (codec == E_CONST_INT)
-           codec = E_CONST_BYTE;
-    }
-
-    if (encode_init[codec]) {
-        cram_codec *r;
-        if ((r = encode_init[codec](st, codec, option, dat, version, vv)))
-            r->out = NULL;
-        if (!r) {
-            hts_log_error("Unable to initialise codec of type %s", cram_encoding2str(codec));
-            return NULL;
-        }
-        r->vv = vv;
-        return r;
-    } else {
-        hts_log_error("Unimplemented codec of type %s", cram_encoding2str(codec));
-        abort();
-    }
-}
-
-/*
- * Returns the content_id used by this codec, also in id2 if byte_array_len.
- * Returns -1 for the CORE block and -2 for unneeded.
- * id2 is only filled out for BYTE_ARRAY_LEN which uses 2 codecs.
- */
-int cram_codec_to_id(cram_codec *c, int *id2) {
-    int bnum1, bnum2 = -2;
-
-    switch (c->codec) {
-    case E_CONST_INT:
-    case E_CONST_BYTE:
-       bnum1 = -2; // no blocks used
-
-    case E_HUFFMAN:
-        bnum1 = c->u.huffman.ncodes == 1 ? -2 : -1;
-        break;
-
-    case E_GOLOMB:
-    case E_BETA:
-    case E_SUBEXP:
-    case E_GOLOMB_RICE:
-    case E_GAMMA:
-        // CORE block
-        bnum1 = -1;
-        break;
-
-    case E_EXTERNAL:
-    case E_VARINT_UNSIGNED:
-    case E_VARINT_SIGNED:
-        bnum1 = c->u.external.content_id;
-        break;
-
-    case E_BYTE_ARRAY_LEN:
-        bnum1 = cram_codec_to_id(c->u.byte_array_len.len_codec, NULL);
-        bnum2 = cram_codec_to_id(c->u.byte_array_len.val_codec, NULL);
-        break;
-
-    case E_BYTE_ARRAY_STOP:
-        bnum1 = c->u.byte_array_stop.content_id;
-        break;
-
-    case E_NULL:
-        bnum1 = -2;
-        break;
-
-    default:
-        hts_log_error("Unknown codec type %d", c->codec);
-        bnum1 = -1;
-    }
-
-    if (id2)
-        *id2 = bnum2;
-    return bnum1;
-}
-
-
-/*
- * cram_codec structures are specialised for decoding or encoding.
- * Unfortunately this makes turning a decoder into an encoder (such as
- * when transcoding files) problematic.
- *
- * This function converts a cram decoder codec into an encoder version
- * in-place (ie it modifiers the codec itself).
- *
- * Returns 0 on success;
- *        -1 on failure.
- */
-int cram_codec_decoder2encoder(cram_fd *fd, cram_codec *c) {
-    int j;
-
-    switch (c->codec) {
-    case E_CONST_INT:
-    case E_CONST_BYTE:
-        // shares struct with decode
-        c->store = cram_const_encode_store;
-        break;
-
-    case E_EXTERNAL:
-        // shares struct with decode
-        c->free = cram_external_encode_free;
-        c->store = cram_external_encode_store;
-        if (c->decode == cram_external_decode_int)
-            c->encode = cram_external_encode_int;
-        else if (c->decode == cram_external_decode_long)
-            c->encode = cram_external_encode_long;
-        else if (c->decode == cram_external_decode_char)
-            c->encode = cram_external_encode_char;
-        else if (c->decode == cram_external_decode_block)
-            c->encode = cram_external_encode_char;
-        else
-            return -1;
-        break;
-
-    case E_VARINT_SIGNED:
-    case E_VARINT_UNSIGNED:
-        // shares struct with decode
-        c->free = cram_varint_encode_free;
-        c->store = cram_varint_encode_store;
-        if (c->decode == cram_varint_decode_int)
-            c->encode = cram_varint_encode_int;
-        else if (c->decode == cram_varint_decode_sint)
-            c->encode = cram_varint_encode_sint;
-        else if (c->decode == cram_varint_decode_long)
-            c->encode = cram_varint_encode_long;
-        else if (c->decode == cram_varint_decode_slong)
-            c->encode = cram_varint_encode_slong;
-        else
-            return -1;
-        break;
-
-    case E_HUFFMAN: {
-        // New structure, so switch.
-        // FIXME: we huffman and e_huffman structs amended, we could
-        // unify this.
-        cram_codec *t = malloc(sizeof(*t));
-        if (!t) return -1;
-        t->codec = E_HUFFMAN;
-        t->free = cram_huffman_encode_free;
-        t->store = cram_huffman_encode_store;
-        t->u.e_huffman.codes = c->u.huffman.codes;
-        t->u.e_huffman.nvals = c->u.huffman.ncodes;
-        t->u.e_huffman.option = c->u.huffman.option;
-        for (j = 0; j < t->u.e_huffman.nvals; j++) {
-            int32_t sym = t->u.e_huffman.codes[j].symbol;
-            if (sym >= -1 && sym < MAX_HUFF)
-                t->u.e_huffman.val2code[sym+1] = j;
-        }
-
-        if (c->decode == cram_huffman_decode_char0)
-            t->encode = cram_huffman_encode_char0;
-        else if (c->decode == cram_huffman_decode_char)
-            t->encode = cram_huffman_encode_char;
-        else if (c->decode == cram_huffman_decode_int0)
-            t->encode = cram_huffman_encode_int0;
-        else if (c->decode == cram_huffman_decode_int)
-            t->encode = cram_huffman_encode_int;
-        else if (c->decode == cram_huffman_decode_long0)
-            t->encode = cram_huffman_encode_long0;
-        else if (c->decode == cram_huffman_decode_long)
-            t->encode = cram_huffman_encode_long;
-        else {
-            free(t);
-            return -1;
-        }
-        *c = *t;
-        free(t);
-        break;
-    }
-
-    case E_BETA:
-        // shares struct with decode
-        c->free = cram_beta_encode_free;
-        c->store = cram_beta_encode_store;
-        if (c->decode == cram_beta_decode_int)
-            c->encode = cram_beta_encode_int;
-        else if (c->decode == cram_beta_decode_long)
-            c->encode = cram_beta_encode_long;
-        else if (c->decode == cram_beta_decode_char)
-            c->encode = cram_beta_encode_char;
-        else
-            return -1;
-        break;
-
-    case E_XPACK: {
-        // shares struct with decode
-        cram_codec t = *c;
-        t.free = cram_xpack_encode_free;
-        t.store = cram_xpack_encode_store;
-        if (t.decode == cram_xpack_decode_long)
-            t.encode = cram_xpack_encode_long;
-        else if (t.decode == cram_xpack_decode_int)
-            t.encode = cram_xpack_encode_int;
-        else if (t.decode == cram_xpack_decode_char)
-            t.encode = cram_xpack_encode_char;
-        else
-            return -1;
-        t.u.e_xpack.sub_codec = t.u.xpack.sub_codec;
-        if (cram_codec_decoder2encoder(fd, t.u.e_xpack.sub_codec) == -1)
-            return -1;
-        *c = t;
-        break;
-    }
-
-    case E_BYTE_ARRAY_LEN: {
-        cram_codec *t = malloc(sizeof(*t));
-        if (!t) return -1;
-        t->vv     = c->vv;
-        t->codec  = E_BYTE_ARRAY_LEN;
-        t->free   = cram_byte_array_len_encode_free;
-        t->store  = cram_byte_array_len_encode_store;
-        t->encode = cram_byte_array_len_encode;
-        t->u.e_byte_array_len.len_codec = c->u.byte_array_len.len_codec;
-        t->u.e_byte_array_len.val_codec = c->u.byte_array_len.val_codec;
-        if (cram_codec_decoder2encoder(fd, t->u.e_byte_array_len.len_codec) == -1 ||
-            cram_codec_decoder2encoder(fd, t->u.e_byte_array_len.val_codec) == -1) {
-            t->free(t);
-            return -1;
-        }
-
-        // {len,val}_{encoding,dat} are undefined, but unused.
-        // Leaving them unset here means we can test that assertion.
-        *c = *t;
-        break;
-    }
-
-    case E_BYTE_ARRAY_STOP:
-        // shares struct with decode
-        c->free   = cram_byte_array_stop_encode_free;
-        c->store  = cram_byte_array_stop_encode_store;
-        c->encode = cram_byte_array_stop_encode;
-        break;
-
-    default:
-        return -1;
-    }
-
-    return 0;
-}
diff -ruN stringtie.orig/htslib/cram/cram_codecs.h stringtie/htslib/cram/cram_codecs.h
--- stringtie.orig/htslib/cram/cram_codecs.h	2024-02-28 13:57:39.701246126 +0100
+++ stringtie/htslib/cram/cram_codecs.h	1970-01-01 01:00:00.000000000 +0100
@@ -1,263 +0,0 @@
-/*
-Copyright (c) 2012-2015, 2018, 2020 Genome Research Ltd.
-Author: James Bonfield <jkb@sanger.ac.uk>
-
-Redistribution and use in source and binary forms, with or without
-modification, are permitted provided that the following conditions are met:
-
-   1. Redistributions of source code must retain the above copyright notice,
-this list of conditions and the following disclaimer.
-
-   2. Redistributions in binary form must reproduce the above copyright notice,
-this list of conditions and the following disclaimer in the documentation
-and/or other materials provided with the distribution.
-
-   3. Neither the names Genome Research Ltd and Wellcome Trust Sanger
-Institute nor the names of its contributors may be used to endorse or promote
-products derived from this software without specific prior written permission.
-
-THIS SOFTWARE IS PROVIDED BY GENOME RESEARCH LTD AND CONTRIBUTORS "AS IS" AND
-ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
-WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
-DISCLAIMED. IN NO EVENT SHALL GENOME RESEARCH LTD OR CONTRIBUTORS BE LIABLE
-FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
-DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
-SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
-CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
-OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
-OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-*/
-
-#ifndef CRAM_CODECS_H
-#define CRAM_CODECS_H
-
-#include <stdint.h>
-
-#ifdef __cplusplus
-extern "C" {
-#endif
-
-struct cram_codec;
-
-/*
- * Slow but simple huffman decoder to start with.
- * Read a bit at a time, keeping track of {length, value}
- * eg. 1 1 0 1 => {1,1},  {2,3}, {3,6}, {4,13}
- *
- * Keep track of this through the huffman code table.
- * For fast scanning we have an index of where the first code of length X
- * appears.
- */
-typedef struct {
-    int64_t symbol;
-    int32_t p; // next code start value, minus index to codes[]
-    int32_t code;
-    int32_t len;
-} cram_huffman_code;
-
-typedef struct {
-    int ncodes;
-    cram_huffman_code *codes;
-    int option;
-} cram_huffman_decoder;
-
-#define MAX_HUFF 128
-typedef struct {
-    cram_huffman_code *codes;
-    int nvals;
-    int val2code[MAX_HUFF+1]; // value to code lookup for small values
-    int option;
-} cram_huffman_encoder;
-
-typedef struct {
-    int32_t offset;
-    int32_t nbits;
-} cram_beta_decoder;
-
-// A PACK transform, packing multiple values into a single byte
-typedef struct {
-    int32_t nbits;
-    enum cram_encoding sub_encoding;
-    void *sub_codec_dat;
-    struct cram_codec *sub_codec;
-    int nval;  // number of items in maps
-    uint32_t rmap[256]; // 0,1,2,3 -> P,A,C,K
-    int map[256];       // P,A,C,K -> 0,1,2,3 // NB: max input is uint8_tb? Or use hash?
-} cram_xpack_decoder;
-typedef cram_xpack_decoder cram_xpack_encoder;
-
-// Transforms symbols X,Y,Z to bytes 0,1,2.
-typedef struct {
-    enum cram_encoding len_encoding;
-    enum cram_encoding lit_encoding;
-    void *len_dat;
-    void *lit_dat;
-    struct cram_codec *len_codec;
-    struct cram_codec *lit_codec;
-    int cur_len;
-    int cur_lit;
-    int rep_score[256];
-    char *to_flush;
-    size_t to_flush_size;
-} cram_xrle_decoder;
-typedef cram_xrle_decoder cram_xrle_encoder;
-
-// DELTA + zigzag + varint encoding
-typedef struct {
-    // FIXME: define endian here too.  Require little endian?
-    int64_t last;
-    uint8_t word_size; // 1, 2, 4, 8
-    //uint8_t sign;      // true if input data is already signed
-    enum cram_encoding sub_encoding;
-    void *sub_codec_dat;
-    struct cram_codec *sub_codec;
-} cram_xdelta_decoder;
-typedef cram_xdelta_decoder cram_xdelta_encoder;
-
-typedef struct {
-    int32_t offset;
-} cram_gamma_decoder;
-
-typedef struct {
-    int32_t offset;
-    int32_t k;
-} cram_subexp_decoder;
-
-typedef struct {
-    int32_t content_id;
-    enum cram_external_type type;
-} cram_external_decoder;
-
-typedef struct {
-    int32_t content_id;
-    int64_t offset;
-    enum cram_external_type type;
-} cram_varint_decoder;
-
-typedef struct {
-    struct cram_codec *len_codec;
-    struct cram_codec *val_codec;
-} cram_byte_array_len_decoder;
-
-typedef struct {
-    unsigned char stop;
-    int32_t content_id;
-} cram_byte_array_stop_decoder;
-
-typedef struct {
-    enum cram_encoding len_encoding;
-    enum cram_encoding val_encoding;
-    void *len_dat;
-    void *val_dat;
-    struct cram_codec *len_codec;
-    struct cram_codec *val_codec;
-} cram_byte_array_len_encoder;
-
-typedef struct {
-    int64_t val;
-} cram_const_codec;
-
-/*
- * A generic codec structure.
- */
-typedef struct cram_codec {
-    enum cram_encoding codec;
-    cram_block *out;
-    varint_vec *vv;
-    int codec_id;
-    void (*free)(struct cram_codec *codec);
-    int (*decode)(cram_slice *slice, struct cram_codec *codec,
-                  cram_block *in, char *out, int *out_size);
-    int (*encode)(cram_slice *slice, struct cram_codec *codec,
-                  char *in, int in_size);
-    int (*store)(struct cram_codec *codec, cram_block *b, char *prefix,
-                 int version);
-    int (*size)(cram_slice *slice, struct cram_codec *codec);
-    int (*flush)(struct cram_codec *codec);
-    cram_block *(*get_block)(cram_slice *slice, struct cram_codec *codec);
-
-    union {
-        cram_huffman_decoder         huffman;
-        cram_external_decoder        external;
-        cram_beta_decoder            beta;
-        cram_gamma_decoder           gamma;
-        cram_subexp_decoder          subexp;
-        cram_byte_array_len_decoder  byte_array_len;
-        cram_byte_array_stop_decoder byte_array_stop;
-        cram_xpack_decoder           xpack;
-        cram_xrle_decoder            xrle;
-        cram_xdelta_decoder          xdelta;
-        cram_const_codec             xconst;
-        cram_varint_decoder          varint;
-
-        cram_huffman_encoder         e_huffman;
-        cram_external_decoder        e_external;
-        cram_byte_array_stop_decoder e_byte_array_stop;
-        cram_byte_array_len_encoder  e_byte_array_len;
-        cram_beta_decoder            e_beta;
-        cram_xpack_decoder           e_xpack;
-        cram_xrle_decoder            e_xrle;
-        cram_xdelta_decoder          e_xdelta;
-        cram_const_codec             e_xconst;
-        cram_varint_decoder          e_varint;
-    } u;
-} cram_codec;
-
-const char *cram_encoding2str(enum cram_encoding t);
-
-cram_codec *cram_decoder_init(cram_block_compression_hdr *hdr,
-                              enum cram_encoding codec, char *data, int size,
-                              enum cram_external_type option,
-                              int version, varint_vec *vv);
-cram_codec *cram_encoder_init(enum cram_encoding codec, cram_stats *st,
-                              enum cram_external_type option, void *dat,
-                              int version, varint_vec *vv);
-
-//int cram_decode(void *codes, char *in, int in_size, char *out, int *out_size);
-//void cram_decoder_free(void *codes);
-
-//#define GET_BIT_MSB(b,v) (void)(v<<=1, v|=(b->data[b->byte] >> b->bit)&1, (--b->bit == -1) && (b->bit = 7, b->byte++))
-
-#define GET_BIT_MSB(b,v) (void)(v<<=1, v|=(b->data[b->byte] >> b->bit)&1, b->byte += (--b->bit<0), b->bit&=7)
-
-/*
- * Check that enough bits are left in a block to satisy a bit-based decoder.
- * Return  0 if there are enough
- *         1 if not.
- */
-
-static inline int cram_not_enough_bits(cram_block *blk, int nbits) {
-    if (nbits < 0 ||
-        (blk->byte >= blk->uncomp_size && nbits > 0) ||
-        (blk->uncomp_size - blk->byte <= INT32_MAX / 8 + 1 &&
-         (blk->uncomp_size - blk->byte) * 8 + blk->bit - 7 < nbits)) {
-        return 1;
-    }
-    return 0;
-}
-
-/*
- * Returns the content_id used by this codec, also in id2 if byte_array_len.
- * Returns -1 for the CORE block and -2 for unneeded.
- * id2 is only filled out for BYTE_ARRAY_LEN which uses 2 codecs.
- */
-int cram_codec_to_id(cram_codec *c, int *id2);
-
-/*
- * cram_codec structures are specialised for decoding or encoding.
- * Unfortunately this makes turning a decoder into an encoder (such as
- * when transcoding files) problematic.
- *
- * This function converts a cram decoder codec into an encoder version
- * in-place (ie it modifiers the codec itself).
- *
- * Returns 0 on success;
- *        -1 on failure.
- */
-int cram_codec_decoder2encoder(cram_fd *fd, cram_codec *c);
-
-#ifdef __cplusplus
-}
-#endif
-
-#endif /* CRAM_CODECS_H */
diff -ruN stringtie.orig/htslib/cram/cram_decode.c stringtie/htslib/cram/cram_decode.c
--- stringtie.orig/htslib/cram/cram_decode.c	2024-02-28 13:57:39.701246126 +0100
+++ stringtie/htslib/cram/cram_decode.c	1970-01-01 01:00:00.000000000 +0100
@@ -1,3546 +0,0 @@
-/*
-Copyright (c) 2012-2020 Genome Research Ltd.
-Author: James Bonfield <jkb@sanger.ac.uk>
-
-Redistribution and use in source and binary forms, with or without
-modification, are permitted provided that the following conditions are met:
-
-   1. Redistributions of source code must retain the above copyright notice,
-this list of conditions and the following disclaimer.
-
-   2. Redistributions in binary form must reproduce the above copyright notice,
-this list of conditions and the following disclaimer in the documentation
-and/or other materials provided with the distribution.
-
-   3. Neither the names Genome Research Ltd and Wellcome Trust Sanger
-Institute nor the names of its contributors may be used to endorse or promote
-products derived from this software without specific prior written permission.
-
-THIS SOFTWARE IS PROVIDED BY GENOME RESEARCH LTD AND CONTRIBUTORS "AS IS" AND
-ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
-WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
-DISCLAIMED. IN NO EVENT SHALL GENOME RESEARCH LTD OR CONTRIBUTORS BE LIABLE
-FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
-DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
-SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
-CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
-OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
-OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-*/
-
-/*
- * - In-memory decoding of CRAM data structures.
- * - Iterator for reading CRAM record by record.
- */
-
-#define HTS_BUILDING_LIBRARY // Enables HTSLIB_EXPORT, see htslib/hts_defs.h
-#include <config.h>
-
-#include <stdio.h>
-#include <errno.h>
-#include <assert.h>
-#include <stdlib.h>
-#include <string.h>
-#include <zlib.h>
-#include <sys/types.h>
-#include <sys/stat.h>
-#include <math.h>
-#include <stdint.h>
-#include <inttypes.h>
-
-#include "cram.h"
-#include "os.h"
-#include "../htslib/hts.h"
-
-//Whether CIGAR has just M or uses = and X to indicate match and mismatch
-//#define USE_X
-
-/* ----------------------------------------------------------------------
- * CRAM compression headers
- */
-
-/*
- * Decodes the Tag Dictionary record in the preservation map
- * Updates the cram compression header.
- *
- * Returns number of bytes decoded on success
- *        -1 on failure
- */
-int cram_decode_TD(cram_fd *fd, char *cp, const char *endp,
-                   cram_block_compression_hdr *h) {
-    char *op = cp;
-    unsigned char *dat;
-    cram_block *b;
-    int32_t blk_size = 0;
-    int nTL, i, sz, err = 0;
-
-    if (!(b = cram_new_block(0, 0)))
-        return -1;
-
-    if (h->TD_blk || h->TL) {
-        hts_log_warning("More than one TD block found in compression header");
-        cram_free_block(h->TD_blk);
-        free(h->TL);
-        h->TD_blk = NULL;
-        h->TL = NULL;
-    }
-
-    /* Decode */
-    blk_size = fd->vv.varint_get32(&cp, endp, &err);
-    if (!blk_size) {
-        h->nTL = 0;
-        cram_free_block(b);
-        return cp - op;
-    }
-
-    if (err || blk_size < 0 || endp - cp < blk_size) {
-        cram_free_block(b);
-        return -1;
-    }
-
-    BLOCK_APPEND(b, cp, blk_size);
-    cp += blk_size;
-    sz = cp - op;
-    // Force nul termination if missing
-    if (BLOCK_DATA(b)[BLOCK_SIZE(b)-1])
-        BLOCK_APPEND_CHAR(b, '\0');
-
-    /* Set up TL lookup table */
-    dat = BLOCK_DATA(b);
-
-    // Count
-    for (nTL = i = 0; i < BLOCK_SIZE(b); i++) {
-        nTL++;
-        while (dat[i])
-            i++;
-    }
-
-    // Copy
-    if (!(h->TL = calloc(nTL, sizeof(*h->TL)))) {
-        cram_free_block(b);
-        return -1;
-    }
-    for (nTL = i = 0; i < BLOCK_SIZE(b); i++) {
-        h->TL[nTL++] = &dat[i];
-        while (dat[i])
-            i++;
-    }
-    h->TD_blk = b;
-    h->nTL = nTL;
-
-    return sz;
-
- block_err:
-    cram_free_block(b);
-    return -1;
-}
-
-/*
- * Decodes a CRAM block compression header.
- * Returns header ptr on success
- *         NULL on failure
- */
-cram_block_compression_hdr *cram_decode_compression_header(cram_fd *fd,
-                                                           cram_block *b) {
-    char *cp, *endp, *cp_copy;
-    cram_block_compression_hdr *hdr = calloc(1, sizeof(*hdr));
-    int i, err = 0;
-    int32_t map_size = 0, map_count = 0;
-
-    if (!hdr)
-        return NULL;
-
-    if (b->method != RAW) {
-        if (cram_uncompress_block(b)) {
-            free(hdr);
-            return NULL;
-        }
-    }
-
-    cp = (char *)b->data;
-    endp = cp + b->uncomp_size;
-
-    if (CRAM_MAJOR_VERS(fd->version) == 1) {
-        hdr->ref_seq_id = fd->vv.varint_get32(&cp, endp, &err);
-        if (CRAM_MAJOR_VERS(fd->version) >= 4) {
-            hdr->ref_seq_start = fd->vv.varint_get64(&cp, endp, &err);
-            hdr->ref_seq_span  = fd->vv.varint_get64(&cp, endp, &err);
-        } else {
-            hdr->ref_seq_start = fd->vv.varint_get32(&cp, endp, &err);
-            hdr->ref_seq_span  = fd->vv.varint_get32(&cp, endp, &err);
-        }
-        hdr->num_records   = fd->vv.varint_get32(&cp, endp, &err);
-        hdr->num_landmarks = fd->vv.varint_get32(&cp, endp, &err);
-        if (hdr->num_landmarks < 0 ||
-            hdr->num_landmarks >= SIZE_MAX / sizeof(int32_t) ||
-            endp - cp < hdr->num_landmarks) {
-            free(hdr);
-            return NULL;
-        }
-        if (!(hdr->landmark = malloc(hdr->num_landmarks * sizeof(int32_t)))) {
-            free(hdr);
-            return NULL;
-        }
-        for (i = 0; i < hdr->num_landmarks; i++)
-            hdr->landmark[i] = fd->vv.varint_get32(&cp, endp, &err);;
-    }
-
-    hdr->preservation_map = kh_init(map);
-
-    memset(hdr->rec_encoding_map, 0,
-           CRAM_MAP_HASH * sizeof(hdr->rec_encoding_map[0]));
-    memset(hdr->tag_encoding_map, 0,
-           CRAM_MAP_HASH * sizeof(hdr->tag_encoding_map[0]));
-
-    if (!hdr->preservation_map) {
-        cram_free_compression_header(hdr);
-        return NULL;
-    }
-
-    /* Initialise defaults for preservation map */
-    hdr->read_names_included = 0;
-    hdr->AP_delta = 1;
-    hdr->qs_seq_orient = 1;
-    memcpy(hdr->substitution_matrix, "CGTNAGTNACTNACGNACGT", 20);
-
-    /* Preservation map */
-    map_size  = fd->vv.varint_get32(&cp, endp, &err); cp_copy = cp;
-    map_count = fd->vv.varint_get32(&cp, endp, &err);
-    for (i = 0; i < map_count; i++) {
-        pmap_t hd;
-        khint_t k;
-        int r;
-
-        if (endp - cp < 3) {
-            cram_free_compression_header(hdr);
-            return NULL;
-        }
-        cp += 2;
-        switch(CRAM_KEY(cp[-2],cp[-1])) {
-        case CRAM_KEY('M','I'): // was mapped QS included in V1.0
-        case CRAM_KEY('U','I'): // was unmapped QS included in V1.0
-        case CRAM_KEY('P','I'): // was unmapped placed in V1.0
-            hd.i = *cp++;
-            break;
-
-        case CRAM_KEY('R','N'):
-            hd.i = *cp++;
-            k = kh_put(map, hdr->preservation_map, "RN", &r);
-            if (-1 == r) {
-                cram_free_compression_header(hdr);
-                return NULL;
-            }
-
-            kh_val(hdr->preservation_map, k) = hd;
-            hdr->read_names_included = hd.i;
-            break;
-
-        case CRAM_KEY('A','P'):
-            hd.i = *cp++;
-            k = kh_put(map, hdr->preservation_map, "AP", &r);
-            if (-1 == r) {
-                cram_free_compression_header(hdr);
-                return NULL;
-            }
-
-            kh_val(hdr->preservation_map, k) = hd;
-            hdr->AP_delta = hd.i;
-            break;
-
-        case CRAM_KEY('R','R'):
-            hd.i = *cp++;
-            k = kh_put(map, hdr->preservation_map, "RR", &r);
-            if (-1 == r) {
-                cram_free_compression_header(hdr);
-                return NULL;
-            }
-
-            kh_val(hdr->preservation_map, k) = hd;
-            hdr->no_ref = !hd.i;
-            break;
-
-        case CRAM_KEY('Q','O'):
-            hd.i = *cp++;
-            k = kh_put(map, hdr->preservation_map, "QO", &r);
-            if (-1 == r) {
-                cram_free_compression_header(hdr);
-                return NULL;
-            }
-
-            kh_val(hdr->preservation_map, k) = hd;
-            hdr->qs_seq_orient = hd.i;
-            break;
-
-        case CRAM_KEY('S','M'):
-            if (endp - cp < 5) {
-                cram_free_compression_header(hdr);
-                return NULL;
-            }
-            hdr->substitution_matrix[0][(cp[0]>>6)&3] = 'C';
-            hdr->substitution_matrix[0][(cp[0]>>4)&3] = 'G';
-            hdr->substitution_matrix[0][(cp[0]>>2)&3] = 'T';
-            hdr->substitution_matrix[0][(cp[0]>>0)&3] = 'N';
-
-            hdr->substitution_matrix[1][(cp[1]>>6)&3] = 'A';
-            hdr->substitution_matrix[1][(cp[1]>>4)&3] = 'G';
-            hdr->substitution_matrix[1][(cp[1]>>2)&3] = 'T';
-            hdr->substitution_matrix[1][(cp[1]>>0)&3] = 'N';
-
-            hdr->substitution_matrix[2][(cp[2]>>6)&3] = 'A';
-            hdr->substitution_matrix[2][(cp[2]>>4)&3] = 'C';
-            hdr->substitution_matrix[2][(cp[2]>>2)&3] = 'T';
-            hdr->substitution_matrix[2][(cp[2]>>0)&3] = 'N';
-
-            hdr->substitution_matrix[3][(cp[3]>>6)&3] = 'A';
-            hdr->substitution_matrix[3][(cp[3]>>4)&3] = 'C';
-            hdr->substitution_matrix[3][(cp[3]>>2)&3] = 'G';
-            hdr->substitution_matrix[3][(cp[3]>>0)&3] = 'N';
-
-            hdr->substitution_matrix[4][(cp[4]>>6)&3] = 'A';
-            hdr->substitution_matrix[4][(cp[4]>>4)&3] = 'C';
-            hdr->substitution_matrix[4][(cp[4]>>2)&3] = 'G';
-            hdr->substitution_matrix[4][(cp[4]>>0)&3] = 'T';
-
-            hd.p = cp;
-            cp += 5;
-
-            k = kh_put(map, hdr->preservation_map, "SM", &r);
-            if (-1 == r) {
-                cram_free_compression_header(hdr);
-                return NULL;
-            }
-            kh_val(hdr->preservation_map, k) = hd;
-            break;
-
-        case CRAM_KEY('T','D'): {
-            int sz = cram_decode_TD(fd, cp, endp, hdr); // tag dictionary
-            if (sz < 0) {
-                cram_free_compression_header(hdr);
-                return NULL;
-            }
-
-            hd.p = cp;
-            cp += sz;
-
-            k = kh_put(map, hdr->preservation_map, "TD", &r);
-            if (-1 == r) {
-                cram_free_compression_header(hdr);
-                return NULL;
-            }
-            kh_val(hdr->preservation_map, k) = hd;
-            break;
-        }
-
-        default:
-            hts_log_warning("Unrecognised preservation map key %c%c", cp[-2], cp[-1]);
-            // guess byte;
-            cp++;
-            break;
-        }
-    }
-    if (cp - cp_copy != map_size) {
-        cram_free_compression_header(hdr);
-        return NULL;
-    }
-
-    /* Record encoding map */
-    map_size  = fd->vv.varint_get32(&cp, endp, &err); cp_copy = cp;
-    map_count = fd->vv.varint_get32(&cp, endp, &err);
-    int is_v4 = CRAM_MAJOR_VERS(fd->version) >= 4 ? 1 : 0;
-    for (i = 0; i < map_count; i++) {
-        char *key = cp;
-        int32_t encoding = E_NULL;
-        int32_t size = 0;
-        ptrdiff_t offset;
-        cram_map *m;
-        enum cram_DS_ID ds_id;
-        enum cram_external_type type;
-
-        if (endp - cp < 4) {
-            cram_free_compression_header(hdr);
-            return NULL;
-        }
-
-        cp += 2;
-        encoding = fd->vv.varint_get32(&cp, endp, &err);
-        size     = fd->vv.varint_get32(&cp, endp, &err);
-
-        offset = cp - (char *)b->data;
-
-        if (encoding == E_NULL)
-            continue;
-
-        if (size < 0 || endp - cp < size) {
-            cram_free_compression_header(hdr);
-            return NULL;
-        }
-
-        //printf("%s codes for %.2s\n", cram_encoding2str(encoding), key);
-
-        /*
-         * For CRAM1.0 CF and BF are Byte and not Int.
-         * Practically speaking it makes no difference unless we have a
-         * 1.0 format file that stores these in EXTERNAL as only then
-         * does Byte vs Int matter.
-         *
-         * Neither this C code nor Java reference implementations did this,
-         * so we gloss over it and treat them as int.
-         */
-        ds_id = DS_CORE;
-        if (key[0] == 'B' && key[1] == 'F') {
-            ds_id = DS_BF; type = E_INT;
-        } else if (key[0] == 'C' && key[1] == 'F') {
-            ds_id = DS_CF; type = E_INT;
-        } else if (key[0] == 'R' && key[1] == 'I') {
-            ds_id = DS_RI; type = E_INT;
-        } else if (key[0] == 'R' && key[1] == 'L') {
-            ds_id = DS_RL; type = E_INT;
-        } else if (key[0] == 'A' && key[1] == 'P') {
-            ds_id = DS_AP;
-            type = is_v4 ? E_SLONG : E_INT;
-        } else if (key[0] == 'R' && key[1] == 'G') {
-            ds_id = DS_RG;
-            type = E_INT;
-        } else if (key[0] == 'M' && key[1] == 'F') {
-            ds_id = DS_MF; type = E_INT;
-        } else if (key[0] == 'N' && key[1] == 'S') {
-            ds_id = DS_NS; type = E_INT;
-        } else if (key[0] == 'N' && key[1] == 'P') {
-            ds_id = DS_NP;
-            type = is_v4 ? E_LONG : E_INT;
-        } else if (key[0] == 'T' && key[1] == 'S') {
-            ds_id = DS_TS;
-            type = is_v4 ? E_SLONG : E_INT;
-        } else if (key[0] == 'N' && key[1] == 'F') {
-            ds_id = DS_NF; type = E_INT;
-        } else if (key[0] == 'T' && key[1] == 'C') {
-            ds_id = DS_TC; type = E_BYTE;
-        } else if (key[0] == 'T' && key[1] == 'N') {
-            ds_id = DS_TN; type = E_INT;
-        } else if (key[0] == 'F' && key[1] == 'N') {
-            ds_id = DS_FN; type = E_INT;
-        } else if (key[0] == 'F' && key[1] == 'C') {
-            ds_id = DS_FC; type = E_BYTE;
-        } else if (key[0] == 'F' && key[1] == 'P') {
-            ds_id = DS_FP; type = E_INT;
-        } else if (key[0] == 'B' && key[1] == 'S') {
-            ds_id = DS_BS; type = E_BYTE;
-        } else if (key[0] == 'I' && key[1] == 'N') {
-            ds_id = DS_IN; type = E_BYTE_ARRAY;
-        } else if (key[0] == 'S' && key[1] == 'C') {
-            ds_id = DS_SC; type = E_BYTE_ARRAY;
-        } else if (key[0] == 'D' && key[1] == 'L') {
-            ds_id = DS_DL; type = E_INT;
-        } else if (key[0] == 'B' && key[1] == 'A') {
-            ds_id = DS_BA; type = E_BYTE;
-        } else if (key[0] == 'B' && key[1] == 'B') {
-            ds_id = DS_BB; type = E_BYTE_ARRAY;
-        } else if (key[0] == 'R' && key[1] == 'S') {
-            ds_id = DS_RS; type = E_INT;
-        } else if (key[0] == 'P' && key[1] == 'D') {
-            ds_id = DS_PD; type = E_INT;
-        } else if (key[0] == 'H' && key[1] == 'C') {
-            ds_id = DS_HC; type = E_INT;
-        } else if (key[0] == 'M' && key[1] == 'Q') {
-            ds_id = DS_MQ; type = E_INT;
-        } else if (key[0] == 'R' && key[1] == 'N') {
-            ds_id = DS_RN; type = E_BYTE_ARRAY_BLOCK;
-        } else if (key[0] == 'Q' && key[1] == 'S') {
-            ds_id = DS_QS; type = E_BYTE;
-        } else if (key[0] == 'Q' && key[1] == 'Q') {
-            ds_id = DS_QQ; type = E_BYTE_ARRAY;
-        } else if (key[0] == 'T' && key[1] == 'L') {
-            ds_id = DS_TL; type = E_INT;
-        } else if (key[0] == 'T' && key[1] == 'M') {
-        } else if (key[0] == 'T' && key[1] == 'V') {
-        } else {
-            hts_log_warning("Unrecognised key: %.2s", key);
-        }
-
-        if (ds_id != DS_CORE) {
-            if (hdr->codecs[ds_id] != NULL) {
-                hts_log_warning("Codec for key %.2s defined more than once",
-                                key);
-                hdr->codecs[ds_id]->free(hdr->codecs[ds_id]);
-            }
-            hdr->codecs[ds_id] = cram_decoder_init(hdr, encoding, cp, size,
-                                                   type, fd->version, &fd->vv);
-            if (!hdr->codecs[ds_id]) {
-                cram_free_compression_header(hdr);
-                return NULL;
-            }
-        }
-
-        cp += size;
-
-        // Fill out cram_map purely for cram_dump to dump out.
-        m = malloc(sizeof(*m));
-        if (!m) {
-            cram_free_compression_header(hdr);
-            return NULL;
-        }
-        m->key = CRAM_KEY(key[0], key[1]);
-        m->encoding = encoding;
-        m->size     = size;
-        m->offset   = offset;
-        m->codec = NULL;
-
-        m->next = hdr->rec_encoding_map[CRAM_MAP(key[0], key[1])];
-        hdr->rec_encoding_map[CRAM_MAP(key[0], key[1])] = m;
-    }
-    if (cp - cp_copy != map_size) {
-        cram_free_compression_header(hdr);
-        return NULL;
-    }
-
-    /* Tag encoding map */
-    map_size  = fd->vv.varint_get32(&cp, endp, &err); cp_copy = cp;
-    map_count = fd->vv.varint_get32(&cp, endp, &err);
-    for (i = 0; i < map_count; i++) {
-        int32_t encoding = E_NULL;
-        int32_t size = 0;
-        cram_map *m = malloc(sizeof(*m)); // FIXME: use pooled_alloc
-        uint8_t key[3];
-
-        if (!m || endp - cp < 6) {
-            free(m);
-            cram_free_compression_header(hdr);
-            return NULL;
-        }
-
-        m->key = fd->vv.varint_get32(&cp, endp, &err);
-        key[0] = m->key>>16;
-        key[1] = m->key>>8;
-        key[2] = m->key;
-        encoding = fd->vv.varint_get32(&cp, endp, &err);
-        size     = fd->vv.varint_get32(&cp, endp, &err);
-
-        m->encoding = encoding;
-        m->size     = size;
-        m->offset   = cp - (char *)b->data;
-        if (size < 0 || endp - cp < size ||
-            !(m->codec = cram_decoder_init(hdr, encoding, cp, size,
-                                           E_BYTE_ARRAY_BLOCK, fd->version, &fd->vv))) {
-            cram_free_compression_header(hdr);
-            free(m);
-            return NULL;
-        }
-
-        cp += size;
-
-        m->next = hdr->tag_encoding_map[CRAM_MAP(key[0],key[1])];
-        hdr->tag_encoding_map[CRAM_MAP(key[0],key[1])] = m;
-    }
-    if (err || cp - cp_copy != map_size) {
-        cram_free_compression_header(hdr);
-        return NULL;
-    }
-
-    return hdr;
-}
-
-/*
- * Note we also need to scan through the record encoding map to
- * see which data series share the same block, either external or
- * CORE. For example if we need the BF data series but MQ and CF
- * are also encoded in the same block then we need to add those in
- * as a dependency in order to correctly decode BF.
- *
- * Returns 0 on success
- *        -1 on failure
- */
-int cram_dependent_data_series(cram_fd *fd,
-                               cram_block_compression_hdr *hdr,
-                               cram_slice *s) {
-    int *block_used;
-    int core_used = 0;
-    int i;
-    static int i_to_id[] = {
-        DS_BF, DS_AP, DS_FP, DS_RL, DS_DL, DS_NF, DS_BA, DS_QS,
-        DS_FC, DS_FN, DS_BS, DS_IN, DS_RG, DS_MQ, DS_TL, DS_RN,
-        DS_NS, DS_NP, DS_TS, DS_MF, DS_CF, DS_RI, DS_RS, DS_PD,
-        DS_HC, DS_SC, DS_BB, DS_QQ,
-    };
-    uint32_t orig_ds;
-
-    /*
-     * Set the data_series bit field based on fd->required_fields
-     * contents.
-     */
-    if (fd->required_fields && fd->required_fields != INT_MAX) {
-        s->data_series = 0;
-
-        if (fd->required_fields & SAM_QNAME)
-            s->data_series |= CRAM_RN;
-
-        if (fd->required_fields & SAM_FLAG)
-            s->data_series |= CRAM_BF;
-
-        if (fd->required_fields & SAM_RNAME)
-            s->data_series |= CRAM_RI | CRAM_BF;
-
-        if (fd->required_fields & SAM_POS)
-            s->data_series |= CRAM_AP | CRAM_BF;
-
-        if (fd->required_fields & SAM_MAPQ)
-            s->data_series |= CRAM_MQ;
-
-        if (fd->required_fields & SAM_CIGAR)
-            s->data_series |= CRAM_CIGAR;
-
-        if (fd->required_fields & SAM_RNEXT)
-            s->data_series |= CRAM_CF | CRAM_NF | CRAM_RI | CRAM_NS |CRAM_BF;
-
-        if (fd->required_fields & SAM_PNEXT)
-            s->data_series |= CRAM_CF | CRAM_NF | CRAM_AP | CRAM_NP | CRAM_BF;
-
-        if (fd->required_fields & SAM_TLEN)
-            s->data_series |= CRAM_CF | CRAM_NF | CRAM_AP | CRAM_TS |
-                CRAM_BF | CRAM_MF | CRAM_RI | CRAM_CIGAR;
-
-        if (fd->required_fields & SAM_SEQ)
-            s->data_series |= CRAM_SEQ;
-
-        if (!(fd->required_fields & SAM_AUX))
-            // No easy way to get MD/NM without other tags at present
-            s->decode_md = 0;
-
-        if (fd->required_fields & SAM_QUAL)
-            s->data_series |= CRAM_QUAL;
-
-        if (fd->required_fields & SAM_AUX)
-            s->data_series |= CRAM_RG | CRAM_TL | CRAM_aux;
-
-        if (fd->required_fields & SAM_RGAUX)
-            s->data_series |= CRAM_RG | CRAM_BF;
-
-        // Always uncompress CORE block
-        if (cram_uncompress_block(s->block[0]))
-            return -1;
-    } else {
-        s->data_series = CRAM_ALL;
-
-        for (i = 0; i < s->hdr->num_blocks; i++) {
-            if (cram_uncompress_block(s->block[i]))
-                return -1;
-        }
-
-        return 0;
-    }
-
-    block_used = calloc(s->hdr->num_blocks+1, sizeof(int));
-    if (!block_used)
-        return -1;
-
-    do {
-        /*
-         * Also set data_series based on code prerequisites. Eg if we need
-         * CRAM_QS then we also need to know CRAM_RL so we know how long it
-         * is, or if we need FC/FP then we also need FN (number of features).
-         *
-         * It's not reciprocal though. We may be needing to decode FN
-         * but have no need to decode FC, FP and cigar ops.
-         */
-        if (s->data_series & CRAM_RS)    s->data_series |= CRAM_FC|CRAM_FP;
-        if (s->data_series & CRAM_PD)    s->data_series |= CRAM_FC|CRAM_FP;
-        if (s->data_series & CRAM_HC)    s->data_series |= CRAM_FC|CRAM_FP;
-        if (s->data_series & CRAM_QS)    s->data_series |= CRAM_FC|CRAM_FP;
-        if (s->data_series & CRAM_IN)    s->data_series |= CRAM_FC|CRAM_FP;
-        if (s->data_series & CRAM_SC)    s->data_series |= CRAM_FC|CRAM_FP;
-        if (s->data_series & CRAM_BS)    s->data_series |= CRAM_FC|CRAM_FP;
-        if (s->data_series & CRAM_DL)    s->data_series |= CRAM_FC|CRAM_FP;
-        if (s->data_series & CRAM_BA)    s->data_series |= CRAM_FC|CRAM_FP;
-        if (s->data_series & CRAM_BB)    s->data_series |= CRAM_FC|CRAM_FP;
-        if (s->data_series & CRAM_QQ)    s->data_series |= CRAM_FC|CRAM_FP;
-
-        // cram_decode_seq() needs seq[] array
-        if (s->data_series & (CRAM_SEQ|CRAM_CIGAR)) s->data_series |= CRAM_RL;
-
-        if (s->data_series & CRAM_FP)    s->data_series |= CRAM_FC;
-        if (s->data_series & CRAM_FC)    s->data_series |= CRAM_FN;
-        if (s->data_series & CRAM_aux)   s->data_series |= CRAM_TL;
-        if (s->data_series & CRAM_MF)    s->data_series |= CRAM_CF;
-        if (s->data_series & CRAM_MQ)    s->data_series |= CRAM_BF;
-        if (s->data_series & CRAM_BS)    s->data_series |= CRAM_RI;
-        if (s->data_series & (CRAM_MF |CRAM_NS |CRAM_NP |CRAM_TS |CRAM_NF))
-            s->data_series |= CRAM_CF;
-        if (!hdr->read_names_included && s->data_series & CRAM_RN)
-            s->data_series |= CRAM_CF | CRAM_NF;
-        if (s->data_series & (CRAM_BA | CRAM_QS | CRAM_BB | CRAM_QQ))
-            s->data_series |= CRAM_BF | CRAM_CF | CRAM_RL;
-
-        orig_ds = s->data_series;
-
-        // Find which blocks are in use.
-        for (i = 0; i < sizeof(i_to_id)/sizeof(*i_to_id); i++) {
-            int bnum1, bnum2, j;
-            cram_codec *c = hdr->codecs[i_to_id[i]];
-
-            if (!(s->data_series & (1<<i)))
-                continue;
-
-            if (!c)
-                continue;
-
-            bnum1 = cram_codec_to_id(c, &bnum2);
-
-            for (;;) {
-                switch (bnum1) {
-                case -2:
-                    break;
-
-                case -1:
-                    core_used = 1;
-                    break;
-
-                default:
-                    for (j = 0; j < s->hdr->num_blocks; j++) {
-                        if (s->block[j]->content_type == EXTERNAL &&
-                            s->block[j]->content_id == bnum1) {
-                            block_used[j] = 1;
-                            if (cram_uncompress_block(s->block[j])) {
-                                free(block_used);
-                                return -1;
-                            }
-                        }
-                    }
-                    break;
-                }
-
-                if (bnum2 == -2 || bnum1 == bnum2)
-                    break;
-
-                bnum1 = bnum2; // 2nd pass
-            }
-        }
-
-        // Tags too
-        if ((fd->required_fields & SAM_AUX) ||
-            (s->data_series & CRAM_aux)) {
-            for (i = 0; i < CRAM_MAP_HASH; i++) {
-                int bnum1, bnum2, j;
-                cram_map *m = hdr->tag_encoding_map[i];
-
-                while (m) {
-                    cram_codec *c = m->codec;
-                    if (!c) {
-                        m = m->next;
-                        continue;
-                    }
-
-                    bnum1 = cram_codec_to_id(c, &bnum2);
-
-                    for (;;) {
-                        switch (bnum1) {
-                        case -2:
-                            break;
-
-                        case -1:
-                            core_used = 1;
-                            break;
-
-                        default:
-                            for (j = 0; j < s->hdr->num_blocks; j++) {
-                                if (s->block[j]->content_type == EXTERNAL &&
-                                    s->block[j]->content_id == bnum1) {
-                                    block_used[j] = 1;
-                                    if (cram_uncompress_block(s->block[j])) {
-                                        free(block_used);
-                                        return -1;
-                                    }
-                                }
-                            }
-                            break;
-                        }
-
-                        if (bnum2 == -2 || bnum1 == bnum2)
-                            break;
-
-                        bnum1 = bnum2; // 2nd pass
-                    }
-
-                    m = m->next;
-                }
-            }
-        }
-
-        // We now know which blocks are in used, so repeat and find
-        // which other data series need to be added.
-        for (i = 0; i < sizeof(i_to_id)/sizeof(*i_to_id); i++) {
-            int bnum1, bnum2, j;
-            cram_codec *c = hdr->codecs[i_to_id[i]];
-
-            if (!c)
-                continue;
-
-            bnum1 = cram_codec_to_id(c, &bnum2);
-
-            for (;;) {
-                switch (bnum1) {
-                case -2:
-                    break;
-
-                case -1:
-                    if (core_used) {
-                        //printf(" + data series %08x:\n", 1<<i);
-                        s->data_series |= 1<<i;
-                    }
-                    break;
-
-                default:
-                    for (j = 0; j < s->hdr->num_blocks; j++) {
-                        if (s->block[j]->content_type == EXTERNAL &&
-                            s->block[j]->content_id == bnum1) {
-                            if (block_used[j]) {
-                                //printf(" + data series %08x:\n", 1<<i);
-                                s->data_series |= 1<<i;
-                            }
-                        }
-                    }
-                    break;
-                }
-
-                if (bnum2 == -2 || bnum1 == bnum2)
-                    break;
-
-                bnum1 = bnum2; // 2nd pass
-            }
-        }
-
-        // Tags too
-        for (i = 0; i < CRAM_MAP_HASH; i++) {
-            int bnum1, bnum2, j;
-            cram_map *m = hdr->tag_encoding_map[i];
-
-            while (m) {
-                cram_codec *c = m->codec;
-                if (!c) {
-                    m = m->next;
-                    continue;
-                }
-
-                bnum1 = cram_codec_to_id(c, &bnum2);
-
-                for (;;) {
-                    switch (bnum1) {
-                    case -2:
-                        break;
-
-                    case -1:
-                        //printf(" + data series %08x:\n", CRAM_aux);
-                        s->data_series |= CRAM_aux;
-                        break;
-
-                    default:
-                        for (j = 0; j < s->hdr->num_blocks; j++) {
-                            if (s->block[j]->content_type == EXTERNAL &&
-                                s->block[j]->content_id == bnum1) {
-                                if (block_used[j]) {
-                                    //printf(" + data series %08x:\n",
-                                    //       CRAM_aux);
-                                    s->data_series |= CRAM_aux;
-                                }
-                            }
-                        }
-                        break;
-                    }
-
-                    if (bnum2 == -2 || bnum1 == bnum2)
-                        break;
-
-                    bnum1 = bnum2; // 2nd pass
-                }
-
-                m = m->next;
-            }
-        }
-    } while (orig_ds != s->data_series);
-
-    free(block_used);
-    return 0;
-}
-
-/*
- * Checks whether an external block is used solely by a single data series.
- * Returns the codec type if so (EXTERNAL, BYTE_ARRAY_LEN, BYTE_ARRAY_STOP)
- *         or 0 if not (E_NULL).
- */
-static int cram_ds_unique(cram_block_compression_hdr *hdr, cram_codec *c,
-                          int id) {
-    int i, n_id = 0;
-    enum cram_encoding e_type = 0;
-
-    for (i = 0; i < DS_END; i++) {
-        cram_codec *c;
-        int bnum1, bnum2, old_n_id;
-
-        if (!(c = hdr->codecs[i]))
-            continue;
-
-        bnum1 = cram_codec_to_id(c, &bnum2);
-
-        old_n_id = n_id;
-        if (bnum1 == id) {
-            n_id++;
-            e_type = c->codec;
-        }
-        if (bnum2 == id) {
-            n_id++;
-            e_type = c->codec;
-        }
-
-        if (n_id == old_n_id+2)
-            n_id--; // len/val in same place counts once only.
-    }
-
-    return n_id == 1 ? e_type : 0;
-}
-
-/*
- * Attempts to estimate the size of some blocks so we can preallocate them
- * before decoding.  Although decoding will automatically grow the blocks,
- * it is typically more efficient to preallocate.
- */
-void cram_decode_estimate_sizes(cram_block_compression_hdr *hdr, cram_slice *s,
-                                int *qual_size, int *name_size,
-                                int *q_id) {
-    int bnum1, bnum2;
-    cram_codec *cd;
-
-    *qual_size = 0;
-    *name_size = 0;
-
-    /* Qual */
-    cd = hdr->codecs[DS_QS];
-    if (cd == NULL) return;
-    bnum1 = cram_codec_to_id(cd, &bnum2);
-    if (bnum1 < 0 && bnum2 >= 0) bnum1 = bnum2;
-    if (cram_ds_unique(hdr, cd, bnum1)) {
-        cram_block *b = cram_get_block_by_id(s, bnum1);
-        if (b) *qual_size = b->uncomp_size;
-        if (q_id && cd->codec == E_EXTERNAL)
-            *q_id = bnum1;
-    }
-
-    /* Name */
-    cd = hdr->codecs[DS_RN];
-    if (cd == NULL) return;
-    bnum1 = cram_codec_to_id(cd, &bnum2);
-    if (bnum1 < 0 && bnum2 >= 0) bnum1 = bnum2;
-    if (cram_ds_unique(hdr, cd, bnum1)) {
-        cram_block *b = cram_get_block_by_id(s, bnum1);
-        if (b) *name_size = b->uncomp_size;
-    }
-}
-
-
-/* ----------------------------------------------------------------------
- * CRAM slices
- */
-
-/*
- * Decodes a CRAM (un)mapped slice header block.
- * Returns slice header ptr on success
- *         NULL on failure
- */
-cram_block_slice_hdr *cram_decode_slice_header(cram_fd *fd, cram_block *b) {
-    cram_block_slice_hdr *hdr;
-    unsigned char *cp;
-    unsigned char *cp_end;
-    int i, err = 0;
-
-    if (b->method != RAW) {
-        /* Spec. says slice header should be RAW, but we can future-proof
-           by trying to decode it if it isn't. */
-        if (cram_uncompress_block(b) < 0)
-            return NULL;
-    }
-    cp =  (unsigned char *)BLOCK_DATA(b);
-    cp_end = cp + b->uncomp_size;
-
-    if (b->content_type != MAPPED_SLICE &&
-        b->content_type != UNMAPPED_SLICE)
-        return NULL;
-
-    if (!(hdr  = calloc(1, sizeof(*hdr))))
-        return NULL;
-
-    hdr->content_type = b->content_type;
-
-    if (b->content_type == MAPPED_SLICE) {
-        hdr->ref_seq_id = fd->vv.varint_get32s((char **)&cp, (char *)cp_end, &err);
-        if (CRAM_MAJOR_VERS(fd->version) >= 4) {
-            hdr->ref_seq_start = fd->vv.varint_get64((char **)&cp, (char *)cp_end, &err);
-            hdr->ref_seq_span  = fd->vv.varint_get64((char **)&cp, (char *)cp_end, &err);
-        } else {
-            hdr->ref_seq_start = fd->vv.varint_get32((char **)&cp, (char *)cp_end, &err);
-            hdr->ref_seq_span  = fd->vv.varint_get32((char **)&cp, (char *)cp_end, &err);
-        }
-        if (hdr->ref_seq_start < 0 || hdr->ref_seq_span < 0) {
-            free(hdr);
-            hts_log_error("Negative values not permitted for header "
-                          "sequence start or span fields");
-            return NULL;
-        }
-    }
-    hdr->num_records = fd->vv.varint_get32((char **)&cp, (char *) cp_end, &err);
-    hdr->record_counter = 0;
-    if (CRAM_MAJOR_VERS(fd->version) == 2) {
-        hdr->record_counter = fd->vv.varint_get32((char **)&cp, (char *)cp_end, &err);
-    } else if (CRAM_MAJOR_VERS(fd->version) >= 3) {
-        hdr->record_counter = fd->vv.varint_get64((char **)&cp, (char *)cp_end, &err);
-    }
-    hdr->num_blocks      = fd->vv.varint_get32((char **)&cp, (char *)cp_end, &err);
-    hdr->num_content_ids = fd->vv.varint_get32((char **)&cp, (char *)cp_end, &err);
-    if (hdr->num_content_ids < 1 ||
-        hdr->num_content_ids >= SIZE_MAX / sizeof(int32_t)) {
-        /* Slice must have at least one data block,
-           and malloc'd size shouldn't wrap. */
-        free(hdr);
-        return NULL;
-    }
-    hdr->block_content_ids = malloc(hdr->num_content_ids * sizeof(int32_t));
-    if (!hdr->block_content_ids) {
-        free(hdr);
-        return NULL;
-    }
-
-    for (i = 0; i < hdr->num_content_ids; i++)
-        hdr->block_content_ids[i] = fd->vv.varint_get32((char **)&cp,
-                                                         (char *)cp_end,
-                                                         &err);
-    if (err) {
-        free(hdr->block_content_ids);
-        free(hdr);
-        return NULL;
-    }
-
-    if (b->content_type == MAPPED_SLICE)
-        hdr->ref_base_id = fd->vv.varint_get32((char **)&cp, (char *) cp_end, &err);
-
-    if (CRAM_MAJOR_VERS(fd->version) != 1) {
-        if (cp_end - cp < 16) {
-            free(hdr->block_content_ids);
-            free(hdr);
-            return NULL;
-        }
-        memcpy(hdr->md5, cp, 16);
-    } else {
-        memset(hdr->md5, 0, 16);
-    }
-
-    if (!err)
-        return hdr;
-
-    free(hdr->block_content_ids);
-    free(hdr);
-    return NULL;
-}
-
-
-#if 0
-/* Returns the number of bits set in val; it the highest bit used */
-static int nbits(int v) {
-    static const int MultiplyDeBruijnBitPosition[32] = {
-        1, 10, 2, 11, 14, 22, 3, 30, 12, 15, 17, 19, 23, 26, 4, 31,
-        9, 13, 21, 29, 16, 18, 25, 8, 20, 28, 24, 7, 27, 6, 5, 32
-    };
-
-    v |= v >> 1; // first up to set all bits 1 after the first 1 */
-    v |= v >> 2;
-    v |= v >> 4;
-    v |= v >> 8;
-    v |= v >> 16;
-
-    // DeBruijn magic to find top bit
-    return MultiplyDeBruijnBitPosition[(uint32_t)(v * 0x07C4ACDDU) >> 27];
-}
-#endif
-
-#if 0
-static int sort_freqs(const void *vp1, const void *vp2) {
-    const int i1 = *(const int *)vp1;
-    const int i2 = *(const int *)vp2;
-    return i1-i2;
-}
-#endif
-
-/* ----------------------------------------------------------------------
- * Primary CRAM sequence decoder
- */
-
-static inline int add_md_char(cram_slice *s, int decode_md, char c, int32_t *md_dist) {
-    if (decode_md) {
-        BLOCK_APPEND_UINT(s->aux_blk, *md_dist);
-        BLOCK_APPEND_CHAR(s->aux_blk, c);
-        *md_dist = 0;
-    }
-    return 0;
-
- block_err:
-    return -1;
-}
-
-/*
- * Internal part of cram_decode_slice().
- * Generates the sequence, quality and cigar components.
- */
-static int cram_decode_seq(cram_fd *fd, cram_container *c, cram_slice *s,
-                           cram_block *blk, cram_record *cr, sam_hdr_t *sh,
-                           int cf, char *seq, char *qual,
-                           int has_MD, int has_NM) {
-    int prev_pos = 0, f, r = 0, out_sz = 1;
-    int seq_pos = 1;
-    int cig_len = 0;
-    int64_t ref_pos = cr->apos;
-    int32_t fn, i32;
-    enum cigar_op cig_op = BAM_CMATCH;
-    uint32_t *cigar = s->cigar;
-    uint32_t ncigar = s->ncigar;
-    uint32_t cigar_alloc = s->cigar_alloc;
-    uint32_t nm = 0;
-    int32_t md_dist = 0;
-    int orig_aux = 0;
-    // CRAM <  4.0 decode_md is off/on
-    // CRAM >= 4.0 decode_md is auto/on (auto=on if MD* present, off otherwise)
-    int do_md = CRAM_MAJOR_VERS(fd->version) >= 4
-        ? (s->decode_md > 0)
-        : (s->decode_md != 0);
-    int decode_md = s->ref && cr->ref_id >= 0 && ((do_md && !has_MD) || has_MD < 0);
-    int decode_nm = s->ref && cr->ref_id >= 0 && ((do_md && !has_NM) || has_NM < 0);
-    uint32_t ds = s->data_series;
-    sam_hrecs_t *bfd = sh->hrecs;
-
-    if ((ds & CRAM_QS) && !(cf & CRAM_FLAG_PRESERVE_QUAL_SCORES)) {
-        memset(qual, 255, cr->len);
-    }
-
-    if (cr->cram_flags & CRAM_FLAG_NO_SEQ)
-        decode_md = decode_nm = 0;
-
-    if (decode_md) {
-        orig_aux = BLOCK_SIZE(s->aux_blk);
-        if (has_MD == 0)
-            BLOCK_APPEND(s->aux_blk, "MDZ", 3);
-    }
-
-    if (ds & CRAM_FN) {
-        if (!c->comp_hdr->codecs[DS_FN]) return -1;
-        r |= c->comp_hdr->codecs[DS_FN]->decode(s,c->comp_hdr->codecs[DS_FN],
-                                                blk, (char *)&fn, &out_sz);
-        if (r) return r;
-    } else {
-        fn = 0;
-    }
-
-    ref_pos--; // count from 0
-    cr->cigar = ncigar;
-
-    if (!(ds & (CRAM_FC | CRAM_FP)))
-        goto skip_cigar;
-
-    for (f = 0; f < fn; f++) {
-        int32_t pos = 0;
-        char op;
-
-        if (ncigar+2 >= cigar_alloc) {
-            cigar_alloc = cigar_alloc ? cigar_alloc*2 : 1024;
-            if (!(cigar = realloc(s->cigar, cigar_alloc * sizeof(*cigar))))
-                return -1;
-            s->cigar = cigar;
-        }
-
-        if (ds & CRAM_FC) {
-            if (!c->comp_hdr->codecs[DS_FC]) return -1;
-            r |= c->comp_hdr->codecs[DS_FC]->decode(s,
-                                                    c->comp_hdr->codecs[DS_FC],
-                                                    blk,
-                                                    &op,  &out_sz);
-            if (r) return r;
-        }
-
-        if (!(ds & CRAM_FP))
-            continue;
-
-        if (!c->comp_hdr->codecs[DS_FP]) return -1;
-        r |= c->comp_hdr->codecs[DS_FP]->decode(s,
-                                                c->comp_hdr->codecs[DS_FP],
-                                                blk,
-                                                (char *)&pos, &out_sz);
-        if (r) return r;
-        pos += prev_pos;
-
-        if (pos <= 0) {
-            hts_log_error("Feature position %d before start of read", pos);
-            return -1;
-        }
-
-        if (pos > seq_pos) {
-            if (pos > cr->len+1)
-                return -1;
-
-            if (s->ref && cr->ref_id >= 0) {
-                if (ref_pos + pos - seq_pos > bfd->ref[cr->ref_id].len) {
-                    static int whinged = 0;
-                    int rlen;
-                    if (!whinged)
-                        hts_log_warning("Ref pos outside of ref sequence boundary");
-                    whinged = 1;
-                    rlen = bfd->ref[cr->ref_id].len - ref_pos;
-                    // May miss MD/NM cases where both seq/ref are N, but this is a
-                    // malformed cram file anyway.
-                    if (rlen > 0) {
-                        if (ref_pos + rlen > s->ref_end)
-                            goto beyond_slice;
-
-                        memcpy(&seq[seq_pos-1],
-                               &s->ref[ref_pos - s->ref_start +1], rlen);
-                        if ((pos - seq_pos) - rlen > 0)
-                            memset(&seq[seq_pos-1+rlen], 'N',
-                                   (pos - seq_pos) - rlen);
-                    } else {
-                        memset(&seq[seq_pos-1], 'N', cr->len - seq_pos + 1);
-                    }
-                    if (md_dist >= 0)
-                        md_dist += pos - seq_pos;
-                } else {
-                    // 'N' in both ref and seq is also mismatch for NM/MD
-                    if (ref_pos + pos-seq_pos > s->ref_end)
-                        goto beyond_slice;
-                    if (decode_md || decode_nm) {
-                        int i;
-                        for (i = 0; i < pos - seq_pos; i++) {
-                            // FIXME: not N, but nt16 lookup == 15?
-                            char base = s->ref[ref_pos - s->ref_start + 1 + i];
-                            if (base == 'N') {
-                                if (add_md_char(s, decode_md,
-                                                s->ref[ref_pos - s->ref_start + 1 + i],
-                                                &md_dist) < 0)
-                                    return -1;
-                                nm++;
-                            } else {
-                                md_dist++;
-                            }
-                            seq[seq_pos-1+i] = base;
-                        }
-                    } else {
-                        memcpy(&seq[seq_pos-1], &s->ref[ref_pos - s->ref_start +1],
-                               pos - seq_pos);
-                    }
-                }
-            }
-#ifdef USE_X
-            if (cig_len && cig_op != BAM_CBASE_MATCH) {
-                cigar[ncigar++] = (cig_len<<4) + cig_op;
-                cig_len = 0;
-            }
-            cig_op = BAM_CBASE_MATCH;
-#else
-            if (cig_len && cig_op != BAM_CMATCH) {
-                cigar[ncigar++] = (cig_len<<4) + cig_op;
-                cig_len = 0;
-            }
-            cig_op = BAM_CMATCH;
-#endif
-            cig_len += pos - seq_pos;
-            ref_pos += pos - seq_pos;
-            seq_pos = pos;
-        }
-
-        prev_pos = pos;
-
-        if (!(ds & CRAM_FC))
-            goto skip_cigar;
-
-        switch(op) {
-        case 'S': { // soft clip: IN
-            int32_t out_sz2 = 1;
-            int have_sc = 0;
-
-            if (cig_len) {
-                cigar[ncigar++] = (cig_len<<4) + cig_op;
-                cig_len = 0;
-            }
-            switch (CRAM_MAJOR_VERS(fd->version)) {
-            case 1:
-                if (ds & CRAM_IN) {
-                    r |= c->comp_hdr->codecs[DS_IN]
-                        ? c->comp_hdr->codecs[DS_IN]
-                                     ->decode(s, c->comp_hdr->codecs[DS_IN],
-                                              blk,
-                                              cr->len ? &seq[pos-1] : NULL,
-                                              &out_sz2)
-                        : (seq[pos-1] = 'N', out_sz2 = 1, 0);
-                    have_sc = 1;
-                }
-                break;
-            case 2:
-            default:
-                if (ds & CRAM_SC) {
-                    r |= c->comp_hdr->codecs[DS_SC]
-                        ? c->comp_hdr->codecs[DS_SC]
-                                     ->decode(s, c->comp_hdr->codecs[DS_SC],
-                                              blk,
-                                              cr->len ? &seq[pos-1] : NULL,
-                                              &out_sz2)
-                        : (seq[pos-1] = 'N', out_sz2 = 1, 0);
-                    have_sc = 1;
-                }
-                break;
-
-                //default:
-                //    r |= c->comp_hdr->codecs[DS_BB]
-                //        ? c->comp_hdr->codecs[DS_BB]
-                //                     ->decode(s, c->comp_hdr->codecs[DS_BB],
-                //                              blk, &seq[pos-1], &out_sz2)
-                //        : (seq[pos-1] = 'N', out_sz2 = 1, 0);
-            }
-            if (have_sc) {
-                if (r) return r;
-                cigar[ncigar++] = (out_sz2<<4) + BAM_CSOFT_CLIP;
-                cig_op = BAM_CSOFT_CLIP;
-                seq_pos += out_sz2;
-            }
-            break;
-        }
-
-        case 'X': { // Substitution; BS
-            unsigned char base;
-#ifdef USE_X
-            if (cig_len && cig_op != BAM_CBASE_MISMATCH) {
-                cigar[ncigar++] = (cig_len<<4) + cig_op;
-                cig_len = 0;
-            }
-            if (ds & CRAM_BS) {
-                if (!c->comp_hdr->codecs[DS_BS]) return -1;
-                r |= c->comp_hdr->codecs[DS_BS]
-                                ->decode(s, c->comp_hdr->codecs[DS_BS], blk,
-                                         (char *)&base, &out_sz);
-                if (pos-1 < cr->len)
-                    seq[pos-1] = 'N'; // FIXME look up BS=base value
-            }
-            cig_op = BAM_CBASE_MISMATCH;
-#else
-            int ref_base;
-            if (cig_len && cig_op != BAM_CMATCH) {
-                cigar[ncigar++] = (cig_len<<4) + cig_op;
-                cig_len = 0;
-            }
-            if (ds & CRAM_BS) {
-                if (!c->comp_hdr->codecs[DS_BS]) return -1;
-                r |= c->comp_hdr->codecs[DS_BS]
-                                ->decode(s, c->comp_hdr->codecs[DS_BS], blk,
-                                         (char *)&base, &out_sz);
-                if (r) return -1;
-                if (cr->ref_id < 0 || ref_pos >= bfd->ref[cr->ref_id].len || !s->ref) {
-                    if (pos-1 < cr->len)
-                        seq[pos-1] = c->comp_hdr->
-                            substitution_matrix[fd->L1['N']][base];
-                    if (decode_md || decode_nm) {
-                        if (md_dist >= 0 && decode_md)
-                            BLOCK_APPEND_UINT(s->aux_blk, md_dist);
-                        md_dist = -1;
-                        nm--;
-                    }
-                } else {
-                    unsigned char ref_call = ref_pos < s->ref_end
-                        ? (uc)s->ref[ref_pos - s->ref_start +1]
-                        : 'N';
-                    ref_base = fd->L1[ref_call];
-                    if (pos-1 < cr->len)
-                        seq[pos-1] = c->comp_hdr->
-                            substitution_matrix[ref_base][base];
-                    if (add_md_char(s, decode_md, ref_call, &md_dist) < 0)
-                        return -1;
-                }
-            }
-            cig_op = BAM_CMATCH;
-#endif
-            nm++;
-            cig_len++;
-            seq_pos++;
-            ref_pos++;
-            break;
-        }
-
-        case 'D': { // Deletion; DL
-            if (cig_len && cig_op != BAM_CDEL) {
-                cigar[ncigar++] = (cig_len<<4) + cig_op;
-                cig_len = 0;
-            }
-            if (ds & CRAM_DL) {
-                if (!c->comp_hdr->codecs[DS_DL]) return -1;
-                r |= c->comp_hdr->codecs[DS_DL]
-                                ->decode(s, c->comp_hdr->codecs[DS_DL], blk,
-                                         (char *)&i32, &out_sz);
-                if (r) return r;
-                if (decode_md || decode_nm) {
-                    if (ref_pos + i32 > s->ref_end)
-                        goto beyond_slice;
-                    if (md_dist >= 0 && decode_md)
-                        BLOCK_APPEND_UINT(s->aux_blk, md_dist);
-                    if (ref_pos + i32 <= bfd->ref[cr->ref_id].len) {
-                        if (decode_md) {
-                            BLOCK_APPEND_CHAR(s->aux_blk, '^');
-                            BLOCK_APPEND(s->aux_blk,
-                                         &s->ref[ref_pos - s->ref_start +1],
-                                         i32);
-                            md_dist = 0;
-                        }
-                        nm += i32;
-                    } else {
-                        uint32_t dlen;
-                        if (bfd->ref[cr->ref_id].len >= ref_pos) {
-                            if (decode_md) {
-                                BLOCK_APPEND_CHAR(s->aux_blk, '^');
-                                BLOCK_APPEND(s->aux_blk,
-                                             &s->ref[ref_pos - s->ref_start+1],
-                                             bfd->ref[cr->ref_id].len-ref_pos);
-                                BLOCK_APPEND_UINT(s->aux_blk, 0);
-                            }
-                            dlen = i32 - (bfd->ref[cr->ref_id].len - ref_pos);
-                            nm += i32 - dlen;
-                        } else {
-                            dlen = i32;
-                        }
-
-                        md_dist = -1;
-                    }
-                }
-                cig_op = BAM_CDEL;
-                cig_len += i32;
-                ref_pos += i32;
-                //printf("  %d: DL = %d (ret %d)\n", f, i32, r);
-            }
-            break;
-        }
-
-        case 'I': { // Insertion (several bases); IN
-            int32_t out_sz2 = 1;
-
-            if (cig_len && cig_op != BAM_CINS) {
-                cigar[ncigar++] = (cig_len<<4) + cig_op;
-                cig_len = 0;
-            }
-
-            if (ds & CRAM_IN) {
-                if (!c->comp_hdr->codecs[DS_IN]) return -1;
-                r |= c->comp_hdr->codecs[DS_IN]
-                                ->decode(s, c->comp_hdr->codecs[DS_IN], blk,
-                                         cr->len ? &seq[pos-1] : NULL,
-                                         &out_sz2);
-                if (r) return r;
-                cig_op = BAM_CINS;
-                cig_len += out_sz2;
-                seq_pos += out_sz2;
-                nm      += out_sz2;
-                //printf("  %d: IN(I) = %.*s (ret %d, out_sz %d)\n", f, out_sz2, dat, r, out_sz2);
-            }
-            break;
-        }
-
-        case 'i': { // Insertion (single base); BA
-            if (cig_len && cig_op != BAM_CINS) {
-                cigar[ncigar++] = (cig_len<<4) + cig_op;
-                cig_len = 0;
-            }
-            if (ds & CRAM_BA) {
-                if (!c->comp_hdr->codecs[DS_BA]) return -1;
-                r |= c->comp_hdr->codecs[DS_BA]
-                                ->decode(s, c->comp_hdr->codecs[DS_BA], blk,
-                                         cr->len ? &seq[pos-1] : NULL,
-                                         &out_sz);
-                if (r) return r;
-            }
-            cig_op = BAM_CINS;
-            cig_len++;
-            seq_pos++;
-            nm++;
-            break;
-        }
-
-        case 'b': { // Several bases
-            int32_t len = 1;
-
-            if (cig_len && cig_op != BAM_CMATCH) {
-                cigar[ncigar++] = (cig_len<<4) + cig_op;
-                cig_len = 0;
-            }
-
-            if (ds & CRAM_BB) {
-                if (!c->comp_hdr->codecs[DS_BB]) return -1;
-                r |= c->comp_hdr->codecs[DS_BB]
-                    ->decode(s, c->comp_hdr->codecs[DS_BB], blk,
-                             cr->len ? &seq[pos-1] : NULL,
-                             &len);
-                if (r) return r;
-
-                if (decode_md || decode_nm) {
-                    int x;
-                    if (md_dist >= 0 && decode_md)
-                        BLOCK_APPEND_UINT(s->aux_blk, md_dist);
-
-                    for (x = 0; x < len; x++) {
-                        if (x && decode_md)
-                            BLOCK_APPEND_UINT(s->aux_blk, 0);
-                        if (ref_pos+x >= bfd->ref[cr->ref_id].len || !s->ref) {
-                            md_dist = -1;
-                            break;
-                        } else {
-                            if (decode_md) {
-                                if (ref_pos + x > s->ref_end)
-                                    goto beyond_slice;
-                                char r = s->ref[ref_pos+x-s->ref_start +1];
-                                BLOCK_APPEND_CHAR(s->aux_blk, r);
-                            }
-                        }
-                    }
-
-                    nm += x;
-                    md_dist = 0;
-                }
-            }
-
-            cig_op = BAM_CMATCH;
-
-            cig_len+=len;
-            seq_pos+=len;
-            ref_pos+=len;
-            //prev_pos+=len;
-            break;
-        }
-
-        case 'q': { // Several quality values
-            int32_t len = 1;
-
-            if (cig_len && cig_op != BAM_CMATCH) {
-                cigar[ncigar++] = (cig_len<<4) + cig_op;
-                cig_len = 0;
-            }
-
-            if (ds & CRAM_QQ) {
-                if (!c->comp_hdr->codecs[DS_QQ]) return -1;
-                if ((ds & CRAM_QS) && !(cf & CRAM_FLAG_PRESERVE_QUAL_SCORES)
-                    && (unsigned char)*qual == 255)
-                    memset(qual, 30, cr->len); // ?
-                r |= c->comp_hdr->codecs[DS_QQ]
-                    ->decode(s, c->comp_hdr->codecs[DS_QQ], blk,
-                             (char *)&qual[pos-1], &len);
-                if (r) return r;
-            }
-
-            cig_op = BAM_CMATCH;
-
-            //prev_pos+=len;
-            break;
-        }
-
-        case 'B': { // Read base; BA, QS
-#ifdef USE_X
-            if (cig_len && cig_op != BAM_CBASE_MISMATCH) {
-                cigar[ncigar++] = (cig_len<<4) + cig_op;
-                cig_len = 0;
-            }
-#else
-            if (cig_len && cig_op != BAM_CMATCH) {
-                cigar[ncigar++] = (cig_len<<4) + cig_op;
-                cig_len = 0;
-            }
-#endif
-            if (ds & CRAM_BA) {
-                if (!c->comp_hdr->codecs[DS_BA]) return -1;
-                r |= c->comp_hdr->codecs[DS_BA]
-                                ->decode(s, c->comp_hdr->codecs[DS_BA], blk,
-                                         cr->len ? &seq[pos-1] : NULL,
-                                         &out_sz);
-
-                if (decode_md || decode_nm) {
-                    if (md_dist >= 0 && decode_md)
-                        BLOCK_APPEND_UINT(s->aux_blk, md_dist);
-                    if (ref_pos >= bfd->ref[cr->ref_id].len || !s->ref) {
-                        md_dist = -1;
-                    } else {
-                        if (decode_md) {
-                            if (ref_pos > s->ref_end)
-                                goto beyond_slice;
-                            BLOCK_APPEND_CHAR(s->aux_blk,
-                                              s->ref[ref_pos-s->ref_start +1]);
-                        }
-                        nm++;
-                        md_dist = 0;
-                    }
-                }
-            }
-            if (ds & CRAM_QS) {
-                if (!c->comp_hdr->codecs[DS_QS]) return -1;
-                if (!(cf & CRAM_FLAG_PRESERVE_QUAL_SCORES)
-                    && (unsigned char)*qual == 255)
-                    memset(qual, 30, cr->len); // ASCII ?.  Same as htsjdk
-                r |= c->comp_hdr->codecs[DS_QS]
-                                ->decode(s, c->comp_hdr->codecs[DS_QS], blk,
-                                         (char *)&qual[pos-1], &out_sz);
-            }
-#ifdef USE_X
-            cig_op = BAM_CBASE_MISMATCH;
-#else
-            cig_op = BAM_CMATCH;
-#endif
-            cig_len++;
-            seq_pos++;
-            ref_pos++;
-            //printf("  %d: BA/QS(B) = %c/%d (ret %d)\n", f, i32, qc, r);
-            break;
-        }
-
-        case 'Q': { // Quality score; QS
-            if (ds & CRAM_QS) {
-                if (!c->comp_hdr->codecs[DS_QS]) return -1;
-                if (!(cf & CRAM_FLAG_PRESERVE_QUAL_SCORES) &&
-                    (unsigned char)*qual == 255)
-                    memset(qual, 30, cr->len); // ?
-                r |= c->comp_hdr->codecs[DS_QS]
-                                ->decode(s, c->comp_hdr->codecs[DS_QS], blk,
-                                         (char *)&qual[pos-1], &out_sz);
-                //printf("  %d: QS = %d (ret %d)\n", f, qc, r);
-            }
-            break;
-        }
-
-        case 'H': { // hard clip; HC
-            if (cig_len && cig_op != BAM_CHARD_CLIP) {
-                cigar[ncigar++] = (cig_len<<4) + cig_op;
-                cig_len = 0;
-            }
-            if (ds & CRAM_HC) {
-                if (!c->comp_hdr->codecs[DS_HC]) return -1;
-                r |= c->comp_hdr->codecs[DS_HC]
-                                ->decode(s, c->comp_hdr->codecs[DS_HC], blk,
-                                         (char *)&i32, &out_sz);
-                if (r) return r;
-                cig_op = BAM_CHARD_CLIP;
-                cig_len += i32;
-            }
-            break;
-        }
-
-        case 'P': { // padding; PD
-            if (cig_len && cig_op != BAM_CPAD) {
-                cigar[ncigar++] = (cig_len<<4) + cig_op;
-                cig_len = 0;
-            }
-            if (ds & CRAM_PD) {
-                if (!c->comp_hdr->codecs[DS_PD]) return -1;
-                r |= c->comp_hdr->codecs[DS_PD]
-                                ->decode(s, c->comp_hdr->codecs[DS_PD], blk,
-                                         (char *)&i32, &out_sz);
-                if (r) return r;
-                cig_op = BAM_CPAD;
-                cig_len += i32;
-            }
-            break;
-        }
-
-        case 'N': { // Ref skip; RS
-            if (cig_len && cig_op != BAM_CREF_SKIP) {
-                cigar[ncigar++] = (cig_len<<4) + cig_op;
-                cig_len = 0;
-            }
-            if (ds & CRAM_RS) {
-                if (!c->comp_hdr->codecs[DS_RS]) return -1;
-                r |= c->comp_hdr->codecs[DS_RS]
-                                ->decode(s, c->comp_hdr->codecs[DS_RS], blk,
-                                         (char *)&i32, &out_sz);
-                if (r) return r;
-                cig_op = BAM_CREF_SKIP;
-                cig_len += i32;
-                ref_pos += i32;
-            }
-            break;
-        }
-
-        default:
-            hts_log_error("Unknown feature code '%c'", op);
-            return -1;
-        }
-    }
-
-    if (!(ds & CRAM_FC))
-        goto skip_cigar;
-
-    /* An implicit match op for any unaccounted for bases */
-    if ((ds & CRAM_FN) && cr->len >= seq_pos) {
-        if (s->ref && cr->ref_id >= 0) {
-            if (ref_pos + cr->len - seq_pos + 1 > bfd->ref[cr->ref_id].len) {
-                static int whinged = 0;
-                int rlen;
-                if (!whinged)
-                    hts_log_warning("Ref pos outside of ref sequence boundary");
-                whinged = 1;
-                rlen = bfd->ref[cr->ref_id].len - ref_pos;
-                // May miss MD/NM cases where both seq/ref are N, but this is a
-                // malformed cram file anyway.
-                if (rlen > 0) {
-                    if (seq_pos-1 + rlen < cr->len)
-                        memcpy(&seq[seq_pos-1],
-                               &s->ref[ref_pos - s->ref_start +1], rlen);
-                    if ((cr->len - seq_pos + 1) - rlen > 0)
-                        memset(&seq[seq_pos-1+rlen], 'N',
-                               (cr->len - seq_pos + 1) - rlen);
-                } else {
-                    if (cr->len - seq_pos + 1 > 0)
-                        memset(&seq[seq_pos-1], 'N', cr->len - seq_pos + 1);
-                }
-                if (md_dist >= 0)
-                    md_dist += cr->len - seq_pos + 1;
-            } else {
-                if (cr->len - seq_pos + 1 > 0) {
-                    if (ref_pos + cr->len-seq_pos +1 > s->ref_end)
-                        goto beyond_slice;
-                    if (decode_md || decode_nm) {
-                        int i, j = ref_pos - s->ref_start + 1;
-                        // FIXME: Update this to match spec once we're also
-                        // ready to update samtools calmd. (N vs any ambig)
-                        if (memchr(&s->ref[j], 'N', cr->len - (seq_pos-1))) {
-                            for (i = seq_pos-1, j -= i; i < cr->len; i++) {
-                                char base = s->ref[j+i];
-                                if (base == 'N') {
-                                    if (add_md_char(s, decode_md, 'N', &md_dist) < 0)
-                                        return -1;
-                                    nm++;
-                                } else {
-                                    md_dist++;
-                                }
-                                seq[i] = base;
-                            }
-                        } else {
-                            // faster than above code
-                            memcpy(&seq[seq_pos-1], &s->ref[j], cr->len - (seq_pos-1));
-                            md_dist += cr->len - (seq_pos-1);
-                        }
-                    } else {
-                        memcpy(&seq[seq_pos-1], &s->ref[ref_pos - s->ref_start +1],
-                               cr->len - (seq_pos-1));
-                    }
-                }
-                ref_pos += cr->len - seq_pos + 1;
-            }
-        } else if (cr->ref_id >= 0) {
-            // So alignment end can be computed even when not decoding sequence
-            ref_pos += cr->len - seq_pos + 1;
-        }
-
-        if (ncigar+1 >= cigar_alloc) {
-            cigar_alloc = cigar_alloc ? cigar_alloc*2 : 1024;
-            if (!(cigar = realloc(s->cigar, cigar_alloc * sizeof(*cigar))))
-                return -1;
-            s->cigar = cigar;
-        }
-#ifdef USE_X
-        if (cig_len && cig_op != BAM_CBASE_MATCH) {
-            cigar[ncigar++] = (cig_len<<4) + cig_op;
-            cig_len = 0;
-        }
-        cig_op = BAM_CBASE_MATCH;
-#else
-        if (cig_len && cig_op != BAM_CMATCH) {
-            cigar[ncigar++] = (cig_len<<4) + cig_op;
-            cig_len = 0;
-        }
-        cig_op = BAM_CMATCH;
-#endif
-        cig_len += cr->len - seq_pos+1;
-    }
-
- skip_cigar:
-
-    if ((ds & CRAM_FN) && decode_md) {
-        if (md_dist >= 0)
-            BLOCK_APPEND_UINT(s->aux_blk, md_dist);
-    }
-
-    if (cig_len) {
-        if (ncigar >= cigar_alloc) {
-            cigar_alloc = cigar_alloc ? cigar_alloc*2 : 1024;
-            if (!(cigar = realloc(s->cigar, cigar_alloc * sizeof(*cigar))))
-                return -1;
-            s->cigar = cigar;
-        }
-
-        cigar[ncigar++] = (cig_len<<4) + cig_op;
-    }
-
-    cr->ncigar = ncigar - cr->cigar;
-    cr->aend = ref_pos;
-
-    //printf("2: %.*s %d .. %d\n", cr->name_len, DSTRING_STR(name_ds) + cr->name, cr->apos, ref_pos);
-
-    if (ds & CRAM_MQ) {
-        if (!c->comp_hdr->codecs[DS_MQ]) return -1;
-        r |= c->comp_hdr->codecs[DS_MQ]
-                        ->decode(s, c->comp_hdr->codecs[DS_MQ], blk,
-                                 (char *)&cr->mqual, &out_sz);
-    } else {
-        cr->mqual = 40;
-    }
-
-    if ((ds & CRAM_QS) && (cf & CRAM_FLAG_PRESERVE_QUAL_SCORES)) {
-        int32_t out_sz2 = cr->len;
-
-        if (!c->comp_hdr->codecs[DS_QS]) return -1;
-        r |= c->comp_hdr->codecs[DS_QS]
-            ->decode(s, c->comp_hdr->codecs[DS_QS], blk,
-                     qual, &out_sz2);
-    }
-
-    s->cigar = cigar;
-    s->cigar_alloc = cigar_alloc;
-    s->ncigar = ncigar;
-
-    if (cr->cram_flags & CRAM_FLAG_NO_SEQ)
-        cr->len = 0;
-
-    if (decode_md) {
-        BLOCK_APPEND_CHAR(s->aux_blk, '\0'); // null terminate MD:Z:
-        size_t sz = BLOCK_SIZE(s->aux_blk) - orig_aux;
-        if (has_MD < 0) {
-            // has_MD < 0; already have MDZ allocated in aux at -has_MD,
-            // but wrote MD to end of aux (at orig_aux).
-            // We need some memmoves to shuffle it around.
-            char tmp_MD_[1024], *tmp_MD = tmp_MD_;
-            unsigned char *orig_aux_p = BLOCK_DATA(s->aux_blk) + orig_aux;
-            if (sz > 1024) {
-                tmp_MD = malloc(sz);
-                if (!tmp_MD)
-                    return -1;
-            }
-            memcpy(tmp_MD, orig_aux_p, sz);
-            memmove(&BLOCK_DATA(s->aux_blk)[-has_MD] + sz,
-                    &BLOCK_DATA(s->aux_blk)[-has_MD],
-                    orig_aux_p - &BLOCK_DATA(s->aux_blk)[-has_MD]);
-            memcpy(&BLOCK_DATA(s->aux_blk)[-has_MD], tmp_MD, sz);
-            if (tmp_MD != tmp_MD_)
-                free(tmp_MD);
-
-            if (-has_NM > -has_MD)
-                // we inserted before NM, so move it up a bit
-                has_NM -= sz;
-        }
-        // else has_MD == 0 and we've already appended MD to the end.
-
-        cr->aux_size += sz;
-    }
-
-    if (decode_nm) {
-        if (has_NM == 0) {
-            char buf[7];
-            size_t buf_size;
-            buf[0] = 'N'; buf[1] = 'M';
-            if (nm <= UINT8_MAX) {
-                buf_size = 4;
-                buf[2] = 'C';
-                buf[3] = (nm>> 0) & 0xff;
-            } else if (nm <= UINT16_MAX) {
-                buf_size = 5;
-                buf[2] = 'S';
-                buf[3] = (nm>> 0) & 0xff;
-                buf[4] = (nm>> 8) & 0xff;
-            } else {
-                buf_size = 7;
-                buf[2] = 'I';
-                buf[3] = (nm>> 0) & 0xff;
-                buf[4] = (nm>> 8) & 0xff;
-                buf[5] = (nm>>16) & 0xff;
-                buf[6] = (nm>>24) & 0xff;
-            }
-            BLOCK_APPEND(s->aux_blk, buf, buf_size);
-            cr->aux_size += buf_size;
-        } else {
-            // Preallocated space for NM at -has_NM into aux block
-            unsigned char *buf = BLOCK_DATA(s->aux_blk) + -has_NM;
-            buf[0] = (nm>> 0) & 0xff;
-            buf[1] = (nm>> 8) & 0xff;
-            buf[2] = (nm>>16) & 0xff;
-            buf[3] = (nm>>24) & 0xff;
-        }
-    }
-
-    return r;
-
- beyond_slice:
-    // Cramtools can create CRAMs that have sequence features outside the
-    // stated range of the container & slice reference extents (start + span).
-    // We have to check for these in many places, but for brevity have the
-    // error reporting in only one.
-    hts_log_error("CRAM CIGAR extends beyond slice reference extents");
-    return -1;
-
- block_err:
-    return -1;
-}
-
-/*
- * Quick and simple hash lookup for cram_map arrays
- */
-static cram_map *map_find(cram_map **map, unsigned char *key, int id) {
-    cram_map *m;
-
-    m = map[CRAM_MAP(key[0],key[1])];
-    while (m && m->key != id)
-        m= m->next;
-
-    return m;
-}
-
-//#define map_find(M,K,I) M[CRAM_MAP(K[0],K[1])];while (m && m->key != I);m= m->next
-
-
-static int cram_decode_aux_1_0(cram_container *c, cram_slice *s,
-                               cram_block *blk, cram_record *cr) {
-    int i, r = 0, out_sz = 1;
-    unsigned char ntags;
-
-    if (!c->comp_hdr->codecs[DS_TC]) return -1;
-    r |= c->comp_hdr->codecs[DS_TC]->decode(s, c->comp_hdr->codecs[DS_TC], blk,
-                                            (char *)&ntags, &out_sz);
-    cr->ntags = ntags;
-
-    //printf("TC=%d\n", cr->ntags);
-    cr->aux_size = 0;
-    cr->aux = BLOCK_SIZE(s->aux_blk);
-
-    for (i = 0; i < cr->ntags; i++) {
-        int32_t id, out_sz = 1;
-        unsigned char tag_data[3];
-        cram_map *m;
-
-        //printf("Tag %d/%d\n", i+1, cr->ntags);
-        if (!c->comp_hdr->codecs[DS_TN]) return -1;
-        r |= c->comp_hdr->codecs[DS_TN]->decode(s, c->comp_hdr->codecs[DS_TN],
-                                                blk, (char *)&id, &out_sz);
-        if (out_sz == 3) {
-            // Tag name stored as 3 chars instead of an int?
-            memcpy(tag_data, &id, 3);
-        } else {
-            tag_data[0] = (id>>16) & 0xff;
-            tag_data[1] = (id>>8)  & 0xff;
-            tag_data[2] = id       & 0xff;
-        }
-
-        m = map_find(c->comp_hdr->tag_encoding_map, tag_data, id);
-        if (!m)
-            return -1;
-        BLOCK_APPEND(s->aux_blk, (char *)tag_data, 3);
-
-        if (!m->codec) return -1;
-        r |= m->codec->decode(s, m->codec, blk, (char *)s->aux_blk, &out_sz);
-
-        cr->aux_size += out_sz + 3;
-    }
-
-    return r;
-
- block_err:
-    return -1;
-}
-
-// has_MD and has_NM are filled out with 0 for none present,
-// 1 for present and verbatim, and -pos for present as placeholder
-// (MD*, NM*) to be generated and filled out at offset +pos.
-static int cram_decode_aux(cram_fd *fd,
-                           cram_container *c, cram_slice *s,
-                           cram_block *blk, cram_record *cr,
-                           int *has_MD, int *has_NM) {
-    int i, r = 0, out_sz = 1;
-    int32_t TL = 0;
-    unsigned char *TN;
-    uint32_t ds = s->data_series;
-
-    if (!(ds & (CRAM_TL|CRAM_aux))) {
-        cr->aux = 0;
-        cr->aux_size = 0;
-        return 0;
-    }
-
-    if (!c->comp_hdr->codecs[DS_TL]) return -1;
-    r |= c->comp_hdr->codecs[DS_TL]->decode(s, c->comp_hdr->codecs[DS_TL], blk,
-                                            (char *)&TL, &out_sz);
-    if (r || TL < 0 || TL >= c->comp_hdr->nTL)
-        return -1;
-
-    TN = c->comp_hdr->TL[TL];
-    cr->ntags = strlen((char *)TN)/3; // optimise to remove strlen
-
-    //printf("TC=%d\n", cr->ntags);
-    cr->aux_size = 0;
-    cr->aux = BLOCK_SIZE(s->aux_blk);
-
-    if (!(ds & CRAM_aux))
-        return 0;
-
-    for (i = 0; i < cr->ntags; i++) {
-        int32_t id, out_sz = 1;
-        unsigned char tag_data[7];
-        cram_map *m;
-
-        if (TN[0] == 'M' && TN[1] == 'D' && has_MD)
-            *has_MD = (BLOCK_SIZE(s->aux_blk)+3) * (TN[2] == '*' ? -1 : 1);
-        if (TN[0] == 'N' && TN[1] == 'M' && has_NM)
-            *has_NM = (BLOCK_SIZE(s->aux_blk)+3) * (TN[2] == '*' ? -1 : 1);;
-
-        //printf("Tag %d/%d\n", i+1, cr->ntags);
-        tag_data[0] = TN[0];
-        tag_data[1] = TN[1];
-        tag_data[2] = TN[2];
-        id = (tag_data[0]<<16) | (tag_data[1]<<8) | tag_data[2];
-
-        if (CRAM_MAJOR_VERS(fd->version) >= 4 && TN[2] == '*') {
-            // Place holder, fill out contents later.
-            int tag_data_size;
-            if (TN[0] == 'N' && TN[1] == 'M') {
-                // Use a fixed size, so we can allocate room for it now.
-                memcpy(&tag_data[2], "I\0\0\0\0", 5);
-                tag_data_size = 7;
-            } else if (TN[0] == 'R' && TN[1] == 'G') {
-                // RG is variable size, but known already.  Insert now
-                TN += 3;
-                // Equiv to fd->header->hrecs->rg[cr->rg], but this is the
-                // new header API equivalent.
-                const char *rg = sam_hdr_line_name(fd->header, "RG", cr->rg);
-                if (!rg)
-                    continue;
-
-                size_t rg_len = strlen(rg);
-                tag_data[2] = 'Z';
-                BLOCK_APPEND(s->aux_blk, (char *)tag_data, 3);
-                BLOCK_APPEND(s->aux_blk, rg, rg_len);
-                BLOCK_APPEND_CHAR(s->aux_blk, '\0');
-                cr->aux_size += 3 + rg_len + 1;
-                cr->rg = -1; // prevents auto-add later
-                continue;
-            } else {
-                // Unknown size.  We'll insert MD into stream later.
-                tag_data[2] = 'Z';
-                tag_data_size = 3;
-            }
-            BLOCK_APPEND(s->aux_blk, (char *)tag_data, tag_data_size);
-            cr->aux_size += tag_data_size;
-            TN += 3;
-        } else {
-            TN += 3;
-            m = map_find(c->comp_hdr->tag_encoding_map, tag_data, id);
-            if (!m)
-                return -1;
-            BLOCK_APPEND(s->aux_blk, (char *)tag_data, 3);
-
-            if (!m->codec) return -1;
-            r |= m->codec->decode(s, m->codec, blk, (char *)s->aux_blk, &out_sz);
-            if (r) break;
-            cr->aux_size += out_sz + 3;
-        }
-    }
-
-    return r;
-
- block_err:
-    return -1;
-}
-
-/* Resolve mate pair cross-references between recs within this slice */
-static int cram_decode_slice_xref(cram_slice *s, int required_fields) {
-    int rec;
-
-    if (!(required_fields & (SAM_RNEXT | SAM_PNEXT | SAM_TLEN))) {
-        for (rec = 0; rec < s->hdr->num_records; rec++) {
-            cram_record *cr = &s->crecs[rec];
-
-            cr->tlen = 0;
-            cr->mate_pos = 0;
-            cr->mate_ref_id = -1;
-        }
-
-        return 0;
-    }
-
-    for (rec = 0; rec < s->hdr->num_records; rec++) {
-        cram_record *cr = &s->crecs[rec];
-
-        if (cr->mate_line >= 0) {
-            if (cr->mate_line < s->hdr->num_records) {
-                /*
-                 * On the first read, loop through computing lengths.
-                 * It's not perfect as we have one slice per reference so we
-                 * cannot detect when TLEN should be zero due to seqs that
-                 * map to multiple references.
-                 *
-                 * We also cannot set tlen correct when it spans a slice for
-                 * other reasons. This may make tlen too small. Should we
-                 * fix this by forcing TLEN to be stored verbatim in such cases?
-                 *
-                 * Or do we just admit defeat and output 0 for tlen? It's the
-                 * safe option...
-                 */
-                if (cr->tlen == INT64_MIN) {
-                    int id1 = rec, id2 = rec;
-                    int64_t aleft = cr->apos, aright = cr->aend;
-                    int64_t tlen;
-                    int ref = cr->ref_id;
-
-                    // number of segments starting at the same point.
-                    int left_cnt = 0;
-
-                    do {
-                        if (aleft > s->crecs[id2].apos)
-                            aleft = s->crecs[id2].apos, left_cnt = 1;
-                        else if (aleft == s->crecs[id2].apos)
-                            left_cnt++;
-                        if (aright < s->crecs[id2].aend)
-                            aright = s->crecs[id2].aend;
-                        if (s->crecs[id2].mate_line == -1) {
-                            s->crecs[id2].mate_line = rec;
-                            break;
-                        }
-                        if (s->crecs[id2].mate_line <= id2 ||
-                            s->crecs[id2].mate_line >= s->hdr->num_records)
-                            return -1;
-                        id2 = s->crecs[id2].mate_line;
-
-                        if (s->crecs[id2].ref_id != ref)
-                            ref = -1;
-                    } while (id2 != id1);
-
-                    if (ref != -1) {
-                        tlen = aright - aleft + 1;
-                        id1 = id2 = rec;
-
-                        /*
-                         * When we have two seqs with identical start and
-                         * end coordinates, set +/- tlen based on 1st/last
-                         * bit flags instead, as a tie breaker.
-                         */
-                        if (s->crecs[id2].apos == aleft) {
-                            if (left_cnt == 1 ||
-                                (s->crecs[id2].flags & BAM_FREAD1))
-                                s->crecs[id2].tlen = tlen;
-                            else
-                                s->crecs[id2].tlen = -tlen;
-                        } else {
-                            s->crecs[id2].tlen = -tlen;
-                        }
-
-                        id2 = s->crecs[id2].mate_line;
-                        while (id2 != id1) {
-                            if (s->crecs[id2].apos == aleft) {
-                                if (left_cnt == 1 ||
-                                    (s->crecs[id2].flags & BAM_FREAD1))
-                                    s->crecs[id2].tlen = tlen;
-                                else
-                                    s->crecs[id2].tlen = -tlen;
-                            } else {
-                                s->crecs[id2].tlen = -tlen;
-                            }
-                            id2 = s->crecs[id2].mate_line;
-                        }
-                    } else {
-                        id1 = id2 = rec;
-
-                        s->crecs[id2].tlen = 0;
-                        id2 = s->crecs[id2].mate_line;
-                        while (id2 != id1) {
-                            s->crecs[id2].tlen = 0;
-                            id2 = s->crecs[id2].mate_line;
-                        }
-                    }
-                }
-
-                cr->mate_pos = s->crecs[cr->mate_line].apos;
-                cr->mate_ref_id = s->crecs[cr->mate_line].ref_id;
-
-                // paired
-                cr->flags |= BAM_FPAIRED;
-
-                // set mate unmapped if needed
-                if (s->crecs[cr->mate_line].flags & BAM_FUNMAP) {
-                    cr->flags |= BAM_FMUNMAP;
-                    cr->tlen = 0;
-                }
-                if (cr->flags & BAM_FUNMAP) {
-                    cr->tlen = 0;
-                }
-
-                // set mate reversed if needed
-                if (s->crecs[cr->mate_line].flags & BAM_FREVERSE)
-                    cr->flags |= BAM_FMREVERSE;
-            } else {
-                hts_log_error("Mate line out of bounds: %d vs [0, %d]",
-                              cr->mate_line, s->hdr->num_records-1);
-            }
-
-            /* FIXME: construct read names here too if needed */
-        } else {
-            if (cr->mate_flags & CRAM_M_REVERSE) {
-                cr->flags |= BAM_FPAIRED | BAM_FMREVERSE;
-            }
-            if (cr->mate_flags & CRAM_M_UNMAP) {
-                cr->flags |= BAM_FMUNMAP;
-                //cr->mate_ref_id = -1;
-            }
-            if (!(cr->flags & BAM_FPAIRED))
-                cr->mate_ref_id = -1;
-        }
-
-        if (cr->tlen == INT64_MIN)
-            cr->tlen = 0; // Just incase
-    }
-
-    for (rec = 0; rec < s->hdr->num_records; rec++) {
-        cram_record *cr = &s->crecs[rec];
-        if (cr->explicit_tlen != INT64_MIN)
-            cr->tlen = cr->explicit_tlen;
-    }
-
-    return 0;
-}
-
-static char *md5_print(unsigned char *md5, char *out) {
-    int i;
-    for (i = 0; i < 16; i++) {
-        out[i*2+0] = "0123456789abcdef"[md5[i]>>4];
-        out[i*2+1] = "0123456789abcdef"[md5[i]&15];
-    }
-    out[32] = 0;
-
-    return out;
-}
-
-/*
- * Utility function to decode tlen (ISIZE), as it's called
- * in multiple places.
- *
- * Returns codec return value (0 on success).
- */
-static int cram_decode_tlen(cram_fd *fd, cram_container *c, cram_slice *s,
-                            cram_block *blk, int64_t *tlen) {
-    int out_sz = 1, r = 0;
-
-    if (!c->comp_hdr->codecs[DS_TS]) return -1;
-    if (CRAM_MAJOR_VERS(fd->version) < 4) {
-        int32_t i32;
-        r |= c->comp_hdr->codecs[DS_TS]
-            ->decode(s, c->comp_hdr->codecs[DS_TS], blk,
-                     (char *)&i32, &out_sz);
-        *tlen = i32;
-    } else {
-        r |= c->comp_hdr->codecs[DS_TS]
-            ->decode(s, c->comp_hdr->codecs[DS_TS], blk,
-                     (char *)tlen, &out_sz);
-    }
-    return r;
-}
-
-/*
- * Decode an entire slice from container blocks. Fills out s->crecs[] array.
- * Returns 0 on success
- *        -1 on failure
- */
-int cram_decode_slice(cram_fd *fd, cram_container *c, cram_slice *s,
-                      sam_hdr_t *sh) {
-    cram_block *blk = s->block[0];
-    int32_t bf, ref_id;
-    unsigned char cf;
-    int out_sz, r = 0;
-    int rec;
-    char *seq = NULL, *qual = NULL;
-    int unknown_rg = -1;
-    int embed_ref;
-    char **refs = NULL;
-    uint32_t ds;
-    sam_hrecs_t *bfd = sh->hrecs;
-
-    if (cram_dependent_data_series(fd, c->comp_hdr, s) != 0)
-        return -1;
-
-    ds = s->data_series;
-
-    blk->bit = 7; // MSB first
-
-    // Study the blocks and estimate approx sizes to preallocate.
-    // This looks to speed up decoding by around 8-9%.
-    // We can always shrink back down at the end if we overestimated.
-    // However it's likely that this also saves memory as own growth
-    // factor (*=1.5) is never applied.
-    {
-        int qsize, nsize, q_id;
-        cram_decode_estimate_sizes(c->comp_hdr, s, &qsize, &nsize, &q_id);
-        //fprintf(stderr, "qsize=%d nsize=%d\n", qsize, nsize);
-
-        if (qsize && (ds & CRAM_RL)) BLOCK_RESIZE_EXACT(s->seqs_blk, qsize+1);
-        if (qsize && (ds & CRAM_RL)) BLOCK_RESIZE_EXACT(s->qual_blk, qsize+1);
-        if (nsize && (ds & CRAM_NS)) BLOCK_RESIZE_EXACT(s->name_blk, nsize+1);
-
-        // To do - consider using q_id here to usurp the quality block and
-        // avoid a memcpy during decode.
-        // Specifically when quality is an external block uniquely used by
-        // DS_QS only, then we can set s->qual_blk directly to this
-        // block and save the codec->decode() calls. (Approx 3% cpu saving)
-    }
-
-    /* Look for unknown RG, added as last by Java CRAM? */
-    if (bfd->nrg > 0 &&
-        bfd->rg[bfd->nrg-1].name != NULL &&
-        !strcmp(bfd->rg[bfd->nrg-1].name, "UNKNOWN"))
-        unknown_rg = bfd->nrg-1;
-
-    if (blk->content_type != CORE)
-        return -1;
-
-    if (s->crecs)
-        free(s->crecs);
-    if (!(s->crecs = malloc(s->hdr->num_records * sizeof(*s->crecs))))
-        return -1;
-
-    ref_id = s->hdr->ref_seq_id;
-    if (CRAM_MAJOR_VERS(fd->version) < 4)
-       embed_ref = s->hdr->ref_base_id >= 0 ? 1 : 0;
-    else
-       embed_ref = s->hdr->ref_base_id > 0 ? 1 : 0;
-
-    if (ref_id >= 0) {
-        if (embed_ref) {
-            cram_block *b;
-            if (s->hdr->ref_base_id < 0) {
-                hts_log_error("No reference specified and no embedded reference is available"
-                              " at #%d:%"PRId64"-%"PRId64, ref_id, s->hdr->ref_seq_start,
-                              s->hdr->ref_seq_start + s->hdr->ref_seq_span-1);
-                return -1;
-            }
-            b = cram_get_block_by_id(s, s->hdr->ref_base_id);
-            if (!b)
-                return -1;
-            if (cram_uncompress_block(b) != 0)
-                return -1;
-            s->ref = (char *)BLOCK_DATA(b);
-            s->ref_start = s->hdr->ref_seq_start;
-            s->ref_end   = s->hdr->ref_seq_start + s->hdr->ref_seq_span-1;
-            if (s->hdr->ref_seq_span > b->uncomp_size) {
-                hts_log_error("Embedded reference is too small at #%d:%d-%d",
-                              ref_id, s->ref_start, s->ref_end);
-                return -1;
-            }
-        } else if (!c->comp_hdr->no_ref) {
-            //// Avoid Java cramtools bug by loading entire reference seq
-            //s->ref = cram_get_ref(fd, s->hdr->ref_seq_id, 1, 0);
-            //s->ref_start = 1;
-
-            if (fd->required_fields & SAM_SEQ) {
-                s->ref =
-                cram_get_ref(fd, s->hdr->ref_seq_id,
-                             s->hdr->ref_seq_start,
-                             s->hdr->ref_seq_start + s->hdr->ref_seq_span -1);
-            }
-            s->ref_start = s->hdr->ref_seq_start;
-            s->ref_end   = s->hdr->ref_seq_start + s->hdr->ref_seq_span-1;
-
-            /* Sanity check */
-            if (s->ref_start < 0) {
-                hts_log_warning("Slice starts before base 1"
-                                " at #%d:%"PRId64"-%"PRId64, ref_id, s->hdr->ref_seq_start,
-                                s->hdr->ref_seq_start + s->hdr->ref_seq_span-1);
-                s->ref_start = 0;
-            }
-            pthread_mutex_lock(&fd->ref_lock);
-            pthread_mutex_lock(&fd->refs->lock);
-            if ((fd->required_fields & SAM_SEQ) &&
-                ref_id < fd->refs->nref && fd->refs->ref_id &&
-                s->ref_end > fd->refs->ref_id[ref_id]->length) {
-                s->ref_end = fd->refs->ref_id[ref_id]->length;
-            }
-            pthread_mutex_unlock(&fd->refs->lock);
-            pthread_mutex_unlock(&fd->ref_lock);
-        }
-    }
-
-    if ((fd->required_fields & SAM_SEQ) &&
-        s->ref == NULL && s->hdr->ref_seq_id >= 0 && !c->comp_hdr->no_ref) {
-        hts_log_error("Unable to fetch reference #%d:%"PRId64"-%"PRId64"\n",
-                      ref_id, s->hdr->ref_seq_start,
-                      s->hdr->ref_seq_start + s->hdr->ref_seq_span-1);
-        return -1;
-    }
-
-    if (CRAM_MAJOR_VERS(fd->version) != 1
-        && (fd->required_fields & SAM_SEQ)
-        && s->hdr->ref_seq_id >= 0
-        && !fd->ignore_md5
-        && memcmp(s->hdr->md5, "\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0", 16)) {
-        hts_md5_context *md5;
-        unsigned char digest[16];
-
-        if (s->ref && s->hdr->ref_seq_id >= 0) {
-            int start, len;
-
-            if (s->hdr->ref_seq_start >= s->ref_start) {
-                start = s->hdr->ref_seq_start - s->ref_start;
-            } else {
-                hts_log_warning("Slice starts before base 1 at #%d:%d-%d",
-                                ref_id, s->ref_start, s->ref_end);
-                start = 0;
-            }
-
-            if (s->hdr->ref_seq_span <= s->ref_end - s->ref_start + 1) {
-                len = s->hdr->ref_seq_span;
-            } else {
-                hts_log_warning("Slice ends beyond reference end at #%d:%d-%d",
-                                ref_id, s->ref_start, s->ref_end);
-                len = s->ref_end - s->ref_start + 1;
-            }
-
-            if (!(md5 = hts_md5_init()))
-                return -1;
-            if (start + len > s->ref_end - s->ref_start + 1)
-                len = s->ref_end - s->ref_start + 1 - start;
-            if (len >= 0)
-                hts_md5_update(md5, s->ref + start, len);
-            hts_md5_final(digest, md5);
-            hts_md5_destroy(md5);
-        } else if (!s->ref && s->hdr->ref_base_id >= 0) {
-            cram_block *b = cram_get_block_by_id(s, s->hdr->ref_base_id);
-            if (b) {
-                if (!(md5 = hts_md5_init()))
-                    return -1;
-                hts_md5_update(md5, b->data, b->uncomp_size);
-                hts_md5_final(digest, md5);
-                hts_md5_destroy(md5);
-            }
-        }
-
-        if ((!s->ref && s->hdr->ref_base_id < 0)
-            || memcmp(digest, s->hdr->md5, 16) != 0) {
-            char M[33];
-            hts_log_error("MD5 checksum reference mismatch at #%d:%d-%d",
-                          ref_id, s->ref_start, s->ref_end);
-            hts_log_error("CRAM: %s", md5_print(s->hdr->md5, M));
-            hts_log_error("Ref : %s", md5_print(digest, M));
-            return -1;
-        }
-    }
-
-    if (ref_id == -2) {
-        pthread_mutex_lock(&fd->ref_lock);
-        pthread_mutex_lock(&fd->refs->lock);
-        refs = calloc(fd->refs->nref, sizeof(char *));
-        pthread_mutex_unlock(&fd->refs->lock);
-        pthread_mutex_unlock(&fd->ref_lock);
-        if (!refs)
-            return -1;
-    }
-
-    int last_ref_id = -9; // Arbitrary -ve marker for not-yet-set
-    for (rec = 0; rec < s->hdr->num_records; rec++) {
-        cram_record *cr = &s->crecs[rec];
-        int has_MD, has_NM;
-
-        //fprintf(stderr, "Decode seq %d, %d/%d\n", rec, blk->byte, blk->bit);
-
-        cr->s = s;
-
-        out_sz = 1; /* decode 1 item */
-        if (ds & CRAM_BF) {
-            if (!c->comp_hdr->codecs[DS_BF]) goto block_err;
-            r |= c->comp_hdr->codecs[DS_BF]
-                            ->decode(s, c->comp_hdr->codecs[DS_BF], blk,
-                                     (char *)&bf, &out_sz);
-            if (r || bf < 0 ||
-                bf >= sizeof(fd->bam_flag_swap)/sizeof(*fd->bam_flag_swap))
-                goto block_err;
-            bf = fd->bam_flag_swap[bf];
-            cr->flags = bf;
-        } else {
-            cr->flags = bf = 0x4; // unmapped
-        }
-
-        if (ds & CRAM_CF) {
-            if (CRAM_MAJOR_VERS(fd->version) == 1) {
-                /* CF is byte in 1.0, int32 in 2.0 */
-                if (!c->comp_hdr->codecs[DS_CF]) goto block_err;
-                r |= c->comp_hdr->codecs[DS_CF]
-                                ->decode(s, c->comp_hdr->codecs[DS_CF], blk,
-                                         (char *)&cf, &out_sz);
-                if (r) goto block_err;
-                cr->cram_flags = cf;
-            } else {
-                if (!c->comp_hdr->codecs[DS_CF]) goto block_err;
-                r |= c->comp_hdr->codecs[DS_CF]
-                                ->decode(s, c->comp_hdr->codecs[DS_CF], blk,
-                                         (char *)&cr->cram_flags, &out_sz);
-                if (r) goto block_err;
-                cf = cr->cram_flags;
-            }
-        } else {
-            cf = cr->cram_flags = 0;
-        }
-
-        if (CRAM_MAJOR_VERS(fd->version) != 1 && ref_id == -2) {
-            if (ds & CRAM_RI) {
-                if (!c->comp_hdr->codecs[DS_RI]) goto block_err;
-                r |= c->comp_hdr->codecs[DS_RI]
-                                ->decode(s, c->comp_hdr->codecs[DS_RI], blk,
-                                         (char *)&cr->ref_id, &out_sz);
-                if (r) goto block_err;
-                if ((fd->required_fields & (SAM_SEQ|SAM_TLEN))
-                    && cr->ref_id >= 0
-                    && cr->ref_id != last_ref_id) {
-                    if (!c->comp_hdr->no_ref) {
-                        // Range(fd):  seq >= 0, unmapped -1, unspecified   -2
-                        // Slice(s):   seq >= 0, unmapped -1, multiple refs -2
-                        // Record(cr): seq >= 0, unmapped -1
-                        pthread_mutex_lock(&fd->range_lock);
-                        int need_ref = (fd->range.refid == -2 || cr->ref_id == fd->range.refid);
-                        pthread_mutex_unlock(&fd->range_lock);
-                        if  (need_ref) {
-                            if (!refs[cr->ref_id])
-                                refs[cr->ref_id] = cram_get_ref(fd, cr->ref_id, 1, 0);
-                            if (!(s->ref = refs[cr->ref_id]))
-                                goto block_err;
-                        } else {
-                            // For multi-ref containers, we don't need to fetch all
-                            // refs if we're only querying one.
-                            s->ref = NULL;
-                        }
-
-                        pthread_mutex_lock(&fd->range_lock);
-                        int discard_last_ref = (last_ref_id >= 0 &&
-                                                refs[last_ref_id] &&
-                                                (fd->range.refid == -2 ||
-                                                 last_ref_id == fd->range.refid));
-                        pthread_mutex_unlock(&fd->range_lock);
-                        if (discard_last_ref) {
-                            pthread_mutex_lock(&fd->ref_lock);
-                            discard_last_ref = !fd->unsorted;
-                            pthread_mutex_unlock(&fd->ref_lock);
-                        }
-                        if (discard_last_ref) {
-                            cram_ref_decr(fd->refs, last_ref_id);
-                            refs[last_ref_id] = NULL;
-                        }
-                    }
-                    s->ref_start = 1;
-                    pthread_mutex_lock(&fd->ref_lock);
-                    pthread_mutex_lock(&fd->refs->lock);
-                    s->ref_end = fd->refs->ref_id[cr->ref_id]->length;
-                    pthread_mutex_unlock(&fd->refs->lock);
-                    pthread_mutex_unlock(&fd->ref_lock);
-
-                    last_ref_id = cr->ref_id;
-                }
-            } else {
-                cr->ref_id = -1;
-            }
-        } else {
-            cr->ref_id = ref_id; // Forced constant in CRAM 1.0
-        }
-        if (cr->ref_id < -1 || cr->ref_id >= bfd->nref) {
-            hts_log_error("Requested unknown reference ID %d", cr->ref_id);
-            goto block_err;
-        }
-
-        if (ds & CRAM_RL) {
-            if (!c->comp_hdr->codecs[DS_RL]) goto block_err;
-            r |= c->comp_hdr->codecs[DS_RL]
-                            ->decode(s, c->comp_hdr->codecs[DS_RL], blk,
-                                     (char *)&cr->len, &out_sz);
-            if (r) goto block_err;
-            if (cr->len < 0) {
-                hts_log_error("Read has negative length");
-                goto block_err;
-            }
-        }
-
-        if (ds & CRAM_AP) {
-            if (!c->comp_hdr->codecs[DS_AP]) goto block_err;
-            if (CRAM_MAJOR_VERS(fd->version) >= 4) {
-                r |= c->comp_hdr->codecs[DS_AP]
-                                ->decode(s, c->comp_hdr->codecs[DS_AP], blk,
-                                         (char *)&cr->apos, &out_sz);
-            } else  {
-                int32_t i32;
-                r |= c->comp_hdr->codecs[DS_AP]
-                                ->decode(s, c->comp_hdr->codecs[DS_AP], blk,
-                                         (char *)&i32, &out_sz);
-                cr->apos = i32;
-            }
-            if (r) goto block_err;;
-            if (c->comp_hdr->AP_delta) {
-                if (cr->apos < 0 && c->unsorted == 0) {
-                    // cache locally in c->unsorted so we don't have an
-                    // excessive number of locks
-                    pthread_mutex_lock(&fd->ref_lock);
-                    c->unsorted = fd->unsorted = 1;
-                    pthread_mutex_unlock(&fd->ref_lock);
-                }
-                cr->apos += s->last_apos;
-            }
-            s->last_apos=  cr->apos;
-        } else {
-            cr->apos = c->ref_seq_start;
-        }
-
-        if (ds & CRAM_RG) {
-            if (!c->comp_hdr->codecs[DS_RG]) goto block_err;
-            r |= c->comp_hdr->codecs[DS_RG]
-                           ->decode(s, c->comp_hdr->codecs[DS_RG], blk,
-                                    (char *)&cr->rg, &out_sz);
-            if (r) goto block_err;
-            if (cr->rg == unknown_rg)
-                cr->rg = -1;
-        } else {
-            cr->rg = -1;
-        }
-
-        cr->name_len = 0;
-
-        if (c->comp_hdr->read_names_included) {
-            int32_t out_sz2 = 1;
-
-            // Read directly into name cram_block
-            cr->name = BLOCK_SIZE(s->name_blk);
-            if (ds & CRAM_RN) {
-                if (!c->comp_hdr->codecs[DS_RN]) goto block_err;
-                r |= c->comp_hdr->codecs[DS_RN]
-                                ->decode(s, c->comp_hdr->codecs[DS_RN], blk,
-                                         (char *)s->name_blk, &out_sz2);
-                if (r) goto block_err;
-                cr->name_len = out_sz2;
-            }
-        }
-
-        cr->mate_pos = 0;
-        cr->mate_line = -1;
-        cr->mate_ref_id = -1;
-        cr->explicit_tlen = INT64_MIN;
-        if ((ds & CRAM_CF) && (cf & CRAM_FLAG_DETACHED)) {
-            if (ds & CRAM_MF) {
-                if (CRAM_MAJOR_VERS(fd->version) == 1) {
-                    /* MF is byte in 1.0, int32 in 2.0 */
-                    unsigned char mf;
-                    if (!c->comp_hdr->codecs[DS_MF]) goto block_err;
-                    r |= c->comp_hdr->codecs[DS_MF]
-                                    ->decode(s, c->comp_hdr->codecs[DS_MF],
-                                             blk, (char *)&mf, &out_sz);
-                    if (r) goto block_err;
-                    cr->mate_flags = mf;
-                } else {
-                    if (!c->comp_hdr->codecs[DS_MF]) goto block_err;
-                    r |= c->comp_hdr->codecs[DS_MF]
-                                    ->decode(s, c->comp_hdr->codecs[DS_MF],
-                                             blk,
-                                             (char *)&cr->mate_flags,
-                                             &out_sz);
-                    if (r) goto block_err;
-                }
-            } else {
-                cr->mate_flags = 0;
-            }
-
-            if (!c->comp_hdr->read_names_included) {
-                int32_t out_sz2 = 1;
-
-                // Read directly into name cram_block
-                cr->name = BLOCK_SIZE(s->name_blk);
-                if (ds & CRAM_RN) {
-                    if (!c->comp_hdr->codecs[DS_RN]) goto block_err;
-                    r |= c->comp_hdr->codecs[DS_RN]
-                                    ->decode(s, c->comp_hdr->codecs[DS_RN],
-                                             blk, (char *)s->name_blk,
-                                             &out_sz2);
-                    if (r) goto block_err;
-                    cr->name_len = out_sz2;
-                }
-            }
-
-            if (ds & CRAM_NS) {
-                if (!c->comp_hdr->codecs[DS_NS]) goto block_err;
-                r |= c->comp_hdr->codecs[DS_NS]
-                                ->decode(s, c->comp_hdr->codecs[DS_NS], blk,
-                                         (char *)&cr->mate_ref_id, &out_sz);
-                if (r) goto block_err;
-            }
-
-            // Skip as mate_ref of "*" is legit. It doesn't mean unmapped, just unknown.
-            // if (cr->mate_ref_id == -1 && cr->flags & 0x01) {
-            //     /* Paired, but unmapped */
-            //     cr->flags |= BAM_FMUNMAP;
-            // }
-
-            if (ds & CRAM_NP) {
-                if (!c->comp_hdr->codecs[DS_NP]) goto block_err;;
-                if (CRAM_MAJOR_VERS(fd->version) < 4) {
-                    int32_t i32;
-                    r |= c->comp_hdr->codecs[DS_NP]
-                                    ->decode(s, c->comp_hdr->codecs[DS_NP], blk,
-                                             (char *)&i32, &out_sz);
-                    cr->mate_pos = i32;
-                } else {
-                    r |= c->comp_hdr->codecs[DS_NP]
-                        ->decode(s, c->comp_hdr->codecs[DS_NP], blk,
-                                 (char *)&cr->mate_pos, &out_sz);
-                }
-                if (r) goto block_err;
-            }
-
-            if (ds & CRAM_TS) {
-                if (!c->comp_hdr->codecs[DS_TS]) goto block_err;
-                r = cram_decode_tlen(fd, c, s, blk, &cr->tlen);
-                if (r) goto block_err;
-            } else {
-                cr->tlen = INT64_MIN;
-            }
-        } else if ((ds & CRAM_CF) && (cf & CRAM_FLAG_MATE_DOWNSTREAM)) {
-            // else not detached
-            if (ds & CRAM_NF) {
-                if (!c->comp_hdr->codecs[DS_NF]) goto block_err;
-                r |= c->comp_hdr->codecs[DS_NF]
-                                ->decode(s, c->comp_hdr->codecs[DS_NF], blk,
-                                         (char *)&cr->mate_line, &out_sz);
-                if (r) goto block_err;
-                cr->mate_line += rec + 1;
-
-                //cr->name_len = sprintf(name, "%d", name_id++);
-                //cr->name = DSTRING_LEN(name_ds);
-                //dstring_nappend(name_ds, name, cr->name_len);
-
-                cr->mate_ref_id = -1;
-                cr->tlen = INT64_MIN;
-                cr->mate_pos = 0;
-            } else  {
-                cr->mate_flags = 0;
-                cr->tlen = INT64_MIN;
-            }
-            if ((ds & CRAM_CF) && (cf & CRAM_FLAG_EXPLICIT_TLEN)) {
-                if (ds & CRAM_TS) {
-                    r = cram_decode_tlen(fd, c, s, blk, &cr->explicit_tlen);
-                    if (r) return r;
-                } else {
-                    cr->mate_flags = 0;
-                    cr->tlen = INT64_MIN;
-                }
-            }
-        } else if ((ds & CRAM_CF) && (cf & CRAM_FLAG_EXPLICIT_TLEN)) {
-            if (ds & CRAM_TS) {
-                r = cram_decode_tlen(fd, c, s, blk, &cr->explicit_tlen);
-                if (r) return r;
-            } else {
-                cr->mate_flags = 0;
-                cr->tlen = INT64_MIN;
-            }
-        } else {
-            cr->mate_flags = 0;
-            cr->tlen = INT64_MIN;
-        }
-        /*
-        else if (!name[0]) {
-            //name[0] = '?'; name[1] = 0;
-            //cr->name_len = 1;
-            //cr->name=  DSTRING_LEN(s->name_ds);
-            //dstring_nappend(s->name_ds, "?", 1);
-
-            cr->mate_ref_id = -1;
-            cr->tlen = 0;
-            cr->mate_pos = 0;
-        }
-        */
-
-        /* Auxiliary tags */
-        has_MD = has_NM = 0;
-        if (CRAM_MAJOR_VERS(fd->version) == 1)
-            r |= cram_decode_aux_1_0(c, s, blk, cr);
-        else
-            r |= cram_decode_aux(fd, c, s, blk, cr, &has_MD, &has_NM);
-        if (r) goto block_err;
-
-        /* Fake up dynamic string growth and appending */
-        if (ds & CRAM_RL) {
-            cr->seq = BLOCK_SIZE(s->seqs_blk);
-            BLOCK_GROW(s->seqs_blk, cr->len);
-            seq = (char *)BLOCK_END(s->seqs_blk);
-            BLOCK_SIZE(s->seqs_blk) += cr->len;
-
-            if (!seq)
-                goto block_err;
-
-            cr->qual = BLOCK_SIZE(s->qual_blk);
-            BLOCK_GROW(s->qual_blk, cr->len);
-            qual = (char *)BLOCK_END(s->qual_blk);
-            BLOCK_SIZE(s->qual_blk) += cr->len;
-
-            if (!s->ref)
-                memset(seq, '=', cr->len);
-        }
-
-        if (!(bf & BAM_FUNMAP)) {
-            if ((ds & CRAM_AP) && cr->apos <= 0) {
-                hts_log_error("Read has alignment position %"PRId64
-                              " but no unmapped flag",
-                              cr->apos);
-                goto block_err;
-            }
-            /* Decode sequence and generate CIGAR */
-            if (ds & (CRAM_SEQ | CRAM_MQ)) {
-                r |= cram_decode_seq(fd, c, s, blk, cr, sh, cf, seq, qual,
-                                     has_MD, has_NM);
-                if (r) goto block_err;
-            } else {
-                cr->cigar = 0;
-                cr->ncigar = 0;
-                cr->aend = cr->apos;
-                cr->mqual = 0;
-            }
-        } else {
-            int out_sz2 = cr->len;
-
-            //puts("Unmapped");
-            cr->cigar = 0;
-            cr->ncigar = 0;
-            cr->aend = cr->apos;
-            cr->mqual = 0;
-
-            if (ds & CRAM_BA && cr->len) {
-                if (!c->comp_hdr->codecs[DS_BA]) goto block_err;
-                r |= c->comp_hdr->codecs[DS_BA]
-                                ->decode(s, c->comp_hdr->codecs[DS_BA], blk,
-                                         (char *)seq, &out_sz2);
-                if (r) goto block_err;
-            }
-
-            if ((ds & CRAM_CF) && (cf & CRAM_FLAG_PRESERVE_QUAL_SCORES)) {
-                out_sz2 = cr->len;
-                if (ds & CRAM_QS && cr->len >= 0) {
-                    if (!c->comp_hdr->codecs[DS_QS]) goto block_err;
-                    r |= c->comp_hdr->codecs[DS_QS]
-                                    ->decode(s, c->comp_hdr->codecs[DS_QS],
-                                             blk, qual, &out_sz2);
-                    if (r) goto block_err;
-                }
-            } else {
-                if (ds & CRAM_RL)
-                    memset(qual, 255, cr->len);
-            }
-        }
-
-        if (!c->comp_hdr->qs_seq_orient && (ds & CRAM_QS) && (cr->flags & BAM_FREVERSE)) {
-            int i, j;
-            for (i = 0, j = cr->len-1; i < j; i++, j--) {
-                unsigned char c;
-                c = qual[i];
-                qual[i] = qual[j];
-                qual[j] = c;
-            }
-        }
-    }
-
-    pthread_mutex_lock(&fd->ref_lock);
-    if (refs) {
-        int i;
-        for (i = 0; i < fd->refs->nref; i++) {
-            if (refs[i])
-                cram_ref_decr(fd->refs, i);
-        }
-        free(refs);
-        refs = NULL;
-    } else if (ref_id >= 0 && s->ref != fd->ref_free && !embed_ref) {
-        cram_ref_decr(fd->refs, ref_id);
-    }
-    pthread_mutex_unlock(&fd->ref_lock);
-
-    /* Resolve mate pair cross-references between recs within this slice */
-    r |= cram_decode_slice_xref(s, fd->required_fields);
-
-    // Free the original blocks as we no longer need these.
-    {
-        int i;
-        for (i = 0; i < s->hdr->num_blocks; i++) {
-            cram_block *b = s->block[i];
-            cram_free_block(b);
-            s->block[i] = NULL;
-        }
-    }
-
-    // Also see initial BLOCK_RESIZE_EXACT at top of function.
-    // As we grow blocks we overallocate by up to 50%. So shrink
-    // back to their final sizes here.
-    //
-    //fprintf(stderr, "%d %d // %d %d // %d %d // %d %d\n",
-    //      (int)s->seqs_blk->byte, (int)s->seqs_blk->alloc,
-    //      (int)s->qual_blk->byte, (int)s->qual_blk->alloc,
-    //      (int)s->name_blk->byte, (int)s->name_blk->alloc,
-    //      (int)s->aux_blk->byte,  (int)s->aux_blk->alloc);
-    BLOCK_RESIZE_EXACT(s->seqs_blk, BLOCK_SIZE(s->seqs_blk)+1);
-    BLOCK_RESIZE_EXACT(s->qual_blk, BLOCK_SIZE(s->qual_blk)+1);
-    BLOCK_RESIZE_EXACT(s->name_blk, BLOCK_SIZE(s->name_blk)+1);
-    BLOCK_RESIZE_EXACT(s->aux_blk,  BLOCK_SIZE(s->aux_blk)+1);
-
-    return r;
-
- block_err:
-    if (refs) {
-        int i;
-        pthread_mutex_lock(&fd->ref_lock);
-        for (i = 0; i < fd->refs->nref; i++) {
-            if (refs[i])
-                cram_ref_decr(fd->refs, i);
-        }
-        free(refs);
-        pthread_mutex_unlock(&fd->ref_lock);
-    }
-
-    return -1;
-}
-
-typedef struct {
-    cram_fd *fd;
-    cram_container *c;
-    cram_slice *s;
-    sam_hdr_t *h;
-    int exit_code;
-} cram_decode_job;
-
-void *cram_decode_slice_thread(void *arg) {
-    cram_decode_job *j = (cram_decode_job *)arg;
-
-    j->exit_code = cram_decode_slice(j->fd, j->c, j->s, j->h);
-
-    return j;
-}
-
-/*
- * Spawn a multi-threaded version of cram_decode_slice().
- */
-int cram_decode_slice_mt(cram_fd *fd, cram_container *c, cram_slice *s,
-                         sam_hdr_t *bfd) {
-    cram_decode_job *j;
-    int nonblock;
-
-    if (!fd->pool)
-        return cram_decode_slice(fd, c, s, bfd);
-
-    if (!(j = malloc(sizeof(*j))))
-        return -1;
-
-    j->fd = fd;
-    j->c  = c;
-    j->s  = s;
-    j->h  = bfd;
-
-    nonblock = hts_tpool_process_sz(fd->rqueue) ? 1 : 0;
-
-    int saved_errno = errno;
-    errno = 0;
-    if (-1 == hts_tpool_dispatch2(fd->pool, fd->rqueue, cram_decode_slice_thread,
-                                  j, nonblock)) {
-        /* Would block */
-        if (errno != EAGAIN)
-            return -1;
-        fd->job_pending = j;
-    } else {
-        fd->job_pending = NULL;
-    }
-    errno = saved_errno;
-
-    // flush too
-    return 0;
-}
-
-
-/* ----------------------------------------------------------------------
- * CRAM sequence iterators.
- */
-
-/*
- * Converts a cram in-memory record into a bam in-memory record. We
- * pass a pointer to a bam_seq_t pointer along with the a pointer to
- * the allocated size. These can initially be pointers to NULL and zero.
- *
- * This function will reallocate the bam buffer as required and update
- * (*bam)->alloc accordingly, allowing it to be used within a loop
- * efficiently without needing to allocate new bam objects over and
- * over again.
- *
- * Returns the used size of the bam record on success
- *         -1 on failure.
- */
-static int cram_to_bam(sam_hdr_t *sh, cram_fd *fd, cram_slice *s,
-                       cram_record *cr, int rec, bam_seq_t **bam) {
-    int ret, rg_len;
-    char name_a[1024], *name;
-    int name_len;
-    char *aux;
-    char *seq, *qual;
-    sam_hrecs_t *bfd = sh->hrecs;
-
-    /* Assign names if not explicitly set */
-    if (fd->required_fields & SAM_QNAME) {
-        if (cr->name_len) {
-            name = (char *)BLOCK_DATA(s->name_blk) + cr->name;
-            name_len = cr->name_len;
-        } else {
-            name = name_a;
-            if (cr->mate_line >= 0 && cr->mate_line < s->max_rec &&
-                s->crecs[cr->mate_line].name_len > 0) {
-                // Copy our mate if non-zero.
-                memcpy(name_a, BLOCK_DATA(s->name_blk)+s->crecs[cr->mate_line].name,
-                       s->crecs[cr->mate_line].name_len);
-                name = name_a + s->crecs[cr->mate_line].name_len;
-            } else {
-                // Otherwise generate a name based on prefix
-                name_len = strlen(fd->prefix);
-                memcpy(name, fd->prefix, name_len);
-                name += name_len;
-                *name++ = ':';
-                if (cr->mate_line >= 0 && cr->mate_line < rec) {
-                    name = (char *)append_uint64((unsigned char *)name,
-                                                 s->hdr->record_counter +
-                                                 cr->mate_line + 1);
-                } else {
-                    name = (char *)append_uint64((unsigned char *)name,
-                                                 s->hdr->record_counter +
-                                                 rec + 1);
-                }
-            }
-            name_len = name - name_a;
-            name = name_a;
-        }
-    } else {
-        name = "?";
-        name_len = 1;
-    }
-
-    /* Generate BAM record */
-    if (cr->rg < -1 || cr->rg >= bfd->nrg)
-        return -1;
-    rg_len = (cr->rg != -1) ? bfd->rg[cr->rg].name_len + 4 : 0;
-
-    if (fd->required_fields & (SAM_SEQ | SAM_QUAL)) {
-        if (!BLOCK_DATA(s->seqs_blk))
-            return -1;
-        seq = (char *)BLOCK_DATA(s->seqs_blk) + cr->seq;
-    } else {
-        seq = "*";
-        cr->len = 0;
-    }
-
-    if (fd->required_fields & SAM_QUAL) {
-        if (!BLOCK_DATA(s->qual_blk))
-            return -1;
-        qual = (char *)BLOCK_DATA(s->qual_blk) + cr->qual;
-    } else {
-        qual = NULL;
-    }
-
-    ret = bam_set1(*bam,
-                   name_len, name,
-                   cr->flags, cr->ref_id, cr->apos - 1, cr->mqual,
-                   cr->ncigar, &s->cigar[cr->cigar],
-                   cr->mate_ref_id, cr->mate_pos - 1, cr->tlen,
-                   cr->len, seq, qual,
-                   cr->aux_size + rg_len);
-    if (ret < 0) {
-        return ret;
-    }
-
-    aux = (char *)bam_aux(*bam);
-
-    /* Auxiliary strings */
-    if (cr->aux_size != 0) {
-        memcpy(aux, BLOCK_DATA(s->aux_blk) + cr->aux, cr->aux_size);
-        aux += cr->aux_size;
-        (*bam)->l_data += cr->aux_size;
-    }
-
-    /* RG:Z: */
-    if (rg_len > 0) {
-        *aux++ = 'R'; *aux++ = 'G'; *aux++ = 'Z';
-        int len = bfd->rg[cr->rg].name_len;
-        memcpy(aux, bfd->rg[cr->rg].name, len);
-        aux += len;
-        *aux++ = 0;
-        (*bam)->l_data += rg_len;
-    }
-
-    return (*bam)->l_data;
-}
-
-/*
- * Here be dragons! The multi-threading code in this is crufty beyond belief.
- */
-
-/*
- * Load first container.
- * Called when fd->ctr is NULL>
- *
- * Returns container on success
- *        NULL on failure.
- */
-static cram_container *cram_first_slice(cram_fd *fd) {
-    cram_container *c;
-
-    do {
-        if (fd->ctr)
-            cram_free_container(fd->ctr);
-
-        if (!(c = fd->ctr = cram_read_container(fd)))
-            return NULL;
-        c->curr_slice_mt = c->curr_slice;
-    } while (c->length == 0);
-
-    /*
-     * The first container may be a result of a sub-range query.
-     * In which case it may still not be the optimal starting point
-     * due to skipped containers/slices in the index.
-     */
-    // No need for locks here as we're in the main thread.
-    if (fd->range.refid != -2) {
-        while (c->ref_seq_id != -2 &&
-               (c->ref_seq_id < fd->range.refid ||
-                (fd->range.refid >= 0 && c->ref_seq_id == fd->range.refid
-                 && c->ref_seq_start + c->ref_seq_span-1 < fd->range.start))) {
-            if (0 != cram_seek(fd, c->length, SEEK_CUR))
-                return NULL;
-            cram_free_container(fd->ctr);
-            do {
-                if (!(c = fd->ctr = cram_read_container(fd)))
-                    return NULL;
-            } while (c->length == 0);
-        }
-
-        if (c->ref_seq_id != -2 && c->ref_seq_id != fd->range.refid) {
-            fd->eof = 1;
-            return NULL;
-        }
-    }
-
-    if (!(c->comp_hdr_block = cram_read_block(fd)))
-        return NULL;
-    if (c->comp_hdr_block->content_type != COMPRESSION_HEADER)
-        return NULL;
-
-    c->comp_hdr = cram_decode_compression_header(fd, c->comp_hdr_block);
-    if (!c->comp_hdr)
-        return NULL;
-    if (!c->comp_hdr->AP_delta &&
-        sam_hrecs_sort_order(fd->header->hrecs) != ORDER_COORD) {
-        pthread_mutex_lock(&fd->ref_lock);
-        fd->unsorted = 1;
-        pthread_mutex_unlock(&fd->ref_lock);
-    }
-
-    return c;
-}
-
-static cram_slice *cram_next_slice(cram_fd *fd, cram_container **cp) {
-    cram_container *c_curr;  // container being consumed via cram_get_seq()
-    cram_slice *s_curr = NULL;
-
-    // Populate the first container if unknown.
-    if (!(c_curr = fd->ctr)) {
-        if (!(c_curr = cram_first_slice(fd)))
-            return NULL;
-    }
-
-    // Discard previous slice
-    if ((s_curr = c_curr->slice)) {
-        c_curr->slice = NULL;
-        cram_free_slice(s_curr);
-        s_curr = NULL;
-    }
-
-    // If we've consumed all slices in this container, also discard
-    // the container too.
-    if (c_curr->curr_slice == c_curr->max_slice) {
-        if (fd->ctr == c_curr)
-            fd->ctr = NULL;
-        if (fd->ctr_mt == c_curr)
-            fd->ctr_mt = NULL;
-        cram_free_container(c_curr);
-        c_curr = NULL;
-    }
-
-    if (!fd->ctr_mt)
-        fd->ctr_mt = c_curr;
-
-    // Fetch the next slice (and the container if necessary).
-    //
-    // If single threaded this loop bails out as soon as it finds
-    // a slice in range.  In this case c_next and c_curr end up being
-    // the same thing.
-    //
-    // If multi-threaded, we loop until we have filled out
-    // thread pool input queue.  Here c_next and c_curr *may* differ, as
-    // can fd->ctr and fd->ctr_mt.
-    for (;;) {
-        cram_container *c_next = fd->ctr_mt;
-        cram_slice *s_next = NULL;
-
-        // Next slice; either from the last job we failed to push
-        // to the input queue or via more I/O.
-        if (fd->job_pending) {
-            cram_decode_job *j = (cram_decode_job *)fd->job_pending;
-            c_next = j->c;
-            s_next = j->s;
-            free(fd->job_pending);
-            fd->job_pending = NULL;
-        } else if (!fd->ooc) {
-        empty_container:
-            if (!c_next || c_next->curr_slice_mt == c_next->max_slice) {
-                // new container
-                for(;;) {
-                    if (!(c_next = cram_read_container(fd))) {
-                        if (fd->pool) {
-                            fd->ooc = 1;
-                            break;
-                        }
-
-                        return NULL;
-                    }
-                    c_next->curr_slice_mt = c_next->curr_slice;
-
-                    if (c_next->length != 0)
-                        break;
-
-                    cram_free_container(c_next);
-                }
-                if (fd->ooc)
-                    break;
-
-                /* Skip containers not yet spanning our range */
-                if (fd->range.refid != -2 && c_next->ref_seq_id != -2) {
-                    // ref_id beyond end of range; bail out
-                    if (c_next->ref_seq_id != fd->range.refid) {
-                        cram_free_container(c_next);
-                        fd->ctr_mt = NULL;
-                        fd->ooc = 1;
-                        break;
-                    }
-
-                    // position beyond end of range; bail out
-                    if (c_next->ref_seq_start > fd->range.end) {
-                        cram_free_container(c_next);
-                        fd->ctr_mt = NULL;
-                        fd->ooc = 1;
-                        break;
-                    }
-
-                    // before start of range; skip to next container
-                    if (c_next->ref_seq_start + c_next->ref_seq_span-1 <
-                        fd->range.start) {
-                        c_next->curr_slice_mt = c_next->max_slice;
-                        cram_seek(fd, c_next->length, SEEK_CUR);
-                        cram_free_container(c_next);
-                        c_next = NULL;
-                        continue;
-                    }
-                }
-
-                // Container is valid range, so remember it for restarting
-                // this function.
-                fd->ctr_mt = c_next;
-
-                if (!(c_next->comp_hdr_block = cram_read_block(fd)))
-                    return NULL;
-                if (c_next->comp_hdr_block->content_type != COMPRESSION_HEADER)
-                    return NULL;
-
-                c_next->comp_hdr =
-                    cram_decode_compression_header(fd, c_next->comp_hdr_block);
-                if (!c_next->comp_hdr)
-                    return NULL;
-
-                if (!c_next->comp_hdr->AP_delta &&
-                    sam_hrecs_sort_order(fd->header->hrecs) != ORDER_COORD) {
-                    pthread_mutex_lock(&fd->ref_lock);
-                    fd->unsorted = 1;
-                    pthread_mutex_unlock(&fd->ref_lock);
-                }
-            }
-
-            if (c_next->num_records == 0) {
-                if (fd->ctr == c_next)
-                    fd->ctr = NULL;
-                if (c_curr == c_next)
-                    c_curr = NULL;
-                if (fd->ctr_mt == c_next)
-                    fd->ctr_mt = NULL;
-                cram_free_container(c_next);
-                c_next = NULL;
-                goto empty_container;
-            }
-
-            if (!(s_next = c_next->slice = cram_read_slice(fd)))
-                return NULL;
-
-            s_next->slice_num = ++c_next->curr_slice_mt;
-            s_next->curr_rec = 0;
-            s_next->max_rec = s_next->hdr->num_records;
-
-            s_next->last_apos = s_next->hdr->ref_seq_start;
-
-            // We know the container overlaps our range, but with multi-slice
-            // containers we may have slices that do not.  Skip these also.
-            if (fd->range.refid != -2 && s_next->hdr->ref_seq_id != -2) {
-                // ref_id beyond end of range; bail out
-                if (s_next->hdr->ref_seq_id != fd->range.refid) {
-                    fd->ooc = 1;
-                    cram_free_slice(s_next);
-                    c_next->slice = s_next = NULL;
-                    break;
-                }
-
-                // position beyond end of range; bail out
-                if (s_next->hdr->ref_seq_start > fd->range.end) {
-                    fd->ooc = 1;
-                    cram_free_slice(s_next);
-                    c_next->slice = s_next = NULL;
-                    break;
-                }
-
-                // before start of range; skip to next slice
-                if (s_next->hdr->ref_seq_start + s_next->hdr->ref_seq_span-1 <
-                    fd->range.start) {
-                    cram_free_slice(s_next);
-                    c_next->slice = s_next = NULL;
-                    continue;
-                }
-            }
-        } // end: if (!fd->ooc)
-
-        if (!c_next || !s_next)
-            break;
-
-        // Decode the slice, either right now (non-threaded) or by pushing
-        // it to the a decode queue (threaded).
-        if (cram_decode_slice_mt(fd, c_next, s_next, fd->header) != 0) {
-            hts_log_error("Failure to decode slice");
-            cram_free_slice(s_next);
-            c_next->slice = NULL;
-            return NULL;
-        }
-
-        // No thread pool, so don't loop again
-        if (!fd->pool) {
-            c_curr = c_next;
-            s_curr = s_next;
-            break;
-        }
-
-        // With thread pool, but we have a job pending so our decode queue
-        // is full.
-        if (fd->job_pending)
-            break;
-
-        // Otherwise we're threaded with room in the decode input queue, so
-        // keep reading slices for decode.
-        // Push it a bit far, to qsize in queue rather than pending arrival,
-        // as cram tends to be a bit bursty in decode timings.
-        if (hts_tpool_process_len(fd->rqueue) >
-            hts_tpool_process_qsize(fd->rqueue))
-            break;
-    } // end of for(;;)
-
-
-    // When not threaded we've already have c_curr and s_curr.
-    // Otherwise we need get them by pulling off the decode output queue.
-    if (fd->pool) {
-        hts_tpool_result *res;
-        cram_decode_job *j;
-
-        if (fd->ooc && hts_tpool_process_empty(fd->rqueue)) {
-            fd->eof = 1;
-            return NULL;
-        }
-
-        res = hts_tpool_next_result_wait(fd->rqueue);
-
-        if (!res || !hts_tpool_result_data(res)) {
-            hts_log_error("Call to hts_tpool_next_result failed");
-            return NULL;
-        }
-
-        j = (cram_decode_job *)hts_tpool_result_data(res);
-        c_curr = j->c;
-        s_curr = j->s;
-
-        if (j->exit_code != 0) {
-            hts_log_error("Slice decode failure");
-            fd->eof = 0;
-            hts_tpool_delete_result(res, 1);
-            return NULL;
-        }
-
-        hts_tpool_delete_result(res, 1);
-    }
-
-    *cp = c_curr;
-
-    // Update current slice being processed (as opposed to current
-    // slice in the multi-threaded reahead.
-    fd->ctr = c_curr;
-    if (c_curr) {
-        c_curr->slice = s_curr;
-        if (s_curr)
-            c_curr->curr_slice = s_curr->slice_num;
-    }
-    if (s_curr)
-        s_curr->curr_rec = 0;
-    else
-        fd->eof = 1;
-
-    return s_curr;
-}
-
-/*
- * Read the next cram record and return it.
- * Note that to decode cram_record the caller will need to look up some data
- * in the current slice, pointed to by fd->ctr->slice. This is valid until
- * the next call to cram_get_seq (which may invalidate it).
- *
- * Returns record pointer on success (do not free)
- *        NULL on failure
- */
-cram_record *cram_get_seq(cram_fd *fd) {
-    cram_container *c;
-    cram_slice *s;
-
-    for (;;) {
-        c = fd->ctr;
-        if (c && c->slice && c->slice->curr_rec < c->slice->max_rec) {
-            s = c->slice;
-        } else {
-            if (!(s = cram_next_slice(fd, &c)))
-                return NULL;
-            continue; /* In case slice contains no records */
-        }
-
-        // No need to lock here as get_seq is running in the main thread,
-        // which is also the same one that does the range modifications.
-        if (fd->range.refid != -2) {
-            if (fd->range.refid == -1 && s->crecs[s->curr_rec].ref_id != -1) {
-                // Special case when looking for unmapped blocks at end.
-                // If these are mixed in with mapped data (c->ref_id == -2)
-                // then we need skip until we find the unmapped data, if at all
-                s->curr_rec++;
-                continue;
-            }
-            if (s->crecs[s->curr_rec].ref_id < fd->range.refid &&
-                s->crecs[s->curr_rec].ref_id != -1) {
-                // Looking for a mapped read, but not there yet.  Special case
-                // as -1 (unmapped) shouldn't be considered < refid.
-                s->curr_rec++;
-                continue;
-            }
-
-            if (s->crecs[s->curr_rec].ref_id != fd->range.refid) {
-                fd->eof = 1;
-                cram_free_slice(s);
-                c->slice = NULL;
-                return NULL;
-            }
-
-            if (fd->range.refid != -1 && s->crecs[s->curr_rec].apos > fd->range.end) {
-                fd->eof = 1;
-                cram_free_slice(s);
-                c->slice = NULL;
-                return NULL;
-            }
-
-            if (fd->range.refid != -1 && s->crecs[s->curr_rec].aend < fd->range.start) {
-                s->curr_rec++;
-                continue;
-            }
-        }
-
-        break;
-    }
-
-    fd->ctr = c;
-    c->slice = s;
-    return &s->crecs[s->curr_rec++];
-}
-
-/*
- * Read the next cram record and convert it to a bam_seq_t struct.
- *
- * Returns >= 0 success (number of bytes written to *bam)
- *        -1 on EOF or failure (check fd->err)
- */
-int cram_get_bam_seq(cram_fd *fd, bam_seq_t **bam) {
-    cram_record *cr;
-    cram_container *c;
-    cram_slice *s;
-
-    if (!(cr = cram_get_seq(fd)))
-        return -1;
-
-    c = fd->ctr;
-    s = c->slice;
-
-    return cram_to_bam(fd->header, fd, s, cr, s->curr_rec-1, bam);
-}
-
-/*
- * Drains and frees the decode read-queue for a multi-threaded reader.
- */
-void cram_drain_rqueue(cram_fd *fd) {
-    cram_container *lc = NULL;
-
-    if (!fd->pool || !fd->rqueue)
-        return;
-
-    // drain queue of any in-flight decode jobs
-    while (!hts_tpool_process_empty(fd->rqueue)) {
-        hts_tpool_result *r = hts_tpool_next_result_wait(fd->rqueue);
-        if (!r)
-            break;
-        cram_decode_job *j = (cram_decode_job *)hts_tpool_result_data(r);
-        if (j->c->slice == j->s)
-            j->c->slice = NULL;
-        if (j->c != lc) {
-            if (lc) {
-                if (fd->ctr == lc)
-                    fd->ctr = NULL;
-                if (fd->ctr_mt == lc)
-                    fd->ctr_mt = NULL;
-                cram_free_container(lc);
-            }
-            lc = j->c;
-        }
-        cram_free_slice(j->s);
-        hts_tpool_delete_result(r, 1);
-    }
-
-    // Also tidy up any pending decode job that we didn't submit to the workers
-    // due to the input queue being full.
-    if (fd->job_pending) {
-        cram_decode_job *j = (cram_decode_job *)fd->job_pending;
-        if (j->c->slice == j->s)
-            j->c->slice = NULL;
-        if (j->c != lc) {
-            if (lc) {
-                if (fd->ctr == lc)
-                    fd->ctr = NULL;
-                if (fd->ctr_mt == lc)
-                    fd->ctr_mt = NULL;
-                cram_free_container(lc);
-            }
-            lc = j->c;
-        }
-        cram_free_slice(j->s);
-        free(j);
-        fd->job_pending = NULL;
-    }
-
-    if (lc) {
-        if (fd->ctr == lc)
-            fd->ctr = NULL;
-        if (fd->ctr_mt == lc)
-            fd->ctr_mt = NULL;
-        cram_free_container(lc);
-    }
-}
diff -ruN stringtie.orig/htslib/cram/cram_decode.h stringtie/htslib/cram/cram_decode.h
--- stringtie.orig/htslib/cram/cram_decode.h	2024-02-28 13:57:39.701246126 +0100
+++ stringtie/htslib/cram/cram_decode.h	1970-01-01 01:00:00.000000000 +0100
@@ -1,117 +0,0 @@
-/*
-Copyright (c) 2012-2013, 2018 Genome Research Ltd.
-Author: James Bonfield <jkb@sanger.ac.uk>
-
-Redistribution and use in source and binary forms, with or without
-modification, are permitted provided that the following conditions are met:
-
-   1. Redistributions of source code must retain the above copyright notice,
-this list of conditions and the following disclaimer.
-
-   2. Redistributions in binary form must reproduce the above copyright notice,
-this list of conditions and the following disclaimer in the documentation
-and/or other materials provided with the distribution.
-
-   3. Neither the names Genome Research Ltd and Wellcome Trust Sanger
-Institute nor the names of its contributors may be used to endorse or promote
-products derived from this software without specific prior written permission.
-
-THIS SOFTWARE IS PROVIDED BY GENOME RESEARCH LTD AND CONTRIBUTORS "AS IS" AND
-ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
-WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
-DISCLAIMED. IN NO EVENT SHALL GENOME RESEARCH LTD OR CONTRIBUTORS BE LIABLE
-FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
-DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
-SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
-CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
-OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
-OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-*/
-
-/*! \file
- * Include cram.h instead.
- *
- * This is an internal part of the CRAM system and is automatically included
- * when you #include cram.h.
- *
- * Implements the decoding portion of CRAM I/O. Also see
- * cram_codecs.[ch] for the actual encoding functions themselves.
- */
-
-#ifndef CRAM_DECODE_H
-#define CRAM_DECODE_H
-
-#ifdef __cplusplus
-extern "C" {
-#endif
-
-/* ----------------------------------------------------------------------
- * CRAM sequence iterators.
- */
-
-/*! Read the next cram record and return it as a cram_record.
- *
- * Note that to decode cram_record the caller will need to look up some data
- * in the current slice, pointed to by fd->ctr->slice. This is valid until
- * the next call to cram_get_seq (which may invalidate it).
- *
- * @return
- * Returns record pointer on success (do not free);
- *        NULL on failure
- */
-cram_record *cram_get_seq(cram_fd *fd);
-
-/*! Read the next cram record and convert it to a bam_seq_t struct.
- *
- * @return
- * Returns 0 on success;
- *        -1 on EOF or failure (check fd->err)
- */
-int cram_get_bam_seq(cram_fd *fd, bam_seq_t **bam);
-
-
-/* ----------------------------------------------------------------------
- * Internal functions
- */
-
-/*! INTERNAL:
- * Decodes a CRAM block compression header.
- *
- * @return
- * Returns header ptr on success;
- *         NULL on failure
- */
-cram_block_compression_hdr *cram_decode_compression_header(cram_fd *fd,
-                                                           cram_block *b);
-
-/*! INTERNAL:
- * Decodes a CRAM (un)mapped slice header block.
- *
- * @return
- * Returns slice header ptr on success;
- *         NULL on failure
- */
-cram_block_slice_hdr *cram_decode_slice_header(cram_fd *fd, cram_block *b);
-
-
-/*! INTERNAL:
- * Decode an entire slice from container blocks. Fills out s->crecs[] array.
- *
- * @return
- * Returns 0 on success;
- *        -1 on failure
- */
-int cram_decode_slice(cram_fd *fd, cram_container *c, cram_slice *s,
-                      sam_hdr_t *hdr);
-
-
-/*
- * Drains and frees the decode read-queue for a multi-threaded reader.
- */
-void cram_drain_rqueue(cram_fd *fd);
-
-#ifdef __cplusplus
-}
-#endif
-
-#endif
diff -ruN stringtie.orig/htslib/cram/cram_encode.c stringtie/htslib/cram/cram_encode.c
--- stringtie.orig/htslib/cram/cram_encode.c	2024-02-28 13:57:39.701246126 +0100
+++ stringtie/htslib/cram/cram_encode.c	1970-01-01 01:00:00.000000000 +0100
@@ -1,3474 +0,0 @@
-/*
-Copyright (c) 2012-2020 Genome Research Ltd.
-Author: James Bonfield <jkb@sanger.ac.uk>
-
-Redistribution and use in source and binary forms, with or without
-modification, are permitted provided that the following conditions are met:
-
-   1. Redistributions of source code must retain the above copyright notice,
-this list of conditions and the following disclaimer.
-
-   2. Redistributions in binary form must reproduce the above copyright notice,
-this list of conditions and the following disclaimer in the documentation
-and/or other materials provided with the distribution.
-
-   3. Neither the names Genome Research Ltd and Wellcome Trust Sanger
-Institute nor the names of its contributors may be used to endorse or promote
-products derived from this software without specific prior written permission.
-
-THIS SOFTWARE IS PROVIDED BY GENOME RESEARCH LTD AND CONTRIBUTORS "AS IS" AND
-ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
-WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
-DISCLAIMED. IN NO EVENT SHALL GENOME RESEARCH LTD OR CONTRIBUTORS BE LIABLE
-FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
-DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
-SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
-CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
-OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
-OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-*/
-
-#define HTS_BUILDING_LIBRARY // Enables HTSLIB_EXPORT, see htslib/hts_defs.h
-#include <config.h>
-
-#include <stdio.h>
-#include <errno.h>
-#include <assert.h>
-#include <stdlib.h>
-#include <string.h>
-#include <strings.h>
-#include <zlib.h>
-#include <sys/types.h>
-#include <sys/stat.h>
-#include <math.h>
-#include <inttypes.h>
-
-#include "cram.h"
-#include "os.h"
-#include "../sam_internal.h" // for nibble2base
-#include "../htslib/hts.h"
-#include "../htslib/hts_endian.h"
-
-KHASH_MAP_INIT_STR(m_s2u64, uint64_t)
-
-#define Z_CRAM_STRAT Z_FILTERED
-//#define Z_CRAM_STRAT Z_RLE
-//#define Z_CRAM_STRAT Z_HUFFMAN_ONLY
-//#define Z_CRAM_STRAT Z_DEFAULT_STRATEGY
-
-static int process_one_read(cram_fd *fd, cram_container *c,
-                            cram_slice *s, cram_record *cr,
-                            bam_seq_t *b, int rnum, kstring_t *MD);
-
-/*
- * Returns index of val into key.
- * Basically strchr(key, val)-key;
- */
-static int sub_idx(char *key, char val) {
-    int i;
-
-    for (i = 0; *key && *key++ != val; i++);
-    return i;
-}
-
-/*
- * Encodes a compression header block into a generic cram_block structure.
- *
- * Returns cram_block ptr on success
- *         NULL on failure
- */
-cram_block *cram_encode_compression_header(cram_fd *fd, cram_container *c,
-                                           cram_block_compression_hdr *h) {
-    cram_block *cb  = cram_new_block(COMPRESSION_HEADER, 0);
-    cram_block *map = cram_new_block(COMPRESSION_HEADER, 0);
-    int i, mc, r = 0;
-
-    if (!cb || !map)
-        return NULL;
-
-    /*
-     * This is a concatenation of several blocks of data:
-     * header + landmarks, preservation map, read encoding map, and the tag
-     * encoding map.
-     * All 4 are variable sized and we need to know how large these are
-     * before creating the compression header itself as this starts with
-     * the total size (stored as a variable length string).
-     */
-
-    // Duplicated from container itself, and removed in 1.1
-    if (CRAM_MAJOR_VERS(fd->version) == 1) {
-        r |= itf8_put_blk(cb, h->ref_seq_id);
-        r |= itf8_put_blk(cb, h->ref_seq_start);
-        r |= itf8_put_blk(cb, h->ref_seq_span);
-        r |= itf8_put_blk(cb, h->num_records);
-        r |= itf8_put_blk(cb, h->num_landmarks);
-        for (i = 0; i < h->num_landmarks; i++) {
-            r |= itf8_put_blk(cb, h->landmark[i]);
-        }
-    }
-
-    if (h->preservation_map)
-        kh_destroy(map, h->preservation_map);
-
-    /* Create in-memory preservation map */
-    /* FIXME: should create this when we create the container */
-    if (h->num_records > 0) {
-        khint_t k;
-        int r;
-
-        if (!(h->preservation_map = kh_init(map)))
-            return NULL;
-
-        k = kh_put(map, h->preservation_map, "RN", &r);
-        if (-1 == r) return NULL;
-        kh_val(h->preservation_map, k).i = !fd->lossy_read_names;
-
-        if (CRAM_MAJOR_VERS(fd->version) == 1) {
-            k = kh_put(map, h->preservation_map, "PI", &r);
-            if (-1 == r) return NULL;
-            kh_val(h->preservation_map, k).i = 0;
-
-            k = kh_put(map, h->preservation_map, "UI", &r);
-            if (-1 == r) return NULL;
-            kh_val(h->preservation_map, k).i = 1;
-
-            k = kh_put(map, h->preservation_map, "MI", &r);
-            if (-1 == r) return NULL;
-            kh_val(h->preservation_map, k).i = 1;
-
-        } else {
-            // Technically SM was in 1.0, but wasn't in Java impl.
-            k = kh_put(map, h->preservation_map, "SM", &r);
-            if (-1 == r) return NULL;
-            kh_val(h->preservation_map, k).i = 0;
-
-            k = kh_put(map, h->preservation_map, "TD", &r);
-            if (-1 == r) return NULL;
-            kh_val(h->preservation_map, k).i = 0;
-
-            k = kh_put(map, h->preservation_map, "AP", &r);
-            if (-1 == r) return NULL;
-            kh_val(h->preservation_map, k).i = h->AP_delta;
-
-            if (CRAM_MAJOR_VERS(fd->version) >= 4) {
-                k = kh_put(map, h->preservation_map, "QO", &r);
-                if (-1 == r) return NULL;
-                kh_val(h->preservation_map, k).i = h->qs_seq_orient;
-            }
-
-            if (fd->no_ref || fd->embed_ref) {
-                // Reference Required == No
-                k = kh_put(map, h->preservation_map, "RR", &r);
-                if (-1 == r) return NULL;
-                kh_val(h->preservation_map, k).i = 0;
-            }
-        }
-    }
-
-    /* Encode preservation map; could collapse this and above into one */
-    mc = 0;
-    BLOCK_SIZE(map) = 0;
-    if (h->preservation_map) {
-        khint_t k;
-
-        for (k = kh_begin(h->preservation_map);
-             k != kh_end(h->preservation_map);
-             k++) {
-            const char *key;
-            khash_t(map) *pmap = h->preservation_map;
-
-
-            if (!kh_exist(pmap, k))
-                continue;
-
-            key = kh_key(pmap, k);
-            BLOCK_APPEND(map, key, 2);
-
-            switch(CRAM_KEY(key[0], key[1])) {
-            case CRAM_KEY('M','I'):
-            case CRAM_KEY('U','I'):
-            case CRAM_KEY('P','I'):
-            case CRAM_KEY('A','P'):
-            case CRAM_KEY('R','N'):
-            case CRAM_KEY('R','R'):
-            case CRAM_KEY('Q','O'):
-                BLOCK_APPEND_CHAR(map, kh_val(pmap, k).i);
-                break;
-
-            case CRAM_KEY('S','M'): {
-                char smat[5], *mp = smat;
-                *mp++ =
-                    (sub_idx("CGTN", h->substitution_matrix[0][0]) << 6) |
-                    (sub_idx("CGTN", h->substitution_matrix[0][1]) << 4) |
-                    (sub_idx("CGTN", h->substitution_matrix[0][2]) << 2) |
-                    (sub_idx("CGTN", h->substitution_matrix[0][3]) << 0);
-                *mp++ =
-                    (sub_idx("AGTN", h->substitution_matrix[1][0]) << 6) |
-                    (sub_idx("AGTN", h->substitution_matrix[1][1]) << 4) |
-                    (sub_idx("AGTN", h->substitution_matrix[1][2]) << 2) |
-                    (sub_idx("AGTN", h->substitution_matrix[1][3]) << 0);
-                *mp++ =
-                    (sub_idx("ACTN", h->substitution_matrix[2][0]) << 6) |
-                    (sub_idx("ACTN", h->substitution_matrix[2][1]) << 4) |
-                    (sub_idx("ACTN", h->substitution_matrix[2][2]) << 2) |
-                    (sub_idx("ACTN", h->substitution_matrix[2][3]) << 0);
-                *mp++ =
-                    (sub_idx("ACGN", h->substitution_matrix[3][0]) << 6) |
-                    (sub_idx("ACGN", h->substitution_matrix[3][1]) << 4) |
-                    (sub_idx("ACGN", h->substitution_matrix[3][2]) << 2) |
-                    (sub_idx("ACGN", h->substitution_matrix[3][3]) << 0);
-                *mp++ =
-                    (sub_idx("ACGT", h->substitution_matrix[4][0]) << 6) |
-                    (sub_idx("ACGT", h->substitution_matrix[4][1]) << 4) |
-                    (sub_idx("ACGT", h->substitution_matrix[4][2]) << 2) |
-                    (sub_idx("ACGT", h->substitution_matrix[4][3]) << 0);
-                BLOCK_APPEND(map, smat, 5);
-                break;
-            }
-
-            case CRAM_KEY('T','D'): {
-                r |= (fd->vv.varint_put32_blk(map, BLOCK_SIZE(h->TD_blk)) <= 0);
-                BLOCK_APPEND(map,
-                             BLOCK_DATA(h->TD_blk),
-                             BLOCK_SIZE(h->TD_blk));
-                break;
-            }
-
-            default:
-                hts_log_warning("Unknown preservation key '%.2s'", key);
-                break;
-            }
-
-            mc++;
-        }
-    }
-    r |= (fd->vv.varint_put32_blk(cb, BLOCK_SIZE(map) + fd->vv.varint_size(mc)) <= 0);
-    r |= (fd->vv.varint_put32_blk(cb, mc) <= 0);
-    BLOCK_APPEND(cb, BLOCK_DATA(map), BLOCK_SIZE(map));
-
-    /* rec encoding map */
-    mc = 0;
-    BLOCK_SIZE(map) = 0;
-    if (h->codecs[DS_BF]) {
-        if (-1 == h->codecs[DS_BF]->store(h->codecs[DS_BF], map, "BF",
-                                          fd->version))
-            return NULL;
-        mc++;
-    }
-    if (h->codecs[DS_CF]) {
-        if (-1 == h->codecs[DS_CF]->store(h->codecs[DS_CF], map, "CF",
-                                          fd->version))
-            return NULL;
-        mc++;
-    }
-    if (h->codecs[DS_RL]) {
-        if (-1 == h->codecs[DS_RL]->store(h->codecs[DS_RL], map, "RL",
-                                          fd->version))
-            return NULL;
-        mc++;
-    }
-    if (h->codecs[DS_AP]) {
-        if (-1 == h->codecs[DS_AP]->store(h->codecs[DS_AP], map, "AP",
-                                          fd->version))
-            return NULL;
-        mc++;
-    }
-    if (h->codecs[DS_RG]) {
-        if (-1 == h->codecs[DS_RG]->store(h->codecs[DS_RG], map, "RG",
-                                          fd->version))
-            return NULL;
-        mc++;
-    }
-    if (h->codecs[DS_MF]) {
-        if (-1 == h->codecs[DS_MF]->store(h->codecs[DS_MF], map, "MF",
-                                          fd->version))
-            return NULL;
-        mc++;
-    }
-    if (h->codecs[DS_NS]) {
-        if (-1 == h->codecs[DS_NS]->store(h->codecs[DS_NS], map, "NS",
-                                          fd->version))
-            return NULL;
-        mc++;
-    }
-    if (h->codecs[DS_NP]) {
-        if (-1 == h->codecs[DS_NP]->store(h->codecs[DS_NP], map, "NP",
-                                          fd->version))
-            return NULL;
-        mc++;
-    }
-    if (h->codecs[DS_TS]) {
-        if (-1 == h->codecs[DS_TS]->store(h->codecs[DS_TS], map, "TS",
-                                          fd->version))
-            return NULL;
-        mc++;
-    }
-    if (h->codecs[DS_NF]) {
-        if (-1 == h->codecs[DS_NF]->store(h->codecs[DS_NF], map, "NF",
-                                          fd->version))
-            return NULL;
-        mc++;
-    }
-    if (h->codecs[DS_TC]) {
-        if (-1 == h->codecs[DS_TC]->store(h->codecs[DS_TC], map, "TC",
-                                          fd->version))
-            return NULL;
-        mc++;
-    }
-    if (h->codecs[DS_TN]) {
-        if (-1 == h->codecs[DS_TN]->store(h->codecs[DS_TN], map, "TN",
-                                          fd->version))
-            return NULL;
-        mc++;
-    }
-    if (h->codecs[DS_TL]) {
-        if (-1 == h->codecs[DS_TL]->store(h->codecs[DS_TL], map, "TL",
-                                          fd->version))
-            return NULL;
-        mc++;
-    }
-    if (h->codecs[DS_FN]) {
-        if (-1 == h->codecs[DS_FN]->store(h->codecs[DS_FN], map, "FN",
-                                          fd->version))
-            return NULL;
-        mc++;
-    }
-    if (h->codecs[DS_FC]) {
-        if (-1 == h->codecs[DS_FC]->store(h->codecs[DS_FC], map, "FC",
-                                          fd->version))
-            return NULL;
-        mc++;
-    }
-    if (h->codecs[DS_FP]) {
-        if (-1 == h->codecs[DS_FP]->store(h->codecs[DS_FP], map, "FP",
-                                          fd->version))
-            return NULL;
-        mc++;
-    }
-    if (h->codecs[DS_BS]) {
-        if (-1 == h->codecs[DS_BS]->store(h->codecs[DS_BS], map, "BS",
-                                          fd->version))
-            return NULL;
-        mc++;
-    }
-    if (h->codecs[DS_IN]) {
-        if (-1 == h->codecs[DS_IN]->store(h->codecs[DS_IN], map, "IN",
-                                          fd->version))
-            return NULL;
-        mc++;
-    }
-    if (h->codecs[DS_DL]) {
-        if (-1 == h->codecs[DS_DL]->store(h->codecs[DS_DL], map, "DL",
-                                          fd->version))
-            return NULL;
-        mc++;
-    }
-    if (h->codecs[DS_BA]) {
-        if (-1 == h->codecs[DS_BA]->store(h->codecs[DS_BA], map, "BA",
-                                          fd->version))
-            return NULL;
-        mc++;
-    }
-    if (h->codecs[DS_BB]) {
-        if (-1 == h->codecs[DS_BB]->store(h->codecs[DS_BB], map, "BB",
-                                          fd->version))
-            return NULL;
-        mc++;
-    }
-    if (h->codecs[DS_MQ]) {
-        if (-1 == h->codecs[DS_MQ]->store(h->codecs[DS_MQ], map, "MQ",
-                                          fd->version))
-            return NULL;
-        mc++;
-    }
-    if (h->codecs[DS_RN]) {
-        if (-1 == h->codecs[DS_RN]->store(h->codecs[DS_RN], map, "RN",
-                                          fd->version))
-            return NULL;
-        mc++;
-    }
-    if (h->codecs[DS_QS]) {
-        if (-1 == h->codecs[DS_QS]->store(h->codecs[DS_QS], map, "QS",
-                                          fd->version))
-            return NULL;
-        mc++;
-    }
-    if (h->codecs[DS_QQ]) {
-        if (-1 == h->codecs[DS_QQ]->store(h->codecs[DS_QQ], map, "QQ",
-                                          fd->version))
-            return NULL;
-        mc++;
-    }
-    if (h->codecs[DS_RI]) {
-        if (-1 == h->codecs[DS_RI]->store(h->codecs[DS_RI], map, "RI",
-                                          fd->version))
-            return NULL;
-        mc++;
-    }
-    if (CRAM_MAJOR_VERS(fd->version) != 1) {
-        if (h->codecs[DS_SC]) {
-            if (-1 == h->codecs[DS_SC]->store(h->codecs[DS_SC], map, "SC",
-                                              fd->version))
-                return NULL;
-            mc++;
-        }
-        if (h->codecs[DS_RS]) {
-            if (-1 == h->codecs[DS_RS]->store(h->codecs[DS_RS], map, "RS",
-                                              fd->version))
-                return NULL;
-            mc++;
-        }
-        if (h->codecs[DS_PD]) {
-            if (-1 == h->codecs[DS_PD]->store(h->codecs[DS_PD], map, "PD",
-                                              fd->version))
-                return NULL;
-            mc++;
-        }
-        if (h->codecs[DS_HC]) {
-            if (-1 == h->codecs[DS_HC]->store(h->codecs[DS_HC], map, "HC",
-                                              fd->version))
-                return NULL;
-            mc++;
-        }
-    }
-    if (h->codecs[DS_TM]) {
-        if (-1 == h->codecs[DS_TM]->store(h->codecs[DS_TM], map, "TM",
-                                          fd->version))
-            return NULL;
-        mc++;
-    }
-    if (h->codecs[DS_TV]) {
-        if (-1 == h->codecs[DS_TV]->store(h->codecs[DS_TV], map, "TV",
-                                          fd->version))
-            return NULL;
-        mc++;
-    }
-    r |= (fd->vv.varint_put32_blk(cb, BLOCK_SIZE(map) + fd->vv.varint_size(mc)) <= 0);
-    r |= (fd->vv.varint_put32_blk(cb, mc) <= 0);
-    BLOCK_APPEND(cb, BLOCK_DATA(map), BLOCK_SIZE(map));
-
-    /* tag encoding map */
-    mc = 0;
-    BLOCK_SIZE(map) = 0;
-    if (c->tags_used) {
-        khint_t k;
-
-        for (k = kh_begin(c->tags_used); k != kh_end(c->tags_used); k++) {
-            int key;
-            if (!kh_exist(c->tags_used, k))
-                continue;
-
-            key = kh_key(c->tags_used, k);
-            cram_codec *cd = kh_val(c->tags_used, k)->codec;
-
-            r |= (fd->vv.varint_put32_blk(map, key) <= 0);
-            if (-1 == cd->store(cd, map, NULL, fd->version))
-                return NULL;
-
-            mc++;
-        }
-    }
-
-    r |= (fd->vv.varint_put32_blk(cb, BLOCK_SIZE(map) + fd->vv.varint_size(mc)) <= 0);
-    r |= (fd->vv.varint_put32_blk(cb, mc) <= 0);
-    BLOCK_APPEND(cb, BLOCK_DATA(map), BLOCK_SIZE(map));
-
-    hts_log_info("Wrote compression block header in %d bytes", (int)BLOCK_SIZE(cb));
-
-    BLOCK_UPLEN(cb);
-
-    cram_free_block(map);
-
-    if (r >= 0)
-        return cb;
-
- block_err:
-    return NULL;
-}
-
-
-/*
- * Encodes a slice compression header.
- *
- * Returns cram_block on success
- *         NULL on failure
- */
-cram_block *cram_encode_slice_header(cram_fd *fd, cram_slice *s) {
-    char *buf;
-    char *cp;
-    cram_block *b = cram_new_block(MAPPED_SLICE, 0);
-    int j;
-
-    if (!b)
-        return NULL;
-
-    cp = buf = malloc(22+16+5*(8+s->hdr->num_blocks));
-    if (NULL == buf) {
-        cram_free_block(b);
-        return NULL;
-    }
-
-    cp += fd->vv.varint_put32s(cp, NULL, s->hdr->ref_seq_id);
-    if (CRAM_MAJOR_VERS(fd->version) >= 4) {
-        cp += fd->vv.varint_put64(cp, NULL, s->hdr->ref_seq_start);
-        cp += fd->vv.varint_put64(cp, NULL, s->hdr->ref_seq_span);
-    } else {
-        cp += fd->vv.varint_put32(cp, NULL, s->hdr->ref_seq_start);
-        cp += fd->vv.varint_put32(cp, NULL, s->hdr->ref_seq_span);
-    }
-    cp += fd->vv.varint_put32(cp, NULL, s->hdr->num_records);
-    if (CRAM_MAJOR_VERS(fd->version) == 2)
-        cp += fd->vv.varint_put32(cp, NULL, s->hdr->record_counter);
-    else if (CRAM_MAJOR_VERS(fd->version) >= 3)
-        cp += fd->vv.varint_put64(cp, NULL, s->hdr->record_counter);
-    cp += fd->vv.varint_put32(cp, NULL, s->hdr->num_blocks);
-    cp += fd->vv.varint_put32(cp, NULL, s->hdr->num_content_ids);
-    for (j = 0; j < s->hdr->num_content_ids; j++) {
-        cp += fd->vv.varint_put32(cp, NULL, s->hdr->block_content_ids[j]);
-    }
-    if (s->hdr->content_type == MAPPED_SLICE)
-        cp += fd->vv.varint_put32(cp, NULL, s->hdr->ref_base_id);
-
-    if (CRAM_MAJOR_VERS(fd->version) != 1) {
-        memcpy(cp, s->hdr->md5, 16); cp += 16;
-    }
-
-    assert(cp-buf <= 22+16+5*(8+s->hdr->num_blocks));
-
-    b->data = (unsigned char *)buf;
-    b->comp_size = b->uncomp_size = cp-buf;
-
-    return b;
-}
-
-
-/*
- * Encodes a single read.
- *
- * Returns 0 on success
- *        -1 on failure
- */
-static int cram_encode_slice_read(cram_fd *fd,
-                                  cram_container *c,
-                                  cram_block_compression_hdr *h,
-                                  cram_slice *s,
-                                  cram_record *cr,
-                                  int64_t *last_pos) {
-    int r = 0;
-    int32_t i32;
-    int64_t i64;
-    unsigned char uc;
-
-    //fprintf(stderr, "Encode seq %d, %d/%d FN=%d, %s\n", rec, core->byte, core->bit, cr->nfeature, s->name_ds->str + cr->name);
-
-    //printf("BF=0x%x\n", cr->flags);
-    //      bf = cram_flag_swap[cr->flags];
-    i32 = fd->cram_flag_swap[cr->flags & 0xfff];
-    r |= h->codecs[DS_BF]->encode(s, h->codecs[DS_BF], (char *)&i32, 1);
-
-    i32 = cr->cram_flags & CRAM_FLAG_MASK;
-    r |= h->codecs[DS_CF]->encode(s, h->codecs[DS_CF], (char *)&i32, 1);
-
-    if (CRAM_MAJOR_VERS(fd->version) != 1 && s->hdr->ref_seq_id == -2)
-        r |= h->codecs[DS_RI]->encode(s, h->codecs[DS_RI], (char *)&cr->ref_id, 1);
-
-    r |= h->codecs[DS_RL]->encode(s, h->codecs[DS_RL], (char *)&cr->len, 1);
-
-    if (c->pos_sorted) {
-        if (CRAM_MAJOR_VERS(fd->version) >= 4) {
-            i64 = cr->apos - *last_pos;
-            r |= h->codecs[DS_AP]->encode(s, h->codecs[DS_AP], (char *)&i64, 1);
-        } else {
-            i32 = cr->apos - *last_pos;
-            r |= h->codecs[DS_AP]->encode(s, h->codecs[DS_AP], (char *)&i32, 1);
-        }
-        *last_pos = cr->apos;
-    } else {
-        if (CRAM_MAJOR_VERS(fd->version) >= 4) {
-            i64 = cr->apos;
-            r |= h->codecs[DS_AP]->encode(s, h->codecs[DS_AP], (char *)&i64, 1);
-        } else {
-            i32 = cr->apos;
-            r |= h->codecs[DS_AP]->encode(s, h->codecs[DS_AP], (char *)&i32, 1);
-        }
-    }
-
-    r |= h->codecs[DS_RG]->encode(s, h->codecs[DS_RG], (char *)&cr->rg, 1);
-
-    if (cr->cram_flags & CRAM_FLAG_DETACHED) {
-        i32 = cr->mate_flags;
-        r |= h->codecs[DS_MF]->encode(s, h->codecs[DS_MF], (char *)&i32, 1);
-
-        r |= h->codecs[DS_NS]->encode(s, h->codecs[DS_NS],
-                                      (char *)&cr->mate_ref_id, 1);
-
-        if (CRAM_MAJOR_VERS(fd->version) >= 4) {
-            r |= h->codecs[DS_NP]->encode(s, h->codecs[DS_NP],
-                                          (char *)&cr->mate_pos, 1);
-            r |= h->codecs[DS_TS]->encode(s, h->codecs[DS_TS],
-                                          (char *)&cr->tlen, 1);
-        } else {
-            i32 = cr->mate_pos;
-            r |= h->codecs[DS_NP]->encode(s, h->codecs[DS_NP],
-                                          (char *)&i32, 1);
-            i32 = cr->tlen;
-            r |= h->codecs[DS_TS]->encode(s, h->codecs[DS_TS],
-                                          (char *)&i32, 1);
-        }
-    } else {
-        if (cr->cram_flags & CRAM_FLAG_MATE_DOWNSTREAM) {
-            r |= h->codecs[DS_NF]->encode(s, h->codecs[DS_NF],
-                                          (char *)&cr->mate_line, 1);
-        }
-        if (cr->cram_flags & CRAM_FLAG_EXPLICIT_TLEN) {
-            if (CRAM_MAJOR_VERS(fd->version) >= 4) {
-                r |= h->codecs[DS_TS]->encode(s, h->codecs[DS_TS],
-                                              (char *)&cr->tlen, 1);
-            }
-        }
-    }
-
-    /* Aux tags */
-    if (CRAM_MAJOR_VERS(fd->version) == 1) {
-        int j;
-        uc = cr->ntags;
-        r |= h->codecs[DS_TC]->encode(s, h->codecs[DS_TC], (char *)&uc, 1);
-
-        for (j = 0; j < cr->ntags; j++) {
-            uint32_t i32 = s->TN[cr->TN_idx + j]; // id
-            r |= h->codecs[DS_TN]->encode(s, h->codecs[DS_TN], (char *)&i32, 1);
-        }
-    } else {
-        r |= h->codecs[DS_TL]->encode(s, h->codecs[DS_TL], (char *)&cr->TL, 1);
-    }
-
-    // qual
-    // QS codec : Already stored in block[2].
-
-    // features (diffs)
-    if (!(cr->flags & BAM_FUNMAP)) {
-        int prev_pos = 0, j;
-
-        r |= h->codecs[DS_FN]->encode(s, h->codecs[DS_FN],
-                                      (char *)&cr->nfeature, 1);
-        for (j = 0; j < cr->nfeature; j++) {
-            cram_feature *f = &s->features[cr->feature + j];
-
-            uc = f->X.code;
-            r |= h->codecs[DS_FC]->encode(s, h->codecs[DS_FC], (char *)&uc, 1);
-            i32 = f->X.pos - prev_pos;
-            r |= h->codecs[DS_FP]->encode(s, h->codecs[DS_FP], (char *)&i32, 1);
-            prev_pos = f->X.pos;
-
-            switch(f->X.code) {
-                //char *seq;
-
-            case 'X':
-                //fprintf(stderr, "    FC=%c FP=%d base=%d\n", f->X.code, i32, f->X.base);
-
-                uc = f->X.base;
-                r |= h->codecs[DS_BS]->encode(s, h->codecs[DS_BS],
-                                              (char *)&uc, 1);
-                break;
-            case 'S':
-                // Already done
-                //r |= h->codecs[DS_SC]->encode(s, h->codecs[DS_SC],
-                //                              BLOCK_DATA(s->soft_blk) + f->S.seq_idx,
-                //                              f->S.len);
-
-                //if (CRAM_MAJOR_VERS(fd->version) >= 3) {
-                //    r |= h->codecs[DS_BB]->encode(s, h->codecs[DS_BB],
-                //                                  BLOCK_DATA(s->seqs_blk) + f->S.seq_idx,
-                //                                  f->S.len);
-                //}
-                break;
-            case 'I':
-                //seq = DSTRING_STR(s->seqs_ds) + f->S.seq_idx;
-                //r |= h->codecs[DS_IN]->encode(s, h->codecs[DS_IN],
-                //                           seq, f->S.len);
-                //if (CRAM_MAJOR_VERS(fd->version) >= 3) {
-                //    r |= h->codecs[DS_BB]->encode(s, h->codecs[DS_BB],
-                //                                  BLOCK_DATA(s->seqs_blk) + f->I.seq_idx,
-                //                                  f->I.len);
-                //}
-                break;
-            case 'i':
-                uc = f->i.base;
-                r |= h->codecs[DS_BA]->encode(s, h->codecs[DS_BA],
-                                              (char *)&uc, 1);
-                //seq = DSTRING_STR(s->seqs_ds) + f->S.seq_idx;
-                //r |= h->codecs[DS_IN]->encode(s, h->codecs[DS_IN],
-                //                           seq, 1);
-                break;
-            case 'D':
-                i32 = f->D.len;
-                r |= h->codecs[DS_DL]->encode(s, h->codecs[DS_DL],
-                                              (char *)&i32, 1);
-                break;
-
-            case 'B':
-                //                  // Used when we try to store a non ACGTN base or an N
-                //                  // that aligns against a non ACGTN reference
-
-                uc  = f->B.base;
-                r |= h->codecs[DS_BA]->encode(s, h->codecs[DS_BA],
-                                              (char *)&uc, 1);
-
-                //                  Already added
-                //                  uc  = f->B.qual;
-                //                  r |= h->codecs[DS_QS]->encode(s, h->codecs[DS_QS],
-                //                                           (char *)&uc, 1);
-                break;
-
-            case 'b':
-                // string of bases
-                r |= h->codecs[DS_BB]->encode(s, h->codecs[DS_BB],
-                                              (char *)BLOCK_DATA(s->seqs_blk)
-                                                      + f->b.seq_idx,
-                                              f->b.len);
-                break;
-
-            case 'Q':
-                //                  Already added
-                //                  uc  = f->B.qual;
-                //                  r |= h->codecs[DS_QS]->encode(s, h->codecs[DS_QS],
-                //                                           (char *)&uc, 1);
-                break;
-
-            case 'N':
-                i32 = f->N.len;
-                r |= h->codecs[DS_RS]->encode(s, h->codecs[DS_RS],
-                                              (char *)&i32, 1);
-                break;
-
-            case 'P':
-                i32 = f->P.len;
-                r |= h->codecs[DS_PD]->encode(s, h->codecs[DS_PD],
-                                              (char *)&i32, 1);
-                break;
-
-            case 'H':
-                i32 = f->H.len;
-                r |= h->codecs[DS_HC]->encode(s, h->codecs[DS_HC],
-                                              (char *)&i32, 1);
-                break;
-
-
-            default:
-                hts_log_error("Unhandled feature code %c", f->X.code);
-                return -1;
-            }
-        }
-
-        r |= h->codecs[DS_MQ]->encode(s, h->codecs[DS_MQ],
-                                      (char *)&cr->mqual, 1);
-    } else {
-        char *seq = (char *)BLOCK_DATA(s->seqs_blk) + cr->seq;
-        if (cr->len)
-            r |= h->codecs[DS_BA]->encode(s, h->codecs[DS_BA], seq, cr->len);
-    }
-
-    return r ? -1 : 0;
-}
-
-
-/*
- * Applies various compression methods to specific blocks, depending on
- * known observations of how data series compress.
- *
- * Returns 0 on success
- *        -1 on failure
- */
-static int cram_compress_slice(cram_fd *fd, cram_container *c, cram_slice *s) {
-    int level = fd->level, i;
-    int method = 1<<GZIP | 1<<GZIP_RLE, methodF = method;
-    int v31_or_above = (fd->version >= (3<<8)+1);
-
-    /* Compress the CORE Block too, with minimal zlib level */
-    if (level > 5 && s->block[0]->uncomp_size > 500)
-        cram_compress_block2(fd, s, s->block[0], NULL, 1<<GZIP, 1);
-
-    if (fd->use_bz2)
-        method |= 1<<BZIP2;
-
-    int method_rans   = (1<<RANS0) | (1<<RANS1);
-    int method_ranspr = method_rans;
-
-    if (fd->use_rans) {
-        method_ranspr = (1<<RANS_PR0)   | (1<<RANS_PR1);
-        if (level > 1)
-            method_ranspr |=
-                  (1<<RANS_PR64)  | (1<<RANS_PR9)
-                | (1<<RANS_PR128) | (1<<RANS_PR193);
-        if (level > 5)
-            method_ranspr |= (1<<RANS_PR129) | (1<<RANS_PR192);
-    }
-
-    if (fd->use_rans) {
-        methodF |= v31_or_above ? method_ranspr : method_rans;
-        method  |= v31_or_above ? method_ranspr : method_rans;
-    }
-
-    int method_arith   = 0;
-    if (fd->use_arith) {
-        method_arith = (1<<ARITH_PR0)   | (1<<ARITH_PR1);
-        if (level > 1)
-            method_arith |=
-                  (1<<ARITH_PR64)  | (1<<ARITH_PR9)
-                | (1<<ARITH_PR128) | (1<<ARITH_PR129)
-                | (1<<ARITH_PR192) | (1u<<ARITH_PR193);
-    }
-    if (fd->use_arith && v31_or_above) {
-        methodF |= method_arith;
-        method  |= method_arith;
-    }
-
-    if (fd->use_lzma)
-        method |= (1<<LZMA);
-
-    /* Faster method for data series we only need entropy encoding on */
-    methodF = method & ~(1<<GZIP | 1<<BZIP2 | 1<<LZMA);
-    if (level >= 5) {
-        method |= 1<<GZIP_1;
-        methodF = method;
-    }
-    if (level == 1) {
-        method &= ~(1<<GZIP);
-        method |=   1<<GZIP_1;
-        methodF = method;
-    }
-
-    int qmethod  = method;
-    int qmethodF = method;
-    if (v31_or_above && fd->use_fqz) {
-        qmethod  |= 1<<FQZ;
-        qmethodF |= 1<<FQZ;
-        if (fd->level > 4) {
-            qmethod  |= 1<<FQZ_b;
-            qmethodF |= 1<<FQZ_b;
-        }
-        if (fd->level > 6) {
-            qmethod  |= (1<<FQZ_c) | (1<<FQZ_d);
-            qmethodF |= (1<<FQZ_c) | (1<<FQZ_d);
-        }
-    }
-
-    pthread_mutex_lock(&fd->metrics_lock);
-    for (i = 0; i < DS_END; i++)
-        if (c->stats[i] && c->stats[i]->nvals > 16)
-            fd->m[i]->unpackable = 1;
-    pthread_mutex_unlock(&fd->metrics_lock);
-
-    /* Specific compression methods for certain block types */
-    if (cram_compress_block2(fd, s, s->block[DS_IN], fd->m[DS_IN], //IN (seq)
-                             method, level))
-        return -1;
-
-    if (fd->level == 0) {
-        /* Do nothing */
-    } else if (fd->level == 1) {
-        if (cram_compress_block2(fd, s, s->block[DS_QS], fd->m[DS_QS],
-                                 qmethodF, 1))
-            return -1;
-        for (i = DS_aux; i <= DS_aux_oz; i++) {
-            if (s->block[i])
-                if (cram_compress_block2(fd, s, s->block[i], fd->m[i],
-                                         method, 1))
-                    return -1;
-        }
-    } else if (fd->level < 3) {
-        if (cram_compress_block2(fd, s, s->block[DS_QS], fd->m[DS_QS],
-                                 qmethod, 1))
-            return -1;
-        if (cram_compress_block2(fd, s, s->block[DS_BA], fd->m[DS_BA],
-                                 method, 1))
-            return -1;
-        if (s->block[DS_BB])
-            if (cram_compress_block2(fd, s, s->block[DS_BB], fd->m[DS_BB],
-                                     method, 1))
-                return -1;
-        for (i = DS_aux; i <= DS_aux_oz; i++) {
-            if (s->block[i])
-                if (cram_compress_block2(fd, s, s->block[i], fd->m[i],
-                                         method, level))
-                    return -1;
-        }
-    } else {
-        if (cram_compress_block2(fd, s, s->block[DS_QS], fd->m[DS_QS],
-                                 qmethod, level))
-            return -1;
-        if (cram_compress_block2(fd, s, s->block[DS_BA], fd->m[DS_BA],
-                                 method, level))
-            return -1;
-        if (s->block[DS_BB])
-            if (cram_compress_block2(fd, s, s->block[DS_BB], fd->m[DS_BB],
-                                     method, level))
-                return -1;
-        for (i = DS_aux; i <= DS_aux_oz; i++) {
-            if (s->block[i])
-                if (cram_compress_block2(fd, s, s->block[i], fd->m[i],
-                                         method, level))
-                    return -1;
-        }
-    }
-
-    // NAME: best is generally xz, bzip2, zlib then rans1
-    int method_rn = method & ~(method_rans | method_ranspr | 1<<GZIP_RLE);
-    if (fd->version >= (3<<8)+1 && fd->use_tok)
-        method_rn |= fd->use_arith ? (1<<TOKA) : (1<<TOK3);
-    if (cram_compress_block2(fd, s, s->block[DS_RN], fd->m[DS_RN],
-                             method_rn, level))
-        return -1;
-
-    // NS shows strong local correlation as rearrangements are localised
-    if (s->block[DS_NS] && s->block[DS_NS] != s->block[0])
-        if (cram_compress_block2(fd, s, s->block[DS_NS], fd->m[DS_NS],
-                                 method, level))
-            return -1;
-
-
-    /*
-     * Compress any auxiliary tags with their own per-tag metrics
-     */
-    {
-        int i;
-        for (i = 0; i < s->naux_block; i++) {
-            if (!s->aux_block[i] || s->aux_block[i] == s->block[0])
-                continue;
-
-            if (s->aux_block[i]->method != RAW)
-                continue;
-
-            if (cram_compress_block2(fd, s, s->aux_block[i], s->aux_block[i]->m,
-                                     method, level))
-                return -1;
-        }
-    }
-
-    /*
-     * Minimal compression of any block still uncompressed, bar CORE
-     */
-    {
-        int i;
-        for (i = 1; i < s->hdr->num_blocks && i < DS_END; i++) {
-            if (!s->block[i] || s->block[i] == s->block[0])
-                continue;
-
-            if (s->block[i]->method != RAW)
-                continue;
-
-            if (cram_compress_block2(fd, s, s->block[i], fd->m[i],
-                                    methodF, level))
-                return -1;
-        }
-    }
-
-    return 0;
-}
-
-/*
- * Allocates a block associated with the cram codec associated with
- * data series ds_id or the internal codec_id (depending on codec
- * type).
- *
- * The ds_ids are what end up written to disk as an external block.
- * The c_ids are internal and used when daisy-chaining transforms
- * such as MAP and RLE.  These blocks are also allocated, but
- * are ephemeral in nature.  (The codecs themselves cannot allocate
- * these as the same codec pointer may be operating on multiple slices
- * if we're using a multi-slice container.)
- *
- * Returns 0 on success
- *        -1 on failure
- */
-static int cram_allocate_block(cram_codec *codec, cram_slice *s, int ds_id) {
-    if (!codec)
-        return 0;
-
-    switch(codec->codec) {
-    // Codecs which are hard-coded to use the CORE block
-    case E_GOLOMB:
-    case E_HUFFMAN:
-    case E_BETA:
-    case E_SUBEXP:
-    case E_GOLOMB_RICE:
-    case E_GAMMA:
-        codec->out = s->block[0];
-        break;
-
-    // Codecs which don't use external blocks
-    case E_CONST_BYTE:
-    case E_CONST_INT:
-       codec->out = NULL;
-       break;
-
-    // Codecs that emit directly to external blocks
-    case E_EXTERNAL:
-    case E_VARINT_UNSIGNED:
-    case E_VARINT_SIGNED:
-        if (!(s->block[ds_id] = cram_new_block(EXTERNAL, ds_id)))
-            return -1;
-        codec->u.external.content_id = ds_id;
-        codec->out = s->block[ds_id];
-        break;
-
-    case E_BYTE_ARRAY_STOP: // Why no sub-codec?
-        if (!(s->block[ds_id] = cram_new_block(EXTERNAL, ds_id)))
-            return -1;
-        codec->u.byte_array_stop.content_id = ds_id;
-        codec->out = s->block[ds_id];
-        break;
-
-
-    // Codecs that contain sub-codecs which may in turn emit to external blocks
-    case E_BYTE_ARRAY_LEN: {
-        cram_codec *bal = codec->u.e_byte_array_len.len_codec;
-        if (cram_allocate_block(bal, s, bal->u.external.content_id))
-            return -1;
-        bal = codec->u.e_byte_array_len.val_codec;
-        if (cram_allocate_block(bal, s, bal->u.external.content_id))
-            return -1;
-
-        break;
-    }
-
-    case E_XRLE:
-        if (cram_allocate_block(codec->u.e_xrle.len_codec, s, ds_id))
-                                //ds_id == DS_QS ? DS_QS_len : ds_id))
-            return -1;
-        if (cram_allocate_block(codec->u.e_xrle.lit_codec, s, ds_id))
-            return -1;
-
-        break;
-
-    case E_XPACK:
-        if (cram_allocate_block(codec->u.e_xpack.sub_codec, s, ds_id))
-            return -1;
-        codec->out = cram_new_block(0, 0); // ephemeral
-        if (!codec->out)
-            return -1;
-
-        break;
-
-    case E_XDELTA:
-        if (cram_allocate_block(codec->u.e_xdelta.sub_codec, s, ds_id))
-            return -1;
-        codec->out = cram_new_block(0, 0); // ephemeral
-        if (!codec->out)
-            return -1;
-
-        break;
-
-    default:
-        break;
-    }
-
-    return 0;
-}
-
-/*
- * Encodes a single slice from a container
- *
- * Returns 0 on success
- *        -1 on failure
- */
-static int cram_encode_slice(cram_fd *fd, cram_container *c,
-                             cram_block_compression_hdr *h, cram_slice *s) {
-    int rec, r = 0;
-    int64_t last_pos;
-    int embed_ref;
-    enum cram_DS_ID id;
-
-    embed_ref = fd->embed_ref && s->hdr->ref_seq_id != -1 ? 1 : 0;
-
-    /*
-     * Slice external blocks:
-     * ID 0 => base calls (insertions, soft-clip)
-     * ID 1 => qualities
-     * ID 2 => names
-     * ID 3 => TS (insert size), NP (next frag)
-     * ID 4 => tag values
-     * ID 6 => tag IDs (TN), if CRAM_V1.0
-     * ID 7 => TD tag dictionary, if !CRAM_V1.0
-     */
-
-    /* Create cram slice header */
-    s->hdr->ref_base_id = embed_ref && s->hdr->ref_seq_span > 0
-        ? DS_ref
-        : (CRAM_MAJOR_VERS(fd->version) >= 4 ? 0 : -1);
-    s->hdr->record_counter = c->num_records + c->record_counter;
-    c->num_records += s->hdr->num_records;
-
-    int ntags = c->tags_used ? c->tags_used->n_occupied : 0;
-    s->block = calloc(DS_END + ntags*2, sizeof(s->block[0]));
-    s->hdr->block_content_ids = malloc(DS_END * sizeof(int32_t));
-    if (!s->block || !s->hdr->block_content_ids)
-        return -1;
-
-    // Create first fixed blocks, always external.
-    // CORE
-    if (!(s->block[0] = cram_new_block(CORE, 0)))
-        return -1;
-
-    // TN block for CRAM v1
-    if (CRAM_MAJOR_VERS(fd->version) == 1) {
-        if (h->codecs[DS_TN]->codec == E_EXTERNAL) {
-            if (!(s->block[DS_TN] = cram_new_block(EXTERNAL,DS_TN))) return -1;
-            h->codecs[DS_TN]->u.external.content_id = DS_TN;
-        } else {
-            s->block[DS_TN] = s->block[0];
-        }
-    }
-
-    // Embedded reference
-    if (embed_ref) {
-        if (!(s->block[DS_ref] = cram_new_block(EXTERNAL, DS_ref)))
-            return -1;
-        s->ref_id = DS_ref; // needed?
-        BLOCK_APPEND(s->block[DS_ref],
-                     c->ref + s->hdr->ref_seq_start - c->ref_start,
-                     s->hdr->ref_seq_span);
-    }
-
-    /*
-     * All the data-series blocks if appropriate.
-     */
-    for (id = DS_QS; id < DS_TN; id++) {
-        if (cram_allocate_block(h->codecs[id], s, id) < 0)
-            return -1;
-    }
-
-    /*
-     * Add in the external tag blocks too.
-     */
-    if (c->tags_used) {
-        int n;
-        s->hdr->num_blocks = DS_END;
-        for (n = 0; n < s->naux_block; n++)
-            s->block[s->hdr->num_blocks++] = s->aux_block[n];
-    }
-
-    /* Encode reads */
-    last_pos = s->hdr->ref_seq_start;
-    for (rec = 0; rec < s->hdr->num_records; rec++) {
-        cram_record *cr = &s->crecs[rec];
-        if (cram_encode_slice_read(fd, c, h, s, cr, &last_pos) == -1)
-            return -1;
-    }
-
-    s->block[0]->uncomp_size = s->block[0]->byte + (s->block[0]->bit < 7);
-    s->block[0]->comp_size = s->block[0]->uncomp_size;
-
-    // Make sure the fixed blocks point to the correct sources
-    if (s->block[DS_IN]) cram_free_block(s->block[DS_IN]);
-    s->block[DS_IN] = s->base_blk; s->base_blk = NULL;
-    if (s->block[DS_QS]) cram_free_block(s->block[DS_QS]);
-    s->block[DS_QS] = s->qual_blk; s->qual_blk = NULL;
-    if (s->block[DS_RN]) cram_free_block(s->block[DS_RN]);
-    s->block[DS_RN] = s->name_blk; s->name_blk = NULL;
-    if (s->block[DS_SC]) cram_free_block(s->block[DS_SC]);
-    s->block[DS_SC] = s->soft_blk; s->soft_blk = NULL;
-
-    // Finalise any data transforms.
-    for (id = DS_QS; id < DS_TN; id++) {
-       if (h->codecs[id] && h->codecs[id]->flush)
-           h->codecs[id]->flush(h->codecs[id]);
-    }
-
-    // Ensure block sizes are up to date.
-    for (id = 1; id < s->hdr->num_blocks; id++) {
-        if (!s->block[id] || s->block[id] == s->block[0])
-            continue;
-
-        if (s->block[id]->uncomp_size == 0)
-            BLOCK_UPLEN(s->block[id]);
-    }
-
-    // Compress it all
-    if (cram_compress_slice(fd, c, s) == -1)
-        return -1;
-
-    // Collapse empty blocks and create hdr_block
-    {
-        int i, j;
-
-        s->hdr->block_content_ids = realloc(s->hdr->block_content_ids,
-                                            s->hdr->num_blocks * sizeof(int32_t));
-        if (!s->hdr->block_content_ids)
-            return -1;
-
-        for (i = j = 1; i < s->hdr->num_blocks; i++) {
-            if (!s->block[i] || s->block[i] == s->block[0])
-                continue;
-            if (s->block[i]->uncomp_size == 0) {
-                cram_free_block(s->block[i]);
-                s->block[i] = NULL;
-                continue;
-            }
-            s->block[j] = s->block[i];
-            s->hdr->block_content_ids[j-1] = s->block[i]->content_id;
-            j++;
-        }
-        s->hdr->num_content_ids = j-1;
-        s->hdr->num_blocks = j;
-
-        if (!(s->hdr_block = cram_encode_slice_header(fd, s)))
-            return -1;
-    }
-
-    return r ? -1 : 0;
-
- block_err:
-    return -1;
-}
-
-/*
- * Returns the number of expected read names for this record.
- */
-static int expected_template_count(bam_seq_t *b) {
-    int expected = bam_flag(b) & BAM_FPAIRED ? 2 : 1;
-
-    uint8_t *TC = (uint8_t *)bam_aux_get(b, "TC");
-    if (TC) {
-        int n = bam_aux2i(TC);
-        if (expected < n)
-            expected = n;
-    }
-
-    if (!TC && bam_aux_get(b, "SA")) {
-        // We could count the semicolons, but we'd have to do this for
-        // read1, read2 and read(not-1-or-2) combining the results
-        // together.  This is a cheap and safe alternative for now.
-        expected = INT_MAX;
-    }
-
-    return expected;
-}
-
-/*
- * Lossily reject read names.
- *
- * The rule here is that if all reads for this template reside in the
- * same slice then we can lose the name.  Otherwise we keep them as we
- * do not know when (or if) the other reads will turn up.
- *
- * Note there may be only 1 read (non-paired library) or more than 2
- * reads (paired library with supplementary reads), or other weird
- * setups.  We need to know how many are expected.  Ways to guess:
- *
- * - Flags (0x1 - has > 1 read)
- * - TC aux field (not mandatory)
- * - SA tags (count semicolons, NB per fragment so sum - hard)
- * - RNEXT/PNEXT uniqueness count. (not implemented, tricky)
- *
- * Returns 0 on success
- *        -1 on failure
- */
-static int lossy_read_names(cram_fd *fd, cram_container *c, cram_slice *s,
-                            int bam_start) {
-    int r1, r2, ret = -1;
-
-    // Initialise cram_flags
-    for (r2 = 0; r2 < s->hdr->num_records; r2++)
-        s->crecs[r2].cram_flags = 0;
-
-    if (!fd->lossy_read_names)
-        return 0;
-
-    khash_t(m_s2u64) *names = kh_init(m_s2u64);
-    if (!names)
-        goto fail;
-
-    // 1: Iterate through names to count frequency
-    for (r1 = bam_start, r2 = 0; r2 < s->hdr->num_records; r1++, r2++) {
-        //cram_record *cr = &s->crecs[r2];
-        bam_seq_t *b = c->bams[r1];
-        khint_t k;
-        int n;
-        uint64_t e;
-        union {
-            uint64_t i64;
-            struct {
-                int32_t e,c; // expected & observed counts.
-            } counts;
-        } u;
-
-        e = expected_template_count(b);
-        u.counts.e = e; u.counts.c = 1;
-
-        k = kh_put(m_s2u64, names, bam_name(b), &n);
-        if (n == -1)
-            goto fail;
-
-        if (n == 0) {
-            // not a new name
-            u.i64 = kh_val(names, k);
-            if (u.counts.e != e) {
-                // different expectation or already hit the max
-                //fprintf(stderr, "Err computing no. %s recs\n", bam_name(b));
-                kh_val(names, k) = 0;
-            } else {
-                u.counts.c++;
-                if (u.counts.e == u.counts.c) {
-                    // Reached expected count.
-                    kh_val(names, k) = -1;
-                } else {
-                    kh_val(names, k) = u.i64;
-                }
-            }
-        } else {
-            // new name
-            kh_val(names, k) = u.i64;
-        }
-    }
-
-    // 2: Remove names if all present (hd.i == -1)
-    for (r1 = bam_start, r2 = 0; r2 < s->hdr->num_records; r1++, r2++) {
-        cram_record *cr = &s->crecs[r2];
-        bam_seq_t *b = c->bams[r1];
-        khint_t k;
-
-        k = kh_get(m_s2u64, names, bam_name(b));
-
-        if (k == kh_end(names))
-            goto fail;
-
-        if (kh_val(names, k) == -1)
-            cr->cram_flags = CRAM_FLAG_DISCARD_NAME;
-    }
-
-    ret = 0;
- fail: // ret==-1
-
-    if (names)
-        kh_destroy(m_s2u64, names);
-
-    return ret;
-}
-
-/*
- * Adds the reading names.  We do this here as a separate pass rather
- * than per record in the process_one_read calls as that function can
- * go back and change the CRAM_FLAG_DETACHED status of a previously
- * processed read if it subsequently determines the TLEN field is
- * incorrect.  Given DETACHED reads always try to decode read names,
- * we need to know their status before generating the read-name block.
- *
- * Output is an update s->name_blk, and cr->name / cr->name_len
- * fields.
- */
-static int add_read_names(cram_fd *fd, cram_container *c, cram_slice *s,
-                          int bam_start) {
-    int r1, r2;
-    int keep_names = !fd->lossy_read_names;
-
-    for (r1 = bam_start, r2 = 0;
-         r1 < c->curr_c_rec && r2 < s->hdr->num_records;
-         r1++, r2++) {
-        cram_record *cr = &s->crecs[r2];
-        bam_seq_t *b = c->bams[r1];
-
-        cr->name        = BLOCK_SIZE(s->name_blk);
-        if ((cr->cram_flags & CRAM_FLAG_DETACHED) || keep_names) {
-            if (CRAM_MAJOR_VERS(fd->version) >= 4
-                && (cr->cram_flags & CRAM_FLAG_MATE_DOWNSTREAM)
-                && cr->mate_line) {
-                // Dedup read names in V4
-                BLOCK_APPEND(s->name_blk, "\0", 1);
-                cr->name_len    = 1;
-            } else {
-                BLOCK_APPEND(s->name_blk, bam_name(b), bam_name_len(b));
-                cr->name_len    = bam_name_len(b);
-            }
-        } else {
-            // Can only discard duplicate names if not detached
-            cr->name_len = 0;
-        }
-
-        if (cram_stats_add(c->stats[DS_RN], cr->name_len) < 0)
-            goto block_err;
-    }
-
-    return 0;
-
- block_err:
-    return -1;
-}
-
-/*
- * Encodes all slices in a container into blocks.
- * Returns 0 on success
- *        -1 on failure
- */
-int cram_encode_container(cram_fd *fd, cram_container *c) {
-    int i, j, slice_offset;
-    cram_block_compression_hdr *h = c->comp_hdr;
-    cram_block *c_hdr;
-    int multi_ref = 0;
-    int r1, r2, sn, nref;
-    spare_bams *spares;
-
-    if (CRAM_MAJOR_VERS(fd->version) == 1)
-        goto err;
-
-//#define goto_err {fprintf(stderr, "ERR at %s:%d\n", __FILE__, __LINE__);goto err;}
-#define goto_err goto err
-
-    /* Cache references up-front if we have unsorted access patterns */
-    pthread_mutex_lock(&fd->ref_lock);
-    nref = fd->refs->nref;
-    pthread_mutex_unlock(&fd->ref_lock);
-
-    if (!fd->no_ref && c->refs_used) {
-        for (i = 0; i < nref; i++) {
-            if (c->refs_used[i])
-                cram_get_ref(fd, i, 1, 0);
-        }
-    }
-
-    /* To create M5 strings */
-    /* Fetch reference sequence */
-    if (!fd->no_ref) {
-        if (!c->bams || !c->bams[0])
-            goto_err;
-        bam_seq_t *b = c->bams[0];
-
-        char *ref = cram_get_ref(fd, bam_ref(b), 1, 0);
-        if (!ref && bam_ref(b) >= 0) {
-            hts_log_error("Failed to load reference #%d", bam_ref(b));
-            return -1;
-        }
-        if ((c->ref_id = bam_ref(b)) >= 0) {
-            c->ref_seq_id = c->ref_id;
-            c->ref       = fd->refs->ref_id[c->ref_seq_id]->seq;
-            c->ref_start = 1;
-            c->ref_end   = fd->refs->ref_id[c->ref_seq_id]->length;
-        } else {
-            c->ref_seq_id = c->ref_id; // FIXME remove one var!
-        }
-    } else {
-        c->ref_id = bam_ref(c->bams[0]);
-        cram_ref_incr(fd->refs, c->ref_id);
-        c->ref_seq_id = c->ref_id;
-    }
-
-    /* Turn bams into cram_records and gather basic stats */
-    for (r1 = sn = 0; r1 < c->curr_c_rec; sn++) {
-        cram_slice *s = c->slices[sn];
-        int64_t first_base = INT64_MAX, last_base = INT64_MIN;
-
-        int r1_start = r1;
-
-        assert(sn < c->curr_slice);
-
-        // Discover which read names *may* be safely removed.
-        // Ie which ones have all their records in this slice.
-        if (lossy_read_names(fd, c, s, r1_start) != 0)
-            return -1;
-
-        // Tracking of MD tags so we can spot when the auto-generated values
-        // will differ from the current stored ones.  The kstring here is
-        // simply to avoid excessive malloc and free calls.  All initialisation
-        // is done within process_one_read().
-        kstring_t MD = {0};
-
-        // Iterate through records creating the cram blocks for some
-        // fields and just gathering stats for others.
-        for (r2 = 0; r1 < c->curr_c_rec && r2 < s->hdr->num_records; r1++, r2++) {
-            cram_record *cr = &s->crecs[r2];
-            bam_seq_t *b = c->bams[r1];
-
-            /* If multi-ref we need to cope with changing reference per seq */
-            if (c->multi_seq && !fd->no_ref) {
-                if (bam_ref(b) != c->ref_seq_id && bam_ref(b) >= 0) {
-                    if (c->ref_seq_id >= 0)
-                        cram_ref_decr(fd->refs, c->ref_seq_id);
-
-                    if (!cram_get_ref(fd, bam_ref(b), 1, 0)) {
-                        hts_log_error("Failed to load reference #%d", bam_ref(b));
-                        free(MD.s);
-                        return -1;
-                    }
-
-                    c->ref_seq_id = bam_ref(b); // overwritten later by -2
-                    if (!fd->refs->ref_id[c->ref_seq_id]->seq)
-                        return -1;
-                    c->ref       = fd->refs->ref_id[c->ref_seq_id]->seq;
-                    c->ref_start = 1;
-                    c->ref_end   = fd->refs->ref_id[c->ref_seq_id]->length;
-                }
-            }
-
-            if (process_one_read(fd, c, s, cr, b, r2, &MD) != 0) {
-                free(MD.s);
-                return -1;
-            }
-
-            if (first_base > cr->apos)
-                first_base = cr->apos;
-
-            if (last_base < cr->aend)
-                last_base = cr->aend;
-        }
-        free(MD.s);
-
-        // Process_one_read doesn't add read names as it can change
-        // its mind during the loop on the CRAM_FLAG_DETACHED setting
-        // of earlier records (if it detects the auto-generation of
-        // TLEN is incorrect).  This affects which read-names can be
-        // lossily compressed, so we do these in another pass.
-        if (add_read_names(fd, c, s, r1_start) < 0)
-            return -1;
-
-        if (c->multi_seq) {
-            s->hdr->ref_seq_id    = -2;
-            s->hdr->ref_seq_start = 0;
-            s->hdr->ref_seq_span  = 0;
-        } else {
-            s->hdr->ref_seq_id    = c->ref_id;
-            s->hdr->ref_seq_start = first_base;
-            s->hdr->ref_seq_span  = MAX(0, last_base - first_base + 1);
-        }
-        s->hdr->num_records = r2;
-
-        // Processed a slice, now stash the aux blocks so the next
-        // slice can start aggregating them from the start again.
-        if (c->tags_used->n_occupied) {
-            int ntags = c->tags_used->n_occupied;
-            s->aux_block = calloc(ntags*2, sizeof(*s->aux_block));
-            if (!s->aux_block)
-                return -1;
-
-            khint_t k;
-
-            s->naux_block = 0;
-            for (k = kh_begin(c->tags_used); k != kh_end(c->tags_used); k++) {
-                if (!kh_exist(c->tags_used, k))
-                    continue;
-
-                cram_tag_map *tm = kh_val(c->tags_used, k);
-                if (!tm) goto_err;
-                if (!tm->blk) continue;
-                s->aux_block[s->naux_block++] = tm->blk;
-                tm->blk = NULL;
-                if (!tm->blk2) continue;
-                s->aux_block[s->naux_block++] = tm->blk2;
-                tm->blk2 = NULL;
-            }
-            assert(s->naux_block <= 2*c->tags_used->n_occupied);
-        }
-    }
-
-    if (c->multi_seq && !fd->no_ref) {
-        if (c->ref_seq_id >= 0)
-            cram_ref_decr(fd->refs, c->ref_seq_id);
-    }
-
-    /* Link our bams[] array onto the spare bam list for reuse */
-    spares = malloc(sizeof(*spares));
-    if (!spares) goto_err;
-    pthread_mutex_lock(&fd->bam_list_lock);
-    spares->bams = c->bams;
-    spares->next = fd->bl;
-    fd->bl = spares;
-    pthread_mutex_unlock(&fd->bam_list_lock);
-    c->bams = NULL;
-
-    /* Detect if a multi-seq container */
-    cram_stats_encoding(fd, c->stats[DS_RI]);
-    multi_ref = c->stats[DS_RI]->nvals > 1;
-    pthread_mutex_lock(&fd->metrics_lock);
-    fd->last_RI_count = c->stats[DS_RI]->nvals;
-    pthread_mutex_unlock(&fd->metrics_lock);
-
-
-    if (multi_ref) {
-        hts_log_info("Multi-ref container");
-        c->ref_seq_id = -2;
-        c->ref_seq_start = 0;
-        c->ref_seq_span = 0;
-    }
-
-
-    /* Compute MD5s */
-    int is_v4 = CRAM_MAJOR_VERS(fd->version) >= 4 ? 1 : 0;
-    for (i = 0; i < c->curr_slice; i++) {
-        cram_slice *s = c->slices[i];
-
-        if (CRAM_MAJOR_VERS(fd->version) != 1) {
-            if (s->hdr->ref_seq_id >= 0 && c->multi_seq == 0 && !fd->no_ref) {
-                hts_md5_context *md5 = hts_md5_init();
-                if (!md5)
-                    return -1;
-                hts_md5_update(md5,
-                               c->ref + s->hdr->ref_seq_start - c->ref_start,
-                               s->hdr->ref_seq_span);
-                hts_md5_final(s->hdr->md5, md5);
-                hts_md5_destroy(md5);
-            } else {
-                memset(s->hdr->md5, 0, 16);
-            }
-        }
-    }
-
-    c->num_records = 0;
-    c->num_blocks = 1; // cram_block_compression_hdr
-    c->length = 0;
-
-    //fprintf(stderr, "=== BF ===\n");
-    h->codecs[DS_BF] = cram_encoder_init(cram_stats_encoding(fd, c->stats[DS_BF]),
-                                         c->stats[DS_BF], E_INT, NULL,
-                                         fd->version, &fd->vv);
-    if (c->stats[DS_BF]->nvals && !h->codecs[DS_BF]) goto_err;
-
-    //fprintf(stderr, "=== CF ===\n");
-    h->codecs[DS_CF] = cram_encoder_init(cram_stats_encoding(fd, c->stats[DS_CF]),
-                                         c->stats[DS_CF], E_INT, NULL,
-                                         fd->version, &fd->vv);
-    if (c->stats[DS_CF]->nvals && !h->codecs[DS_CF]) goto_err;
-
-    //fprintf(stderr, "=== RN ===\n");
-    //h->codecs[DS_RN] = cram_encoder_init(cram_stats_encoding(fd, c->stats[DS_RN]),
-    //                                     c->stats[DS_RN], E_BYTE_ARRAY, NULL,
-    //                                     fd->version);
-
-    //fprintf(stderr, "=== AP ===\n");
-    if (c->pos_sorted || CRAM_MAJOR_VERS(fd->version) >= 4) {
-        if (c->pos_sorted)
-            h->codecs[DS_AP] = cram_encoder_init(cram_stats_encoding(fd, c->stats[DS_AP]),
-                                                 c->stats[DS_AP],
-                                                 is_v4 ? E_LONG : E_INT,
-                                                 NULL, fd->version, &fd->vv);
-        else
-            // Unsorted data has no stats, but hard-code VARINT_SIGNED / EXT.
-            h->codecs[DS_AP] = cram_encoder_init(is_v4 ? E_VARINT_SIGNED
-                                                       : E_EXTERNAL,
-                                                 NULL,
-                                                 is_v4 ? E_LONG : E_INT,
-                                                 NULL, fd->version, &fd->vv);
-    } else {
-        // Removed BETA in v4.0.
-        // Should we consider dropping use of it for 3.0 too?
-        int p[2] = {0, c->max_apos};
-        h->codecs[DS_AP] = cram_encoder_init(E_BETA, NULL,
-                                             is_v4 ? E_LONG : E_INT,
-                                             p, fd->version, &fd->vv);
-//      cram_xdelta_encoder e;
-//      e.word_size = is_v4 ? 8 : 4;
-//      e.sub_encoding = E_EXTERNAL;
-//      e.sub_codec_dat = (void *)DS_AP;
-//
-//      h->codecs[DS_AP] = cram_encoder_init(E_XDELTA, NULL,
-//                                           is_v4 ? E_LONG : E_INT,
-//                                           &e, fd->version, &fd->vv);
-    }
-    if (!h->codecs[DS_AP]) goto_err;
-
-    //fprintf(stderr, "=== RG ===\n");
-    h->codecs[DS_RG] = cram_encoder_init(cram_stats_encoding(fd, c->stats[DS_RG]),
-                                         c->stats[DS_RG],
-                                         E_INT,
-                                         NULL,
-                                         fd->version, &fd->vv);
-    if (c->stats[DS_RG]->nvals && !h->codecs[DS_RG]) goto_err;
-
-    //fprintf(stderr, "=== MQ ===\n");
-    h->codecs[DS_MQ] = cram_encoder_init(cram_stats_encoding(fd, c->stats[DS_MQ]),
-                                         c->stats[DS_MQ], E_INT, NULL,
-                                         fd->version, &fd->vv);
-    if (c->stats[DS_MQ]->nvals && !h->codecs[DS_MQ]) goto_err;
-
-    //fprintf(stderr, "=== NS ===\n");
-    h->codecs[DS_NS] = cram_encoder_init(cram_stats_encoding(fd, c->stats[DS_NS]),
-                                         c->stats[DS_NS], E_INT, NULL,
-                                         fd->version, &fd->vv);
-    if (c->stats[DS_NS]->nvals && !h->codecs[DS_NS]) goto_err;
-
-    //fprintf(stderr, "=== MF ===\n");
-    h->codecs[DS_MF] = cram_encoder_init(cram_stats_encoding(fd, c->stats[DS_MF]),
-                                         c->stats[DS_MF], E_INT, NULL,
-                                         fd->version, &fd->vv);
-    if (c->stats[DS_MF]->nvals && !h->codecs[DS_MF]) goto_err;
-
-    //fprintf(stderr, "=== TS ===\n");
-    h->codecs[DS_TS] = cram_encoder_init(cram_stats_encoding(fd, c->stats[DS_TS]),
-                                         c->stats[DS_TS],
-                                         is_v4 ? E_LONG : E_INT,
-                                         NULL, fd->version, &fd->vv);
-    if (c->stats[DS_TS]->nvals && !h->codecs[DS_TS]) goto_err;
-
-    //fprintf(stderr, "=== NP ===\n");
-    h->codecs[DS_NP] = cram_encoder_init(cram_stats_encoding(fd, c->stats[DS_NP]),
-                                         c->stats[DS_NP],
-                                         is_v4 ? E_LONG : E_INT,
-                                         NULL, fd->version, &fd->vv);
-    if (c->stats[DS_NP]->nvals && !h->codecs[DS_NP]) goto_err;
-
-    //fprintf(stderr, "=== NF ===\n");
-    h->codecs[DS_NF] = cram_encoder_init(cram_stats_encoding(fd, c->stats[DS_NF]),
-                                         c->stats[DS_NF], E_INT, NULL,
-                                         fd->version, &fd->vv);
-    if (c->stats[DS_NF]->nvals && !h->codecs[DS_NF]) goto_err;
-
-    //fprintf(stderr, "=== RL ===\n");
-    h->codecs[DS_RL] = cram_encoder_init(cram_stats_encoding(fd, c->stats[DS_RL]),
-                                         c->stats[DS_RL], E_INT, NULL,
-                                         fd->version, &fd->vv);
-    if (c->stats[DS_RL]->nvals && !h->codecs[DS_RL]) goto_err;
-
-    //fprintf(stderr, "=== FN ===\n");
-    h->codecs[DS_FN] = cram_encoder_init(cram_stats_encoding(fd, c->stats[DS_FN]),
-                                         c->stats[DS_FN], E_INT, NULL,
-                                         fd->version, &fd->vv);
-    if (c->stats[DS_FN]->nvals && !h->codecs[DS_FN]) goto_err;
-
-    //fprintf(stderr, "=== FC ===\n");
-    h->codecs[DS_FC] = cram_encoder_init(cram_stats_encoding(fd, c->stats[DS_FC]),
-                                         c->stats[DS_FC], E_BYTE, NULL,
-                                         fd->version, &fd->vv);
-    if (c->stats[DS_FC]->nvals && !h->codecs[DS_FC]) goto_err;
-
-    //fprintf(stderr, "=== FP ===\n");
-    h->codecs[DS_FP] = cram_encoder_init(cram_stats_encoding(fd, c->stats[DS_FP]),
-                                         c->stats[DS_FP], E_INT, NULL,
-                                         fd->version, &fd->vv);
-    if (c->stats[DS_FP]->nvals && !h->codecs[DS_FP]) goto_err;
-
-    //fprintf(stderr, "=== DL ===\n");
-    h->codecs[DS_DL] = cram_encoder_init(cram_stats_encoding(fd, c->stats[DS_DL]),
-                                         c->stats[DS_DL], E_INT, NULL,
-                                         fd->version, &fd->vv);
-    if (c->stats[DS_DL]->nvals && !h->codecs[DS_DL]) goto_err;
-
-    //fprintf(stderr, "=== BA ===\n");
-    h->codecs[DS_BA] = cram_encoder_init(cram_stats_encoding(fd, c->stats[DS_BA]),
-                                         c->stats[DS_BA], E_BYTE, NULL,
-                                         fd->version, &fd->vv);
-    if (c->stats[DS_BA]->nvals && !h->codecs[DS_BA]) goto_err;
-
-    if (CRAM_MAJOR_VERS(fd->version) >= 3) {
-        cram_byte_array_len_encoder e;
-
-        e.len_encoding = CRAM_MAJOR_VERS(fd->version) >= 4
-            ? E_VARINT_UNSIGNED
-            : E_EXTERNAL;
-        e.len_dat = (void *)DS_BB_len;
-        //e.len_dat = (void *)DS_BB;
-
-        e.val_encoding = E_EXTERNAL;
-        e.val_dat = (void *)DS_BB;
-
-        h->codecs[DS_BB] = cram_encoder_init(E_BYTE_ARRAY_LEN, NULL,
-                                             E_BYTE_ARRAY, (void *)&e,
-                                             fd->version, &fd->vv);
-        if (!h->codecs[DS_BB]) goto_err;
-    } else {
-        h->codecs[DS_BB] = NULL;
-    }
-
-    //fprintf(stderr, "=== BS ===\n");
-    h->codecs[DS_BS] = cram_encoder_init(cram_stats_encoding(fd, c->stats[DS_BS]),
-                                         c->stats[DS_BS], E_BYTE, NULL,
-                                         fd->version, &fd->vv);
-    if (c->stats[DS_BS]->nvals && !h->codecs[DS_BS]) goto_err;
-
-    if (CRAM_MAJOR_VERS(fd->version) == 1) {
-        h->codecs[DS_TL] = NULL;
-        h->codecs[DS_RI] = NULL;
-        h->codecs[DS_RS] = NULL;
-        h->codecs[DS_PD] = NULL;
-        h->codecs[DS_HC] = NULL;
-        h->codecs[DS_SC] = NULL;
-
-        //fprintf(stderr, "=== TC ===\n");
-        h->codecs[DS_TC] = cram_encoder_init(cram_stats_encoding(fd, c->stats[DS_TC]),
-                                             c->stats[DS_TC], E_BYTE, NULL,
-                                             fd->version, &fd->vv);
-        if (c->stats[DS_TC]->nvals && !h->codecs[DS_TC]) goto_err;
-
-        //fprintf(stderr, "=== TN ===\n");
-        h->codecs[DS_TN] = cram_encoder_init(cram_stats_encoding(fd, c->stats[DS_TN]),
-                                             c->stats[DS_TN], E_INT, NULL,
-                                             fd->version, &fd->vv);
-        if (c->stats[DS_TN]->nvals && !h->codecs[DS_TN]) goto_err;
-    } else {
-        h->codecs[DS_TC] = NULL;
-        h->codecs[DS_TN] = NULL;
-
-        //fprintf(stderr, "=== TL ===\n");
-        h->codecs[DS_TL] = cram_encoder_init(cram_stats_encoding(fd, c->stats[DS_TL]),
-                                             c->stats[DS_TL], E_INT, NULL,
-                                             fd->version, &fd->vv);
-        if (c->stats[DS_TL]->nvals && !h->codecs[DS_TL]) goto_err;
-
-
-        //fprintf(stderr, "=== RI ===\n");
-        h->codecs[DS_RI] = cram_encoder_init(cram_stats_encoding(fd, c->stats[DS_RI]),
-                                             c->stats[DS_RI], E_INT, NULL,
-                                             fd->version, &fd->vv);
-        if (c->stats[DS_RI]->nvals && !h->codecs[DS_RI]) goto_err;
-
-        //fprintf(stderr, "=== RS ===\n");
-        h->codecs[DS_RS] = cram_encoder_init(cram_stats_encoding(fd, c->stats[DS_RS]),
-                                             c->stats[DS_RS], E_INT, NULL,
-                                             fd->version, &fd->vv);
-        if (c->stats[DS_RS]->nvals && !h->codecs[DS_RS]) goto_err;
-
-        //fprintf(stderr, "=== PD ===\n");
-        h->codecs[DS_PD] = cram_encoder_init(cram_stats_encoding(fd, c->stats[DS_PD]),
-                                             c->stats[DS_PD], E_INT, NULL,
-                                             fd->version, &fd->vv);
-        if (c->stats[DS_PD]->nvals && !h->codecs[DS_PD]) goto_err;
-
-        //fprintf(stderr, "=== HC ===\n");
-        h->codecs[DS_HC] = cram_encoder_init(cram_stats_encoding(fd, c->stats[DS_HC]),
-                                             c->stats[DS_HC], E_INT, NULL,
-                                             fd->version, &fd->vv);
-        if (c->stats[DS_HC]->nvals && !h->codecs[DS_HC]) goto_err;
-
-        //fprintf(stderr, "=== SC ===\n");
-        if (1) {
-            int i2[2] = {0, DS_SC};
-
-            h->codecs[DS_SC] = cram_encoder_init(E_BYTE_ARRAY_STOP, NULL,
-                                                 E_BYTE_ARRAY, (void *)i2,
-                                                 fd->version, &fd->vv);
-        } else {
-            // Appears to be no practical benefit to using this method,
-            // but it may work better if we start mixing SC, IN and BB
-            // elements into the same external block.
-            cram_byte_array_len_encoder e;
-
-            e.len_encoding = CRAM_MAJOR_VERS(fd->version) >= 4
-                ? E_VARINT_UNSIGNED
-                : E_EXTERNAL;
-            e.len_dat = (void *)DS_SC_len;
-
-            e.val_encoding = E_EXTERNAL;
-            e.val_dat = (void *)DS_SC;
-
-            h->codecs[DS_SC] = cram_encoder_init(E_BYTE_ARRAY_LEN, NULL,
-                                                 E_BYTE_ARRAY, (void *)&e,
-                                                 fd->version, &fd->vv);
-        }
-        if (!h->codecs[DS_SC]) goto_err;
-    }
-
-    //fprintf(stderr, "=== IN ===\n");
-    {
-        int i2[2] = {0, DS_IN};
-        h->codecs[DS_IN] = cram_encoder_init(E_BYTE_ARRAY_STOP, NULL,
-                                             E_BYTE_ARRAY, (void *)i2,
-                                             fd->version, &fd->vv);
-        if (!h->codecs[DS_IN]) goto_err;
-    }
-
-    h->codecs[DS_QS] = cram_encoder_init(E_EXTERNAL, NULL, E_BYTE,
-                                         (void *)DS_QS,
-                                         fd->version, &fd->vv);
-    if (!h->codecs[DS_QS]) goto_err;
-    {
-        int i2[2] = {0, DS_RN};
-        h->codecs[DS_RN] = cram_encoder_init(E_BYTE_ARRAY_STOP, NULL,
-                                             E_BYTE_ARRAY, (void *)i2,
-                                             fd->version, &fd->vv);
-        if (!h->codecs[DS_RN]) goto_err;
-    }
-
-
-    /* Encode slices */
-    for (i = 0; i < c->curr_slice; i++) {
-        hts_log_info("Encode slice %d", i);
-
-        if (cram_encode_slice(fd, c, h, c->slices[i]) != 0)
-            return -1;
-    }
-
-    /* Create compression header */
-    {
-        h->ref_seq_id    = c->ref_seq_id;
-        h->ref_seq_start = c->ref_seq_start;
-        h->ref_seq_span  = c->ref_seq_span;
-        h->num_records   = c->num_records;
-        h->qs_seq_orient = c->qs_seq_orient;
-        // slight misnomer - sorted or treat as-if sorted (ap_delta force to 1)
-        h->AP_delta      = c->pos_sorted;
-        memcpy(h->substitution_matrix, CRAM_SUBST_MATRIX, 20);
-
-        if (!(c_hdr = cram_encode_compression_header(fd, c, h)))
-            return -1;
-    }
-
-    /* Compute landmarks */
-    /* Fill out slice landmarks */
-    c->num_landmarks = c->curr_slice;
-    c->landmark = malloc(c->num_landmarks * sizeof(*c->landmark));
-    if (!c->landmark)
-        return -1;
-
-    /*
-     * Slice offset starts after the first block, so we need to simulate
-     * writing it to work out the correct offset
-     */
-    {
-        slice_offset = c_hdr->method == RAW
-            ? c_hdr->uncomp_size
-            : c_hdr->comp_size;
-        slice_offset += 2 + 4*(CRAM_MAJOR_VERS(fd->version) >= 3) +
-            fd->vv.varint_size(c_hdr->content_id) +
-            fd->vv.varint_size(c_hdr->comp_size) +
-            fd->vv.varint_size(c_hdr->uncomp_size);
-    }
-
-    c->ref_seq_id    = c->slices[0]->hdr->ref_seq_id;
-    c->ref_seq_start = c->slices[0]->hdr->ref_seq_start;
-    c->ref_seq_span  = c->slices[0]->hdr->ref_seq_span;
-    for (i = 0; i < c->curr_slice; i++) {
-        cram_slice *s = c->slices[i];
-
-        c->num_blocks += s->hdr->num_blocks + 1; // slice header
-        c->landmark[i] = slice_offset;
-
-        if (s->hdr->ref_seq_start + s->hdr->ref_seq_span >
-            c->ref_seq_start + c->ref_seq_span) {
-            c->ref_seq_span = s->hdr->ref_seq_start + s->hdr->ref_seq_span
-                - c->ref_seq_start;
-        }
-
-        slice_offset += s->hdr_block->method == RAW
-            ? s->hdr_block->uncomp_size
-            : s->hdr_block->comp_size;
-
-        slice_offset += 2 + 4*(CRAM_MAJOR_VERS(fd->version) >= 3) +
-            fd->vv.varint_size(s->hdr_block->content_id) +
-            fd->vv.varint_size(s->hdr_block->comp_size) +
-            fd->vv.varint_size(s->hdr_block->uncomp_size);
-
-        for (j = 0; j < s->hdr->num_blocks; j++) {
-            slice_offset += 2 + 4*(CRAM_MAJOR_VERS(fd->version) >= 3) +
-                fd->vv.varint_size(s->block[j]->content_id) +
-                fd->vv.varint_size(s->block[j]->comp_size) +
-                fd->vv.varint_size(s->block[j]->uncomp_size);
-
-            slice_offset += s->block[j]->method == RAW
-                ? s->block[j]->uncomp_size
-                : s->block[j]->comp_size;
-        }
-    }
-    c->length += slice_offset; // just past the final slice
-
-    c->comp_hdr_block = c_hdr;
-
-    if (c->ref_seq_id >= 0) {
-        cram_ref_decr(fd->refs, c->ref_seq_id);
-    }
-
-    /* Cache references up-front if we have unsorted access patterns */
-    if (!fd->no_ref && c->refs_used) {
-        for (i = 0; i < fd->refs->nref; i++) {
-            if (c->refs_used[i])
-                cram_ref_decr(fd->refs, i);
-        }
-    }
-
-    return 0;
-
- err:
-    return -1;
-}
-
-
-/*
- * Adds a feature code to a read within a slice. For purposes of minimising
- * memory allocations and fragmentation we have one array of features for all
- * reads within the slice. We return the index into this array for this new
- * feature.
- *
- * Returns feature index on success
- *         -1 on failure.
- */
-static int cram_add_feature(cram_container *c, cram_slice *s,
-                            cram_record *r, cram_feature *f) {
-    if (s->nfeatures >= s->afeatures) {
-        s->afeatures = s->afeatures ? s->afeatures*2 : 1024;
-        s->features = realloc(s->features, s->afeatures*sizeof(*s->features));
-        if (!s->features)
-            return -1;
-    }
-
-    if (!r->nfeature++) {
-        r->feature = s->nfeatures;
-        if (cram_stats_add(c->stats[DS_FP], f->X.pos) < 0)
-            return -1;
-    } else {
-        if (cram_stats_add(c->stats[DS_FP],
-                           f->X.pos - s->features[r->feature + r->nfeature-2].X.pos) < 0)
-            return -1;
-
-    }
-    if (cram_stats_add(c->stats[DS_FC], f->X.code) < 0)
-        return -1;
-
-    s->features[s->nfeatures++] = *f;
-
-    return 0;
-}
-
-static int cram_add_substitution(cram_fd *fd, cram_container *c,
-                                 cram_slice *s, cram_record *r,
-                                 int pos, char base, char qual, char ref) {
-    cram_feature f;
-
-    // seq=ACGTN vs ref=ACGT or seq=ACGT vs ref=ACGTN
-    if (fd->L2[(uc)base]<4 || (fd->L2[(uc)base]<5 && fd->L2[(uc)ref]<4)) {
-        f.X.pos = pos+1;
-        f.X.code = 'X';
-        f.X.base = fd->cram_sub_matrix[ref&0x1f][base&0x1f];
-        if (cram_stats_add(c->stats[DS_BS], f.X.base) < 0)
-            return -1;
-    } else {
-        f.B.pos = pos+1;
-        f.B.code = 'B';
-        f.B.base = base;
-        f.B.qual = qual;
-        if (cram_stats_add(c->stats[DS_BA], f.B.base) < 0) return -1;
-        if (cram_stats_add(c->stats[DS_QS], f.B.qual) < 0) return -1;
-        BLOCK_APPEND_CHAR(s->qual_blk, qual);
-    }
-    return cram_add_feature(c, s, r, &f);
-
- block_err:
-    return -1;
-}
-
-static int cram_add_bases(cram_fd *fd, cram_container *c,
-                          cram_slice *s, cram_record *r,
-                          int pos, int len, char *base) {
-    cram_feature f;
-
-    f.b.pos = pos+1;
-    f.b.code = 'b';
-    f.b.seq_idx = base - (char *)BLOCK_DATA(s->seqs_blk);
-    f.b.len = len;
-
-    return cram_add_feature(c, s, r, &f);
-}
-
-static int cram_add_base(cram_fd *fd, cram_container *c,
-                         cram_slice *s, cram_record *r,
-                         int pos, char base, char qual) {
-    cram_feature f;
-    f.B.pos = pos+1;
-    f.B.code = 'B';
-    f.B.base = base;
-    f.B.qual = qual;
-    if (cram_stats_add(c->stats[DS_BA], base) < 0) return -1;
-    if (cram_stats_add(c->stats[DS_QS], qual) < 0) return -1;
-    BLOCK_APPEND_CHAR(s->qual_blk, qual);
-    return cram_add_feature(c, s, r, &f);
-
- block_err:
-    return -1;
-}
-
-static int cram_add_quality(cram_fd *fd, cram_container *c,
-                            cram_slice *s, cram_record *r,
-                            int pos, char qual) {
-    cram_feature f;
-    f.Q.pos = pos+1;
-    f.Q.code = 'Q';
-    f.Q.qual = qual;
-    if (cram_stats_add(c->stats[DS_QS], qual) < 0) return -1;
-    BLOCK_APPEND_CHAR(s->qual_blk, qual);
-    return cram_add_feature(c, s, r, &f);
-
- block_err:
-    return -1;
-}
-
-static int cram_add_deletion(cram_container *c, cram_slice *s, cram_record *r,
-                             int pos, int len, char *base) {
-    cram_feature f;
-    f.D.pos = pos+1;
-    f.D.code = 'D';
-    f.D.len = len;
-    if (cram_stats_add(c->stats[DS_DL], len) < 0) return -1;
-    return cram_add_feature(c, s, r, &f);
-}
-
-static int cram_add_softclip(cram_container *c, cram_slice *s, cram_record *r,
-                             int pos, int len, char *base, int version) {
-    cram_feature f;
-    f.S.pos = pos+1;
-    f.S.code = 'S';
-    f.S.len = len;
-    switch (CRAM_MAJOR_VERS(version)) {
-    case 1:
-        f.S.seq_idx = BLOCK_SIZE(s->base_blk);
-        BLOCK_APPEND(s->base_blk, base, len);
-        BLOCK_APPEND_CHAR(s->base_blk, '\0');
-        break;
-
-    case 2:
-    default:
-        f.S.seq_idx = BLOCK_SIZE(s->soft_blk);
-        if (base) {
-            BLOCK_APPEND(s->soft_blk, base, len);
-        } else {
-            int i;
-            for (i = 0; i < len; i++)
-                BLOCK_APPEND_CHAR(s->soft_blk, 'N');
-        }
-        BLOCK_APPEND_CHAR(s->soft_blk, '\0');
-        break;
-
-        //default:
-        //    // v3.0 onwards uses BB data-series
-        //    f.S.seq_idx = BLOCK_SIZE(s->soft_blk);
-    }
-    return cram_add_feature(c, s, r, &f);
-
- block_err:
-    return -1;
-}
-
-static int cram_add_hardclip(cram_container *c, cram_slice *s, cram_record *r,
-                             int pos, int len, char *base) {
-    cram_feature f;
-    f.S.pos = pos+1;
-    f.S.code = 'H';
-    f.S.len = len;
-    if (cram_stats_add(c->stats[DS_HC], len) < 0) return -1;
-    return cram_add_feature(c, s, r, &f);
-}
-
-static int cram_add_skip(cram_container *c, cram_slice *s, cram_record *r,
-                         int pos, int len, char *base) {
-    cram_feature f;
-    f.S.pos = pos+1;
-    f.S.code = 'N';
-    f.S.len = len;
-    if (cram_stats_add(c->stats[DS_RS], len) < 0) return -1;
-    return cram_add_feature(c, s, r, &f);
-}
-
-static int cram_add_pad(cram_container *c, cram_slice *s, cram_record *r,
-                        int pos, int len, char *base) {
-    cram_feature f;
-    f.S.pos = pos+1;
-    f.S.code = 'P';
-    f.S.len = len;
-    if (cram_stats_add(c->stats[DS_PD], len) < 0) return -1;
-    return cram_add_feature(c, s, r, &f);
-}
-
-static int cram_add_insertion(cram_container *c, cram_slice *s, cram_record *r,
-                              int pos, int len, char *base) {
-    cram_feature f;
-    f.I.pos = pos+1;
-    if (len == 1) {
-        char b = base ? *base : 'N';
-        f.i.code = 'i';
-        f.i.base = b;
-        if (cram_stats_add(c->stats[DS_BA], b) < 0) return -1;
-    } else {
-        f.I.code = 'I';
-        f.I.len = len;
-        f.S.seq_idx = BLOCK_SIZE(s->base_blk);
-        if (base) {
-            BLOCK_APPEND(s->base_blk, base, len);
-        } else {
-            int i;
-            for (i = 0; i < len; i++)
-                BLOCK_APPEND_CHAR(s->base_blk, 'N');
-        }
-        BLOCK_APPEND_CHAR(s->base_blk, '\0');
-    }
-    return cram_add_feature(c, s, r, &f);
-
- block_err:
-    return -1;
-}
-
-/*
- * Encodes auxiliary data. Largely duplicated from above, but done so to
- * keep it simple and avoid a myriad of version ifs.
- *
- * Returns the read-group parsed out of the BAM aux fields on success
- *         NULL on failure or no rg present, also sets "*err" to non-zero
- */
-static char *cram_encode_aux(cram_fd *fd, bam_seq_t *b, cram_container *c,
-                             cram_slice *s, cram_record *cr,
-                             int verbatim_NM, int verbatim_MD,
-                             int NM, kstring_t *MD,
-                             int *err) {
-    char *aux, *orig, *rg = NULL;
-    int aux_size = bam_get_l_aux(b);
-    cram_block *td_b = c->comp_hdr->TD_blk;
-    int TD_blk_size = BLOCK_SIZE(td_b), new;
-    char *key;
-    khint_t k;
-
-    if (err) *err = 1;
-
-    orig = aux = (char *)bam_aux(b);
-
-    // Copy aux keys to td_b and aux values to slice aux blocks
-    while (aux - orig < aux_size && aux[0] != 0) {
-        int r;
-
-        // RG:Z
-        if (aux[0] == 'R' && aux[1] == 'G' && aux[2] == 'Z') {
-            rg = &aux[3];
-            while (*aux++);
-            if (CRAM_MAJOR_VERS(fd->version) >= 4)
-                BLOCK_APPEND(td_b, "RG*", 3);
-            continue;
-        }
-
-        // MD:Z
-        if (aux[0] == 'M' && aux[1] == 'D' && aux[2] == 'Z') {
-            if (cr->len && !fd->no_ref && !(cr->flags & BAM_FUNMAP) && !verbatim_MD) {
-                if (MD && MD->s && strncasecmp(MD->s, aux+3, orig + aux_size - (aux+3)) == 0) {
-                    while (*aux++);
-                    if (CRAM_MAJOR_VERS(fd->version) >= 4)
-                        BLOCK_APPEND(td_b, "MD*", 3);
-                    continue;
-                }
-            }
-        }
-
-        // NM:i
-        if (aux[0] == 'N' && aux[1] == 'M') {
-            if (cr->len && !fd->no_ref && !(cr->flags & BAM_FUNMAP) && !verbatim_NM) {
-                int NM_ = bam_aux2i((uint8_t *)aux+2);
-                if (NM_ == NM) {
-                    switch(aux[2]) {
-                    case 'A': case 'C': case 'c': aux+=4; break;
-                    case 'S': case 's':           aux+=5; break;
-                    case 'I': case 'i': case 'f': aux+=7; break;
-                    default:
-                        hts_log_error("Unhandled type code for NM tag");
-                        return NULL;
-                    }
-                    if (CRAM_MAJOR_VERS(fd->version) >= 4)
-                        BLOCK_APPEND(td_b, "NM*", 3);
-                    continue;
-                }
-            }
-        }
-
-        BLOCK_APPEND(td_b, aux, 3);
-
-        // Container level tags_used, for TD series
-        // Maps integer key ('X0i') to cram_tag_map struct.
-        int key = (aux[0]<<16)|(aux[1]<<8)|aux[2];
-        k = kh_put(m_tagmap, c->tags_used, key, &r);
-        if (-1 == r)
-            return NULL;
-        else if (r != 0)
-            kh_val(c->tags_used, k) = NULL;
-
-        if (r == 1) {
-            khint_t k_global;
-
-            // Global tags_used for cram_metrics support
-            pthread_mutex_lock(&fd->metrics_lock);
-            k_global = kh_put(m_metrics, fd->tags_used, key, &r);
-            if (-1 == r) {
-                pthread_mutex_unlock(&fd->metrics_lock);
-                return NULL;
-            }
-            if (r >= 1) {
-                kh_val(fd->tags_used, k_global) = cram_new_metrics();
-                if (!kh_val(fd->tags_used, k_global)) {
-                    kh_del(m_metrics, fd->tags_used, k_global);
-                    pthread_mutex_unlock(&fd->metrics_lock);
-                    goto err;
-                }
-            }
-
-            pthread_mutex_unlock(&fd->metrics_lock);
-
-            int i2[2] = {'\t',key};
-            size_t sk = key;
-            cram_tag_map *m = calloc(1, sizeof(*m));
-            if (!m)
-                goto_err;
-            kh_val(c->tags_used, k) = m;
-
-            cram_codec *c;
-
-            // Use a block content id based on the tag id.
-            // Codec type depends on tag data type.
-            switch(aux[2]) {
-            case 'Z': case 'H':
-                // string as byte_array_stop
-                c = cram_encoder_init(E_BYTE_ARRAY_STOP, NULL,
-                                      E_BYTE_ARRAY, (void *)i2,
-                                      fd->version, &fd->vv);
-                break;
-
-            case 'A': case 'c': case 'C': {
-                // byte array len, 1 byte
-                cram_byte_array_len_encoder e;
-                cram_stats st;
-
-                if (CRAM_MAJOR_VERS(fd->version) <= 3) {
-                    e.len_encoding = E_HUFFMAN;
-                    e.len_dat = NULL; // will get codes from st
-                } else {
-                    e.len_encoding = E_CONST_INT;
-                    e.len_dat = NULL; // will get codes from st
-                }
-                memset(&st, 0, sizeof(st));
-                if (cram_stats_add(&st, 1) < 0) goto block_err;
-                cram_stats_encoding(fd, &st);
-
-                e.val_encoding = E_EXTERNAL;
-                e.val_dat = (void *)sk;
-
-                c = cram_encoder_init(E_BYTE_ARRAY_LEN, &st,
-                                      E_BYTE_ARRAY, (void *)&e,
-                                      fd->version, &fd->vv);
-                break;
-            }
-
-            case 's': case 'S': {
-                // byte array len, 2 byte
-                cram_byte_array_len_encoder e;
-                cram_stats st;
-
-                if (CRAM_MAJOR_VERS(fd->version) <= 3) {
-                    e.len_encoding = E_HUFFMAN;
-                    e.len_dat = NULL; // will get codes from st
-                } else {
-                    e.len_encoding = E_CONST_INT;
-                    e.len_dat = NULL; // will get codes from st
-                }
-                memset(&st, 0, sizeof(st));
-                if (cram_stats_add(&st, 2) < 0) goto block_err;
-                cram_stats_encoding(fd, &st);
-
-                e.val_encoding = E_EXTERNAL;
-                e.val_dat = (void *)sk;
-
-                c = cram_encoder_init(E_BYTE_ARRAY_LEN, &st,
-                                      E_BYTE_ARRAY, (void *)&e,
-                                      fd->version, &fd->vv);
-                break;
-            }
-            case 'i': case 'I': case 'f': {
-                // byte array len, 4 byte
-                cram_byte_array_len_encoder e;
-                cram_stats st;
-
-                if (CRAM_MAJOR_VERS(fd->version) <= 3) {
-                    e.len_encoding = E_HUFFMAN;
-                    e.len_dat = NULL; // will get codes from st
-                } else {
-                    e.len_encoding = E_CONST_INT;
-                    e.len_dat = NULL; // will get codes from st
-                }
-                memset(&st, 0, sizeof(st));
-                if (cram_stats_add(&st, 4) < 0) goto block_err;
-                cram_stats_encoding(fd, &st);
-
-                e.val_encoding = E_EXTERNAL;
-                e.val_dat = (void *)sk;
-
-                c = cram_encoder_init(E_BYTE_ARRAY_LEN, &st,
-                                      E_BYTE_ARRAY, (void *)&e,
-                                      fd->version, &fd->vv);
-                break;
-            }
-
-            case 'B': {
-                // Byte array of variable size, but we generate our tag
-                // byte stream at the wrong stage (during reading and not
-                // after slice header construction). So we use
-                // BYTE_ARRAY_LEN with the length codec being external
-                // too.
-                cram_byte_array_len_encoder e;
-
-                e.len_encoding = CRAM_MAJOR_VERS(fd->version) >= 4
-                    ? E_VARINT_UNSIGNED
-                    : E_EXTERNAL;
-                e.len_dat = (void *)sk; // or key+128 for len?
-
-                e.val_encoding = E_EXTERNAL;
-                e.val_dat = (void *)sk;
-
-                c = cram_encoder_init(E_BYTE_ARRAY_LEN, NULL,
-                                      E_BYTE_ARRAY, (void *)&e,
-                                      fd->version, &fd->vv);
-                break;
-            }
-
-            default:
-                hts_log_error("Unsupported SAM aux type '%c'", aux[2]);
-                c = NULL;
-            }
-
-            if (!c)
-                goto_err;
-
-            m->codec = c;
-
-            // Link to fd-global tag metrics
-            pthread_mutex_lock(&fd->metrics_lock);
-            m->m = k_global ? (cram_metrics *)kh_val(fd->tags_used, k_global) : NULL;
-            pthread_mutex_unlock(&fd->metrics_lock);
-        }
-
-        cram_tag_map *tm = (cram_tag_map *)kh_val(c->tags_used, k);
-        if (!tm) goto_err;
-        cram_codec *codec = tm->codec;
-        if (!tm->codec) goto_err;
-
-        switch(aux[2]) {
-        case 'A': case 'C': case 'c':
-            if (!tm->blk) {
-                if (!(tm->blk = cram_new_block(EXTERNAL, key)))
-                    return NULL;
-                codec->u.e_byte_array_len.val_codec->out = tm->blk;
-            }
-
-            aux+=3;
-            //codec->encode(s, codec, aux, 1);
-            // Functionally equivalent, but less code.
-            BLOCK_APPEND_CHAR(tm->blk, *aux);
-            aux++;
-            break;
-
-        case 'S': case 's':
-            if (!tm->blk) {
-                if (!(tm->blk = cram_new_block(EXTERNAL, key)))
-                    return NULL;
-                codec->u.e_byte_array_len.val_codec->out = tm->blk;
-            }
-
-            aux+=3;
-            //codec->encode(s, codec, aux, 2);
-            BLOCK_APPEND(tm->blk, aux, 2);
-            aux+=2;
-            break;
-
-        case 'I': case 'i': case 'f':
-            if (!tm->blk) {
-                if (!(tm->blk = cram_new_block(EXTERNAL, key)))
-                    return NULL;
-                codec->u.e_byte_array_len.val_codec->out = tm->blk;
-            }
-
-            aux+=3;
-            //codec->encode(s, codec, aux, 4);
-            BLOCK_APPEND(tm->blk, aux, 4);
-            aux+=4;
-            break;
-
-        case 'd':
-            if (!tm->blk) {
-                if (!(tm->blk = cram_new_block(EXTERNAL, key)))
-                    return NULL;
-                codec->u.e_byte_array_len.val_codec->out = tm->blk;
-            }
-
-            aux+=3; //*tmp++=*aux++; *tmp++=*aux++; *tmp++=*aux++;
-            //codec->encode(s, codec, aux, 8);
-            BLOCK_APPEND(tm->blk, aux, 8);
-            aux+=8;
-            break;
-
-        case 'Z': case 'H':
-            {
-                if (!tm->blk) {
-                    if (!(tm->blk = cram_new_block(EXTERNAL, key)))
-                        return NULL;
-                    codec->out = tm->blk;
-                }
-
-                char *aux_s;
-                aux += 3;
-                aux_s = aux;
-                while (*aux++);
-                if (codec->encode(s, codec, aux_s, aux - aux_s) < 0)
-                    return NULL;
-            }
-            break;
-
-        case 'B': {
-            int type = aux[3], blen;
-            uint32_t count = (uint32_t)((((unsigned char *)aux)[4]<< 0) +
-                                        (((unsigned char *)aux)[5]<< 8) +
-                                        (((unsigned char *)aux)[6]<<16) +
-                                        (((unsigned char *)aux)[7]<<24));
-            if (!tm->blk) {
-                if (!(tm->blk = cram_new_block(EXTERNAL, key)))
-                    return NULL;
-                if (codec->u.e_byte_array_len.val_codec->codec == E_XDELTA) {
-                    if (!(tm->blk2 = cram_new_block(EXTERNAL, key+128)))
-                        return NULL;
-                    codec->u.e_byte_array_len.len_codec->out = tm->blk2;
-                    codec->u.e_byte_array_len.val_codec->u.e_xdelta.sub_codec->out = tm->blk;
-                } else {
-                    codec->u.e_byte_array_len.len_codec->out = tm->blk;
-                    codec->u.e_byte_array_len.val_codec->out = tm->blk;
-                }
-            }
-
-            // skip TN field
-            aux+=3;
-
-            // We use BYTE_ARRAY_LEN with external length, so store that first
-            switch (type) {
-            case 'c': case 'C':
-                blen = count;
-                break;
-            case 's': case 'S':
-                blen = 2*count;
-                break;
-            case 'i': case 'I': case 'f':
-                blen = 4*count;
-                break;
-            default:
-                hts_log_error("Unknown sub-type '%c' for aux type 'B'", type);
-                return NULL;
-            }
-
-            blen += 5; // sub-type & length
-
-            if (codec->encode(s, codec, aux, blen) < 0)
-                return NULL;
-            aux += blen;
-            break;
-        }
-        default:
-            hts_log_error("Unknown aux type '%c'", aux[2]);
-            return NULL;
-        }
-        tm->blk->m = tm->m;
-    }
-
-    // FIXME: sort BLOCK_DATA(td_b) by char[3] triples
-
-    // And and increment TD hash entry
-    BLOCK_APPEND_CHAR(td_b, 0);
-
-    // Duplicate key as BLOCK_DATA() can be realloced to a new pointer.
-    key = string_ndup(c->comp_hdr->TD_keys,
-                      (char *)BLOCK_DATA(td_b) + TD_blk_size,
-                      BLOCK_SIZE(td_b) - TD_blk_size);
-    if (!key)
-        goto block_err;
-    k = kh_put(m_s2i, c->comp_hdr->TD_hash, key, &new);
-    if (new < 0) {
-        return NULL;
-    } else if (new == 0) {
-        BLOCK_SIZE(td_b) = TD_blk_size;
-    } else {
-        kh_val(c->comp_hdr->TD_hash, k) = c->comp_hdr->nTL;
-        c->comp_hdr->nTL++;
-    }
-
-    cr->TL = kh_val(c->comp_hdr->TD_hash, k);
-    if (cram_stats_add(c->stats[DS_TL], cr->TL) < 0)
-        goto block_err;
-
-    if (err) *err = 0;
-    return rg;
-
- err:
- block_err:
-    return NULL;
-}
-
-/*
- * During cram_next_container or before the final flush at end of
- * file, we update the current slice headers and increment the slice
- * number to the next slice.
- *
- * See cram_next_container() and cram_close().
- */
-void cram_update_curr_slice(cram_container *c) {
-    cram_slice *s = c->slice;
-    if (c->multi_seq) {
-        s->hdr->ref_seq_id    = -2;
-        s->hdr->ref_seq_start = 0;
-        s->hdr->ref_seq_span  = 0;
-    } else {
-        s->hdr->ref_seq_id    = c->curr_ref;
-        s->hdr->ref_seq_start = c->first_base;
-        s->hdr->ref_seq_span  = MAX(0, c->last_base - c->first_base + 1);
-    }
-    s->hdr->num_records   = c->curr_rec;
-
-    if (c->curr_slice == 0) {
-        if (c->ref_seq_id != s->hdr->ref_seq_id)
-            c->ref_seq_id  = s->hdr->ref_seq_id;
-        c->ref_seq_start = c->first_base;
-    }
-
-    c->curr_slice++;
-}
-
-/*
- * Handles creation of a new container or new slice, flushing any
- * existing containers when appropriate.
- *
- * Really this is next slice, which may or may not lead to a new container.
- *
- * Returns cram_container pointer on success
- *         NULL on failure.
- */
-static cram_container *cram_next_container(cram_fd *fd, bam_seq_t *b) {
-    cram_container *c = fd->ctr;
-    int i;
-
-    /* First occurrence */
-    if (c->curr_ref == -2)
-        c->curr_ref = bam_ref(b);
-
-    if (c->slice)
-        cram_update_curr_slice(c);
-
-    /* Flush container */
-    if (c->curr_slice == c->max_slice ||
-        (bam_ref(b) != c->curr_ref && !c->multi_seq)) {
-        c->ref_seq_span = fd->last_base - c->ref_seq_start + 1;
-        hts_log_info("Flush container %d/%"PRId64"..%"PRId64,
-                     c->ref_seq_id, c->ref_seq_start,
-                     c->ref_seq_start + c->ref_seq_span -1);
-
-        /* Encode slices */
-        if (-1 == cram_flush_container_mt(fd, c))
-            return NULL;
-        if (!fd->pool) {
-            // Move to sep func, as we need cram_flush_container for
-            // the closing phase to flush the partial container.
-            for (i = 0; i < c->max_slice; i++) {
-                cram_free_slice(c->slices[i]);
-                c->slices[i] = NULL;
-            }
-
-            c->slice = NULL;
-            c->curr_slice = 0;
-
-            /* Easy approach for purposes of freeing stats */
-            cram_free_container(c);
-        }
-
-        c = fd->ctr = cram_new_container(fd->seqs_per_slice,
-                                         fd->slices_per_container);
-        if (!c)
-            return NULL;
-        c->record_counter = fd->record_counter;
-        c->curr_ref = bam_ref(b);
-    }
-
-    c->last_pos = c->first_base = c->last_base = bam_pos(b)+1;
-
-    /* New slice */
-    c->slice = c->slices[c->curr_slice] =
-        cram_new_slice(MAPPED_SLICE, c->max_rec);
-    if (!c->slice)
-        return NULL;
-
-    if (c->multi_seq) {
-        c->slice->hdr->ref_seq_id = -2;
-        c->slice->hdr->ref_seq_start = 0;
-        c->slice->last_apos = 1;
-    } else {
-        c->slice->hdr->ref_seq_id = bam_ref(b);
-        // wrong for unsorted data, will fix during encoding.
-        c->slice->hdr->ref_seq_start = bam_pos(b)+1;
-        c->slice->last_apos = bam_pos(b)+1;
-    }
-
-    c->curr_rec = 0;
-    c->s_num_bases = 0;
-    c->n_mapped = 0;
-
-    // QO field: 0 implies original orientation, 1 implies sequence orientation
-    // 1 is often preferable for NovaSeq, but impact is slight. ~0.5% diff.
-    // Conversely other data sets it's often better than 1% saving for 0.
-    // Short of trying both and learning, for now we use use 0 for V4, 1 for V3.
-    c->qs_seq_orient = CRAM_MAJOR_VERS(fd->version) >= 4 ? 0 : 1;
-
-    return c;
-}
-
-/*
- * Converts a single bam record into a cram record.
- * Possibly used within a thread.
- *
- * Returns 0 on success;
- *        -1 on failure
- */
-static int process_one_read(cram_fd *fd, cram_container *c,
-                            cram_slice *s, cram_record *cr,
-                            bam_seq_t *b, int rnum, kstring_t *MD) {
-    int i, fake_qual = -1, NM = 0;
-    char *cp, *rg;
-    char *ref, *seq, *qual;
-
-    // Any places with N in seq and/or reference can lead to ambiguous
-    // interpretation of the SAM NM:i tag.  So we store these verbatim
-    // to ensure valid data round-trips the same regardless of who
-    // defines it as valid.
-    // Similarly when alignments go beyond end of the reference.
-    int verbatim_NM = fd->store_nm;
-    int verbatim_MD = fd->store_md;
-
-    // FIXME: multi-ref containers
-
-    ref = c->ref;
-    cr->flags       = bam_flag(b);
-    cr->len         = bam_seq_len(b);
-    if (!bam_aux_get(b, "MD"))
-        MD = NULL;
-    else
-        MD->l = 0;
-
-    //fprintf(stderr, "%s => %d\n", rg ? rg : "\"\"", cr->rg);
-
-    cr->ref_id      = bam_ref(b);
-    if (cram_stats_add(c->stats[DS_RI], cr->ref_id) < 0)
-        goto block_err;
-    if (cram_stats_add(c->stats[DS_BF], fd->cram_flag_swap[cr->flags & 0xfff]) < 0)
-        goto block_err;
-
-    // Non reference based encoding means storing the bases verbatim as features, which in
-    // turn means every base also has a quality already stored.
-    if (!fd->no_ref || CRAM_MAJOR_VERS(fd->version) >= 3)
-        cr->cram_flags |= CRAM_FLAG_PRESERVE_QUAL_SCORES;
-
-    if (cr->len <= 0 && CRAM_MAJOR_VERS(fd->version) >= 3)
-        cr->cram_flags |= CRAM_FLAG_NO_SEQ;
-    //cram_stats_add(c->stats[DS_CF], cr->cram_flags & CRAM_FLAG_MASK);
-
-    c->num_bases   += cr->len;
-    cr->apos        = bam_pos(b)+1;
-    if (c->pos_sorted) {
-        if (cr->apos < s->last_apos && !fd->ap_delta) {
-            c->pos_sorted = 0;
-        } else {
-            if (cram_stats_add(c->stats[DS_AP], cr->apos - s->last_apos) < 0)
-                goto block_err;
-            s->last_apos = cr->apos;
-        }
-    } else {
-        //cram_stats_add(c->stats[DS_AP], cr->apos);
-    }
-    c->max_apos += (cr->apos > c->max_apos) * (cr->apos - c->max_apos);
-
-    /*
-     * This seqs_ds is largely pointless and it could reuse the same memory
-     * over and over.
-     * s->base_blk is what we need for encoding.
-     */
-    cr->seq         = BLOCK_SIZE(s->seqs_blk);
-    cr->qual        = BLOCK_SIZE(s->qual_blk);
-    BLOCK_GROW(s->seqs_blk, cr->len+1);
-    BLOCK_GROW(s->qual_blk, cr->len);
-
-    // Convert BAM nibble encoded sequence to string of base pairs
-    seq = cp = (char *)BLOCK_END(s->seqs_blk);
-    *seq = 0;
-    nibble2base(bam_seq(b), cp, cr->len);
-    BLOCK_SIZE(s->seqs_blk) += cr->len;
-
-    qual = cp = (char *)bam_qual(b);
-
-
-    /* Copy and parse */
-    if (!(cr->flags & BAM_FUNMAP)) {
-        uint32_t *cig_to, *cig_from;
-        int64_t apos = cr->apos-1, spos = 0;
-        int64_t MD_last = apos; // last position of edit in MD tag
-
-        cr->cigar       = s->ncigar;
-        cr->ncigar      = bam_cigar_len(b);
-        while (cr->cigar + cr->ncigar >= s->cigar_alloc) {
-            s->cigar_alloc = s->cigar_alloc ? s->cigar_alloc*2 : 1024;
-            s->cigar = realloc(s->cigar, s->cigar_alloc * sizeof(*s->cigar));
-            if (!s->cigar)
-                return -1;
-        }
-
-        cig_to = (uint32_t *)s->cigar;
-        cig_from = (uint32_t *)bam_cigar(b);
-
-        cr->feature = 0;
-        cr->nfeature = 0;
-        for (i = 0; i < cr->ncigar; i++) {
-            enum cigar_op cig_op = cig_from[i] & BAM_CIGAR_MASK;
-            uint32_t cig_len = cig_from[i] >> BAM_CIGAR_SHIFT;
-            cig_to[i] = cig_from[i];
-
-            /* Can also generate events from here for CRAM diffs */
-
-            switch (cig_op) {
-                int l;
-
-                // Don't trust = and X ops to be correct.
-            case BAM_CMATCH:
-            case BAM_CBASE_MATCH:
-            case BAM_CBASE_MISMATCH:
-                //fprintf(stderr, "\nBAM_CMATCH\nR: %.*s\nS: %.*s\n",
-                //      cig_len, &ref[apos], cig_len, &seq[spos]);
-                l = 0;
-                if (!fd->no_ref && cr->len) {
-                    int end = cig_len+apos < c->ref_end
-                        ? cig_len : c->ref_end - apos;
-                    char *sp = &seq[spos];
-                    char *rp = &ref[apos];
-                    char *qp = &qual[spos];
-                    if (end > cr->len) {
-                        hts_log_error("CIGAR and query sequence are of different length");
-                        return -1;
-                    }
-                    for (l = 0; l < end; l++) {
-                        // This case is just too disputed and different tools
-                        // interpret these in different ways.  We give up and
-                        // store verbatim.
-                        if (rp[l] == 'N' && sp[l] == 'N')
-                            verbatim_NM = verbatim_MD = 1;
-                        if (rp[l] != sp[l]) {
-                            // Build our own MD tag if one is on the sequence, so
-                            // we can ensure it matches and thus can be discarded.
-                            if (MD && ref) {
-                                if (kputuw(apos+l - MD_last, MD) < 0) goto err;
-                                if (kputc(rp[l], MD) < 0) goto err;
-                                MD_last = apos+l+1;
-                            }
-                            NM++;
-                            if (!sp[l])
-                                break;
-                            if (0 && CRAM_MAJOR_VERS(fd->version) >= 3) {
-#if 0
-                                // Disabled for the time being as it doesn't
-                                // seem to gain us much.
-                                int ol=l;
-                                while (l<end && rp[l] != sp[l])
-                                    l++;
-                                if (l-ol > 1) {
-                                    if (cram_add_bases(fd, c, s, cr, spos+ol,
-                                                       l-ol, &seq[spos+ol]))
-                                        return -1;
-                                    l--;
-                                } else {
-                                    l = ol;
-                                    if (cram_add_substitution(fd, c, s, cr,
-                                                              spos+l, sp[l],
-                                                              qp[l], rp[l]))
-                                        return -1;
-                                }
-#else
-                                // With urmap pushed to the limit and lots
-                                // of unaligned data (should be soft-clipped)
-                                // this saves ~2-7%. Worth it?
-                                int nl = l;
-                                int max_end = nl, max_score = 0, score = 0;
-                                while (nl < end) {
-                                    if (rp[nl] != sp[nl]) {
-                                        score += 3;
-                                        if (max_score < score) {
-                                            max_score = score;
-                                            max_end = nl;
-                                        }
-                                    } else {
-                                        score--;
-                                        if (score < -2 ||
-                                            max_score - score > 7)
-                                            break;
-                                    }
-                                    nl++;
-                                }
-                                if (max_score > 20) {
-                                    cram_add_bases(fd, c, s, cr, spos+l,
-                                                   max_end-l, &seq[spos+l]);
-                                    l = max_end-1;
-                                } else {
-                                    while (l < nl) {
-                                        if (rp[l] != sp[l])
-                                            cram_add_substitution(fd, c, s,
-                                                                  cr, spos+l,
-                                                                  sp[l], qp[l],
-                                                                  rp[l]);
-                                        l++;
-                                    }
-                                    l--;
-                                }
-#endif
-                            } else {
-                                if (cram_add_substitution(fd, c, s, cr, spos+l,
-                                                          sp[l], qp[l], rp[l]))
-                                    return -1;
-                            }
-                        }
-                    }
-                    spos += l;
-                    apos += l;
-                }
-
-                if (l < cig_len && cr->len) {
-                    if (fd->no_ref) {
-                        if (CRAM_MAJOR_VERS(fd->version) == 3) {
-                            if (cram_add_bases(fd, c, s, cr, spos,
-                                               cig_len-l, &seq[spos]))
-                                return -1;
-                            spos += cig_len-l;
-                        } else {
-                            for (; l < cig_len && seq[spos]; l++, spos++) {
-                                if (cram_add_base(fd, c, s, cr, spos,
-                                                  seq[spos], qual[spos]))
-                                    return -1;
-                            }
-                        }
-                    } else {
-                        /* off end of sequence or non-ref based output */
-                        verbatim_NM = verbatim_MD = 1;
-                        for (; l < cig_len && seq[spos]; l++, spos++) {
-                            if (cram_add_base(fd, c, s, cr, spos,
-                                              seq[spos], qual[spos]))
-                                return -1;
-                        }
-                    }
-                    apos += cig_len;
-                } else if (!cr->len) {
-                    /* Seq "*" */
-                    verbatim_NM = verbatim_MD = 1;
-                    apos += cig_len;
-                    spos += cig_len;
-                }
-                break;
-
-            case BAM_CDEL:
-                if (MD && ref) {
-                    if (kputuw(apos - MD_last, MD) < 0) goto err;
-                    if (apos < c->ref_end) {
-                        if (kputc_('^', MD) < 0) goto err;
-                        if (kputsn(&ref[apos], MIN(c->ref_end - apos, cig_len), MD) < 0)
-                            goto err;
-                    }
-                }
-                NM += cig_len;
-
-                if (cram_add_deletion(c, s, cr, spos, cig_len, &seq[spos]))
-                    return -1;
-                apos += cig_len;
-                MD_last = apos;
-                break;
-
-            case BAM_CREF_SKIP:
-                if (cram_add_skip(c, s, cr, spos, cig_len, &seq[spos]))
-                    return -1;
-                apos += cig_len;
-                MD_last += cig_len;
-                break;
-
-            case BAM_CINS:
-                if (cram_add_insertion(c, s, cr, spos, cig_len,
-                                       cr->len ? &seq[spos] : NULL))
-                    return -1;
-                if (fd->no_ref && cr->len) {
-                    for (l = 0; l < cig_len; l++, spos++) {
-                        cram_add_quality(fd, c, s, cr, spos, qual[spos]);
-                    }
-                } else {
-                    spos += cig_len;
-                }
-                NM += cig_len;
-                break;
-
-            case BAM_CSOFT_CLIP:
-                if (cram_add_softclip(c, s, cr, spos, cig_len,
-                                      cr->len ? &seq[spos] : NULL,
-                                      fd->version))
-                    return -1;
-
-                if (fd->no_ref &&
-                    !(cr->cram_flags & CRAM_FLAG_PRESERVE_QUAL_SCORES)) {
-                    if (cr->len) {
-                        for (l = 0; l < cig_len; l++, spos++) {
-                            cram_add_quality(fd, c, s, cr, spos, qual[spos]);
-                        }
-                    } else {
-                        for (l = 0; l < cig_len; l++, spos++) {
-                            cram_add_quality(fd, c, s, cr, spos, -1);
-                        }
-                    }
-                } else {
-                    spos += cig_len;
-                }
-                break;
-
-            case BAM_CHARD_CLIP:
-                if (cram_add_hardclip(c, s, cr, spos, cig_len, &seq[spos]))
-                    return -1;
-                break;
-
-            case BAM_CPAD:
-                if (cram_add_pad(c, s, cr, spos, cig_len, &seq[spos]))
-                    return -1;
-                break;
-
-            default:
-                hts_log_error("Unknown CIGAR op code %d", cig_op);
-                return -1;
-            }
-        }
-        if (cr->len && spos != cr->len) {
-            hts_log_error("CIGAR and query sequence are of different length");
-            return -1;
-        }
-        fake_qual = spos;
-        cr->aend = fd->no_ref ? apos : MIN(apos, c->ref_end);
-        if (cram_stats_add(c->stats[DS_FN], cr->nfeature) < 0)
-            goto block_err;
-
-        if (MD && ref)
-            if (kputuw(apos - MD_last, MD) < 0) goto err;
-    } else {
-        // Unmapped
-        cr->cram_flags |= CRAM_FLAG_PRESERVE_QUAL_SCORES;
-        cr->cigar  = 0;
-        cr->ncigar = 0;
-        cr->nfeature = 0;
-        cr->aend = cr->apos;
-        for (i = 0; i < cr->len; i++)
-            if (cram_stats_add(c->stats[DS_BA], seq[i]) < 0)
-                goto block_err;
-        fake_qual = 0;
-    }
-
-    cr->ntags      = 0; //cram_stats_add(c->stats[DS_TC], cr->ntags);
-    int err = 0;
-    rg = cram_encode_aux(fd, b, c, s, cr, verbatim_NM, verbatim_MD, NM, MD, &err);
-    if (err)
-        goto block_err;
-
-    /* Read group, identified earlier */
-    if (rg) {
-        sam_hrec_rg_t *brg = sam_hrecs_find_rg(fd->header->hrecs, rg);
-        cr->rg = brg ? brg->id : -1;
-    } else if (CRAM_MAJOR_VERS(fd->version) == 1) {
-        sam_hrec_rg_t *brg = sam_hrecs_find_rg(fd->header->hrecs, "UNKNOWN");
-        assert(brg);
-    } else {
-        cr->rg = -1;
-    }
-    if (cram_stats_add(c->stats[DS_RG], cr->rg) < 0)
-        goto block_err;
-
-    /*
-     * Append to the qual block now. We do this here as
-     * cram_add_substitution() can generate BA/QS events which need to
-     * be in the qual block before we append the rest of the data.
-     */
-    if (cr->cram_flags & CRAM_FLAG_PRESERVE_QUAL_SCORES) {
-        /* Special case of seq "*" */
-        if (cr->len == 0) {
-            cr->len = fake_qual;
-            BLOCK_GROW(s->qual_blk, cr->len);
-            cp = (char *)BLOCK_END(s->qual_blk);
-            memset(cp, 255, cr->len);
-        } else {
-            BLOCK_GROW(s->qual_blk, cr->len);
-            cp = (char *)BLOCK_END(s->qual_blk);
-            char *from = (char *)&bam_qual(b)[0];
-            char *to = &cp[0];
-            memcpy(to, from, cr->len);
-
-            // Store quality in original orientation for better compression.
-            if (!c->qs_seq_orient) {
-                if (cr->flags & BAM_FREVERSE) {
-                    int i, j;
-                    for (i = 0, j = cr->len-1; i < j; i++, j--) {
-                        unsigned char c;
-                        c = to[i];
-                        to[i] = to[j];
-                        to[j] = c;
-                    }
-                }
-            }
-        }
-        BLOCK_SIZE(s->qual_blk) += cr->len;
-    } else {
-        if (cr->len == 0)
-            cr->len = fake_qual >= 0 ? fake_qual : cr->aend - cr->apos + 1;
-    }
-
-    if (cram_stats_add(c->stats[DS_RL], cr->len) < 0)
-        goto block_err;
-
-    /* Now we know apos and aend both, update mate-pair information */
-    {
-        int new;
-        khint_t k;
-        int sec = (cr->flags & BAM_FSECONDARY) ? 1 : 0;
-
-        //fprintf(stderr, "Checking %"PRId64"/%.*s\t", rnum,
-        //      cr->name_len, DSTRING_STR(s->name_ds)+cr->name);
-        if (cr->flags & BAM_FPAIRED) {
-            char *key = string_ndup(s->pair_keys, bam_name(b), bam_name_len(b));
-            if (!key)
-                return -1;
-
-            k = kh_put(m_s2i, s->pair[sec], key, &new);
-            if (-1 == new)
-                return -1;
-            else if (new > 0)
-                kh_val(s->pair[sec], k) = rnum;
-        } else {
-            new = 1;
-            k = 0; // Prevents false-positive warning from gcc -Og
-        }
-
-        if (new == 0) {
-            cram_record *p = &s->crecs[kh_val(s->pair[sec], k)];
-            int64_t aleft, aright;
-            int sign;
-
-            aleft = MIN(cr->apos, p->apos);
-            aright = MAX(cr->aend, p->aend);
-            if (cr->apos < p->apos) {
-                sign = 1;
-            } else if (cr->apos > p->apos) {
-                sign = -1;
-            } else if (cr->flags & BAM_FREAD1) {
-                sign = 1;
-            } else {
-                sign = -1;
-            }
-
-            // This vs p: tlen, matepos, flags. Permit TLEN 0 and/or TLEN +/-
-            // a small amount, if appropriate options set.
-            if ((!fd->tlen_zero && MAX(bam_mate_pos(b)+1, 0) != p->apos) &&
-                !(fd->tlen_zero && bam_mate_pos(b) == 0))
-                goto detached;
-
-            if (((bam_flag(b) & BAM_FMUNMAP) != 0) !=
-                ((p->flags & BAM_FUNMAP) != 0))
-                goto detached;
-
-            if (((bam_flag(b) & BAM_FMREVERSE) != 0) !=
-                ((p->flags & BAM_FREVERSE) != 0))
-                goto detached;
-
-
-            // p vs this: tlen, matepos, flags
-            if (p->ref_id != cr->ref_id &&
-                !(fd->tlen_zero && p->ref_id == -1))
-                goto detached;
-
-            if (p->mate_pos != cr->apos &&
-                !(fd->tlen_zero && p->mate_pos == 0))
-                goto detached;
-
-            if (((p->flags & BAM_FMUNMAP) != 0) !=
-                ((p->mate_flags & CRAM_M_UNMAP) != 0))
-                goto detached;
-
-            if (((p->flags & BAM_FMREVERSE) != 0) !=
-                ((p->mate_flags & CRAM_M_REVERSE) != 0))
-                goto detached;
-
-            // Supplementary reads are just too ill defined
-            if ((cr->flags & BAM_FSUPPLEMENTARY) ||
-                (p->flags & BAM_FSUPPLEMENTARY))
-                goto detached;
-
-            // When in lossy name mode, if a read isn't detached we
-            // cannot store the name.  The corollary is that when we
-            // must store the name, it must be detached (inefficient).
-            if (fd->lossy_read_names &&
-                (!(cr->cram_flags & CRAM_FLAG_DISCARD_NAME) ||
-                 !((p->cram_flags & CRAM_FLAG_DISCARD_NAME))))
-                goto detached;
-
-            // Now check TLEN.  We do this last as sometimes it's the
-            // only thing that differs.  In CRAM4 we have a better way
-            // of handling this that doesn't break detached status
-            int explicit_tlen = 0;
-            int tflag1 = ((bam_ins_size(b) &&
-                           llabs(bam_ins_size(b) - sign*(aright-aleft+1))
-                           > fd->tlen_approx)
-                          || (!bam_ins_size(b) && !fd->tlen_zero));
-
-            int tflag2 = ((p->tlen && llabs(p->tlen - -sign*(aright-aleft+1))
-                           > fd->tlen_approx)
-                          || (!p->tlen && !fd->tlen_zero));
-
-            if (tflag1 || tflag2) {
-                if (CRAM_MAJOR_VERS(fd->version) >= 4) {
-                    explicit_tlen = CRAM_FLAG_EXPLICIT_TLEN;
-                } else {
-                    // Stil do detached for unmapped data in CRAM4 as this
-                    // also impacts RNEXT calculation.
-                    goto detached;
-                }
-            }
-
-            /*
-             * The fields below are unused when encoding this read as it is
-             * no longer detached.  In theory they may get referred to when
-             * processing a 3rd or 4th read in this template?, so we set them
-             * here just to be sure.
-             *
-             * They do not need cram_stats_add() calls those as they are
-             * not emitted.
-             */
-            cr->mate_pos = p->apos;
-            cram_stats_add(c->stats[DS_NP], cr->mate_pos);
-            cr->tlen = explicit_tlen ? bam_ins_size(b) : sign*(aright-aleft+1);
-            cram_stats_add(c->stats[DS_TS], cr->tlen);
-            cr->mate_flags =
-                ((p->flags & BAM_FMUNMAP)   == BAM_FMUNMAP)   * CRAM_M_UNMAP +
-                ((p->flags & BAM_FMREVERSE) == BAM_FMREVERSE) * CRAM_M_REVERSE;
-
-            // Decrement statistics aggregated earlier
-            if (p->cram_flags & CRAM_FLAG_STATS_ADDED) {
-                cram_stats_del(c->stats[DS_NP], p->mate_pos);
-                cram_stats_del(c->stats[DS_MF], p->mate_flags);
-                if (!(p->cram_flags & CRAM_FLAG_EXPLICIT_TLEN))
-                    cram_stats_del(c->stats[DS_TS], p->tlen);
-                cram_stats_del(c->stats[DS_NS], p->mate_ref_id);
-            }
-
-            /* Similarly we could correct the p-> values too, but these will no
-             * longer have any code that refers back to them as the new 'p'
-             * for this template is our current 'cr'.
-             */
-            //p->mate_pos = cr->apos;
-            //p->mate_flags =
-            //  ((cr->flags & BAM_FMUNMAP)   == BAM_FMUNMAP)  * CRAM_M_UNMAP +
-            //  ((cr->flags & BAM_FMREVERSE) == BAM_FMREVERSE)* CRAM_M_REVERSE;
-            //p->tlen = p->apos - cr->aend;
-
-            // Clear detached from cr flags
-            cr->cram_flags &= ~CRAM_FLAG_DETACHED;
-            cr->cram_flags |= explicit_tlen;
-            if (cram_stats_add(c->stats[DS_CF], cr->cram_flags & CRAM_FLAG_MASK) < 0)
-                goto block_err;
-
-            // Clear detached from p flags and set downstream
-            if (p->cram_flags & CRAM_FLAG_STATS_ADDED) {
-                cram_stats_del(c->stats[DS_CF], p->cram_flags & CRAM_FLAG_MASK);
-                p->cram_flags &= ~CRAM_FLAG_STATS_ADDED;
-            }
-
-            p->cram_flags  &= ~CRAM_FLAG_DETACHED;
-            p->cram_flags  |=  CRAM_FLAG_MATE_DOWNSTREAM | explicit_tlen;;
-            if (cram_stats_add(c->stats[DS_CF], p->cram_flags & CRAM_FLAG_MASK) < 0)
-                goto block_err;
-
-            p->mate_line = rnum - (kh_val(s->pair[sec], k) + 1);
-            if (cram_stats_add(c->stats[DS_NF], p->mate_line) < 0)
-                goto block_err;
-
-            kh_val(s->pair[sec], k) = rnum;
-        } else {
-        detached:
-            //fprintf(stderr, "unpaired\n");
-
-            /* Derive mate flags from this flag */
-            cr->mate_flags = 0;
-            if (bam_flag(b) & BAM_FMUNMAP)
-                cr->mate_flags |= CRAM_M_UNMAP;
-            if (bam_flag(b) & BAM_FMREVERSE)
-                cr->mate_flags |= CRAM_M_REVERSE;
-
-            if (cram_stats_add(c->stats[DS_MF], cr->mate_flags) < 0)
-                goto block_err;
-
-            cr->mate_pos    = MAX(bam_mate_pos(b)+1, 0);
-            if (cram_stats_add(c->stats[DS_NP], cr->mate_pos) < 0)
-                goto block_err;
-
-            cr->tlen        = bam_ins_size(b);
-            if (cram_stats_add(c->stats[DS_TS], cr->tlen) < 0)
-                goto block_err;
-
-            cr->cram_flags |= CRAM_FLAG_DETACHED;
-            if (cram_stats_add(c->stats[DS_CF], cr->cram_flags & CRAM_FLAG_MASK) < 0)
-                goto block_err;
-            if (cram_stats_add(c->stats[DS_NS], bam_mate_ref(b)) < 0)
-                goto block_err;
-
-            cr->cram_flags |= CRAM_FLAG_STATS_ADDED;
-        }
-    }
-
-    cr->mqual       = bam_map_qual(b);
-    if (cram_stats_add(c->stats[DS_MQ], cr->mqual) < 0)
-        goto block_err;
-
-    cr->mate_ref_id = bam_mate_ref(b);
-
-    if (!(bam_flag(b) & BAM_FUNMAP)) {
-        if (c->first_base > cr->apos)
-            c->first_base = cr->apos;
-
-        if (c->last_base < cr->aend)
-            c->last_base = cr->aend;
-    }
-
-    return 0;
-
- block_err:
- err:
-    return -1;
-}
-
-/*
- * Write iterator: put BAM format sequences into a CRAM file.
- * We buffer up a containers worth of data at a time.
- *
- * Returns 0 on success
- *        -1 on failure
- */
-int cram_put_bam_seq(cram_fd *fd, bam_seq_t *b) {
-    cram_container *c;
-
-    if (!fd->ctr) {
-        fd->ctr = cram_new_container(fd->seqs_per_slice,
-                                     fd->slices_per_container);
-        if (!fd->ctr)
-            return -1;
-        fd->ctr->record_counter = fd->record_counter;
-    }
-    c = fd->ctr;
-
-    if (!c->slice || c->curr_rec == c->max_rec ||
-        (bam_ref(b) != c->curr_ref && c->curr_ref >= -1) ||
-        (c->s_num_bases >= fd->bases_per_slice)) {
-        int slice_rec, curr_rec, multi_seq = fd->multi_seq == 1;
-        int curr_ref = c->slice ? c->curr_ref : bam_ref(b);
-
-        /*
-         * Start packing slices when we routinely have under 1/4tr full.
-         *
-         * This option isn't available if we choose to embed references
-         * since we can only have one per slice.
-         *
-         * The multi_seq var here refers to our intention for the next slice.
-         * This slice has already been encoded so we output as-is.
-         */
-        if (fd->multi_seq == -1 && c->curr_rec < c->max_rec/4+10 &&
-            fd->last_slice && fd->last_slice < c->max_rec/4+10 &&
-            !fd->embed_ref) {
-            if (!c->multi_seq)
-                hts_log_info("Multi-ref enabled for next container");
-            multi_seq = 1;
-        } else if (fd->multi_seq == 1) {
-            pthread_mutex_lock(&fd->metrics_lock);
-            if (fd->last_RI_count <= c->max_slice && fd->multi_seq_user != 1) {
-                multi_seq = 0;
-                hts_log_info("Multi-ref disabled for next container");
-            }
-            pthread_mutex_unlock(&fd->metrics_lock);
-        }
-
-        slice_rec = c->slice_rec;
-        curr_rec  = c->curr_rec;
-
-        if (CRAM_MAJOR_VERS(fd->version) == 1 ||
-            c->curr_rec == c->max_rec || fd->multi_seq != 1 || !c->slice ||
-            c->s_num_bases >= fd->bases_per_slice) {
-            if (NULL == (c = cram_next_container(fd, b))) {
-                if (fd->ctr) {
-                    // prevent cram_close attempting to flush
-                    cram_free_container(fd->ctr);
-                    fd->ctr = NULL;
-                }
-                return -1;
-            }
-        }
-
-        /*
-         * Due to our processing order, some things we've already done we
-         * cannot easily undo. So when we first notice we should be packing
-         * multiple sequences per container we emit the small partial
-         * container as-is and then start a fresh one in a different mode.
-         */
-        if (multi_seq == 0 && fd->multi_seq == 1 && fd->multi_seq_user == -1) {
-            // User selected auto-mode, we're currently using multi-seq, but
-            // have detected we don't need to.  Switch back to auto.
-            fd->multi_seq = -1;
-        } else if (multi_seq) {
-            // We detected we need multi-seq
-            fd->multi_seq = 1;
-            c->multi_seq = 1;
-            c->pos_sorted = 0;
-
-            if (!c->refs_used) {
-                pthread_mutex_lock(&fd->ref_lock);
-                c->refs_used = calloc(fd->refs->nref, sizeof(int));
-                pthread_mutex_unlock(&fd->ref_lock);
-                if (!c->refs_used)
-                    return -1;
-            }
-        }
-
-        fd->last_slice = curr_rec - slice_rec;
-        c->slice_rec = c->curr_rec;
-
-        // Have we seen this reference before?
-        if (bam_ref(b) >= 0 && curr_ref >= 0 && bam_ref(b) != curr_ref && !fd->embed_ref &&
-            !fd->unsorted && multi_seq) {
-
-            if (!c->refs_used) {
-                pthread_mutex_lock(&fd->ref_lock);
-                c->refs_used = calloc(fd->refs->nref, sizeof(int));
-                pthread_mutex_unlock(&fd->ref_lock);
-                if (!c->refs_used)
-                    return -1;
-            } else if (c->refs_used && c->refs_used[bam_ref(b)]) {
-                pthread_mutex_lock(&fd->ref_lock);
-                fd->unsorted = 1;
-                pthread_mutex_unlock(&fd->ref_lock);
-                fd->multi_seq = 1;
-            }
-        }
-
-        c->curr_ref = bam_ref(b);
-        if (c->refs_used && c->curr_ref >= 0) c->refs_used[c->curr_ref]++;
-    }
-
-    if (!c->bams) {
-        /* First time through, allocate a set of bam pointers */
-        pthread_mutex_lock(&fd->bam_list_lock);
-        if (fd->bl) {
-            spare_bams *spare = fd->bl;
-            c->bams = spare->bams;
-            fd->bl = spare->next;
-            free(spare);
-        } else {
-            c->bams = calloc(c->max_c_rec, sizeof(bam_seq_t *));
-            if (!c->bams) {
-                pthread_mutex_unlock(&fd->bam_list_lock);
-                return -1;
-            }
-        }
-        pthread_mutex_unlock(&fd->bam_list_lock);
-    }
-
-    /* Copy or alloc+copy the bam record, for later encoding */
-    if (c->bams[c->curr_c_rec]) {
-        if (bam_copy1(c->bams[c->curr_c_rec], b) == NULL)
-            return -1;
-    } else {
-        c->bams[c->curr_c_rec] = bam_dup1(b);
-        if (c->bams[c->curr_c_rec] == NULL)
-            return -1;
-    }
-    c->curr_rec++;
-    c->curr_c_rec++;
-    c->s_num_bases += bam_seq_len(b);
-    c->n_mapped += (bam_flag(b) & BAM_FUNMAP) ? 0 : 1;
-    fd->record_counter++;
-
-    return 0;
-}
diff -ruN stringtie.orig/htslib/cram/cram_encode.h stringtie/htslib/cram/cram_encode.h
--- stringtie.orig/htslib/cram/cram_encode.h	2024-02-28 13:57:39.701246126 +0100
+++ stringtie/htslib/cram/cram_encode.h	1970-01-01 01:00:00.000000000 +0100
@@ -1,115 +0,0 @@
-/*
-Copyright (c) 2012-2013, 2018 Genome Research Ltd.
-Author: James Bonfield <jkb@sanger.ac.uk>
-
-Redistribution and use in source and binary forms, with or without
-modification, are permitted provided that the following conditions are met:
-
-   1. Redistributions of source code must retain the above copyright notice,
-this list of conditions and the following disclaimer.
-
-   2. Redistributions in binary form must reproduce the above copyright notice,
-this list of conditions and the following disclaimer in the documentation
-and/or other materials provided with the distribution.
-
-   3. Neither the names Genome Research Ltd and Wellcome Trust Sanger
-Institute nor the names of its contributors may be used to endorse or promote
-products derived from this software without specific prior written permission.
-
-THIS SOFTWARE IS PROVIDED BY GENOME RESEARCH LTD AND CONTRIBUTORS "AS IS" AND
-ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
-WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
-DISCLAIMED. IN NO EVENT SHALL GENOME RESEARCH LTD OR CONTRIBUTORS BE LIABLE
-FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
-DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
-SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
-CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
-OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
-OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-*/
-
-/*! \file
- * Include cram.h instead.
- *
- * This is an internal part of the CRAM system and is automatically included
- * when you #include cram.h.
- *
- * Implements the encoding portion of CRAM I/O. Also see
- * cram_codecs.[ch] for the actual encoding functions themselves.
- */
-
-#ifndef CRAM_ENCODE_H
-#define CRAM_ENCODE_H
-
-#ifdef __cplusplus
-extern "C" {
-#endif
-
-/* ----------------------------------------------------------------------
- * CRAM sequence iterators.
- */
-
-/*! Write iterator: put BAM format sequences into a CRAM file.
- *
- * We buffer up a containers worth of data at a time.
- *
- * FIXME: break this into smaller pieces.
- *
- * @return
- * Returns 0 on success;
- *        -1 on failure
- */
-int cram_put_bam_seq(cram_fd *fd, bam_seq_t *b);
-
-
-/* ----------------------------------------------------------------------
- * Internal functions
- */
-
-/*! INTERNAL:
- * Encodes a compression header block into a generic cram_block structure.
- *
- * @return
- * Returns cram_block ptr on success;
- *         NULL on failure
- */
-cram_block *cram_encode_compression_header(cram_fd *fd, cram_container *c,
-                                           cram_block_compression_hdr *h);
-
-/*! INTERNAL:
- * Encodes a slice compression header.
- *
- * @return
- * Returns cram_block on success;
- *         NULL on failure
- */
-cram_block *cram_encode_slice_header(cram_fd *fd, cram_slice *s);
-
-/*! INTERNAL:
- * Encodes all slices in a container into blocks.
- *
- * @return
- * Returns 0 on success;
- *        -1 on failure
- *
- * FIXME: separate into encode_container and write_container. Ideally
- * we should be able to do read_container / write_container or
- * decode_container / encode_container.
- */
-int cram_encode_container(cram_fd *fd, cram_container *c);
-
-/*! INTERNAL:
- *
- * During cram_next_container or before the final flush at end of
- * file, we update the current slice headers and increment the slice
- * number to the next slice.
- *
- * See cram_next_container() and cram_close().
- */
-void cram_update_curr_slice(cram_container *c);
-
-#ifdef __cplusplus
-}
-#endif
-
-#endif
diff -ruN stringtie.orig/htslib/cram/cram_external.c stringtie/htslib/cram/cram_external.c
--- stringtie.orig/htslib/cram/cram_external.c	2024-02-28 13:57:39.701246126 +0100
+++ stringtie/htslib/cram/cram_external.c	1970-01-01 01:00:00.000000000 +0100
@@ -1,399 +0,0 @@
-/*
-Copyright (c) 2015, 2018-2020 Genome Research Ltd.
-Author: James Bonfield <jkb@sanger.ac.uk>
-
-Redistribution and use in source and binary forms, with or without
-modification, are permitted provided that the following conditions are met:
-
-   1. Redistributions of source code must retain the above copyright notice,
-this list of conditions and the following disclaimer.
-
-   2. Redistributions in binary form must reproduce the above copyright notice,
-this list of conditions and the following disclaimer in the documentation
-and/or other materials provided with the distribution.
-
-   3. Neither the names Genome Research Ltd and Wellcome Trust Sanger
-Institute nor the names of its contributors may be used to endorse or promote
-products derived from this software without specific prior written permission.
-
-THIS SOFTWARE IS PROVIDED BY GENOME RESEARCH LTD AND CONTRIBUTORS "AS IS" AND
-ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
-WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
-DISCLAIMED. IN NO EVENT SHALL GENOME RESEARCH LTD OR CONTRIBUTORS BE LIABLE
-FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
-DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
-SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
-CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
-OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
-OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-*/
-
-/*! \file
- * External CRAM interface.
- *
- * Internally we're happy to use macros and to grub around in the cram
- * structures.  This isn't very sustainable for an externally usable
- * ABI though, so we have anonymous structs and accessor functions too
- * to permit software such as samtools reheader to manipulate cram
- * containers and blocks in a robust manner.
- */
-
-#define HTS_BUILDING_LIBRARY // Enables HTSLIB_EXPORT, see htslib/hts_defs.h
-#include <config.h>
-
-#include "../htslib/hfile.h"
-#include "cram.h"
-
-/*
- *-----------------------------------------------------------------------------
- * cram_fd
- */
-sam_hdr_t *cram_fd_get_header(cram_fd *fd) { return fd->header; }
-void cram_fd_set_header(cram_fd *fd, sam_hdr_t *hdr) { fd->header = hdr; }
-
-int cram_fd_get_version(cram_fd *fd) { return fd->version; }
-void cram_fd_set_version(cram_fd *fd, int vers) { fd->version = vers; }
-
-int cram_major_vers(cram_fd *fd) { return CRAM_MAJOR_VERS(fd->version); }
-int cram_minor_vers(cram_fd *fd) { return CRAM_MINOR_VERS(fd->version); }
-
-hFILE *cram_fd_get_fp(cram_fd *fd) { return fd->fp; }
-void cram_fd_set_fp(cram_fd *fd, hFILE *fp) { fd->fp = fp; }
-
-
-/*
- *-----------------------------------------------------------------------------
- * cram_container
- */
-int32_t cram_container_get_length(cram_container *c) {
-    return c->length;
-}
-
-void cram_container_set_length(cram_container *c, int32_t length) {
-    c->length = length;
-}
-
-
-int32_t cram_container_get_num_blocks(cram_container *c) {
-    return c->num_blocks;
-}
-
-void cram_container_set_num_blocks(cram_container *c, int32_t num_blocks) {
-    c->num_blocks = num_blocks;
-}
-
-
-/* Returns the landmarks[] array and the number of elements
- * in num_landmarks.
- */
-int32_t *cram_container_get_landmarks(cram_container *c, int32_t *num_landmarks) {
-    *num_landmarks = c->num_landmarks;
-    return c->landmark;
-}
-
-/* Sets the landmarks[] array (pointer copy, not a memory dup) and
- * num_landmarks value.
- */
-void cram_container_set_landmarks(cram_container *c, int32_t num_landmarks,
-                                  int32_t *landmarks) {
-    c->num_landmarks = num_landmarks;
-    c->landmark = landmarks;
-}
-
-
-/* Returns true if the container is empty (EOF marker) */
-int cram_container_is_empty(cram_fd *fd) {
-    return fd->empty_container;
-}
-
-
-/*
- *-----------------------------------------------------------------------------
- * cram_block_compression_hdr
- */
-
-/*
- * Utility function to edit an RG id.
- * This is only possible if there is one single RG value used and it
- * is in the container compression header using HUFFMAN or BETA
- * codec.  In this case it is essentially hard coded and needs no
- * editing of external (or worse, CORE) blocks.
- *
- * Returns 0 on success
- *        -1 on failure
- */
-// Or arbitrary set compression header constant?
-
-static int cram_block_compression_hdr_set_DS(cram_block_compression_hdr *ch,
-                                             int ds, int new_rg) {
-    if (!ch || !ch->codecs[ds])
-        return -1;
-
-    switch (ch->codecs[ds]->codec) {
-    case E_HUFFMAN:
-        if (ch->codecs[ds]->u.huffman.ncodes != 1)
-            return -1;
-        ch->codecs[ds]->u.huffman.codes[0].symbol = new_rg;
-        return 0;
-
-    case E_BETA:
-        if (ch->codecs[ds]->u.beta.nbits != 0)
-            return -1;
-        ch->codecs[ds]->u.beta.offset = -new_rg;
-        return 0;
-
-    default:
-        break;
-    }
-
-    return -1;
-}
-
-int cram_block_compression_hdr_set_rg(cram_block_compression_hdr *ch, int new_rg) {
-    return cram_block_compression_hdr_set_DS(ch, DS_RG, new_rg);
-}
-
-/*
- * Converts a cram_block_compression_hdr struct used for decoding to
- * one used for encoding.  Maybe this should be a transparent
- * operation applied on-demand.
- *
- * Returns 0 on success
- *        -1 on failure
- */
-int cram_block_compression_hdr_decoder2encoder(cram_fd *fd,
-                                               cram_block_compression_hdr *ch) {
-    int i;
-
-    if (!ch)
-        return -1;
-
-    for (i = 0; i < DS_END; i++) {
-        cram_codec *co = ch->codecs[i];
-        if (!co)
-            continue;
-
-        if (-1 == cram_codec_decoder2encoder(fd, co))
-            return -1;
-    }
-
-    return 0;
-}
-
-/*
- *-----------------------------------------------------------------------------
- * cram_slice
- */
-int32_t cram_slice_hdr_get_num_blocks(cram_block_slice_hdr *hdr) {
-    return hdr->num_blocks;
-}
-
-
-/*
- *-----------------------------------------------------------------------------
- * cram_block
- */
-int32_t cram_block_get_content_id(cram_block *b)  { return b->content_id; }
-int32_t cram_block_get_comp_size(cram_block *b)   { return b->comp_size; }
-int32_t cram_block_get_uncomp_size(cram_block *b) { return b->uncomp_size; }
-int32_t cram_block_get_crc32(cram_block *b)       { return b->crc32; }
-void *  cram_block_get_data(cram_block *b)        { return BLOCK_DATA(b); }
-int32_t cram_block_get_size(cram_block *b)        { return BLOCK_SIZE(b); }
-enum cram_content_type cram_block_get_content_type(cram_block *b) {
-    return b->content_type;
-}
-
-void cram_block_set_content_id(cram_block *b, int32_t id) { b->content_id = id; }
-void cram_block_set_comp_size(cram_block *b, int32_t size) { b->comp_size = size; }
-void cram_block_set_uncomp_size(cram_block *b, int32_t size) { b->uncomp_size = size; }
-void cram_block_set_crc32(cram_block *b, int32_t crc) { b->crc32 = crc; }
-void cram_block_set_data(cram_block *b, void *data) { BLOCK_DATA(b) = data; }
-void cram_block_set_size(cram_block *b, int32_t size) { BLOCK_SIZE(b) = size; }
-
-int cram_block_append(cram_block *b, const void *data, int size) {
-    BLOCK_APPEND(b, data, size);
-    return 0;
-
- block_err:
-    return -1;
-}
-void cram_block_update_size(cram_block *b) { BLOCK_UPLEN(b); }
-
-// Offset is known as "size" internally, but it can be confusing.
-size_t cram_block_get_offset(cram_block *b) { return BLOCK_SIZE(b); }
-void cram_block_set_offset(cram_block *b, size_t offset) { BLOCK_SIZE(b) = offset; }
-
-
-/*
- * Copies the blocks representing the next num_slice slices from a
- * container from 'in' to 'out'.  It is expected that the file pointer
- * is just after the read of the cram_container and cram compression
- * header.
- *
- * Returns 0 on success
- *        -1 on failure
- */
-int cram_copy_slice(cram_fd *in, cram_fd *out, int32_t num_slice) {
-    int32_t i, j;
-
-    for (i = 0; i < num_slice; i++) {
-        cram_block *blk;
-        cram_block_slice_hdr *hdr;
-
-        if (!(blk = cram_read_block(in)))
-            return -1;
-        if (!(hdr = cram_decode_slice_header(in, blk))) {
-            cram_free_block(blk);
-            return -1;
-        }
-        if (cram_write_block(out, blk) != 0) {
-            cram_free_block(blk);
-            return -1;
-        }
-        cram_free_block(blk);
-
-        int num_blocks = cram_slice_hdr_get_num_blocks(hdr);
-        for (j = 0; j < num_blocks; j++) {
-            blk = cram_read_block(in);
-            if (!blk || cram_write_block(out, blk) != 0) {
-                if (blk) cram_free_block(blk);
-                return -1;
-            }
-            cram_free_block(blk);
-        }
-        cram_free_slice_header(hdr);
-    }
-
-    return 0;
-}
-
-/*
- * Renumbers RG numbers in a cram compression header.
- *
- * CRAM stores RG as the Nth number in the header, rather than a
- * string holding the ID: tag.  This is smaller in space, but means
- * "samtools cat" to join files together that contain single but
- * different RG lines needs a way of renumbering them.
- *
- * The file descriptor is expected to be immediately after the
- * cram_container structure (ie before the cram compression header).
- * Due to the nature of the CRAM format, this needs to read and write
- * the blocks itself.  Note that there may be multiple slices within
- * the container, meaning multiple compression headers to manipulate.
- * Changing RG may change the size of the compression header and
- * therefore the length field in the container.  Hence we rewrite all
- * blocks just in case and also emit the adjusted container.
- *
- * The current implementation can only cope with renumbering a single
- * RG (and only then if it is using HUFFMAN or BETA codecs).  In
- * theory it *may* be possible to renumber multiple RGs if they use
- * HUFFMAN to the CORE block or use an external block unshared by any
- * other data series.  So we have an API that can be upgraded to
- * support this, but do not implement it for now.  An example
- * implementation of RG as an EXTERNAL block would be to find that
- * block and rewrite it, returning the number of blocks consumed.
- *
- * Returns 0 on success;
- *        -1 if unable to edit;
- *        -2 on other errors (eg I/O).
- */
-int cram_transcode_rg(cram_fd *in, cram_fd *out,
-                      cram_container *c,
-                      int nrg, int *in_rg, int *out_rg) {
-    int new_rg = *out_rg, old_size, new_size;
-    cram_block *o_blk, *n_blk;
-    cram_block_compression_hdr *ch;
-
-    if (nrg != 1) {
-        hts_log_error("CRAM transcode supports only a single RG");
-        return -2;
-    }
-
-    // Produce a new block holding the updated compression header,
-    // with RG transcoded to a new value. (Single only supported.)
-    o_blk = cram_read_block(in);
-    old_size = cram_block_size(o_blk);
-    ch = cram_decode_compression_header(in, o_blk);
-    if (cram_block_compression_hdr_set_rg(ch, new_rg) != 0)
-        return -1;
-    if (cram_block_compression_hdr_decoder2encoder(in, ch) != 0)
-        return -1;
-    n_blk = cram_encode_compression_header(in, c, ch);
-    cram_free_compression_header(ch);
-
-    /*
-     * Warning: this has internal knowledge of the cram compression
-     * header format.
-     *
-     * The decoder doesn't set c->tags_used, so the encoder puts a two
-     * byte blank segment.  This means n_blk is too short.  We skip
-     * through the decoded old block (o_blk) and copy from there.
-     */
-    char *cp = cram_block_get_data(o_blk);
-    char *op = cp;
-    char *endp = cp + cram_block_get_uncomp_size(o_blk);
-    //fprintf(stderr, "sz = %d\n", (int)(endp-cp));
-    int32_t i32, err = 0;
-
-    i32 = in->vv.varint_get32(&cp, endp, &err);
-    cp += i32;
-    i32 = in->vv.varint_get32(&cp, endp, &err);
-    cp += i32;
-    op = cp;
-    i32 = in->vv.varint_get32(&cp, endp, &err);
-    i32 += (cp-op);
-    if (err)
-        return -2;
-
-    //fprintf(stderr, "remaining %d bytes\n", i32);
-    cram_block_set_size(n_blk, cram_block_get_size(n_blk)-2);
-    cram_block_append(n_blk, op, i32);
-    cram_block_update_size(n_blk);
-
-    new_size = cram_block_size(n_blk);
-
-    //fprintf(stderr, "size %d -> %d\n", old_size, new_size);
-
-    // Now we've constructedthe updated compression header,
-    // amend the container too (it may have changed size).
-    int32_t *landmarks, num_landmarks;
-    landmarks = cram_container_get_landmarks(c, &num_landmarks);
-
-    if (old_size != new_size) {
-        int diff = new_size - old_size, j;
-
-        for (j = 0; j < num_landmarks; j++)
-            landmarks[j] += diff;
-        //cram_container_set_landmarks(c, num_landmarks, landmarks);
-        cram_container_set_length(c, cram_container_get_length(c) + diff);
-    }
-
-    // Finally write it all out; container, compression header,
-    // and then all the remaining slice blocks.
-    if (cram_write_container(out, c) != 0)
-        return -2;
-
-    cram_write_block(out, n_blk);
-    cram_free_block(o_blk);
-    cram_free_block(n_blk);
-
-    // Container num_blocks can be invalid, due to a bug.
-    // Instead we iterate in slice context instead.
-    return cram_copy_slice(in, out, num_landmarks);
-}
-
-
-/*!
- * Returns the refs_t structure used by a cram file handle.
- *
- * This may be used in conjunction with option CRAM_OPT_SHARED_REF to
- * share reference memory between multiple file handles.
- *
- * @return
- * Returns NULL if none exists or the file handle is not a CRAM file.
- */
-refs_t *cram_get_refs(htsFile *fd) {
-    return fd->format.format == cram
-        ? fd->fp.cram->refs
-        : NULL;
-}
diff -ruN stringtie.orig/htslib/cram/cram.h stringtie/htslib/cram/cram.h
--- stringtie.orig/htslib/cram/cram.h	2024-02-28 13:57:39.701246126 +0100
+++ stringtie/htslib/cram/cram.h	1970-01-01 01:00:00.000000000 +0100
@@ -1,61 +0,0 @@
-/*
-Copyright (c) 2012-2013, 2015, 2018 Genome Research Ltd.
-Author: James Bonfield <jkb@sanger.ac.uk>
-
-Redistribution and use in source and binary forms, with or without
-modification, are permitted provided that the following conditions are met:
-
-   1. Redistributions of source code must retain the above copyright notice,
-this list of conditions and the following disclaimer.
-
-   2. Redistributions in binary form must reproduce the above copyright notice,
-this list of conditions and the following disclaimer in the documentation
-and/or other materials provided with the distribution.
-
-   3. Neither the names Genome Research Ltd and Wellcome Trust Sanger
-Institute nor the names of its contributors may be used to endorse or promote
-products derived from this software without specific prior written permission.
-
-THIS SOFTWARE IS PROVIDED BY GENOME RESEARCH LTD AND CONTRIBUTORS "AS IS" AND
-ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
-WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
-DISCLAIMED. IN NO EVENT SHALL GENOME RESEARCH LTD OR CONTRIBUTORS BE LIABLE
-FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
-DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
-SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
-CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
-OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
-OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-*/
-
-/*! \file
- * CRAM interface.
- *
- * Consider using the higher level hts_*() API for programs that wish to
- * be file format agnostic (see htslib/hts.h).
- *
- * This API should be used for CRAM specific code. The specifics of the
- * public API are implemented in cram_io.h, cram_encode.h and cram_decode.h
- * although these should not be included directly (use this file instead).
- */
-
-#ifndef CRAM_ALL_H
-#define CRAM_ALL_H
-
-#include "cram_samtools.h"
-#include "../header.h"
-#include "cram_structs.h"
-#include "cram_io.h"
-#include "cram_encode.h"
-#include "cram_decode.h"
-#include "cram_stats.h"
-#include "cram_codecs.h"
-#include "cram_index.h"
-
-// Validate against the external cram.h,
-//
-// This contains duplicated portions from cram_io.h and cram_structs.h,
-// so we want to ensure that the prototypes match.
-#include "../htslib/cram.h"
-
-#endif
diff -ruN stringtie.orig/htslib/cram/cram_index.c stringtie/htslib/cram/cram_index.c
--- stringtie.orig/htslib/cram/cram_index.c	2024-02-28 13:57:39.701246126 +0100
+++ stringtie/htslib/cram/cram_index.c	1970-01-01 01:00:00.000000000 +0100
@@ -1,800 +0,0 @@
-/*
-Copyright (c) 2013-2020 Genome Research Ltd.
-Author: James Bonfield <jkb@sanger.ac.uk>
-
-Redistribution and use in source and binary forms, with or without
-modification, are permitted provided that the following conditions are met:
-
-   1. Redistributions of source code must retain the above copyright notice,
-this list of conditions and the following disclaimer.
-
-   2. Redistributions in binary form must reproduce the above copyright notice,
-this list of conditions and the following disclaimer in the documentation
-and/or other materials provided with the distribution.
-
-   3. Neither the names Genome Research Ltd and Wellcome Trust Sanger
-Institute nor the names of its contributors may be used to endorse or promote
-products derived from this software without specific prior written permission.
-
-THIS SOFTWARE IS PROVIDED BY GENOME RESEARCH LTD AND CONTRIBUTORS "AS IS" AND
-ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
-WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
-DISCLAIMED. IN NO EVENT SHALL GENOME RESEARCH LTD OR CONTRIBUTORS BE LIABLE
-FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
-DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
-SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
-CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
-OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
-OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-*/
-
-/*
- * The index is a gzipped tab-delimited text file with one line per slice.
- * The columns are:
- * 1: reference number (0 to N-1, as per BAM ref_id)
- * 2: reference position of 1st read in slice (1..?)
- * 3: number of reads in slice
- * 4: offset of container start (relative to end of SAM header, so 1st
- *    container is offset 0).
- * 5: slice number within container (ie which landmark).
- *
- * In memory, we hold this in a nested containment list. Each list element is
- * a cram_index struct. Each element in turn can contain its own list of
- * cram_index structs.
- *
- * Any start..end range which is entirely contained within another (and
- * earlier as it is sorted) range will be held within it. This ensures that
- * the outer list will never have containments and we can safely do a
- * binary search to find the first range which overlaps any given coordinate.
- */
-
-#define HTS_BUILDING_LIBRARY // Enables HTSLIB_EXPORT, see htslib/hts_defs.h
-#include <config.h>
-
-#include <stdio.h>
-#include <errno.h>
-#include <assert.h>
-#include <inttypes.h>
-#include <stdlib.h>
-#include <string.h>
-#include <zlib.h>
-#include <sys/types.h>
-#include <sys/stat.h>
-#include <math.h>
-
-#include "../htslib/bgzf.h"
-#include "../htslib/hfile.h"
-#include "../hts_internal.h"
-#include "cram.h"
-#include "os.h"
-
-#if 0
-static void dump_index_(cram_index *e, int level) {
-    int i, n;
-    n = printf("%*s%d / %d .. %d, ", level*4, "", e->refid, e->start, e->end);
-    printf("%*soffset %"PRId64"\n", MAX(0,50-n), "", e->offset);
-    for (i = 0; i < e->nslice; i++) {
-        dump_index_(&e->e[i], level+1);
-    }
-}
-
-static void dump_index(cram_fd *fd) {
-    int i;
-    for (i = 0; i < fd->index_sz; i++) {
-        dump_index_(&fd->index[i], 0);
-    }
-}
-#endif
-
-static int kget_int32(kstring_t *k, size_t *pos, int32_t *val_p) {
-    int sign = 1;
-    int32_t val = 0;
-    size_t p = *pos;
-
-    while (p < k->l && (k->s[p] == ' ' || k->s[p] == '\t'))
-        p++;
-
-    if (p < k->l && k->s[p] == '-')
-        sign = -1, p++;
-
-    if (p >= k->l || !(k->s[p] >= '0' && k->s[p] <= '9'))
-        return -1;
-
-    while (p < k->l && k->s[p] >= '0' && k->s[p] <= '9') {
-        int digit = k->s[p++]-'0';
-        val = val*10 + digit;
-    }
-
-    *pos = p;
-    *val_p = sign*val;
-
-    return 0;
-}
-
-static int kget_int64(kstring_t *k, size_t *pos, int64_t *val_p) {
-    int sign = 1;
-    int64_t val = 0;
-    size_t p = *pos;
-
-    while (p < k->l && (k->s[p] == ' ' || k->s[p] == '\t'))
-        p++;
-
-    if (p < k->l && k->s[p] == '-')
-        sign = -1, p++;
-
-    if (p >= k->l || !(k->s[p] >= '0' && k->s[p] <= '9'))
-        return -1;
-
-    while (p < k->l && k->s[p] >= '0' && k->s[p] <= '9') {
-        int digit = k->s[p++]-'0';
-        val = val*10 + digit;
-    }
-
-    *pos = p;
-    *val_p = sign*val;
-
-    return 0;
-}
-
-/*
- * Loads a CRAM .crai index into memory.
- *
- * Returns 0 for success
- *        -1 for failure
- */
-int cram_index_load(cram_fd *fd, const char *fn, const char *fn_idx) {
-
-    char *tfn_idx = NULL;
-    char buf[65536];
-    ssize_t len;
-    kstring_t kstr = {0};
-    hFILE *fp;
-    cram_index *idx;
-    cram_index **idx_stack = NULL, *ep, e;
-    int idx_stack_alloc = 0, idx_stack_ptr = 0;
-    size_t pos = 0;
-
-    /* Check if already loaded */
-    if (fd->index)
-        return 0;
-
-    fd->index = calloc((fd->index_sz = 1), sizeof(*fd->index));
-    if (!fd->index)
-        return -1;
-
-    idx = &fd->index[0];
-    idx->refid = -1;
-    idx->start = INT_MIN;
-    idx->end   = INT_MAX;
-
-    idx_stack = calloc(++idx_stack_alloc, sizeof(*idx_stack));
-    if (!idx_stack)
-        goto fail;
-
-    idx_stack[idx_stack_ptr] = idx;
-
-    if (!fn_idx) {
-        if (hts_idx_check_local(fn, HTS_FMT_CRAI, &tfn_idx) == 0 && hisremote(fn))
-            tfn_idx = hts_idx_getfn(fn, ".crai");
-
-        if (!tfn_idx) {
-            hts_log_error("Could not retrieve index file for '%s'", fn);
-            goto fail;
-        }
-        fn_idx = tfn_idx;
-    }
-
-    if (!(fp = hopen(fn_idx, "r"))) {
-        hts_log_error("Could not open index file '%s'", fn_idx);
-        goto fail;
-    }
-
-    // Load the file into memory
-    while ((len = hread(fp, buf, sizeof(buf))) > 0) {
-        if (kputsn(buf, len, &kstr) < 0)
-            goto fail;
-    }
-
-    if (len < 0 || kstr.l < 2)
-        goto fail;
-
-    if (hclose(fp) < 0)
-        goto fail;
-
-    // Uncompress if required
-    if (kstr.s[0] == 31 && (uc)kstr.s[1] == 139) {
-        size_t l = 0;
-        char *s = zlib_mem_inflate(kstr.s, kstr.l, &l);
-        if (!s)
-            goto fail;
-
-        free(kstr.s);
-        kstr.s = s;
-        kstr.l = l;
-        kstr.m = l; // conservative estimate of the size allocated
-        if (kputsn("", 0, &kstr) < 0) // ensure kstr.s is NUL-terminated
-            goto fail;
-    }
-
-
-    // Parse it line at a time
-    while (pos < kstr.l) {
-        /* 1.1 layout */
-        if (kget_int32(&kstr, &pos, &e.refid) == -1)
-            goto fail;
-
-        if (kget_int32(&kstr, &pos, &e.start) == -1)
-            goto fail;
-
-        if (kget_int32(&kstr, &pos, &e.end) == -1)
-            goto fail;
-
-        if (kget_int64(&kstr, &pos, &e.offset) == -1)
-            goto fail;
-
-        if (kget_int32(&kstr, &pos, &e.slice) == -1)
-            goto fail;
-
-        if (kget_int32(&kstr, &pos, &e.len) == -1)
-            goto fail;
-
-        e.end += e.start-1;
-        //printf("%d/%d..%d-offset=%" PRIu64 ",len=%d,slice=%d\n", e.refid, e.start, e.end, e.offset, e.len, e.slice);
-
-        if (e.refid < -1) {
-            hts_log_error("Malformed index file, refid %d", e.refid);
-            goto fail;
-        }
-
-        if (e.refid != idx->refid) {
-            if (fd->index_sz < e.refid+2) {
-                cram_index *new_idx;
-                int new_sz = e.refid+2;
-                size_t index_end = fd->index_sz * sizeof(*fd->index);
-                new_idx = realloc(fd->index,
-                                  new_sz * sizeof(*fd->index));
-                if (!new_idx)
-                    goto fail;
-
-                fd->index = new_idx;
-                fd->index_sz = new_sz;
-                memset(((char *)fd->index) + index_end, 0,
-                       fd->index_sz * sizeof(*fd->index) - index_end);
-            }
-            idx = &fd->index[e.refid+1];
-            idx->refid = e.refid;
-            idx->start = INT_MIN;
-            idx->end   = INT_MAX;
-            idx->nslice = idx->nalloc = 0;
-            idx->e = NULL;
-            idx_stack[(idx_stack_ptr = 0)] = idx;
-        }
-
-        while (!(e.start >= idx->start && e.end <= idx->end) || idx->end == 0) {
-            idx = idx_stack[--idx_stack_ptr];
-        }
-
-        // Now contains, so append
-        if (idx->nslice+1 >= idx->nalloc) {
-            cram_index *new_e;
-            idx->nalloc = idx->nalloc ? idx->nalloc*2 : 16;
-            new_e = realloc(idx->e, idx->nalloc * sizeof(*idx->e));
-            if (!new_e)
-                goto fail;
-
-            idx->e = new_e;
-        }
-
-        e.nalloc = e.nslice = 0; e.e = NULL;
-        *(ep = &idx->e[idx->nslice++]) = e;
-        idx = ep;
-
-        if (++idx_stack_ptr >= idx_stack_alloc) {
-            cram_index **new_stack;
-            idx_stack_alloc *= 2;
-            new_stack = realloc(idx_stack, idx_stack_alloc*sizeof(*idx_stack));
-            if (!new_stack)
-                goto fail;
-            idx_stack = new_stack;
-        }
-        idx_stack[idx_stack_ptr] = idx;
-
-        while (pos < kstr.l && kstr.s[pos] != '\n')
-            pos++;
-        pos++;
-    }
-
-    free(idx_stack);
-    free(kstr.s);
-    free(tfn_idx);
-
-    // dump_index(fd);
-
-    return 0;
-
- fail:
-    free(kstr.s);
-    free(idx_stack);
-    free(tfn_idx);
-    cram_index_free(fd); // Also sets fd->index = NULL
-    return -1;
-}
-
-static void cram_index_free_recurse(cram_index *e) {
-    if (e->e) {
-        int i;
-        for (i = 0; i < e->nslice; i++) {
-            cram_index_free_recurse(&e->e[i]);
-        }
-        free(e->e);
-    }
-}
-
-void cram_index_free(cram_fd *fd) {
-    int i;
-
-    if (!fd->index)
-        return;
-
-    for (i = 0; i < fd->index_sz; i++) {
-        cram_index_free_recurse(&fd->index[i]);
-    }
-    free(fd->index);
-
-    fd->index = NULL;
-}
-
-/*
- * Searches the index for the first slice overlapping a reference ID
- * and position, or one immediately preceding it if none is found in
- * the index to overlap this position. (Our index may have missing
- * entries, but we require at least one per reference.)
- *
- * If the index finds multiple slices overlapping this position we
- * return the first one only. Subsequent calls should specifying
- * "from" as the last slice we checked to find the next one. Otherwise
- * set "from" to be NULL to find the first one.
- *
- * Refid can also be any of the special HTS_IDX_ values.
- * For backwards compatibility, refid -1 is equivalent to HTS_IDX_NOCOOR.
- *
- * Returns the cram_index pointer on success
- *         NULL on failure
- */
-cram_index *cram_index_query(cram_fd *fd, int refid, hts_pos_t pos,
-                             cram_index *from) {
-    int i, j, k;
-    cram_index *e;
-
-    switch(refid) {
-    case HTS_IDX_NONE:
-    case HTS_IDX_REST:
-        // fail, or already there, dealt with elsewhere.
-        return NULL;
-
-    case HTS_IDX_NOCOOR:
-        refid = -1;
-        pos = 0;
-        break;
-
-    case HTS_IDX_START: {
-        int64_t min_idx = INT64_MAX;
-        for (i = 0, j = -1; i < fd->index_sz; i++) {
-            if (fd->index[i].e && fd->index[i].e[0].offset < min_idx) {
-                min_idx = fd->index[i].e[0].offset;
-                j = i;
-            }
-        }
-        if (j < 0)
-            return NULL;
-        return fd->index[j].e;
-    }
-
-    default:
-        if (refid < HTS_IDX_NONE || refid+1 >= fd->index_sz)
-            return NULL;
-    }
-
-    if (!from)
-        from = &fd->index[refid+1];
-
-    // Ref with nothing aligned against it.
-    if (!from->e)
-        return NULL;
-
-    // This sequence is covered by the index, so binary search to find
-    // the optimal starting block.
-    i = 0, j = fd->index[refid+1].nslice-1;
-    for (k = j/2; k != i; k = (j-i)/2 + i) {
-        if (from->e[k].refid > refid) {
-            j = k;
-            continue;
-        }
-
-        if (from->e[k].refid < refid) {
-            i = k;
-            continue;
-        }
-
-        if (from->e[k].start >= pos) {
-            j = k;
-            continue;
-        }
-
-        if (from->e[k].start < pos) {
-            i = k;
-            continue;
-        }
-    }
-    // i==j or i==j-1. Check if j is better.
-    if (j >= 0 && from->e[j].start < pos && from->e[j].refid == refid)
-        i = j;
-
-    /* The above found *a* bin overlapping, but not necessarily the first */
-    while (i > 0 && from->e[i-1].end >= pos)
-        i--;
-
-    /* We may be one bin before the optimum, so check */
-    while (i+1 < from->nslice &&
-           (from->e[i].refid < refid ||
-            from->e[i].end < pos))
-        i++;
-
-    e = &from->e[i];
-
-    return e;
-}
-
-// Return the index entry for last slice on a specific reference.
-cram_index *cram_index_last(cram_fd *fd, int refid, cram_index *from) {
-    int slice;
-
-    if (refid+1 < 0 || refid+1 >= fd->index_sz)
-        return NULL;
-
-    if (!from)
-        from = &fd->index[refid+1];
-
-    // Ref with nothing aligned against it.
-    if (!from->e)
-        return NULL;
-
-    slice = fd->index[refid+1].nslice - 1;
-
-    return &from->e[slice];
-}
-
-cram_index *cram_index_query_last(cram_fd *fd, int refid, hts_pos_t end) {
-    cram_index *first = cram_index_query(fd, refid, end, NULL);
-    cram_index *last =  cram_index_last(fd, refid, NULL);
-    if (!first || !last)
-        return NULL;
-
-    while (first < last && (first+1)->start <= end)
-        first++;
-
-    while (first->e) {
-        int count = 0;
-        int nslices = first->nslice;
-        first = first->e;
-        while (++count < nslices && (first+1)->start <= end)
-            first++;
-    }
-
-    // Compute the start location of next container.
-    //
-    // This is useful for stitching containers together in the multi-region
-    // iterator.  Sadly we can't compute this from the single index line.
-    //
-    // Note we can have neighbouring index entries at the same location
-    // for when we have multi-reference mode and/or multiple slices per
-    // container.
-    cram_index *next = first;
-    do {
-        if (next >= last) {
-            // Next non-empty reference
-            while (++refid+1 < fd->index_sz)
-                if (fd->index[refid+1].nslice)
-                    break;
-            if (refid+1 >= fd->index_sz) {
-                next = NULL;
-            } else {
-                next = fd->index[refid+1].e;
-                last = fd->index[refid+1].e + fd->index[refid+1].nslice;
-            }
-        } else {
-            next++;
-        }
-    } while (next && next->offset == first->offset);
-
-    first->next = next ? next->offset : 0;
-
-    return first;
-}
-
-/*
- * Skips to a container overlapping the start coordinate listed in
- * cram_range.
- *
- * In theory we call cram_index_query multiple times, once per slice
- * overlapping the range. However slices may be absent from the index
- * which makes this problematic. Instead we find the left-most slice
- * and then read from then on, skipping decoding of slices and/or
- * whole containers when they don't overlap the specified cram_range.
- *
- * This function also updates the cram_fd range field.
- *
- * Returns 0 on success
- *        -1 on general failure
- *        -2 on no-data (empty chromosome)
- */
-int cram_seek_to_refpos(cram_fd *fd, cram_range *r) {
-    int ret = 0;
-    cram_index *e;
-
-    if (r->refid == HTS_IDX_NONE) {
-        ret = -2; goto err;
-    }
-
-    // Ideally use an index, so see if we have one.
-    if ((e = cram_index_query(fd, r->refid, r->start, NULL))) {
-        if (0 != cram_seek(fd, e->offset, SEEK_SET)) {
-            if (0 != cram_seek(fd, e->offset - fd->first_container, SEEK_CUR)) {
-                ret = -1; goto err;
-            }
-        }
-    } else {
-        // Absent from index, but this most likely means it simply has no data.
-        ret = -2; goto err;
-    }
-
-    pthread_mutex_lock(&fd->range_lock);
-    fd->range = *r;
-    if (r->refid == HTS_IDX_NOCOOR) {
-        fd->range.refid = -1;
-        fd->range.start = 0;
-    } else if (r->refid == HTS_IDX_START || r->refid == HTS_IDX_REST) {
-        fd->range.refid = -2; // special case in cram_next_slice
-    }
-    pthread_mutex_unlock(&fd->range_lock);
-
-    if (fd->ctr) {
-        cram_free_container(fd->ctr);
-        if (fd->ctr_mt && fd->ctr_mt != fd->ctr)
-            cram_free_container(fd->ctr_mt);
-        fd->ctr = NULL;
-        fd->ctr_mt = NULL;
-        fd->ooc = 0;
-        fd->eof = 0;
-    }
-
-    return 0;
-
- err:
-    // It's unlikely fd->range will be accessed after EOF or error,
-    // but this maintains identical behaviour to the previous code.
-    pthread_mutex_lock(&fd->range_lock);
-    fd->range = *r;
-    pthread_mutex_unlock(&fd->range_lock);
-    return ret;
-}
-
-
-/*
- * A specialised form of cram_index_build (below) that deals with slices
- * having multiple references in this (ref_id -2). In this scenario we
- * decode the slice to look at the RI data series instead.
- *
- * Returns 0 on success
- *        -1 on read failure
- *        -2 on wrong sort order
- *        -4 on write failure
- */
-static int cram_index_build_multiref(cram_fd *fd,
-                                     cram_container *c,
-                                     cram_slice *s,
-                                     BGZF *fp,
-                                     off_t cpos,
-                                     int32_t landmark,
-                                     int sz) {
-    int i, ref = -2;
-    int64_t ref_start = 0, ref_end;
-    char buf[1024];
-
-    if (fd->mode != 'w') {
-        if (0 != cram_decode_slice(fd, c, s, fd->header))
-            return -1;
-    }
-
-    ref_end = INT_MIN;
-
-    int32_t last_ref = -9;
-    int32_t last_pos = -9;
-    for (i = 0; i < s->hdr->num_records; i++) {
-        if (s->crecs[i].ref_id == last_ref && s->crecs[i].apos < last_pos) {
-            hts_log_error("CRAM file is not sorted by chromosome / position");
-            return -2;
-        }
-        last_ref = s->crecs[i].ref_id;
-        last_pos = s->crecs[i].apos;
-
-        if (s->crecs[i].ref_id == ref) {
-            if (ref_end < s->crecs[i].aend)
-                ref_end = s->crecs[i].aend;
-            continue;
-        }
-
-        if (ref != -2) {
-            sprintf(buf, "%d\t%"PRId64"\t%"PRId64"\t%"PRId64"\t%d\t%d\n",
-                    ref, ref_start, ref_end - ref_start + 1,
-                    (int64_t)cpos, landmark, sz);
-            if (bgzf_write(fp, buf, strlen(buf)) < 0)
-                return -4;
-        }
-
-        ref = s->crecs[i].ref_id;
-        ref_start = s->crecs[i].apos;
-        ref_end   = s->crecs[i].aend;
-    }
-
-    if (ref != -2) {
-        sprintf(buf, "%d\t%"PRId64"\t%"PRId64"\t%"PRId64"\t%d\t%d\n",
-                ref, ref_start, ref_end - ref_start + 1,
-                (int64_t)cpos, landmark, sz);
-        if (bgzf_write(fp, buf, strlen(buf)) < 0)
-            return -4;
-    }
-
-    return 0;
-}
-
-/*
- * Adds a single slice to the index.
- */
-int cram_index_slice(cram_fd *fd,
-                     cram_container *c,
-                     cram_slice *s,
-                     BGZF *fp,
-                     off_t cpos,
-                     off_t spos, // relative to cpos
-                     off_t sz) {
-    int ret;
-    char buf[1024];
-
-    if (sz > INT_MAX) {
-        hts_log_error("CRAM slice is too big (%"PRId64" bytes)",
-                      (int64_t) sz);
-        return -1;
-    }
-
-    if (s->hdr->ref_seq_id == -2) {
-        ret = cram_index_build_multiref(fd, c, s, fp, cpos, spos, sz);
-    } else {
-        sprintf(buf, "%d\t%"PRId64"\t%"PRId64"\t%"PRId64"\t%d\t%d\n",
-                s->hdr->ref_seq_id, s->hdr->ref_seq_start,
-                s->hdr->ref_seq_span, (int64_t)cpos, (int)spos, (int)sz);
-        ret = (bgzf_write(fp, buf, strlen(buf)) >= 0)? 0 : -4;
-    }
-
-    return ret;
-}
-
-/*
- * Adds a single container to the index.
- */
-static
-int cram_index_container(cram_fd *fd,
-                         cram_container *c,
-                         BGZF *fp,
-                         off_t cpos) {
-    int j;
-    off_t spos;
-
-    // 2.0 format
-    for (j = 0; j < c->num_landmarks; j++) {
-        cram_slice *s;
-        off_t sz;
-        int ret;
-
-        spos = htell(fd->fp);
-        if (spos - cpos - c->offset != c->landmark[j]) {
-            hts_log_error("CRAM slice offset %"PRId64" does not match"
-                          " landmark %d in container header (%d)",
-                          spos - cpos - c->offset, j, c->landmark[j]);
-            return -1;
-        }
-
-        if (!(s = cram_read_slice(fd))) {
-            return -1;
-        }
-
-        sz = htell(fd->fp) - spos;
-        ret = cram_index_slice(fd, c, s, fp, cpos, c->landmark[j], sz);
-
-        cram_free_slice(s);
-
-        if (ret < 0) {
-            return ret;
-        }
-    }
-
-    return 0;
-}
-
-
-/*
- * Builds an index file.
- *
- * fd is a newly opened cram file that we wish to index.
- * fn_base is the filename of the associated CRAM file.
- * fn_idx is the filename of the index file to be written;
- * if NULL, we add ".crai" to fn_base to get the index filename.
- *
- * Returns 0 on success,
- *         negative on failure (-1 for read failure, -4 for write failure)
- */
-int cram_index_build(cram_fd *fd, const char *fn_base, const char *fn_idx) {
-    cram_container *c;
-    off_t cpos, hpos;
-    BGZF *fp;
-    kstring_t fn_idx_str = {0};
-    int64_t last_ref = -9, last_start = -9;
-
-    // Useful for cram_index_build_multiref
-    cram_set_option(fd, CRAM_OPT_REQUIRED_FIELDS, SAM_RNAME | SAM_POS | SAM_CIGAR);
-
-    if (! fn_idx) {
-        kputs(fn_base, &fn_idx_str);
-        kputs(".crai", &fn_idx_str);
-        fn_idx = fn_idx_str.s;
-    }
-
-    if (!(fp = bgzf_open(fn_idx, "wg"))) {
-        perror(fn_idx);
-        free(fn_idx_str.s);
-        return -4;
-    }
-
-    free(fn_idx_str.s);
-
-    cpos = htell(fd->fp);
-    while ((c = cram_read_container(fd))) {
-        if (fd->err) {
-            perror("Cram container read");
-            return -1;
-        }
-
-        hpos = htell(fd->fp);
-
-        if (!(c->comp_hdr_block = cram_read_block(fd)))
-            return -1;
-        assert(c->comp_hdr_block->content_type == COMPRESSION_HEADER);
-
-        c->comp_hdr = cram_decode_compression_header(fd, c->comp_hdr_block);
-        if (!c->comp_hdr)
-            return -1;
-
-        if (c->ref_seq_id == last_ref && c->ref_seq_start < last_start) {
-            hts_log_error("CRAM file is not sorted by chromosome / position");
-            return -2;
-        }
-        last_ref = c->ref_seq_id;
-        last_start = c->ref_seq_start;
-
-        if (cram_index_container(fd, c, fp, cpos) < 0) {
-            bgzf_close(fp);
-            return -1;
-        }
-
-        cpos = htell(fd->fp);
-        assert(cpos == hpos + c->length);
-
-        cram_free_container(c);
-    }
-    if (fd->err) {
-        bgzf_close(fp);
-        return -1;
-    }
-
-    return (bgzf_close(fp) >= 0)? 0 : -4;
-}
diff -ruN stringtie.orig/htslib/cram/cram_index.h stringtie/htslib/cram/cram_index.h
--- stringtie.orig/htslib/cram/cram_index.h	2024-02-28 13:57:39.701246126 +0100
+++ stringtie/htslib/cram/cram_index.h	1970-01-01 01:00:00.000000000 +0100
@@ -1,115 +0,0 @@
-/*
-Copyright (c) 2013, 2018 Genome Research Ltd.
-Author: James Bonfield <jkb@sanger.ac.uk>
-
-Redistribution and use in source and binary forms, with or without
-modification, are permitted provided that the following conditions are met:
-
-   1. Redistributions of source code must retain the above copyright notice,
-this list of conditions and the following disclaimer.
-
-   2. Redistributions in binary form must reproduce the above copyright notice,
-this list of conditions and the following disclaimer in the documentation
-and/or other materials provided with the distribution.
-
-   3. Neither the names Genome Research Ltd and Wellcome Trust Sanger
-Institute nor the names of its contributors may be used to endorse or promote
-products derived from this software without specific prior written permission.
-
-THIS SOFTWARE IS PROVIDED BY GENOME RESEARCH LTD AND CONTRIBUTORS "AS IS" AND
-ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
-WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
-DISCLAIMED. IN NO EVENT SHALL GENOME RESEARCH LTD OR CONTRIBUTORS BE LIABLE
-FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
-DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
-SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
-CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
-OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
-OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-*/
-
-#ifndef CRAM_INDEX_H
-#define CRAM_INDEX_H
-
-#ifdef __cplusplus
-extern "C" {
-#endif
-
-/*
- * Loads a CRAM .crai index into memory.
- * Returns 0 for success
- *        -1 for failure
- */
-int cram_index_load(cram_fd *fd, const char *fn, const char *fn_idx);
-
-void cram_index_free(cram_fd *fd);
-
-/*
- * Searches the index for the first slice overlapping a reference ID
- * and position.
- *
- * Returns the cram_index pointer on success
- *         NULL on failure
- */
-cram_index *cram_index_query(cram_fd *fd, int refid, hts_pos_t pos, cram_index *frm);
-cram_index *cram_index_last(cram_fd *fd, int refid, cram_index *from);
-cram_index *cram_index_query_last(cram_fd *fd, int refid, hts_pos_t end);
-
-/*
- * Skips to a container overlapping the start coordinate listed in
- * cram_range.
- *
- * Returns 0 on success
- *        -1 on failure
- */
-int cram_seek_to_refpos(cram_fd *fd, cram_range *r);
-
-void cram_index_free(cram_fd *fd);
-
-/*
- * Skips to a container overlapping the start coordinate listed in
- * cram_range.
- *
- * In theory we call cram_index_query multiple times, once per slice
- * overlapping the range. However slices may be absent from the index
- * which makes this problematic. Instead we find the left-most slice
- * and then read from then on, skipping decoding of slices and/or
- * whole containers when they don't overlap the specified cram_range.
- *
- * Returns 0 on success
- *        -1 on failure
- */
-int cram_seek_to_refpos(cram_fd *fd, cram_range *r);
-
-/*
- * Builds an index file.
- *
- * fd is a newly opened cram file that we wish to index.
- * fn_base is the filename of the associated CRAM file.
- * fn_idx is the filename of the index file to be written;
- * if NULL, we add ".crai" to fn_base to get the index filename.
- *
- * Returns 0 on success,
- *         negative on failure (-1 for read failure, -4 for write failure)
- */
-int cram_index_build(cram_fd *fd, const char *fn_base, const char *fn_idx);
-
-/*
- * Adds a single slice to the index.
- *
- * Returns 0 on success,
- *        -1 on failure
- */
-int cram_index_slice(cram_fd *fd,
-                     cram_container *c,
-                     cram_slice *s,
-                     BGZF *fp,
-                     off_t cpos,
-                     off_t spos, // relative to cpos
-                     off_t sz);
-
-#ifdef __cplusplus
-}
-#endif
-
-#endif
diff -ruN stringtie.orig/htslib/cram/cram_io.c stringtie/htslib/cram/cram_io.c
--- stringtie.orig/htslib/cram/cram_io.c	2024-02-28 13:57:39.701246126 +0100
+++ stringtie/htslib/cram/cram_io.c	1970-01-01 01:00:00.000000000 +0100
@@ -1,5861 +0,0 @@
-/*
-Copyright (c) 2012-2021 Genome Research Ltd.
-Author: James Bonfield <jkb@sanger.ac.uk>
-
-Redistribution and use in source and binary forms, with or without
-modification, are permitted provided that the following conditions are met:
-
-   1. Redistributions of source code must retain the above copyright notice,
-this list of conditions and the following disclaimer.
-
-   2. Redistributions in binary form must reproduce the above copyright notice,
-this list of conditions and the following disclaimer in the documentation
-and/or other materials provided with the distribution.
-
-   3. Neither the names Genome Research Ltd and Wellcome Trust Sanger
-Institute nor the names of its contributors may be used to endorse or promote
-products derived from this software without specific prior written permission.
-
-THIS SOFTWARE IS PROVIDED BY GENOME RESEARCH LTD AND CONTRIBUTORS "AS IS" AND
-ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
-WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
-DISCLAIMED. IN NO EVENT SHALL GENOME RESEARCH LTD OR CONTRIBUTORS BE LIABLE
-FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
-DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
-SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
-CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
-OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
-OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-*/
-
-/*
- * CRAM I/O primitives.
- *
- * - ITF8 encoding and decoding.
- * - Block based I/O
- * - Zlib inflating and deflating (memory)
- * - CRAM basic data structure reading and writing
- * - File opening / closing
- * - Reference sequence handling
- */
-
-#define HTS_BUILDING_LIBRARY // Enables HTSLIB_EXPORT, see htslib/hts_defs.h
-#include <config.h>
-
-#include <stdio.h>
-#include <errno.h>
-#include <assert.h>
-#include <stdlib.h>
-#include <string.h>
-#include <unistd.h>
-#include <zlib.h>
-#ifdef HAVE_LIBBZ2
-#include <bzlib.h>
-#endif
-#ifdef HAVE_LIBLZMA
-#ifdef HAVE_LZMA_H
-#include <lzma.h>
-#else
-#include "../os/lzma_stub.h"
-#endif
-#endif
-#include <sys/types.h>
-#include <sys/stat.h>
-#include <math.h>
-#include <stdint.h>
-
-#ifdef HAVE_LIBDEFLATE
-#include <libdeflate.h>
-#define crc32(a,b,c) libdeflate_crc32((a),(b),(c))
-#endif
-
-#include "cram.h"
-#include "os.h"
-#include "../htslib/hts.h"
-#include "open_trace_file.h"
-
-#if defined(HAVE_EXTERNAL_LIBHTSCODECS)
-#include <htscodecs/rANS_static.h>
-#include <htscodecs/rANS_static4x16.h>
-#include <htscodecs/arith_dynamic.h>
-#include <htscodecs/tokenise_name3.h>
-#include <htscodecs/fqzcomp_qual.h>
-#include <htscodecs/varint.h> // CRAM v4.0 variable-size integers
-#else
-#include "../htscodecs/htscodecs/rANS_static.h"
-#include "../htscodecs/htscodecs/rANS_static4x16.h"
-#include "../htscodecs/htscodecs/arith_dynamic.h"
-#include "../htscodecs/htscodecs/tokenise_name3.h"
-#include "../htscodecs/htscodecs/fqzcomp_qual.h"
-#include "../htscodecs/htscodecs/varint.h"
-#endif
-
-//#define REF_DEBUG
-
-#ifdef REF_DEBUG
-#include <sys/syscall.h>
-#define gettid() (int)syscall(SYS_gettid)
-
-#define RP(...) fprintf (stderr, __VA_ARGS__)
-#else
-#define RP(...)
-#endif
-
-#include "../htslib/hfile.h"
-#include "../htslib/bgzf.h"
-#include "../htslib/faidx.h"
-#include "../hts_internal.h"
-
-#ifndef PATH_MAX
-#define PATH_MAX FILENAME_MAX
-#endif
-
-#define TRIAL_SPAN 70
-#define NTRIALS 3
-
-#define CRAM_DEFAULT_LEVEL 5
-
-/* ----------------------------------------------------------------------
- * ITF8 encoding and decoding.
- *
- * Also see the itf8_get and itf8_put macros in cram_io.h
- */
-
-/*
- * LEGACY: consider using itf8_decode_crc.
- *
- * Reads an integer in ITF-8 encoding from 'cp' and stores it in
- * *val.
- *
- * Returns the number of bytes read on success
- *        -1 on failure
- */
-int itf8_decode(cram_fd *fd, int32_t *val_p) {
-    static int nbytes[16] = {
-        0,0,0,0, 0,0,0,0,                               // 0000xxxx - 0111xxxx
-        1,1,1,1,                                        // 1000xxxx - 1011xxxx
-        2,2,                                            // 1100xxxx - 1101xxxx
-        3,                                              // 1110xxxx
-        4,                                              // 1111xxxx
-    };
-
-    static int nbits[16] = {
-        0x7f, 0x7f, 0x7f, 0x7f, 0x7f, 0x7f, 0x7f, 0x7f, // 0000xxxx - 0111xxxx
-        0x3f, 0x3f, 0x3f, 0x3f,                         // 1000xxxx - 1011xxxx
-        0x1f, 0x1f,                                     // 1100xxxx - 1101xxxx
-        0x0f,                                           // 1110xxxx
-        0x0f,                                           // 1111xxxx
-    };
-
-    int32_t val = hgetc(fd->fp);
-    if (val == -1)
-        return -1;
-
-    int i = nbytes[val>>4];
-    val &= nbits[val>>4];
-
-    switch(i) {
-    case 0:
-        *val_p = val;
-        return 1;
-
-    case 1:
-        val = (val<<8) | (unsigned char)hgetc(fd->fp);
-        *val_p = val;
-        return 2;
-
-    case 2:
-        val = (val<<8) | (unsigned char)hgetc(fd->fp);
-        val = (val<<8) | (unsigned char)hgetc(fd->fp);
-        *val_p = val;
-        return 3;
-
-    case 3:
-        val = (val<<8) | (unsigned char)hgetc(fd->fp);
-        val = (val<<8) | (unsigned char)hgetc(fd->fp);
-        val = (val<<8) | (unsigned char)hgetc(fd->fp);
-        *val_p = val;
-        return 4;
-
-    case 4: // really 3.5 more, why make it different?
-        val = (val<<8) | (unsigned char)hgetc(fd->fp);
-        val = (val<<8) | (unsigned char)hgetc(fd->fp);
-        val = (val<<8) | (unsigned char)hgetc(fd->fp);
-        val = (val<<4) | (((unsigned char)hgetc(fd->fp)) & 0x0f);
-        *val_p = val;
-    }
-
-    return 5;
-}
-
-int itf8_decode_crc(cram_fd *fd, int32_t *val_p, uint32_t *crc) {
-    static int nbytes[16] = {
-        0,0,0,0, 0,0,0,0,                               // 0000xxxx - 0111xxxx
-        1,1,1,1,                                        // 1000xxxx - 1011xxxx
-        2,2,                                            // 1100xxxx - 1101xxxx
-        3,                                              // 1110xxxx
-        4,                                              // 1111xxxx
-    };
-
-    static int nbits[16] = {
-        0x7f, 0x7f, 0x7f, 0x7f, 0x7f, 0x7f, 0x7f, 0x7f, // 0000xxxx - 0111xxxx
-        0x3f, 0x3f, 0x3f, 0x3f,                         // 1000xxxx - 1011xxxx
-        0x1f, 0x1f,                                     // 1100xxxx - 1101xxxx
-        0x0f,                                           // 1110xxxx
-        0x0f,                                           // 1111xxxx
-    };
-    unsigned char c[5];
-
-    int32_t val = hgetc(fd->fp);
-    if (val == -1)
-        return -1;
-
-    c[0]=val;
-
-    int i = nbytes[val>>4];
-    val &= nbits[val>>4];
-
-    if (i > 0) {
-        if (hread(fd->fp, &c[1], i) < i)
-            return -1;
-    }
-
-    switch(i) {
-    case 0:
-        *val_p = val;
-        *crc = crc32(*crc, c, 1);
-        return 1;
-
-    case 1:
-        val = (val<<8) | c[1];
-        *val_p = val;
-        *crc = crc32(*crc, c, 2);
-        return 2;
-
-    case 2:
-        val = (val<<8) | c[1];
-        val = (val<<8) | c[2];
-        *val_p = val;
-        *crc = crc32(*crc, c, 3);
-        return 3;
-
-    case 3:
-        val = (val<<8) | c[1];
-        val = (val<<8) | c[2];
-        val = (val<<8) | c[3];
-        *val_p = val;
-        *crc = crc32(*crc, c, 4);
-        return 4;
-
-    case 4: // really 3.5 more, why make it different?
-        {
-            uint32_t uv = val;
-            uv = (uv<<8) |  c[1];
-            uv = (uv<<8) |  c[2];
-            uv = (uv<<8) |  c[3];
-            uv = (uv<<4) | (c[4] & 0x0f);
-            // Avoid implementation-defined behaviour on negative values
-            *val_p = uv < 0x80000000UL ? (int32_t) uv : -((int32_t) (0xffffffffUL - uv)) - 1;
-            *crc = crc32(*crc, c, 5);
-        }
-    }
-
-    return 5;
-}
-
-/*
- * Stores a value to memory in ITF-8 format.
- *
- * Returns the number of bytes required to store the number.
- * This is a maximum of 5 bytes.
- */
-static inline int itf8_put(char *cp, int32_t val) {
-    unsigned char *up = (unsigned char *)cp;
-    if        (!(val & ~0x00000007f)) { // 1 byte
-        *up = val;
-        return 1;
-    } else if (!(val & ~0x00003fff)) { // 2 byte
-        *up++ = (val >> 8 ) | 0x80;
-        *up   = val & 0xff;
-        return 2;
-    } else if (!(val & ~0x01fffff)) { // 3 byte
-        *up++ = (val >> 16) | 0xc0;
-        *up++ = (val >> 8 ) & 0xff;
-        *up   = val & 0xff;
-        return 3;
-    } else if (!(val & ~0x0fffffff)) { // 4 byte
-        *up++ = (val >> 24) | 0xe0;
-        *up++ = (val >> 16) & 0xff;
-        *up++ = (val >> 8 ) & 0xff;
-        *up   = val & 0xff;
-        return 4;
-    } else {                           // 5 byte
-        *up++ = 0xf0 | ((val>>28) & 0xff);
-        *up++ = (val >> 20) & 0xff;
-        *up++ = (val >> 12) & 0xff;
-        *up++ = (val >> 4 ) & 0xff;
-        *up = val & 0x0f;
-        return 5;
-    }
-}
-
-
-/* 64-bit itf8 variant */
-static inline int ltf8_put(char *cp, int64_t val) {
-    unsigned char *up = (unsigned char *)cp;
-    if        (!(val & ~((1LL<<7)-1))) {
-        *up = val;
-        return 1;
-    } else if (!(val & ~((1LL<<(6+8))-1))) {
-        *up++ = (val >> 8 ) | 0x80;
-        *up   = val & 0xff;
-        return 2;
-    } else if (!(val & ~((1LL<<(5+2*8))-1))) {
-        *up++ = (val >> 16) | 0xc0;
-        *up++ = (val >> 8 ) & 0xff;
-        *up   = val & 0xff;
-        return 3;
-    } else if (!(val & ~((1LL<<(4+3*8))-1))) {
-        *up++ = (val >> 24) | 0xe0;
-        *up++ = (val >> 16) & 0xff;
-        *up++ = (val >> 8 ) & 0xff;
-        *up   = val & 0xff;
-        return 4;
-    } else if (!(val & ~((1LL<<(3+4*8))-1))) {
-        *up++ = (val >> 32) | 0xf0;
-        *up++ = (val >> 24) & 0xff;
-        *up++ = (val >> 16) & 0xff;
-        *up++ = (val >> 8 ) & 0xff;
-        *up   = val & 0xff;
-        return 5;
-    } else if (!(val & ~((1LL<<(2+5*8))-1))) {
-        *up++ = (val >> 40) | 0xf8;
-        *up++ = (val >> 32) & 0xff;
-        *up++ = (val >> 24) & 0xff;
-        *up++ = (val >> 16) & 0xff;
-        *up++ = (val >> 8 ) & 0xff;
-        *up   = val & 0xff;
-        return 6;
-    } else if (!(val & ~((1LL<<(1+6*8))-1))) {
-        *up++ = (val >> 48) | 0xfc;
-        *up++ = (val >> 40) & 0xff;
-        *up++ = (val >> 32) & 0xff;
-        *up++ = (val >> 24) & 0xff;
-        *up++ = (val >> 16) & 0xff;
-        *up++ = (val >> 8 ) & 0xff;
-        *up   = val & 0xff;
-        return 7;
-    } else if (!(val & ~((1LL<<(7*8))-1))) {
-        *up++ = (val >> 56) | 0xfe;
-        *up++ = (val >> 48) & 0xff;
-        *up++ = (val >> 40) & 0xff;
-        *up++ = (val >> 32) & 0xff;
-        *up++ = (val >> 24) & 0xff;
-        *up++ = (val >> 16) & 0xff;
-        *up++ = (val >> 8 ) & 0xff;
-        *up   = val & 0xff;
-        return 8;
-    } else {
-        *up++ = 0xff;
-        *up++ = (val >> 56) & 0xff;
-        *up++ = (val >> 48) & 0xff;
-        *up++ = (val >> 40) & 0xff;
-        *up++ = (val >> 32) & 0xff;
-        *up++ = (val >> 24) & 0xff;
-        *up++ = (val >> 16) & 0xff;
-        *up++ = (val >> 8 ) & 0xff;
-        *up   = val & 0xff;
-        return 9;
-    }
-}
-
-/*
- * Encodes and writes a single integer in ITF-8 format.
- * Returns 0 on success
- *        -1 on failure
- */
-int itf8_encode(cram_fd *fd, int32_t val) {
-    char buf[5];
-    int len = itf8_put(buf, val);
-    return hwrite(fd->fp, buf, len) == len ? 0 : -1;
-}
-
-const int itf8_bytes[16] = {
-    1, 1, 1, 1,  1, 1, 1, 1,
-    2, 2, 2, 2,  3, 3, 4, 5
-};
-
-const int ltf8_bytes[256] = {
-    1, 1, 1, 1,  1, 1, 1, 1,  1, 1, 1, 1,  1, 1, 1, 1,
-    1, 1, 1, 1,  1, 1, 1, 1,  1, 1, 1, 1,  1, 1, 1, 1,
-    1, 1, 1, 1,  1, 1, 1, 1,  1, 1, 1, 1,  1, 1, 1, 1,
-    1, 1, 1, 1,  1, 1, 1, 1,  1, 1, 1, 1,  1, 1, 1, 1,
-
-    1, 1, 1, 1,  1, 1, 1, 1,  1, 1, 1, 1,  1, 1, 1, 1,
-    1, 1, 1, 1,  1, 1, 1, 1,  1, 1, 1, 1,  1, 1, 1, 1,
-    1, 1, 1, 1,  1, 1, 1, 1,  1, 1, 1, 1,  1, 1, 1, 1,
-    1, 1, 1, 1,  1, 1, 1, 1,  1, 1, 1, 1,  1, 1, 1, 1,
-
-    2, 2, 2, 2,  2, 2, 2, 2,  2, 2, 2, 2,  2, 2, 2, 2,
-    2, 2, 2, 2,  2, 2, 2, 2,  2, 2, 2, 2,  2, 2, 2, 2,
-    2, 2, 2, 2,  2, 2, 2, 2,  2, 2, 2, 2,  2, 2, 2, 2,
-    2, 2, 2, 2,  2, 2, 2, 2,  2, 2, 2, 2,  2, 2, 2, 2,
-
-    3, 3, 3, 3,  3, 3, 3, 3,  3, 3, 3, 3,  3, 3, 3, 3,
-    3, 3, 3, 3,  3, 3, 3, 3,  3, 3, 3, 3,  3, 3, 3, 3,
-
-    4, 4, 4, 4,  4, 4, 4, 4,  4, 4, 4, 4,  4, 4, 4, 4,
-
-    5, 5, 5, 5,  5, 5, 5, 5,  6, 6, 6, 6,  7, 7, 8, 9
-};
-
-/*
- * LEGACY: consider using ltf8_decode_crc.
- */
-int ltf8_decode(cram_fd *fd, int64_t *val_p) {
-    int c = hgetc(fd->fp);
-    int64_t val = (unsigned char)c;
-    if (c == -1)
-        return -1;
-
-    if (val < 0x80) {
-        *val_p =   val;
-        return 1;
-
-    } else if (val < 0xc0) {
-        val = (val<<8) | (unsigned char)hgetc(fd->fp);
-        *val_p = val & (((1LL<<(6+8)))-1);
-        return 2;
-
-    } else if (val < 0xe0) {
-        val = (val<<8) | (unsigned char)hgetc(fd->fp);
-        val = (val<<8) | (unsigned char)hgetc(fd->fp);
-        *val_p = val & ((1LL<<(5+2*8))-1);
-        return 3;
-
-    } else if (val < 0xf0) {
-        val = (val<<8) | (unsigned char)hgetc(fd->fp);
-        val = (val<<8) | (unsigned char)hgetc(fd->fp);
-        val = (val<<8) | (unsigned char)hgetc(fd->fp);
-        *val_p = val & ((1LL<<(4+3*8))-1);
-        return 4;
-
-    } else if (val < 0xf8) {
-        val = (val<<8) | (unsigned char)hgetc(fd->fp);
-        val = (val<<8) | (unsigned char)hgetc(fd->fp);
-        val = (val<<8) | (unsigned char)hgetc(fd->fp);
-        val = (val<<8) | (unsigned char)hgetc(fd->fp);
-        *val_p = val & ((1LL<<(3+4*8))-1);
-        return 5;
-
-    } else if (val < 0xfc) {
-        val = (val<<8) | (unsigned char)hgetc(fd->fp);
-        val = (val<<8) | (unsigned char)hgetc(fd->fp);
-        val = (val<<8) | (unsigned char)hgetc(fd->fp);
-        val = (val<<8) | (unsigned char)hgetc(fd->fp);
-        val = (val<<8) | (unsigned char)hgetc(fd->fp);
-        *val_p = val & ((1LL<<(2+5*8))-1);
-        return 6;
-
-    } else if (val < 0xfe) {
-        val = (val<<8) | (unsigned char)hgetc(fd->fp);
-        val = (val<<8) | (unsigned char)hgetc(fd->fp);
-        val = (val<<8) | (unsigned char)hgetc(fd->fp);
-        val = (val<<8) | (unsigned char)hgetc(fd->fp);
-        val = (val<<8) | (unsigned char)hgetc(fd->fp);
-        val = (val<<8) | (unsigned char)hgetc(fd->fp);
-        *val_p = val & ((1LL<<(1+6*8))-1);
-        return 7;
-
-    } else if (val < 0xff) {
-        val = (val<<8) | (unsigned char)hgetc(fd->fp);
-        val = (val<<8) | (unsigned char)hgetc(fd->fp);
-        val = (val<<8) | (unsigned char)hgetc(fd->fp);
-        val = (val<<8) | (unsigned char)hgetc(fd->fp);
-        val = (val<<8) | (unsigned char)hgetc(fd->fp);
-        val = (val<<8) | (unsigned char)hgetc(fd->fp);
-        val = (val<<8) | (unsigned char)hgetc(fd->fp);
-        *val_p = val & ((1LL<<(7*8))-1);
-        return 8;
-
-    } else {
-        val = (val<<8) | (unsigned char)hgetc(fd->fp);
-        val = (val<<8) | (unsigned char)hgetc(fd->fp);
-        val = (val<<8) | (unsigned char)hgetc(fd->fp);
-        val = (val<<8) | (unsigned char)hgetc(fd->fp);
-        val = (val<<8) | (unsigned char)hgetc(fd->fp);
-        val = (val<<8) | (unsigned char)hgetc(fd->fp);
-        val = (val<<8) | (unsigned char)hgetc(fd->fp);
-        val = (val<<8) | (unsigned char)hgetc(fd->fp);
-        *val_p = val;
-    }
-
-    return 9;
-}
-
-int ltf8_decode_crc(cram_fd *fd, int64_t *val_p, uint32_t *crc) {
-    unsigned char c[9];
-    int64_t val = hgetc(fd->fp);
-    if (val < 0)
-        return -1;
-
-    c[0] = val;
-
-    if (val < 0x80) {
-        *val_p =   val;
-        *crc = crc32(*crc, c, 1);
-        return 1;
-
-    } else if (val < 0xc0) {
-        int v = hgetc(fd->fp);
-        if (v < 0)
-            return -1;
-        val = (val<<8) | (c[1]=v);
-        *val_p = val & (((1LL<<(6+8)))-1);
-        *crc = crc32(*crc, c, 2);
-        return 2;
-
-    } else if (val < 0xe0) {
-        if (hread(fd->fp, &c[1], 2) < 2)
-            return -1;
-        val = (val<<8) | c[1];
-        val = (val<<8) | c[2];
-        *val_p = val & ((1LL<<(5+2*8))-1);
-        *crc = crc32(*crc, c, 3);
-        return 3;
-
-    } else if (val < 0xf0) {
-        if (hread(fd->fp, &c[1], 3) < 3)
-            return -1;
-        val = (val<<8) | c[1];
-        val = (val<<8) | c[2];
-        val = (val<<8) | c[3];
-        *val_p = val & ((1LL<<(4+3*8))-1);
-        *crc = crc32(*crc, c, 4);
-        return 4;
-
-    } else if (val < 0xf8) {
-        if (hread(fd->fp, &c[1], 4) < 4)
-            return -1;
-        val = (val<<8) | c[1];
-        val = (val<<8) | c[2];
-        val = (val<<8) | c[3];
-        val = (val<<8) | c[4];
-        *val_p = val & ((1LL<<(3+4*8))-1);
-        *crc = crc32(*crc, c, 5);
-        return 5;
-
-    } else if (val < 0xfc) {
-        if (hread(fd->fp, &c[1], 5) < 5)
-            return -1;
-        val = (val<<8) | c[1];
-        val = (val<<8) | c[2];
-        val = (val<<8) | c[3];
-        val = (val<<8) | c[4];
-        val = (val<<8) | c[5];
-        *val_p = val & ((1LL<<(2+5*8))-1);
-        *crc = crc32(*crc, c, 6);
-        return 6;
-
-    } else if (val < 0xfe) {
-        if (hread(fd->fp, &c[1], 6) < 6)
-            return -1;
-        val = (val<<8) | c[1];
-        val = (val<<8) | c[2];
-        val = (val<<8) | c[3];
-        val = (val<<8) | c[4];
-        val = (val<<8) | c[5];
-        val = (val<<8) | c[6];
-        *val_p = val & ((1LL<<(1+6*8))-1);
-        *crc = crc32(*crc, c, 7);
-        return 7;
-
-    } else if (val < 0xff) {
-        uint64_t uval = val;
-        if (hread(fd->fp, &c[1], 7) < 7)
-            return -1;
-        uval = (uval<<8) | c[1];
-        uval = (uval<<8) | c[2];
-        uval = (uval<<8) | c[3];
-        uval = (uval<<8) | c[4];
-        uval = (uval<<8) | c[5];
-        uval = (uval<<8) | c[6];
-        uval = (uval<<8) | c[7];
-        *val_p = uval & ((1ULL<<(7*8))-1);
-        *crc = crc32(*crc, c, 8);
-        return 8;
-
-    } else {
-        uint64_t uval;
-        if (hread(fd->fp, &c[1], 8) < 8)
-            return -1;
-        uval =             c[1];
-        uval = (uval<<8) | c[2];
-        uval = (uval<<8) | c[3];
-        uval = (uval<<8) | c[4];
-        uval = (uval<<8) | c[5];
-        uval = (uval<<8) | c[6];
-        uval = (uval<<8) | c[7];
-        uval = (uval<<8) | c[8];
-        *crc = crc32(*crc, c, 9);
-        // Avoid implementation-defined behaviour on negative values
-        *val_p = c[1] < 0x80 ? (int64_t) uval : -((int64_t) (0xffffffffffffffffULL - uval)) - 1;
-    }
-
-    return 9;
-}
-
-/*
- * Pushes a value in ITF8 format onto the end of a block.
- * This shouldn't be used for high-volume data as it is not the fastest
- * method.
- *
- * Returns the number of bytes written
- */
-int itf8_put_blk(cram_block *blk, int32_t val) {
-    char buf[5];
-    int sz;
-
-    sz = itf8_put(buf, val);
-    BLOCK_APPEND(blk, buf, sz);
-    return sz;
-
- block_err:
-    return -1;
-}
-
-int ltf8_put_blk(cram_block *blk, int64_t val) {
-    char buf[9];
-    int sz;
-
-    sz = ltf8_put(buf, val);
-    BLOCK_APPEND(blk, buf, sz);
-    return sz;
-
- block_err:
-    return -1;
-}
-
-static int64_t safe_itf8_get(char **cp, const char *endp, int *err) {
-    const unsigned char *up = (unsigned char *)*cp;
-
-    if (endp && endp - *cp < 5 &&
-        (*cp >= endp || endp - *cp < itf8_bytes[up[0]>>4])) {
-        if (err) *err = 1;
-        return 0;
-    }
-
-    if (up[0] < 0x80) {
-        (*cp)++;
-        return up[0];
-    } else if (up[0] < 0xc0) {
-        (*cp)+=2;
-        return ((up[0] <<8) |  up[1])                           & 0x3fff;
-    } else if (up[0] < 0xe0) {
-        (*cp)+=3;
-        return ((up[0]<<16) | (up[1]<< 8) |  up[2])             & 0x1fffff;
-    } else if (up[0] < 0xf0) {
-        (*cp)+=4;
-        uint32_t uv = (((uint32_t)up[0]<<24) | (up[1]<<16) | (up[2]<<8) | up[3]) & 0x0fffffff;
-        return (int32_t)uv;
-    } else {
-        (*cp)+=5;
-        uint32_t uv = (((uint32_t)up[0] & 0x0f)<<28) | (up[1]<<20) | (up[2]<<12) | (up[3]<<4) | (up[4] & 0x0f);
-        return (int32_t)uv;
-    }
-}
-
-static int64_t safe_ltf8_get(char **cp, const char *endp, int *err) {
-    unsigned char *up = (unsigned char *)*cp;
-
-    if (endp && endp - *cp < 9 &&
-        (*cp >= endp || endp - *cp < ltf8_bytes[up[0]])) {
-        if (err) *err = 1;
-        return 0;
-    }
-
-    if (up[0] < 0x80) {
-        (*cp)++;
-        return up[0];
-    } else if (up[0] < 0xc0) {
-        (*cp)+=2;
-        return (((uint64_t)up[0]<< 8) |
-                 (uint64_t)up[1]) & (((1LL<<(6+8)))-1);
-    } else if (up[0] < 0xe0) {
-        (*cp)+=3;
-        return (((uint64_t)up[0]<<16) |
-                ((uint64_t)up[1]<< 8) |
-                 (uint64_t)up[2]) & ((1LL<<(5+2*8))-1);
-    } else if (up[0] < 0xf0) {
-        (*cp)+=4;
-        return (((uint64_t)up[0]<<24) |
-                ((uint64_t)up[1]<<16) |
-                ((uint64_t)up[2]<< 8) |
-                 (uint64_t)up[3]) & ((1LL<<(4+3*8))-1);
-    } else if (up[0] < 0xf8) {
-        (*cp)+=5;
-        return (((uint64_t)up[0]<<32) |
-                ((uint64_t)up[1]<<24) |
-                ((uint64_t)up[2]<<16) |
-                ((uint64_t)up[3]<< 8) |
-                 (uint64_t)up[4]) & ((1LL<<(3+4*8))-1);
-    } else if (up[0] < 0xfc) {
-        (*cp)+=6;
-        return (((uint64_t)up[0]<<40) |
-                ((uint64_t)up[1]<<32) |
-                ((uint64_t)up[2]<<24) |
-                ((uint64_t)up[3]<<16) |
-                ((uint64_t)up[4]<< 8) |
-                 (uint64_t)up[5]) & ((1LL<<(2+5*8))-1);
-    } else if (up[0] < 0xfe) {
-        (*cp)+=7;
-        return (((uint64_t)up[0]<<48) |
-                ((uint64_t)up[1]<<40) |
-                ((uint64_t)up[2]<<32) |
-                ((uint64_t)up[3]<<24) |
-                ((uint64_t)up[4]<<16) |
-                ((uint64_t)up[5]<< 8) |
-                 (uint64_t)up[6]) & ((1LL<<(1+6*8))-1);
-    } else if (up[0] < 0xff) {
-        (*cp)+=8;
-        return (((uint64_t)up[1]<<48) |
-                ((uint64_t)up[2]<<40) |
-                ((uint64_t)up[3]<<32) |
-                ((uint64_t)up[4]<<24) |
-                ((uint64_t)up[5]<<16) |
-                ((uint64_t)up[6]<< 8) |
-                 (uint64_t)up[7]) & ((1LL<<(7*8))-1);
-    } else {
-        (*cp)+=9;
-        return (((uint64_t)up[1]<<56) |
-                ((uint64_t)up[2]<<48) |
-                ((uint64_t)up[3]<<40) |
-                ((uint64_t)up[4]<<32) |
-                ((uint64_t)up[5]<<24) |
-                ((uint64_t)up[6]<<16) |
-                ((uint64_t)up[7]<< 8) |
-                 (uint64_t)up[8]);
-    }
-}
-
-// Wrapper for now
-int safe_itf8_put(char *cp, const char *cp_end, int32_t val) {
-    return itf8_put(cp, val);
-}
-
-int safe_ltf8_put(char *cp, const char *cp_end, int64_t val) {
-    return ltf8_put(cp, val);
-}
-
-int itf8_size(int64_t v) {
-    return ((!((v)&~0x7f))?1:(!((v)&~0x3fff))?2:(!((v)&~0x1fffff))?3:(!((v)&~0xfffffff))?4:5);
-}
-
-//-----------------------------------------------------------------------------
-
-// CRAM v4.0 onwards uses a different variable sized integer encoding
-// that is size agnostic.
-
-// Local interface to varint.h inline version, so we can use in func ptr.
-// Note a lot of these use the unsigned interface but take signed int64_t.
-// This is because the old CRAM ITF8 inteface had signed -1 as unsigned
-// 0xffffffff.
-static int uint7_size(int64_t v) {
-    return var_size_u64(v);
-}
-
-static int64_t uint7_get_32(char **cp, const char *endp, int *err) {
-    uint32_t val;
-    int nb = var_get_u32((uint8_t *)(*cp), (const uint8_t *)endp, &val);
-    (*cp) += nb;
-    if (!nb && err) *err = 1;
-    return val;
-}
-
-static int64_t sint7_get_32(char **cp, const char *endp, int *err) {
-    int32_t val;
-    int nb = var_get_s32((uint8_t *)(*cp), (const uint8_t *)endp, &val);
-    (*cp) += nb;
-    if (!nb && err) *err = 1;
-    return val;
-}
-
-static int64_t uint7_get_64(char **cp, const char *endp, int *err) {
-    uint64_t val;
-    int nb = var_get_u64((uint8_t *)(*cp), (const uint8_t *)endp, &val);
-    (*cp) += nb;
-    if (!nb && err) *err = 1;
-    return val;
-}
-
-static int64_t sint7_get_64(char **cp, const char *endp, int *err) {
-    int64_t val;
-    int nb = var_get_s64((uint8_t *)(*cp), (const uint8_t *)endp, &val);
-    (*cp) += nb;
-    if (!nb && err) *err = 1;
-    return val;
-}
-
-static int uint7_put_32(char *cp, const char *endp, int32_t val) {
-    return var_put_u32((uint8_t *)cp, (const uint8_t *)endp, val);
-}
-
-static int sint7_put_32(char *cp, const char *endp, int32_t val) {
-    return var_put_s32((uint8_t *)cp, (const uint8_t *)endp, val);
-}
-
-static int uint7_put_64(char *cp, const char *endp, int64_t val) {
-    return var_put_u64((uint8_t *)cp, (const uint8_t *)endp, val);
-}
-
-static int sint7_put_64(char *cp, const char *endp, int64_t val) {
-    return var_put_s64((uint8_t *)cp, (const uint8_t *)endp, val);
-}
-
-// Put direct to to cram_block
-static int uint7_put_blk_32(cram_block *blk, int32_t v) {
-    uint8_t buf[10];
-    int sz = var_put_u32(buf, buf+10, v);
-    BLOCK_APPEND(blk, buf, sz);
-    return sz;
-
- block_err:
-    return -1;
-}
-
-static int sint7_put_blk_32(cram_block *blk, int32_t v) {
-    uint8_t buf[10];
-    int sz = var_put_s32(buf, buf+10, v);
-    BLOCK_APPEND(blk, buf, sz);
-    return sz;
-
- block_err:
-    return -1;
-}
-
-static int uint7_put_blk_64(cram_block *blk, int64_t v) {
-    uint8_t buf[10];
-    int sz = var_put_u64(buf, buf+10, v);
-    BLOCK_APPEND(blk, buf, sz);
-    return sz;
-
- block_err:
-    return -1;
-}
-
-static int sint7_put_blk_64(cram_block *blk, int64_t v) {
-    uint8_t buf[10];
-    int sz = var_put_s64(buf, buf+10, v);
-    BLOCK_APPEND(blk, buf, sz);
-    return sz;
-
- block_err:
-    return -1;
-}
-
-// Decode 32-bits with CRC update from cram_fd
-static int uint7_decode_crc32(cram_fd *fd, int32_t *val_p, uint32_t *crc) {
-    uint8_t b[5], i = 0;
-    int c;
-    uint32_t v = 0;
-
-#ifdef VARINT2
-    b[0] = hgetc(fd->fp);
-    if (b[0] < 177) {
-    } else if (b[0] < 241) {
-        b[1] = hgetc(fd->fp);
-    } else if (b[0] < 249) {
-        b[1] = hgetc(fd->fp);
-        b[2] = hgetc(fd->fp);
-    } else {
-        int n = b[0]+2, z = 1;
-        while (n-- >= 249)
-            b[z++] = hgetc(fd->fp);
-    }
-    i = var_get_u32(b, NULL, &v);
-#else
-//    // Little endian
-//    int s = 0;
-//    do {
-//        b[i++] = c = hgetc(fd->fp);
-//        if (c < 0)
-//            return -1;
-//        v |= (c & 0x7f) << s;
-//      s += 7;
-//    } while (i < 5 && (c & 0x80));
-
-    // Big endian, see also htscodecs/varint.h
-    do {
-        b[i++] = c = hgetc(fd->fp);
-        if (c < 0)
-            return -1;
-        v = (v<<7) | (c & 0x7f);
-    } while (i < 5 && (c & 0x80));
-#endif
-    *crc = crc32(*crc, b, i);
-
-    *val_p = v;
-    return i;
-}
-
-// Decode 32-bits with CRC update from cram_fd
-static int sint7_decode_crc32(cram_fd *fd, int32_t *val_p, uint32_t *crc) {
-    uint8_t b[5], i = 0;
-    int c;
-    uint32_t v = 0;
-
-#ifdef VARINT2
-    b[0] = hgetc(fd->fp);
-    if (b[0] < 177) {
-    } else if (b[0] < 241) {
-        b[1] = hgetc(fd->fp);
-    } else if (b[0] < 249) {
-        b[1] = hgetc(fd->fp);
-        b[2] = hgetc(fd->fp);
-    } else {
-        int n = b[0]+2, z = 1;
-        while (n-- >= 249)
-            b[z++] = hgetc(fd->fp);
-    }
-    i = var_get_u32(b, NULL, &v);
-#else
-//    // Little endian
-//    int s = 0;
-//    do {
-//        b[i++] = c = hgetc(fd->fp);
-//        if (c < 0)
-//            return -1;
-//        v |= (c & 0x7f) << s;
-//      s += 7;
-//    } while (i < 5 && (c & 0x80));
-
-    // Big endian, see also htscodecs/varint.h
-    do {
-        b[i++] = c = hgetc(fd->fp);
-        if (c < 0)
-            return -1;
-        v = (v<<7) | (c & 0x7f);
-    } while (i < 5 && (c & 0x80));
-#endif
-    *crc = crc32(*crc, b, i);
-
-    *val_p = (v>>1) ^ -(v&1);
-    return i;
-}
-
-
-// Decode 64-bits with CRC update from cram_fd
-static int uint7_decode_crc64(cram_fd *fd, int64_t *val_p, uint32_t *crc) {
-    uint8_t b[10], i = 0;
-    int c;
-    uint64_t v = 0;
-
-#ifdef VARINT2
-    b[0] = hgetc(fd->fp);
-    if (b[0] < 177) {
-    } else if (b[0] < 241) {
-        b[1] = hgetc(fd->fp);
-    } else if (b[0] < 249) {
-        b[1] = hgetc(fd->fp);
-        b[2] = hgetc(fd->fp);
-    } else {
-        int n = b[0]+2, z = 1;
-        while (n-- >= 249)
-            b[z++] = hgetc(fd->fp);
-    }
-    i = var_get_u64(b, NULL, &v);
-#else
-//    // Little endian
-//    int s = 0;
-//    do {
-//        b[i++] = c = hgetc(fd->fp);
-//        if (c < 0)
-//            return -1;
-//        v |= (c & 0x7f) << s;
-//      s += 7;
-//    } while (i < 10 && (c & 0x80));
-
-    // Big endian, see also htscodecs/varint.h
-    do {
-        b[i++] = c = hgetc(fd->fp);
-        if (c < 0)
-            return -1;
-        v = (v<<7) | (c & 0x7f);
-    } while (i < 5 && (c & 0x80));
-#endif
-    *crc = crc32(*crc, b, i);
-
-    *val_p = v;
-    return i;
-}
-
-//-----------------------------------------------------------------------------
-
-/*
- * Decodes a 32-bit little endian value from fd and stores in val.
- *
- * Returns the number of bytes read on success
- *         -1 on failure
- */
-static int int32_decode(cram_fd *fd, int32_t *val) {
-    int32_t i;
-    if (4 != hread(fd->fp, &i, 4))
-        return -1;
-
-    *val = le_int4(i);
-    return 4;
-}
-
-/*
- * Encodes a 32-bit little endian value 'val' and writes to fd.
- *
- * Returns the number of bytes written on success
- *         -1 on failure
- */
-static int int32_encode(cram_fd *fd, int32_t val) {
-    uint32_t v = le_int4(val);
-    if (4 != hwrite(fd->fp, &v, 4))
-        return -1;
-
-    return 4;
-}
-
-/* As int32_decoded/encode, but from/to blocks instead of cram_fd */
-int int32_get_blk(cram_block *b, int32_t *val) {
-    if (b->uncomp_size - BLOCK_SIZE(b) < 4)
-        return -1;
-
-    uint32_t v =
-         ((uint32_t) b->data[b->byte  ])        |
-        (((uint32_t) b->data[b->byte+1]) <<  8) |
-        (((uint32_t) b->data[b->byte+2]) << 16) |
-        (((uint32_t) b->data[b->byte+3]) << 24);
-    // Avoid implementation-defined behaviour on negative values
-    *val = v < 0x80000000U ? (int32_t) v : -((int32_t) (0xffffffffU - v)) - 1;
-    BLOCK_SIZE(b) += 4;
-    return 4;
-}
-
-/* As int32_decoded/encode, but from/to blocks instead of cram_fd */
-int int32_put_blk(cram_block *b, int32_t val) {
-    unsigned char cp[4];
-    uint32_t v = val;
-    cp[0] = ( v      & 0xff);
-    cp[1] = ((v>>8)  & 0xff);
-    cp[2] = ((v>>16) & 0xff);
-    cp[3] = ((v>>24) & 0xff);
-
-    BLOCK_APPEND(b, cp, 4);
-    return 0;
-
- block_err:
-    return -1;
-}
-
-#ifdef HAVE_LIBDEFLATE
-/* ----------------------------------------------------------------------
- * libdeflate compression code, with interface to match
- * zlib_mem_{in,de}flate for simplicity elsewhere.
- */
-
-// Named the same as the version that uses zlib as we always use libdeflate for
-// decompression when available.
-char *zlib_mem_inflate(char *cdata, size_t csize, size_t *size) {
-    struct libdeflate_decompressor *z = libdeflate_alloc_decompressor();
-    if (!z) {
-        hts_log_error("Call to libdeflate_alloc_decompressor failed");
-        return NULL;
-    }
-
-    uint8_t *data = NULL, *new_data;
-    if (!*size)
-        *size = csize*2;
-    for(;;) {
-        new_data = realloc(data, *size);
-        if (!new_data) {
-            hts_log_error("Memory allocation failure");
-            goto fail;
-        }
-        data = new_data;
-
-        int ret = libdeflate_gzip_decompress(z, cdata, csize, data, *size, size);
-
-        // Auto grow output buffer size if needed and try again.
-        // Fortunately for all bar one call of this we know the size already.
-        if (ret == LIBDEFLATE_INSUFFICIENT_SPACE) {
-            (*size) *= 1.5;
-            continue;
-        }
-
-        if (ret != LIBDEFLATE_SUCCESS) {
-            hts_log_error("Inflate operation failed: %d", ret);
-            goto fail;
-        } else {
-            break;
-        }
-    }
-
-    libdeflate_free_decompressor(z);
-    return (char *)data;
-
- fail:
-    libdeflate_free_decompressor(z);
-    free(data);
-    return NULL;
-}
-
-// Named differently as we use both zlib/libdeflate for compression.
-static char *libdeflate_deflate(char *data, size_t size, size_t *cdata_size,
-                                int level, int strat) {
-    level = level > 0 ? level : 6; // libdeflate doesn't honour -1 as default
-    level *= 1.2; // NB levels go up to 12 here; 5 onwards is +1
-    if (level >= 8) level += level/8; // 8->10, 9->12
-    if (level > 12) level = 12;
-
-    if (strat == Z_RLE) // not supported by libdeflate
-        level = 1;
-
-    struct libdeflate_compressor *z = libdeflate_alloc_compressor(level);
-    if (!z) {
-        hts_log_error("Call to libdeflate_alloc_compressor failed");
-        return NULL;
-    }
-
-    unsigned char *cdata = NULL; /* Compressed output */
-    size_t cdata_alloc;
-    cdata = malloc(cdata_alloc = size*1.05+100);
-    if (!cdata) {
-        hts_log_error("Memory allocation failure");
-        libdeflate_free_compressor(z);
-        return NULL;
-    }
-
-    *cdata_size = libdeflate_gzip_compress(z, data, size, cdata, cdata_alloc);
-    libdeflate_free_compressor(z);
-
-    if (*cdata_size == 0) {
-        hts_log_error("Call to libdeflate_gzip_compress failed");
-        free(cdata);
-        return NULL;
-    }
-
-    return (char *)cdata;
-}
-
-#else
-
-/* ----------------------------------------------------------------------
- * zlib compression code - from Gap5's tg_iface_g.c
- * They're static here as they're only used within the cram_compress_block
- * and cram_uncompress_block functions, which are the external interface.
- */
-char *zlib_mem_inflate(char *cdata, size_t csize, size_t *size) {
-    z_stream s;
-    unsigned char *data = NULL; /* Uncompressed output */
-    int data_alloc = 0;
-    int err;
-
-    /* Starting point at uncompressed size, and scale after that */
-    data = malloc(data_alloc = csize*1.2+100);
-    if (!data)
-        return NULL;
-
-    /* Initialise zlib stream */
-    s.zalloc = Z_NULL; /* use default allocation functions */
-    s.zfree  = Z_NULL;
-    s.opaque = Z_NULL;
-    s.next_in  = (unsigned char *)cdata;
-    s.avail_in = csize;
-    s.total_in = 0;
-    s.next_out  = data;
-    s.avail_out = data_alloc;
-    s.total_out = 0;
-
-    //err = inflateInit(&s);
-    err = inflateInit2(&s, 15 + 32);
-    if (err != Z_OK) {
-        hts_log_error("Call to zlib inflateInit failed: %s", s.msg);
-        free(data);
-        return NULL;
-    }
-
-    /* Decode to 'data' array */
-    for (;s.avail_in;) {
-        unsigned char *data_tmp;
-        int alloc_inc;
-
-        s.next_out = &data[s.total_out];
-        err = inflate(&s, Z_NO_FLUSH);
-        if (err == Z_STREAM_END)
-            break;
-
-        if (err != Z_OK) {
-            hts_log_error("Call to zlib inflate failed: %s", s.msg);
-            free(data);
-            inflateEnd(&s);
-            return NULL;
-        }
-
-        /* More to come, so realloc based on growth so far */
-        alloc_inc = (double)s.avail_in/s.total_in * s.total_out + 100;
-        data = realloc((data_tmp = data), data_alloc += alloc_inc);
-        if (!data) {
-            free(data_tmp);
-            inflateEnd(&s);
-            return NULL;
-        }
-        s.avail_out += alloc_inc;
-    }
-    inflateEnd(&s);
-
-    *size = s.total_out;
-    return (char *)data;
-}
-#endif
-
-static char *zlib_mem_deflate(char *data, size_t size, size_t *cdata_size,
-                              int level, int strat) {
-    z_stream s;
-    unsigned char *cdata = NULL; /* Compressed output */
-    int cdata_alloc = 0;
-    int cdata_pos = 0;
-    int err;
-
-    cdata = malloc(cdata_alloc = size*1.05+100);
-    if (!cdata)
-        return NULL;
-    cdata_pos = 0;
-
-    /* Initialise zlib stream */
-    s.zalloc = Z_NULL; /* use default allocation functions */
-    s.zfree  = Z_NULL;
-    s.opaque = Z_NULL;
-    s.next_in  = (unsigned char *)data;
-    s.avail_in = size;
-    s.total_in = 0;
-    s.next_out  = cdata;
-    s.avail_out = cdata_alloc;
-    s.total_out = 0;
-    s.data_type = Z_BINARY;
-
-    err = deflateInit2(&s, level, Z_DEFLATED, 15|16, 9, strat);
-    if (err != Z_OK) {
-        hts_log_error("Call to zlib deflateInit2 failed: %s", s.msg);
-        return NULL;
-    }
-
-    /* Encode to 'cdata' array */
-    for (;s.avail_in;) {
-        s.next_out = &cdata[cdata_pos];
-        s.avail_out = cdata_alloc - cdata_pos;
-        if (cdata_alloc - cdata_pos <= 0) {
-            hts_log_error("Deflate produced larger output than expected");
-            return NULL;
-        }
-        err = deflate(&s, Z_NO_FLUSH);
-        cdata_pos = cdata_alloc - s.avail_out;
-        if (err != Z_OK) {
-            hts_log_error("Call to zlib deflate failed: %s", s.msg);
-            break;
-        }
-    }
-    if (deflate(&s, Z_FINISH) != Z_STREAM_END) {
-        hts_log_error("Call to zlib deflate failed: %s", s.msg);
-    }
-    *cdata_size = s.total_out;
-
-    if (deflateEnd(&s) != Z_OK) {
-        hts_log_error("Call to zlib deflate failed: %s", s.msg);
-    }
-    return (char *)cdata;
-}
-
-#ifdef HAVE_LIBLZMA
-/* ------------------------------------------------------------------------ */
-/*
- * Data compression routines using liblzma (xz)
- *
- * On a test set this shrunk the main db from 136157104 bytes to 114796168, but
- * caused tg_index to grow from 2m43.707s to 15m3.961s. Exporting as bfastq
- * went from 18.3s to 36.3s. So decompression suffers too, but not as bad
- * as compression times.
- *
- * For now we disable this functionality. If it's to be reenabled make sure you
- * improve the mem_inflate implementation as it's just a test hack at the
- * moment.
- */
-
-static char *lzma_mem_deflate(char *data, size_t size, size_t *cdata_size,
-                              int level) {
-    char *out;
-    size_t out_size = lzma_stream_buffer_bound(size);
-    *cdata_size = 0;
-
-    out = malloc(out_size);
-
-    /* Single call compression */
-    if (LZMA_OK != lzma_easy_buffer_encode(level, LZMA_CHECK_CRC32, NULL,
-                                           (uint8_t *)data, size,
-                                           (uint8_t *)out, cdata_size,
-                                           out_size))
-        return NULL;
-
-    return out;
-}
-
-static char *lzma_mem_inflate(char *cdata, size_t csize, size_t *size) {
-    lzma_stream strm = LZMA_STREAM_INIT;
-    size_t out_size = 0, out_pos = 0;
-    char *out = NULL, *new_out;
-    int r;
-
-    /* Initiate the decoder */
-    if (LZMA_OK != lzma_stream_decoder(&strm, lzma_easy_decoder_memusage(9), 0))
-        return NULL;
-
-    /* Decode loop */
-    strm.avail_in = csize;
-    strm.next_in = (uint8_t *)cdata;
-
-    for (;strm.avail_in;) {
-        if (strm.avail_in > out_size - out_pos) {
-            out_size += strm.avail_in * 4 + 32768;
-            new_out = realloc(out, out_size);
-            if (!new_out)
-                goto fail;
-            out = new_out;
-        }
-        strm.avail_out = out_size - out_pos;
-        strm.next_out = (uint8_t *)&out[out_pos];
-
-        r = lzma_code(&strm, LZMA_RUN);
-        if (LZMA_OK != r && LZMA_STREAM_END != r) {
-            hts_log_error("LZMA decode failure (error %d)", r);
-            goto fail;
-        }
-
-        out_pos = strm.total_out;
-
-        if (r == LZMA_STREAM_END)
-            break;
-    }
-
-    /* finish up any unflushed data; necessary? */
-    r = lzma_code(&strm, LZMA_FINISH);
-    if (r != LZMA_OK && r != LZMA_STREAM_END) {
-        hts_log_error("Call to lzma_code failed with error %d", r);
-        return NULL;
-    }
-
-    new_out = realloc(out, strm.total_out > 0 ? strm.total_out : 1);
-    if (new_out)
-        out = new_out;
-    *size = strm.total_out;
-
-    lzma_end(&strm);
-
-    return out;
-
- fail:
-    lzma_end(&strm);
-    free(out);
-    return NULL;
-}
-#endif
-
-/* ----------------------------------------------------------------------
- * CRAM blocks - the dynamically growable data block. We have code to
- * create, update, (un)compress and read/write.
- *
- * These are derived from the deflate_interlaced.c blocks, but with the
- * CRAM extension of content types and IDs.
- */
-
-/*
- * Allocates a new cram_block structure with a specified content_type and
- * id.
- *
- * Returns block pointer on success
- *         NULL on failure
- */
-cram_block *cram_new_block(enum cram_content_type content_type,
-                           int content_id) {
-    cram_block *b = malloc(sizeof(*b));
-    if (!b)
-        return NULL;
-    b->method = b->orig_method = RAW;
-    b->content_type = content_type;
-    b->content_id = content_id;
-    b->comp_size = 0;
-    b->uncomp_size = 0;
-    b->data = NULL;
-    b->alloc = 0;
-    b->byte = 0;
-    b->bit = 7; // MSB
-    b->crc32 = 0;
-    b->idx = 0;
-    b->m = NULL;
-
-    return b;
-}
-
-/*
- * Reads a block from a cram file.
- * Returns cram_block pointer on success.
- *         NULL on failure
- */
-cram_block *cram_read_block(cram_fd *fd) {
-    cram_block *b = malloc(sizeof(*b));
-    unsigned char c;
-    uint32_t crc = 0;
-    if (!b)
-        return NULL;
-
-    //fprintf(stderr, "Block at %d\n", (int)ftell(fd->fp));
-
-    if (-1 == (b->method      = hgetc(fd->fp))) { free(b); return NULL; }
-    c = b->method; crc = crc32(crc, &c, 1);
-    if (-1 == (b->content_type= hgetc(fd->fp))) { free(b); return NULL; }
-    c = b->content_type; crc = crc32(crc, &c, 1);
-    if (-1 == fd->vv.varint_decode32_crc(fd, &b->content_id, &crc))  { free(b); return NULL; }
-    if (-1 == fd->vv.varint_decode32_crc(fd, &b->comp_size, &crc))   { free(b); return NULL; }
-    if (-1 == fd->vv.varint_decode32_crc(fd, &b->uncomp_size, &crc)) { free(b); return NULL; }
-
-    //fprintf(stderr, "  method %d, ctype %d, cid %d, csize %d, ucsize %d\n",
-    //      b->method, b->content_type, b->content_id, b->comp_size, b->uncomp_size);
-
-    if (b->method == RAW) {
-        if (b->uncomp_size < 0 || b->comp_size != b->uncomp_size) {
-            free(b);
-            return NULL;
-        }
-        b->alloc = b->uncomp_size;
-        if (!(b->data = malloc(b->uncomp_size))){ free(b); return NULL; }
-        if (b->uncomp_size != hread(fd->fp, b->data, b->uncomp_size)) {
-            free(b->data);
-            free(b);
-            return NULL;
-        }
-    } else {
-        if (b->comp_size < 0 || b->uncomp_size < 0) {
-            free(b);
-            return NULL;
-        }
-        b->alloc = b->comp_size;
-        if (!(b->data = malloc(b->comp_size)))  { free(b); return NULL; }
-        if (b->comp_size != hread(fd->fp, b->data, b->comp_size)) {
-            free(b->data);
-            free(b);
-            return NULL;
-        }
-    }
-
-    if (CRAM_MAJOR_VERS(fd->version) >= 3) {
-        if (-1 == int32_decode(fd, (int32_t *)&b->crc32)) {
-            free(b->data);
-            free(b);
-            return NULL;
-        }
-
-        b->crc32_checked = fd->ignore_md5;
-        b->crc_part = crc;
-    } else {
-        b->crc32_checked = 1; // CRC not present
-    }
-
-    b->orig_method = b->method;
-    b->idx = 0;
-    b->byte = 0;
-    b->bit = 7; // MSB
-
-    return b;
-}
-
-
-/*
- * Computes the size of a cram block, including the block
- * header itself.
- */
-uint32_t cram_block_size(cram_block *b) {
-    unsigned char dat[100], *cp = dat;;
-    uint32_t sz;
-
-    *cp++ = b->method;
-    *cp++ = b->content_type;
-    cp += itf8_put((char*)cp, b->content_id);
-    cp += itf8_put((char*)cp, b->comp_size);
-    cp += itf8_put((char*)cp, b->uncomp_size);
-
-    sz = cp-dat + 4;
-    sz += b->method == RAW ? b->uncomp_size : b->comp_size;
-
-    return sz;
-}
-
-/*
- * Writes a CRAM block.
- * Returns 0 on success
- *        -1 on failure
- */
-int cram_write_block(cram_fd *fd, cram_block *b) {
-    char vardata[100];
-    int vardata_o = 0;
-
-    assert(b->method != RAW || (b->comp_size == b->uncomp_size));
-
-    if (hputc(b->method,       fd->fp)  == EOF) return -1;
-    if (hputc(b->content_type, fd->fp)  == EOF) return -1;
-    vardata_o += fd->vv.varint_put32(vardata          , vardata+100, b->content_id);
-    vardata_o += fd->vv.varint_put32(vardata+vardata_o, vardata+100, b->comp_size);
-    vardata_o += fd->vv.varint_put32(vardata+vardata_o, vardata+100, b->uncomp_size);
-    if (vardata_o != hwrite(fd->fp, vardata, vardata_o))
-        return -1;
-
-    if (b->data) {
-        if (b->method == RAW) {
-            if (b->uncomp_size != hwrite(fd->fp, b->data, b->uncomp_size))
-                return -1;
-        } else {
-            if (b->comp_size != hwrite(fd->fp, b->data, b->comp_size))
-                return -1;
-        }
-    } else {
-        // Absent blocks should be size 0
-        assert(b->method == RAW && b->uncomp_size == 0);
-    }
-
-    if (CRAM_MAJOR_VERS(fd->version) >= 3) {
-        char dat[100], *cp = (char *)dat;
-        uint32_t crc;
-
-        *cp++ = b->method;
-        *cp++ = b->content_type;
-        cp += fd->vv.varint_put32(cp, dat+100, b->content_id);
-        cp += fd->vv.varint_put32(cp, dat+100, b->comp_size);
-        cp += fd->vv.varint_put32(cp, dat+100, b->uncomp_size);
-        crc = crc32(0L, (uc *)dat, cp-dat);
-
-        if (b->method == RAW) {
-            b->crc32 = crc32(crc, b->data ? b->data : (uc*)"", b->uncomp_size);
-        } else {
-            b->crc32 = crc32(crc, b->data ? b->data : (uc*)"", b->comp_size);
-        }
-
-        if (-1 == int32_encode(fd, b->crc32))
-            return -1;
-    }
-
-    return 0;
-}
-
-/*
- * Frees a CRAM block, deallocating internal data too.
- */
-void cram_free_block(cram_block *b) {
-    if (!b)
-        return;
-    if (b->data)
-        free(b->data);
-    free(b);
-}
-
-/*
- * Uncompresses a CRAM block, if compressed.
- */
-int cram_uncompress_block(cram_block *b) {
-    char *uncomp;
-    size_t uncomp_size = 0;
-
-    if (b->crc32_checked == 0) {
-        uint32_t crc = crc32(b->crc_part, b->data ? b->data : (uc *)"", b->alloc);
-        b->crc32_checked = 1;
-        if (crc != b->crc32) {
-            hts_log_error("Block CRC32 failure");
-            return -1;
-        }
-    }
-
-    if (b->uncomp_size == 0) {
-        // blank block
-        b->method = RAW;
-        return 0;
-    }
-    assert(b->uncomp_size >= 0); // cram_read_block should ensure this
-
-    switch (b->method) {
-    case RAW:
-        return 0;
-
-    case GZIP:
-        uncomp_size = b->uncomp_size;
-        uncomp = zlib_mem_inflate((char *)b->data, b->comp_size, &uncomp_size);
-
-        if (!uncomp)
-            return -1;
-        if (uncomp_size != b->uncomp_size) {
-            free(uncomp);
-            return -1;
-        }
-        free(b->data);
-        b->data = (unsigned char *)uncomp;
-        b->alloc = uncomp_size;
-        b->method = RAW;
-        break;
-
-#ifdef HAVE_LIBBZ2
-    case BZIP2: {
-        unsigned int usize = b->uncomp_size;
-        if (!(uncomp = malloc(usize)))
-            return -1;
-        if (BZ_OK != BZ2_bzBuffToBuffDecompress(uncomp, &usize,
-                                                (char *)b->data, b->comp_size,
-                                                0, 0)) {
-            free(uncomp);
-            return -1;
-        }
-        free(b->data);
-        b->data = (unsigned char *)uncomp;
-        b->alloc = usize;
-        b->method = RAW;
-        b->uncomp_size = usize; // Just in case it differs
-        break;
-    }
-#else
-    case BZIP2:
-        hts_log_error("Bzip2 compression is not compiled into this version. Please rebuild and try again");
-        return -1;
-#endif
-
-#ifdef HAVE_LIBLZMA
-    case LZMA:
-        uncomp = lzma_mem_inflate((char *)b->data, b->comp_size, &uncomp_size);
-        if (!uncomp)
-            return -1;
-        if (uncomp_size != b->uncomp_size) {
-            free(uncomp);
-            return -1;
-        }
-        free(b->data);
-        b->data = (unsigned char *)uncomp;
-        b->alloc = uncomp_size;
-        b->method = RAW;
-        break;
-#else
-    case LZMA:
-        hts_log_error("Lzma compression is not compiled into this version. Please rebuild and try again");
-        return -1;
-        break;
-#endif
-
-    case RANS: {
-        unsigned int usize = b->uncomp_size, usize2;
-        uncomp = (char *)rans_uncompress(b->data, b->comp_size, &usize2);
-        if (!uncomp)
-            return -1;
-        if (usize != usize2) {
-            free(uncomp);
-            return -1;
-        }
-        free(b->data);
-        b->data = (unsigned char *)uncomp;
-        b->alloc = usize2;
-        b->method = RAW;
-        b->uncomp_size = usize2; // Just in case it differs
-        //fprintf(stderr, "Expanded %d to %d\n", b->comp_size, b->uncomp_size);
-        break;
-    }
-
-    case FQZ: {
-        uncomp_size = b->uncomp_size;
-        uncomp = fqz_decompress((char *)b->data, b->comp_size, &uncomp_size, NULL, 0);
-        if (!uncomp)
-            return -1;
-        free(b->data);
-        b->data = (unsigned char *)uncomp;
-        b->alloc = uncomp_size;
-        b->method = RAW;
-        b->uncomp_size = uncomp_size;
-        break;
-    }
-
-    case RANS_PR0: {
-        unsigned int usize = b->uncomp_size, usize2;
-        uncomp = (char *)rans_uncompress_4x16(b->data, b->comp_size, &usize2);
-        if (!uncomp)
-            return -1;
-        if (usize != usize2) {
-            free(uncomp);
-            return -1;
-        }
-        b->orig_method = RANS_PR0 + (b->data[0]&1)
-            + 2*((b->data[0]&0x40)>0) + 4*((b->data[0]&0x80)>0);
-        free(b->data);
-        b->data = (unsigned char *)uncomp;
-        b->alloc = usize2;
-        b->method = RAW;
-        b->uncomp_size = usize2; // Just incase it differs
-        //fprintf(stderr, "Expanded %d to %d\n", b->comp_size, b->uncomp_size);
-        break;
-    }
-
-    case ARITH_PR0: {
-        unsigned int usize = b->uncomp_size, usize2;
-        uncomp = (char *)arith_uncompress_to(b->data, b->comp_size, NULL, &usize2);
-        if (!uncomp)
-            return -1;
-        if (usize != usize2) {
-            free(uncomp);
-            return -1;
-        }
-        b->orig_method = ARITH_PR0 + (b->data[0]&1)
-            + 2*((b->data[0]&0x40)>0) + 4*((b->data[0]&0x80)>0);
-        free(b->data);
-        b->data = (unsigned char *)uncomp;
-        b->alloc = usize2;
-        b->method = RAW;
-        b->uncomp_size = usize2; // Just incase it differs
-        //fprintf(stderr, "Expanded %d to %d\n", b->comp_size, b->uncomp_size);
-        break;
-    }
-
-    case TOK3: {
-        uint32_t out_len;
-        uint8_t *cp = decode_names(b->data, b->comp_size, &out_len);
-        if (!cp)
-            return -1;
-        b->orig_method = TOK3;
-        b->method = RAW;
-        free(b->data);
-        b->data = cp;
-        b->alloc = out_len;
-        b->uncomp_size = out_len;
-        break;
-    }
-
-    default:
-        return -1;
-    }
-
-    return 0;
-}
-
-static char *cram_compress_by_method(cram_slice *s, char *in, size_t in_size,
-                                     int content_id, size_t *out_size,
-                                     enum cram_block_method_int method,
-                                     int level, int strat) {
-    switch (method) {
-    case GZIP:
-    case GZIP_RLE:
-    case GZIP_1:
-        // Read names bizarrely benefit from zlib over libdeflate for
-        // mid-range compression levels.  Focusing purely of ratio or
-        // speed, libdeflate still wins.  It also seems to win for
-        // other data series too.
-        //
-        // Eg RN at level 5;  libdeflate=55.9MB  zlib=51.6MB
-#ifdef HAVE_LIBDEFLATE
-        if (content_id == DS_RN && level >= 4 && level <= 7)
-            return zlib_mem_deflate(in, in_size, out_size, level, strat);
-        else
-            return libdeflate_deflate(in, in_size, out_size, level, strat);
-#else
-        return zlib_mem_deflate(in, in_size, out_size, level, strat);
-#endif
-
-    case BZIP2: {
-#ifdef HAVE_LIBBZ2
-        unsigned int comp_size = in_size*1.01 + 600;
-        char *comp = malloc(comp_size);
-        if (!comp)
-            return NULL;
-
-        if (BZ_OK != BZ2_bzBuffToBuffCompress(comp, &comp_size,
-                                              in, in_size,
-                                              level, 0, 30)) {
-            free(comp);
-            return NULL;
-        }
-        *out_size = comp_size;
-        return comp;
-#else
-        return NULL;
-#endif
-    }
-
-    case FQZ:
-    case FQZ_b:
-    case FQZ_c:
-    case FQZ_d: {
-        // Extract the necessary portion of the slice into an fqz_slice struct.
-        // These previously were the same thing, but this permits us to detach
-        // the codec from the rest of this CRAM implementation.
-        fqz_slice *f = malloc(2*s->hdr->num_records * sizeof(uint32_t) + sizeof(fqz_slice));
-        if (!f)
-            return NULL;
-        f->num_records = s->hdr->num_records;
-        f->len = (uint32_t *)(((char *)f) + sizeof(fqz_slice));
-        f->flags = f->len + s->hdr->num_records;
-        int i;
-        for (i = 0; i < s->hdr->num_records; i++) {
-            f->flags[i] = s->crecs[i].flags;
-            f->len[i] = (i+1 < s->hdr->num_records
-                         ? s->crecs[i+1].qual - s->crecs[i].qual
-                         : s->block[DS_QS]->uncomp_size - s->crecs[i].qual);
-        }
-        char *comp = fqz_compress(strat & 0xff /* cram vers */, f,
-                                  in, in_size, out_size, strat >> 8, NULL);
-        free(f);
-        return comp;
-    }
-
-    case LZMA:
-#ifdef HAVE_LIBLZMA
-        return lzma_mem_deflate(in, in_size, out_size, level);
-#else
-        return NULL;
-#endif
-
-    case RANS0:
-    case RANS1: {
-        unsigned int out_size_i;
-        unsigned char *cp;
-        cp = rans_compress((unsigned char *)in, in_size, &out_size_i,
-                           method == RANS0 ? 0 : 1);
-        *out_size = out_size_i;
-        return (char *)cp;
-    }
-
-    case RANS_PR0:
-    case RANS_PR1:
-    case RANS_PR64:
-    case RANS_PR9:
-    case RANS_PR128:
-    case RANS_PR129:
-    case RANS_PR192:
-    case RANS_PR193: {
-        unsigned int out_size_i;
-        unsigned char *cp;
-
-        // see enum cram_block. We map RANS_* methods to order bit-fields
-        static int methmap[] = { 1, 64,9, 128,129, 192,193 };
-
-        cp = rans_compress_4x16((unsigned char *)in, in_size, &out_size_i,
-                                method == RANS_PR0 ? 0 : methmap[method - RANS_PR1]);
-        *out_size = out_size_i;
-        return (char *)cp;
-    }
-
-    case ARITH_PR0:
-    case ARITH_PR1:
-    case ARITH_PR64:
-    case ARITH_PR9:
-    case ARITH_PR128:
-    case ARITH_PR129:
-    case ARITH_PR192:
-    case ARITH_PR193: {
-        unsigned int out_size_i;
-        unsigned char *cp;
-
-        // see enum cram_block. We map ARITH_* methods to order bit-fields
-        static int methmap[] = { 1, 64,9, 128,129, 192,193 };
-
-        cp = arith_compress_to((unsigned char *)in, in_size, NULL, &out_size_i,
-                               method == ARITH_PR0 ? 0 : methmap[method - ARITH_PR1]);
-        *out_size = out_size_i;
-        return (char *)cp;
-    }
-
-    case TOK3:
-    case TOKA: {
-        int out_len;
-        int lev = level;
-        if (method == TOK3 && lev > 3)
-            lev = 3;
-        uint8_t *cp = encode_names(in, in_size, lev, strat, &out_len, NULL);
-        *out_size = out_len;
-        return (char *)cp;
-    }
-
-    case RAW:
-        break;
-
-    default:
-        return NULL;
-    }
-
-    return NULL;
-}
-
-
-/*
- * Compresses a block using one of two different zlib strategies. If we only
- * want one choice set strat2 to be -1.
- *
- * The logic here is that sometimes Z_RLE does a better job than Z_FILTERED
- * or Z_DEFAULT_STRATEGY on quality data. If so, we'd rather use it as it is
- * significantly faster.
- *
- * Method and level -1 implies defaults, as specified in cram_fd.
- */
-int cram_compress_block2(cram_fd *fd, cram_slice *s,
-                         cram_block *b, cram_metrics *metrics,
-                         int method, int level) {
-
-    if (!b)
-        return 0;
-
-    char *comp = NULL;
-    size_t comp_size = 0;
-    int strat;
-
-    // Internally we have parameterised methods that externally map
-    // to the same CRAM method value.
-    // See enum_cram_block_method_int in cram_structs.h.
-    int methmap[] = {
-        // Externally defined values
-        RAW, GZIP, BZIP2, LZMA, RANS, RANSPR, ARITH, FQZ, TOK3,
-
-        // Reserved for possible expansion
-        0, 0,
-
-        // Internally parameterised versions matching back to above
-        // external values
-        GZIP, GZIP,
-        FQZ, FQZ, FQZ,
-        RANS,
-        RANSPR, RANSPR, RANSPR, RANSPR, RANSPR, RANSPR, RANSPR,
-        TOK3,
-        ARITH,  ARITH,  ARITH,  ARITH,  ARITH,  ARITH,  ARITH,
-    };
-
-    if (b->method != RAW) {
-        // Maybe already compressed if s->block[0] was compressed and
-        // we have e.g. s->block[DS_BA] set to s->block[0] due to only
-        // one base type present and hence using E_HUFFMAN on block 0.
-        // A second explicit attempt to compress the same block then
-        // occurs.
-        return 0;
-    }
-
-    if (method == -1) {
-        method = 1<<GZIP;
-        if (fd->use_bz2)
-            method |= 1<<BZIP2;
-        if (fd->use_lzma)
-            method |= 1<<LZMA;
-    }
-
-    if (level == -1)
-        level = fd->level;
-
-    //fprintf(stderr, "IN: block %d, sz %d\n", b->content_id, b->uncomp_size);
-
-    if (method == RAW || level == 0 || b->uncomp_size == 0) {
-        b->method = RAW;
-        b->comp_size = b->uncomp_size;
-        //fprintf(stderr, "Skip block id %d\n", b->content_id);
-        return 0;
-    }
-
-    if (metrics) {
-        pthread_mutex_lock(&fd->metrics_lock);
-        if (metrics->trial > 0 || --metrics->next_trial <= 0) {
-            int m, unpackable = metrics->unpackable;
-            size_t sz_best = b->uncomp_size;
-            size_t sz[CRAM_MAX_METHOD] = {0};
-            int method_best = 0; // RAW
-            char *c_best = NULL, *c = NULL;
-
-            if (metrics->revised_method)
-                method = metrics->revised_method;
-            else
-                metrics->revised_method = method;
-
-            if (metrics->next_trial <= 0) {
-                metrics->next_trial = TRIAL_SPAN;
-                metrics->trial = NTRIALS;
-                for (m = 0; m < CRAM_MAX_METHOD; m++)
-                    metrics->sz[m] /= 2;
-                metrics->unpackable = 0;
-            }
-
-            // Compress this block using the best method
-            if (unpackable && CRAM_MAJOR_VERS(fd->version) > 3) {
-                // No point trying bit-pack if 17+ symbols.
-                if (method & (1<<RANS_PR128))
-                    method = (method|(1<<RANS_PR0))&~(1<<RANS_PR128);
-                if (method & (1<<RANS_PR129))
-                    method = (method|(1<<RANS_PR1))&~(1<<RANS_PR129);
-                if (method & (1<<RANS_PR192))
-                    method = (method|(1<<RANS_PR64))&~(1<<RANS_PR192);
-                if (method & (1<<RANS_PR193))
-                    method = (method|(1<<RANS_PR64)|(1<<RANS_PR1))&~(1<<RANS_PR193);
-
-                if (method & (1<<ARITH_PR128))
-                    method = (method|(1<<ARITH_PR0))&~(1<<ARITH_PR128);
-                if (method & (1<<ARITH_PR129))
-                    method = (method|(1<<ARITH_PR1))&~(1<<ARITH_PR129);
-                if (method & (1<<ARITH_PR192))
-                    method = (method|(1<<ARITH_PR64))&~(1<<ARITH_PR192);
-                if (method & (1u<<ARITH_PR193))
-                    method = (method|(1<<ARITH_PR64)|(1<<ARITH_PR1))&~(1u<<ARITH_PR193);
-            }
-
-            // Libdeflate doesn't have a Z_RLE strategy.
-            // We treat it as level 1, but iff we haven't also
-            // explicitly listed that in the method list.
-#ifdef HAVE_LIBDEFLATE
-            if ((method & (1<<GZIP_RLE)) && (method & (1<<GZIP_1)))
-                method &= ~(1<<GZIP_RLE);
-#endif
-
-            pthread_mutex_unlock(&fd->metrics_lock);
-
-            for (m = 0; m < CRAM_MAX_METHOD; m++) {
-                if (method & (1u<<m)) {
-                    int lvl = level;
-                    switch (m) {
-                    case GZIP:     strat = Z_FILTERED; break;
-                    case GZIP_1:   strat = Z_DEFAULT_STRATEGY; lvl = 1; break;
-                    case GZIP_RLE: strat = Z_RLE; break;
-                    case FQZ:      strat = CRAM_MAJOR_VERS(fd->version); break;
-                    case FQZ_b:    strat = CRAM_MAJOR_VERS(fd->version)+256; break;
-                    case FQZ_c:    strat = CRAM_MAJOR_VERS(fd->version)+2*256; break;
-                    case FQZ_d:    strat = CRAM_MAJOR_VERS(fd->version)+3*256; break;
-                    case TOK3:     strat = 0; break;
-                    case TOKA:     strat = 1; break;
-                    default:       strat = 0;
-                    }
-
-                    c = cram_compress_by_method(s, (char *)b->data, b->uncomp_size,
-                                                b->content_id, &sz[m], m, lvl, strat);
-
-                    if (c && sz_best > sz[m]) {
-                        sz_best = sz[m];
-                        method_best = m;
-                        if (c_best)
-                            free(c_best);
-                        c_best = c;
-                    } else if (c) {
-                        free(c);
-                    } else {
-                        sz[m] = b->uncomp_size*2+1000; // arbitrarily worse than raw
-                    }
-                } else {
-                    sz[m] = b->uncomp_size*2+1000; // arbitrarily worse than raw
-                }
-            }
-
-            if (c_best) {
-                free(b->data);
-                b->data = (unsigned char *)c_best;
-                b->method = method_best; // adjusted to methmap[method_best] later
-                b->comp_size = sz_best;
-            }
-
-            // Accumulate stats for all methods tried
-            pthread_mutex_lock(&fd->metrics_lock);
-            for (m = 0; m < CRAM_MAX_METHOD; m++)
-                // don't be overly sure on small blocks.
-                // +2000 means eg bzip2 vs gzip (1.07 to 1.04) or gz vs rans1
-                // needs to be at least 60 bytes smaller to overcome the
-                // fixed size addition.
-                metrics->sz[m] += sz[m]+2000;
-
-            // When enough trials performed, find the best on average
-            if (--metrics->trial == 0) {
-                int best_method = RAW;
-                int best_sz = INT_MAX;
-
-                // Relative costs of methods. See enum_cram_block_method_int
-                // and methmap
-                double meth_cost[32] = {
-                    // Externally defined methods
-                    1,    // 0  raw
-                    1.04, // 1  gzip (Z_FILTERED)
-                    1.07, // 2  bzip2
-                    1.08, // 3  lzma
-                    1.00, // 4  rans    (O0)
-                    1.00, // 5  ranspr  (O0)
-                    1.04, // 6  arithpr (O0)
-                    1.05, // 7  fqz
-                    1.05, // 8  tok3 (rans)
-                    1.00, 1.00, // 9,10 reserved
-
-                    // Paramterised versions of above
-                    1.01, // gzip rle
-                    1.01, // gzip -1
-
-                    1.05, 1.05, 1.05, // FQZ_b,c,d
-
-                    1.01, // rans O1
-
-                    1.01, // rans_pr1
-                    1.00, // rans_pr64; if smaller, usually fast
-                    1.03, // rans_pr65/9
-                    1.00, // rans_pr128
-                    1.01, // rans_pr129
-                    1.00, // rans_pr192
-                    1.01, // rans_pr193
-
-                    1.07, // tok3 arith
-
-                    1.04, // arith_pr1
-                    1.04, // arith_pr64
-                    1.04, // arith_pr9
-                    1.03, // arith_pr128
-                    1.04, // arith_pr129
-                    1.04, // arith_pr192
-                    1.04, // arith_pr193
-                };
-
-                // Scale methods by cost based on compression level
-                if (fd->level <= 1) {
-                    for (m = 0; m < CRAM_MAX_METHOD; m++)
-                        metrics->sz[m] *= 1+(meth_cost[m]-1)*4;
-                } else if (fd->level <= 3) {
-                    for (m = 0; m < CRAM_MAX_METHOD; m++)
-                        metrics->sz[m] *= 1+(meth_cost[m]-1);
-                } else if (fd->level <= 6) {
-                    for (m = 0; m < CRAM_MAX_METHOD; m++)
-                        metrics->sz[m] *= 1+(meth_cost[m]-1)/2;
-                } else if (fd->level <= 7) {
-                    for (m = 0; m < CRAM_MAX_METHOD; m++)
-                        metrics->sz[m] *= 1+(meth_cost[m]-1)/3;
-                } // else cost is ignored
-
-                // Ensure these are never used
-                metrics->sz[9] = metrics->sz[10] = INT_MAX;
-
-                for (m = 0; m < CRAM_MAX_METHOD; m++) {
-                    if ((!metrics->sz[m]) || (!(method & (1u<<m))))
-                        continue;
-
-                    if (best_sz > metrics->sz[m])
-                        best_sz = metrics->sz[m], best_method = m;
-                }
-
-                if (best_method != metrics->method) {
-                    //metrics->trial = (NTRIALS+1)/2; // be sure
-                    //metrics->next_trial /= 1.5;
-                    metrics->consistency = 0;
-                } else {
-                    metrics->next_trial *= MIN(2, 1+metrics->consistency/4.0);
-                    metrics->consistency++;
-                }
-
-                metrics->method = best_method;
-                switch (best_method) {
-                case GZIP:     strat = Z_FILTERED; break;
-                case GZIP_1:   strat = Z_DEFAULT_STRATEGY; break;
-                case GZIP_RLE: strat = Z_RLE; break;
-                case FQZ:      strat = CRAM_MAJOR_VERS(fd->version); break;
-                case FQZ_b:    strat = CRAM_MAJOR_VERS(fd->version)+256; break;
-                case FQZ_c:    strat = CRAM_MAJOR_VERS(fd->version)+2*256; break;
-                case FQZ_d:    strat = CRAM_MAJOR_VERS(fd->version)+3*256; break;
-                default:       strat = 0;
-                }
-                metrics->strat  = strat;
-
-                // If we see at least MAXFAIL trials in a row for a specific
-                // compression method with more than MAXDELTA aggregate
-                // size then we drop this from the list of methods used
-                // for this block type.
-#define MAXDELTA 0.20
-#define MAXFAILS 4
-                for (m = 0; m < CRAM_MAX_METHOD; m++) {
-                    if (best_method == m) {
-                        metrics->cnt[m] = 0;
-                        metrics->extra[m] = 0;
-                    } else if (best_sz < metrics->sz[m]) {
-                        double r = (double)metrics->sz[m] / best_sz - 1;
-                        int mul = 1+(fd->level>=7);
-                        if (++metrics->cnt[m] >= MAXFAILS*mul &&
-                            (metrics->extra[m] += r) >= MAXDELTA*mul)
-                            method &= ~(1u<<m);
-
-                        // Special case for fqzcomp as it rarely changes
-                        if (m == FQZ || m == FQZ_b || m == FQZ_c || m == FQZ_d) {
-                            if (metrics->sz[m] > best_sz)
-                                method &= ~(1u<<m);
-                        }
-                    }
-                }
-
-                //if (fd->verbose > 1 && method != metrics->revised_method)
-                //    fprintf(stderr, "%d: revising method from %x to %x\n",
-                //          b->content_id, metrics->revised_method, method);
-                metrics->revised_method = method;
-            }
-            pthread_mutex_unlock(&fd->metrics_lock);
-        } else {
-            strat = metrics->strat;
-            method = metrics->method;
-
-            pthread_mutex_unlock(&fd->metrics_lock);
-            comp = cram_compress_by_method(s, (char *)b->data, b->uncomp_size,
-                                           b->content_id, &comp_size, method,
-                                           method == GZIP_1 ? 1 : level,
-                                           strat);
-            if (!comp)
-                return -1;
-
-            if (comp_size < b->uncomp_size) {
-                free(b->data);
-                b->data = (unsigned char *)comp;
-                b->comp_size = comp_size;
-                b->method = method;
-            } else {
-                free(comp);
-            }
-        }
-
-    } else {
-        // no cached metrics, so just do zlib?
-        comp = cram_compress_by_method(s, (char *)b->data, b->uncomp_size,
-                                       b->content_id, &comp_size, GZIP, level, Z_FILTERED);
-        if (!comp) {
-            hts_log_error("Compression failed!");
-            return -1;
-        }
-
-        if (comp_size < b->uncomp_size) {
-            free(b->data);
-            b->data = (unsigned char *)comp;
-            b->comp_size = comp_size;
-            b->method = GZIP;
-        } else {
-            free(comp);
-        }
-        strat = Z_FILTERED;
-    }
-
-    hts_log_info("Compressed block ID %d from %d to %d by method %s",
-                 b->content_id, b->uncomp_size, b->comp_size,
-                 cram_block_method2str(b->method));
-
-    b->method = methmap[b->method];
-
-    return 0;
-}
-int cram_compress_block(cram_fd *fd, cram_block *b, cram_metrics *metrics,
-                        int method, int level) {
-    return cram_compress_block2(fd, NULL, b, metrics, method, level);
-}
-
-cram_metrics *cram_new_metrics(void) {
-    cram_metrics *m = calloc(1, sizeof(*m));
-    if (!m)
-        return NULL;
-    m->trial = NTRIALS-1;
-    m->next_trial = TRIAL_SPAN/2; // learn quicker at start
-    m->method = RAW;
-    m->strat = 0;
-    m->revised_method = 0;
-    m->unpackable = 0;
-
-    return m;
-}
-
-char *cram_block_method2str(enum cram_block_method_int m) {
-    switch(m) {
-    case RAW:         return "RAW";
-    case GZIP:        return "GZIP";
-    case BZIP2:       return "BZIP2";
-    case LZMA:        return "LZMA";
-    case RANS0:       return "RANS0";
-    case RANS1:       return "RANS1";
-    case GZIP_RLE:    return "GZIP_RLE";
-    case GZIP_1:      return "GZIP_1";
-    case FQZ:         return "FQZ";
-    case FQZ_b:       return "FQZ_b";
-    case FQZ_c:       return "FQZ_c";
-    case FQZ_d:       return "FQZ_d";
-    case RANS_PR0:    return "RANS_PR0";
-    case RANS_PR1:    return "RANS_PR1";
-    case RANS_PR64:   return "RANS_PR64";
-    case RANS_PR9:    return "RANS_PR9";
-    case RANS_PR128:  return "RANS_PR128";
-    case RANS_PR129:  return "RANS_PR129";
-    case RANS_PR192:  return "RANS_PR192";
-    case RANS_PR193:  return "RANS_PR193";
-    case TOK3:        return "TOK3_R";
-    case TOKA:        return "TOK3_A";
-    case ARITH_PR0:   return "ARITH_PR0";
-    case ARITH_PR1:   return "ARITH_PR1";
-    case ARITH_PR64:  return "ARITH_PR64";
-    case ARITH_PR9:   return "ARITH_PR9";
-    case ARITH_PR128: return "ARITH_PR128";
-    case ARITH_PR129: return "ARITH_PR129";
-    case ARITH_PR192: return "ARITH_PR192";
-    case ARITH_PR193: return "ARITH_PR193";
-    case BM_ERROR: break;
-    }
-    return "?";
-}
-
-char *cram_content_type2str(enum cram_content_type t) {
-    switch (t) {
-    case FILE_HEADER:         return "FILE_HEADER";
-    case COMPRESSION_HEADER:  return "COMPRESSION_HEADER";
-    case MAPPED_SLICE:        return "MAPPED_SLICE";
-    case UNMAPPED_SLICE:      return "UNMAPPED_SLICE";
-    case EXTERNAL:            return "EXTERNAL";
-    case CORE:                return "CORE";
-    case CT_ERROR:            break;
-    }
-    return "?";
-}
-
-/* ----------------------------------------------------------------------
- * Reference sequence handling
- *
- * These revolve around the refs_t structure, which may potentially be
- * shared between multiple cram_fd.
- *
- * We start with refs_create() to allocate an empty refs_t and then
- * populate it with @SQ line data using refs_from_header(). This is done on
- * cram_open().  Also at start up we can call cram_load_reference() which
- * is used with "scramble -r foo.fa". This replaces the fd->refs with the
- * new one specified. In either case refs2id() is then called which
- * maps ref_entry names to @SQ ids (refs_t->ref_id[]).
- *
- * Later, possibly within a thread, we will want to know the actual ref
- * seq itself, obtained by calling cram_get_ref().  This may use the
- * UR: or M5: fields or the filename specified in the original
- * cram_load_reference() call.
- *
- * Given the potential for multi-threaded reference usage, we have
- * reference counting (sorry for the confusing double use of "ref") to
- * track the number of callers interested in any specific reference.
- */
-
-/*
- * Frees/unmaps a reference sequence and associated file handles.
- */
-static void ref_entry_free_seq(ref_entry *e) {
-    if (e->mf)
-        mfclose(e->mf);
-    if (e->seq && !e->mf)
-        free(e->seq);
-
-    e->seq = NULL;
-    e->mf = NULL;
-}
-
-void refs_free(refs_t *r) {
-    RP("refs_free()\n");
-
-    if (--r->count > 0)
-        return;
-
-    if (!r)
-        return;
-
-    if (r->pool)
-        string_pool_destroy(r->pool);
-
-    if (r->h_meta) {
-        khint_t k;
-
-        for (k = kh_begin(r->h_meta); k != kh_end(r->h_meta); k++) {
-            ref_entry *e;
-
-            if (!kh_exist(r->h_meta, k))
-                continue;
-            if (!(e = kh_val(r->h_meta, k)))
-                continue;
-            ref_entry_free_seq(e);
-            free(e);
-        }
-
-        kh_destroy(refs, r->h_meta);
-    }
-
-    if (r->ref_id)
-        free(r->ref_id);
-
-    if (r->fp)
-        bgzf_close(r->fp);
-
-    pthread_mutex_destroy(&r->lock);
-
-    free(r);
-}
-
-static refs_t *refs_create(void) {
-    refs_t *r = calloc(1, sizeof(*r));
-
-    RP("refs_create()\n");
-
-    if (!r)
-        return NULL;
-
-    if (!(r->pool = string_pool_create(8192)))
-        goto err;
-
-    r->ref_id = NULL; // see refs2id() to populate.
-    r->count = 1;
-    r->last = NULL;
-    r->last_id = -1;
-
-    if (!(r->h_meta = kh_init(refs)))
-        goto err;
-
-    pthread_mutex_init(&r->lock, NULL);
-
-    return r;
-
- err:
-    refs_free(r);
-    return NULL;
-}
-
-/*
- * Opens a reference fasta file as a BGZF stream, allowing for
- * compressed files.  It automatically builds a .fai file if
- * required and if compressed a .gzi bgzf index too.
- *
- * Returns a BGZF handle on success;
- *         NULL on failure.
- */
-static BGZF *bgzf_open_ref(char *fn, char *mode, int is_md5) {
-    BGZF *fp;
-
-    if (!is_md5 && !hisremote(fn)) {
-        char fai_file[PATH_MAX];
-
-        snprintf(fai_file, PATH_MAX, "%s.fai", fn);
-        if (access(fai_file, R_OK) != 0)
-            if (fai_build(fn) != 0)
-                return NULL;
-    }
-
-    if (!(fp = bgzf_open(fn, mode))) {
-        perror(fn);
-        return NULL;
-    }
-
-    if (fp->is_compressed == 1 && bgzf_index_load(fp, fn, ".gzi") < 0) {
-        hts_log_error("Unable to load .gzi index '%s.gzi'", fn);
-        bgzf_close(fp);
-        return NULL;
-    }
-
-    return fp;
-}
-
-/*
- * Loads a FAI file for a reference.fasta.
- * "is_err" indicates whether failure to load is worthy of emitting an
- * error message. In some cases (eg with embedded references) we
- * speculatively load, just in case, and silently ignore errors.
- *
- * Returns the refs_t struct on success (maybe newly allocated);
- *         NULL on failure
- */
-static refs_t *refs_load_fai(refs_t *r_orig, const char *fn, int is_err) {
-    hFILE *fp = NULL;
-    char fai_fn[PATH_MAX];
-    char line[8192];
-    refs_t *r = r_orig;
-    size_t fn_l = strlen(fn);
-    int id = 0, id_alloc = 0;
-
-    RP("refs_load_fai %s\n", fn);
-
-    if (!r)
-        if (!(r = refs_create()))
-            goto err;
-
-    if (r->fp)
-        if (bgzf_close(r->fp) != 0)
-            goto err;
-    r->fp = NULL;
-
-    /* Look for a FASTA##idx##FAI format */
-    char *fn_delim = strstr(fn, HTS_IDX_DELIM);
-    if (fn_delim) {
-        if (!(r->fn = string_ndup(r->pool, fn, fn_delim - fn)))
-            goto err;
-        fn_delim += strlen(HTS_IDX_DELIM);
-        snprintf(fai_fn, PATH_MAX, "%s", fn_delim);
-    } else {
-        /* An index file was provided, instead of the actual reference file */
-        if (fn_l > 4 && strcmp(&fn[fn_l-4], ".fai") == 0) {
-            if (!r->fn) {
-                if (!(r->fn = string_ndup(r->pool, fn, fn_l-4)))
-                    goto err;
-            }
-            snprintf(fai_fn, PATH_MAX, "%s", fn);
-        } else {
-        /* Only the reference file provided. Get the index file name from it */
-            if (!(r->fn = string_dup(r->pool, fn)))
-                goto err;
-            sprintf(fai_fn, "%.*s.fai", PATH_MAX-5, fn);
-        }
-    }
-
-    if (!(r->fp = bgzf_open_ref(r->fn, "r", 0))) {
-        hts_log_error("Failed to open reference file '%s'", r->fn);
-        goto err;
-    }
-
-    if (!(fp = hopen(fai_fn, "r"))) {
-        hts_log_error("Failed to open index file '%s'", fai_fn);
-        if (is_err)
-            perror(fai_fn);
-        goto err;
-    }
-    while (hgets(line, 8192, fp) != NULL) {
-        ref_entry *e = malloc(sizeof(*e));
-        char *cp;
-        int n;
-        khint_t k;
-
-        if (!e)
-            return NULL;
-
-        // id
-        for (cp = line; *cp && !isspace_c(*cp); cp++)
-            ;
-        *cp++ = 0;
-        e->name = string_dup(r->pool, line);
-
-        // length
-        while (*cp && isspace_c(*cp))
-            cp++;
-        e->length = strtoll(cp, &cp, 10);
-
-        // offset
-        while (*cp && isspace_c(*cp))
-            cp++;
-        e->offset = strtoll(cp, &cp, 10);
-
-        // bases per line
-        while (*cp && isspace_c(*cp))
-            cp++;
-        e->bases_per_line = strtol(cp, &cp, 10);
-
-        // line length
-        while (*cp && isspace_c(*cp))
-            cp++;
-        e->line_length = strtol(cp, &cp, 10);
-
-        // filename
-        e->fn = r->fn;
-
-        e->count = 0;
-        e->seq = NULL;
-        e->mf = NULL;
-        e->is_md5 = 0;
-
-        k = kh_put(refs, r->h_meta, e->name, &n);
-        if (-1 == n)  {
-            free(e);
-            return NULL;
-        }
-
-        if (n) {
-            kh_val(r->h_meta, k) = e;
-        } else {
-            ref_entry *re = kh_val(r->h_meta, k);
-            if (re && (re->count != 0 || re->length != 0)) {
-                /* Keep old */
-                free(e);
-            } else {
-                /* Replace old */
-                if (re)
-                    free(re);
-                kh_val(r->h_meta, k) = e;
-            }
-        }
-
-        if (id >= id_alloc) {
-            ref_entry **new_refs;
-            int x;
-
-            id_alloc = id_alloc ?id_alloc*2 : 16;
-            new_refs = realloc(r->ref_id, id_alloc * sizeof(*r->ref_id));
-            if (!new_refs)
-                goto err;
-            r->ref_id = new_refs;
-
-            for (x = id; x < id_alloc; x++)
-                r->ref_id[x] = NULL;
-        }
-        r->ref_id[id] = e;
-        r->nref = ++id;
-    }
-
-    if(hclose(fp) < 0)
-        goto err;
-    return r;
-
- err:
-    if (fp)
-        hclose_abruptly(fp);
-
-    if (!r_orig)
-        refs_free(r);
-
-    return NULL;
-}
-
-/*
- * Verifies that the CRAM @SQ lines and .fai files match.
- */
-static void sanitise_SQ_lines(cram_fd *fd) {
-    int i;
-
-    if (!fd->header || !fd->header->hrecs)
-        return;
-
-    if (!fd->refs || !fd->refs->h_meta)
-        return;
-
-    for (i = 0; i < fd->header->hrecs->nref; i++) {
-        const char *name = fd->header->hrecs->ref[i].name;
-        khint_t k = kh_get(refs, fd->refs->h_meta, name);
-        ref_entry *r;
-
-        // We may have @SQ lines which have no known .fai, but do not
-        // in themselves pose a problem because they are unused in the file.
-        if (k == kh_end(fd->refs->h_meta))
-            continue;
-
-        if (!(r = (ref_entry *)kh_val(fd->refs->h_meta, k)))
-            continue;
-
-        if (r->length && r->length != fd->header->hrecs->ref[i].len) {
-            assert(strcmp(r->name, fd->header->hrecs->ref[i].name) == 0);
-
-            // Should we also check MD5sums here to ensure the correct
-            // reference was given?
-            hts_log_warning("Header @SQ length mismatch for ref %s, %"PRIhts_pos" vs %d",
-                            r->name, fd->header->hrecs->ref[i].len, (int)r->length);
-
-            // Fixing the parsed @SQ header will make MD:Z: strings work
-            // and also stop it producing N for the sequence.
-            fd->header->hrecs->ref[i].len = r->length;
-        }
-    }
-}
-
-/*
- * Indexes references by the order they appear in a BAM file. This may not
- * necessarily be the same order they appear in the fasta reference file.
- *
- * Returns 0 on success
- *        -1 on failure
- */
-int refs2id(refs_t *r, sam_hdr_t *hdr) {
-    int i;
-    sam_hrecs_t *h = hdr->hrecs;
-
-    if (r->ref_id)
-        free(r->ref_id);
-    if (r->last)
-        r->last = NULL;
-
-    r->ref_id = calloc(h->nref, sizeof(*r->ref_id));
-    if (!r->ref_id)
-        return -1;
-
-    r->nref = h->nref;
-    for (i = 0; i < h->nref; i++) {
-        khint_t k = kh_get(refs, r->h_meta, h->ref[i].name);
-        if (k != kh_end(r->h_meta)) {
-            r->ref_id[i] = kh_val(r->h_meta, k);
-        } else {
-            hts_log_warning("Unable to find ref name '%s'", h->ref[i].name);
-        }
-    }
-
-    return 0;
-}
-
-/*
- * Generates refs_t entries based on @SQ lines in the header.
- * Returns 0 on success
- *         -1 on failure
- */
-static int refs_from_header(cram_fd *fd) {
-    if (!fd)
-        return -1;
-
-    refs_t *r = fd->refs;
-    if (!r)
-        return -1;
-
-    sam_hdr_t *h = fd->header;
-    if (!h)
-        return 0;
-
-    if (!h->hrecs) {
-        if (-1 == sam_hdr_fill_hrecs(h))
-            return -1;
-    }
-
-    if (h->hrecs->nref == 0)
-        return 0;
-
-    //fprintf(stderr, "refs_from_header for %p mode %c\n", fd, fd->mode);
-
-    /* Existing refs are fine, as long as they're compatible with the hdr. */
-    ref_entry **new_ref_id = realloc(r->ref_id, (r->nref + h->hrecs->nref) * sizeof(*r->ref_id));
-    if (!new_ref_id)
-        return -1;
-    r->ref_id = new_ref_id;
-
-    int i, j;
-    /* Copy info from h->ref[i] over to r */
-    for (i = 0, j = r->nref; i < h->hrecs->nref; i++) {
-        sam_hrec_type_t *ty;
-        sam_hrec_tag_t *tag;
-        khint_t k;
-        int n;
-
-        k = kh_get(refs, r->h_meta, h->hrecs->ref[i].name);
-        if (k != kh_end(r->h_meta))
-            // Ref already known about
-            continue;
-
-        if (!(r->ref_id[j] = calloc(1, sizeof(ref_entry))))
-            return -1;
-
-        if (!h->hrecs->ref[i].name)
-            return -1;
-
-        r->ref_id[j]->name = string_dup(r->pool, h->hrecs->ref[i].name);
-        if (!r->ref_id[j]->name) return -1;
-        r->ref_id[j]->length = 0; // marker for not yet loaded
-
-        /* Initialise likely filename if known */
-        if ((ty = sam_hrecs_find_type_id(h->hrecs, "SQ", "SN", h->hrecs->ref[i].name))) {
-            if ((tag = sam_hrecs_find_key(ty, "M5", NULL))) {
-                r->ref_id[j]->fn = string_dup(r->pool, tag->str+3);
-                //fprintf(stderr, "Tagging @SQ %s / %s\n", r->ref_id[h]->name, r->ref_id[h]->fn);
-            }
-        }
-
-        k = kh_put(refs, r->h_meta, r->ref_id[j]->name, &n);
-        if (n <= 0) // already exists or error
-            return -1;
-        kh_val(r->h_meta, k) = r->ref_id[j];
-
-        j++;
-    }
-    r->nref = j;
-
-    return 0;
-}
-
-/*
- * Attaches a header to a cram_fd.
- *
- * This should be used when creating a new cram_fd for writing where
- * we have a header already constructed (eg from a file we've read
- * in).
- */
-int cram_set_header2(cram_fd *fd, const sam_hdr_t *hdr) {
-    if (!fd || !hdr )
-        return -1;
-
-    if (fd->header != hdr) {
-        if (fd->header)
-            sam_hdr_destroy(fd->header);
-        fd->header = sam_hdr_dup(hdr);
-        if (!fd->header)
-            return -1;
-    }
-    return refs_from_header(fd);
-}
-
-int cram_set_header(cram_fd *fd, sam_hdr_t *hdr) {
-    return cram_set_header2(fd, hdr);
-}
-
-/*
- * Returns whether the path refers to a directory.
- */
-static int is_directory(char *fn) {
-    struct stat buf;
-    if ( stat(fn,&buf) ) return 0;
-    return S_ISDIR(buf.st_mode);
-}
-
-/*
- * Converts a directory and a filename into an expanded path, replacing %s
- * in directory with the filename and %[0-9]+s with portions of the filename
- * Any remaining parts of filename are added to the end with /%s.
- */
-static int expand_cache_path(char *path, char *dir, const char *fn) {
-    char *cp, *start = path;
-    size_t len;
-    size_t sz = PATH_MAX;
-
-    while ((cp = strchr(dir, '%'))) {
-        if (cp-dir >= sz) return -1;
-        strncpy(path, dir, cp-dir);
-        path += cp-dir;
-        sz -= cp-dir;
-
-        if (*++cp == 's') {
-            len = strlen(fn);
-            if (len >= sz) return -1;
-            strcpy(path, fn);
-            path += len;
-            sz -= len;
-            fn += len;
-            cp++;
-        } else if (*cp >= '0' && *cp <= '9') {
-            char *endp;
-            long l;
-
-            l = strtol(cp, &endp, 10);
-            l = MIN(l, strlen(fn));
-            if (*endp == 's') {
-                if (l >= sz) return -1;
-                strncpy(path, fn, l);
-                path += l;
-                fn += l;
-                sz -= l;
-                *path = 0;
-                cp = endp+1;
-            } else {
-                if (sz < 3) return -1;
-                *path++ = '%';
-                *path++ = *cp++;
-            }
-        } else {
-            if (sz < 3) return -1;
-            *path++ = '%';
-            *path++ = *cp++;
-        }
-        dir = cp;
-    }
-
-    len = strlen(dir);
-    if (len >= sz) return -1;
-    strcpy(path, dir);
-    path += len;
-    sz -= len;
-
-    len = strlen(fn) + ((*fn && path > start && path[-1] != '/') ? 1 : 0);
-    if (len >= sz) return -1;
-    if (*fn && path > start && path[-1] != '/')
-        *path++ = '/';
-    strcpy(path, fn);
-    return 0;
-}
-
-/*
- * Make the directory containing path and any prefix directories.
- */
-static void mkdir_prefix(char *path, int mode) {
-    char *cp = strrchr(path, '/');
-    if (!cp)
-        return;
-
-    *cp = 0;
-    if (is_directory(path)) {
-        *cp = '/';
-        return;
-    }
-
-    if (mkdir(path, mode) == 0) {
-        chmod(path, mode);
-        *cp = '/';
-        return;
-    }
-
-    mkdir_prefix(path, mode);
-    mkdir(path, mode);
-    chmod(path, mode);
-    *cp = '/';
-}
-
-/*
- * Return the cache directory to use, based on the first of these
- * environment variables to be set to a non-empty value.
- */
-static const char *get_cache_basedir(const char **extra) {
-    char *base;
-
-    *extra = "";
-
-    base = getenv("XDG_CACHE_HOME");
-    if (base && *base) return base;
-
-    base = getenv("HOME");
-    if (base && *base) { *extra = "/.cache"; return base; }
-
-    base = getenv("TMPDIR");
-    if (base && *base) return base;
-
-    base = getenv("TEMP");
-    if (base && *base) return base;
-
-    return "/tmp";
-}
-
-/*
- * Queries the M5 string from the header and attempts to populate the
- * reference from this using the REF_PATH environment.
- *
- * Returns 0 on success
- *        -1 on failure
- */
-static int cram_populate_ref(cram_fd *fd, int id, ref_entry *r) {
-    char *ref_path = getenv("REF_PATH");
-    sam_hrec_type_t *ty;
-    sam_hrec_tag_t *tag;
-    char path[PATH_MAX];
-    kstring_t path_tmp = KS_INITIALIZE;
-    char cache[PATH_MAX], cache_root[PATH_MAX];
-    char *local_cache = getenv("REF_CACHE");
-    mFILE *mf;
-    int local_path = 0;
-
-    hts_log_info("Running cram_populate_ref on fd %p, id %d", (void *)fd, id);
-
-    cache_root[0] = '\0';
-
-    if (!ref_path || *ref_path == '\0') {
-        /*
-         * If we have no ref path, we use the EBI server.
-         * However to avoid spamming it we require a local ref cache too.
-         */
-        ref_path = "https://www.ebi.ac.uk/ena/cram/md5/%s";
-        if (!local_cache || *local_cache == '\0') {
-            const char *extra;
-            const char *base = get_cache_basedir(&extra);
-            snprintf(cache_root, PATH_MAX, "%s%s/hts-ref", base, extra);
-            snprintf(cache,PATH_MAX, "%s%s/hts-ref/%%2s/%%2s/%%s", base, extra);
-            local_cache = cache;
-            hts_log_info("Populating local cache: %s", local_cache);
-        }
-    }
-
-    if (!r->name)
-        return -1;
-
-    if (!(ty = sam_hrecs_find_type_id(fd->header->hrecs, "SQ", "SN", r->name)))
-        return -1;
-
-    if (!(tag = sam_hrecs_find_key(ty, "M5", NULL)))
-        goto no_M5;
-
-    hts_log_info("Querying ref %s", tag->str+3);
-
-    /* Use cache if available */
-    if (local_cache && *local_cache) {
-        if (expand_cache_path(path, local_cache, tag->str+3) == 0)
-            local_path = 1;
-    }
-
-#ifndef HAVE_MMAP
-    char *path2;
-    /* Search local files in REF_PATH; we can open them and return as above */
-    if (!local_path && (path2 = find_path(tag->str+3, ref_path))) {
-        int len = snprintf(path, PATH_MAX, "%s", path2);
-        free(path2);
-        if (len > 0 && len < PATH_MAX) // in case it's too long
-            local_path = 1;
-    }
-#endif
-
-    /* Found via REF_CACHE or local REF_PATH file */
-    if (local_path) {
-        struct stat sb;
-        BGZF *fp;
-
-        if (0 == stat(path, &sb)
-            && S_ISREG(sb.st_mode)
-            && (fp = bgzf_open(path, "r"))) {
-            r->length = sb.st_size;
-            r->offset = r->line_length = r->bases_per_line = 0;
-
-            r->fn = string_dup(fd->refs->pool, path);
-
-            if (fd->refs->fp)
-                if (bgzf_close(fd->refs->fp) != 0)
-                    return -1;
-            fd->refs->fp = fp;
-            fd->refs->fn = r->fn;
-            r->is_md5 = 1;
-
-            // Fall back to cram_get_ref() where it'll do the actual
-            // reading of the file.
-            return 0;
-        }
-    }
-
-
-    /* Otherwise search full REF_PATH; slower as loads entire file */
-    if ((mf = open_path_mfile(tag->str+3, ref_path, NULL))) {
-        size_t sz;
-        r->seq = mfsteal(mf, &sz);
-        if (r->seq) {
-            r->mf = NULL;
-        } else {
-            // keep mf around as we couldn't detach
-            r->seq = mf->data;
-            r->mf = mf;
-        }
-        r->length = sz;
-        r->is_md5 = 1;
-    } else {
-        refs_t *refs;
-        const char *fn;
-
-    no_M5:
-        /* Failed to find in search path or M5 cache, see if @SQ UR: tag? */
-        if (!(tag = sam_hrecs_find_key(ty, "UR", NULL)))
-            return -1;
-
-        fn = (strncmp(tag->str+3, "file:", 5) == 0)
-            ? tag->str+8
-            : tag->str+3;
-
-        if (fd->refs->fp) {
-            if (bgzf_close(fd->refs->fp) != 0)
-                return -1;
-            fd->refs->fp = NULL;
-        }
-        if (!(refs = refs_load_fai(fd->refs, fn, 0)))
-            return -1;
-        sanitise_SQ_lines(fd);
-
-        fd->refs = refs;
-        if (fd->refs->fp) {
-            if (bgzf_close(fd->refs->fp) != 0)
-                return -1;
-            fd->refs->fp = NULL;
-        }
-
-        if (!fd->refs->fn)
-            return -1;
-
-        if (-1 == refs2id(fd->refs, fd->header))
-            return -1;
-        if (!fd->refs->ref_id || !fd->refs->ref_id[id])
-            return -1;
-
-        // Local copy already, so fall back to cram_get_ref().
-        return 0;
-    }
-
-    /* Populate the local disk cache if required */
-    if (local_cache && *local_cache) {
-        hFILE *fp;
-
-        if (*cache_root && !is_directory(cache_root)) {
-            hts_log_warning("Creating reference cache directory %s\n"
-                            "This may become large; see the samtools(1) manual page REF_CACHE discussion",
-                            cache_root);
-        }
-
-        if (expand_cache_path(path, local_cache, tag->str+3) < 0) {
-            return 0; // Not fatal - we have the data already so keep going.
-        }
-        hts_log_info("Writing cache file '%s'", path);
-        mkdir_prefix(path, 01777);
-
-        fp = hts_open_tmpfile(path, "wx", &path_tmp);
-        if (!fp) {
-            perror(path_tmp.s);
-            free(path_tmp.s);
-
-            // Not fatal - we have the data already so keep going.
-            return 0;
-        }
-
-        // Check md5sum
-        hts_md5_context *md5;
-        char unsigned md5_buf1[16];
-        char md5_buf2[33];
-
-        if (!(md5 = hts_md5_init())) {
-            hclose_abruptly(fp);
-            unlink(path_tmp.s);
-            free(path_tmp.s);
-            return -1;
-        }
-        hts_md5_update(md5, r->seq, r->length);
-        hts_md5_final(md5_buf1, md5);
-        hts_md5_destroy(md5);
-        hts_md5_hex(md5_buf2, md5_buf1);
-
-        if (strncmp(tag->str+3, md5_buf2, 32) != 0) {
-            hts_log_error("Mismatching md5sum for downloaded reference");
-            hclose_abruptly(fp);
-            unlink(path_tmp.s);
-            free(path_tmp.s);
-            return -1;
-        }
-
-        ssize_t length_written = hwrite(fp, r->seq, r->length);
-        if (hclose(fp) < 0 || length_written != r->length ||
-            chmod(path_tmp.s, 0444) < 0 ||
-            rename(path_tmp.s, path) < 0) {
-            hts_log_error("Creating reference at %s failed: %s",
-                          path, strerror(errno));
-            unlink(path_tmp.s);
-        }
-    }
-
-    free(path_tmp.s);
-    return 0;
-}
-
-static void cram_ref_incr_locked(refs_t *r, int id) {
-    RP("%d INC REF %d, %d %p\n", gettid(), id,
-       (int)(id>=0 && r->ref_id[id]?r->ref_id[id]->count+1:-999),
-       id>=0 && r->ref_id[id]?r->ref_id[id]->seq:(char *)1);
-
-    if (id < 0 || !r->ref_id[id] || !r->ref_id[id]->seq)
-        return;
-
-    if (r->last_id == id)
-        r->last_id = -1;
-
-    ++r->ref_id[id]->count;
-}
-
-void cram_ref_incr(refs_t *r, int id) {
-    pthread_mutex_lock(&r->lock);
-    cram_ref_incr_locked(r, id);
-    pthread_mutex_unlock(&r->lock);
-}
-
-static void cram_ref_decr_locked(refs_t *r, int id) {
-    RP("%d DEC REF %d, %d %p\n", gettid(), id,
-       (int)(id>=0 && r->ref_id[id]?r->ref_id[id]->count-1:-999),
-       id>=0 && r->ref_id[id]?r->ref_id[id]->seq:(char *)1);
-
-    if (id < 0 || !r->ref_id[id] || !r->ref_id[id]->seq) {
-        return;
-    }
-
-    if (--r->ref_id[id]->count <= 0) {
-        assert(r->ref_id[id]->count == 0);
-        if (r->last_id >= 0) {
-            if (r->ref_id[r->last_id]->count <= 0 &&
-                r->ref_id[r->last_id]->seq) {
-                RP("%d FREE REF %d (%p)\n", gettid(),
-                   r->last_id, r->ref_id[r->last_id]->seq);
-                ref_entry_free_seq(r->ref_id[r->last_id]);
-                if (r->ref_id[r->last_id]->is_md5) r->ref_id[r->last_id]->length = 0;
-            }
-        }
-        r->last_id = id;
-    }
-}
-
-void cram_ref_decr(refs_t *r, int id) {
-    pthread_mutex_lock(&r->lock);
-    cram_ref_decr_locked(r, id);
-    pthread_mutex_unlock(&r->lock);
-}
-
-/*
- * Used by cram_ref_load and cram_ref_get. The file handle will have
- * already been opened, so we can catch it. The ref_entry *e informs us
- * of whether this is a multi-line fasta file or a raw MD5 style file.
- * Either way we create a single contiguous sequence.
- *
- * Returns all or part of a reference sequence on success (malloced);
- *         NULL on failure.
- */
-static char *load_ref_portion(BGZF *fp, ref_entry *e, int start, int end) {
-    off_t offset, len;
-    char *seq;
-
-    if (end < start)
-        end = start;
-
-    /*
-     * Compute locations in file. This is trivial for the MD5 files, but
-     * is still necessary for the fasta variants.
-     */
-    offset = e->line_length
-        ? e->offset + (start-1)/e->bases_per_line * e->line_length +
-          (start-1) % e->bases_per_line
-        : start-1;
-
-    len = (e->line_length
-           ? e->offset + (end-1)/e->bases_per_line * e->line_length +
-             (end-1) % e->bases_per_line
-           : end-1) - offset + 1;
-
-    if (bgzf_useek(fp, offset, SEEK_SET) < 0) {
-        perror("bgzf_useek() on reference file");
-        return NULL;
-    }
-
-    if (len == 0 || !(seq = malloc(len))) {
-        return NULL;
-    }
-
-    if (len != bgzf_read(fp, seq, len)) {
-        perror("bgzf_read() on reference file");
-        free(seq);
-        return NULL;
-    }
-
-    /* Strip white-space if required. */
-    if (len != end-start+1) {
-        int i, j;
-        char *cp = seq;
-        char *cp_to;
-
-        for (i = j = 0; i < len; i++) {
-            if (cp[i] >= '!' && cp[i] <= '~')
-                cp[j++] = toupper_c(cp[i]);
-        }
-        cp_to = cp+j;
-
-        if (cp_to - seq != end-start+1) {
-            hts_log_error("Malformed reference file");
-            free(seq);
-            return NULL;
-        }
-    } else {
-        int i;
-        for (i = 0; i < len; i++) {
-            seq[i] = toupper_c(seq[i]);
-        }
-    }
-
-    return seq;
-}
-
-/*
- * Load the entire reference 'id'.
- * This also increments the reference count by 1.
- *
- * Returns ref_entry on success;
- *         NULL on failure
- */
-ref_entry *cram_ref_load(refs_t *r, int id, int is_md5) {
-    ref_entry *e = r->ref_id[id];
-    int start = 1, end = e->length;
-    char *seq;
-
-    if (e->seq) {
-        return e;
-    }
-
-    assert(e->count == 0);
-
-    if (r->last) {
-#ifdef REF_DEBUG
-        int idx = 0;
-        for (idx = 0; idx < r->nref; idx++)
-            if (r->last == r->ref_id[idx])
-                break;
-        RP("%d cram_ref_load DECR %d\n", gettid(), idx);
-#endif
-        assert(r->last->count > 0);
-        if (--r->last->count <= 0) {
-            RP("%d FREE REF %d (%p)\n", gettid(), id, r->ref_id[id]->seq);
-            if (r->last->seq)
-                ref_entry_free_seq(r->last);
-        }
-    }
-
-    if (!r->fn)
-        return NULL;
-
-    /* Open file if it's not already the current open reference */
-    if (strcmp(r->fn, e->fn) || r->fp == NULL) {
-        if (r->fp)
-            if (bgzf_close(r->fp) != 0)
-                return NULL;
-        r->fn = e->fn;
-        if (!(r->fp = bgzf_open_ref(r->fn, "r", is_md5)))
-            return NULL;
-    }
-
-    RP("%d Loading ref %d (%d..%d)\n", gettid(), id, start, end);
-
-    if (!(seq = load_ref_portion(r->fp, e, start, end))) {
-        return NULL;
-    }
-
-    RP("%d Loaded ref %d (%d..%d) = %p\n", gettid(), id, start, end, seq);
-
-    RP("%d INC REF %d, %"PRId64"\n", gettid(), id, (e->count+1));
-    e->seq = seq;
-    e->mf = NULL;
-    e->count++;
-
-    /*
-     * Also keep track of last used ref so incr/decr loops on the same
-     * sequence don't cause load/free loops.
-     */
-    RP("%d cram_ref_load INCR %d => %"PRId64"\n", gettid(), id, e->count+1);
-    r->last = e;
-    e->count++;
-
-    return e;
-}
-
-/*
- * Returns a portion of a reference sequence from start to end inclusive.
- * The returned pointer is owned by either the cram_file fd or by the
- * internal refs_t structure and should not be freed  by the caller.
- *
- * The difference is whether or not this refs_t is in use by just the one
- * cram_fd or by multiples, or whether we have multiple threads accessing
- * references. In either case fd->shared will be true and we start using
- * reference counting to track the number of users of a specific reference
- * sequence.
- *
- * Otherwise the ref seq returned is allocated as part of cram_fd itself
- * and will be freed up on the next call to cram_get_ref or cram_close.
- *
- * To return the entire reference sequence, specify start as 1 and end
- * as 0.
- *
- * To cease using a reference, call cram_ref_decr().
- *
- * Returns reference on success,
- *         NULL on failure
- */
-char *cram_get_ref(cram_fd *fd, int id, int start, int end) {
-    ref_entry *r;
-    char *seq;
-    int ostart = start;
-
-    if (id == -1)
-        return NULL;
-
-    /* FIXME: axiomatic query of r->seq being true?
-     * Or shortcut for unsorted data where we load once and never free?
-     */
-
-    //fd->shared_ref = 1; // hard code for now to simplify things
-
-    pthread_mutex_lock(&fd->ref_lock);
-
-    RP("%d cram_get_ref on fd %p, id %d, range %d..%d\n", gettid(), fd, id, start, end);
-
-    /*
-     * Unsorted data implies we want to fetch an entire reference at a time.
-     * We just deal with this at the moment by claiming we're sharing
-     * references instead, which has the same requirement.
-     */
-    if (fd->unsorted)
-        fd->shared_ref = 1;
-
-
-    /* Sanity checking: does this ID exist? */
-    if (id >= fd->refs->nref) {
-        hts_log_error("No reference found for id %d", id);
-        pthread_mutex_unlock(&fd->ref_lock);
-        return NULL;
-    }
-
-    if (!fd->refs || !fd->refs->ref_id[id]) {
-        hts_log_error("No reference found for id %d", id);
-        pthread_mutex_unlock(&fd->ref_lock);
-        return NULL;
-    }
-
-    if (!(r = fd->refs->ref_id[id])) {
-        hts_log_error("No reference found for id %d", id);
-        pthread_mutex_unlock(&fd->ref_lock);
-        return NULL;
-    }
-
-
-    /*
-     * It has an entry, but may not have been populated yet.
-     * Any manually loaded .fai files have their lengths known.
-     * A ref entry computed from @SQ lines (M5 or UR field) will have
-     * r->length == 0 unless it's been loaded once and verified that we have
-     * an on-disk filename for it.
-     *
-     * 19 Sep 2013: Moved the lock here as the cram_populate_ref code calls
-     * open_path_mfile and libcurl, which isn't multi-thread safe unless I
-     * rewrite my code to have one curl handle per thread.
-     */
-    pthread_mutex_lock(&fd->refs->lock);
-    if (r->length == 0) {
-        if (cram_populate_ref(fd, id, r) == -1) {
-            hts_log_error("Failed to populate reference for id %d", id);
-            pthread_mutex_unlock(&fd->refs->lock);
-            pthread_mutex_unlock(&fd->ref_lock);
-            return NULL;
-        }
-        r = fd->refs->ref_id[id];
-        if (fd->unsorted)
-            cram_ref_incr_locked(fd->refs, id);
-    }
-
-
-    /*
-     * We now know that we the filename containing the reference, so check
-     * for limits. If it's over half the reference we'll load all of it in
-     * memory as this will speed up subsequent calls.
-     */
-    if (end < 1)
-        end = r->length;
-    if (end >= r->length)
-        end  = r->length;
-    if (start < 1)
-        return NULL;
-
-    if (end - start >= 0.5*r->length || fd->shared_ref) {
-        start = 1;
-        end = r->length;
-    }
-
-    /*
-     * Maybe we have it cached already? If so use it.
-     *
-     * Alternatively if we don't have the sequence but we're sharing
-     * references and/or are asking for the entire length of it, then
-     * load the full reference into the refs structure and return
-     * a pointer to that one instead.
-     */
-    if (fd->shared_ref || r->seq || (start == 1 && end == r->length)) {
-        char *cp;
-
-        if (id >= 0) {
-            if (r->seq) {
-                cram_ref_incr_locked(fd->refs, id);
-            } else {
-                ref_entry *e;
-                if (!(e = cram_ref_load(fd->refs, id, r->is_md5))) {
-                    pthread_mutex_unlock(&fd->refs->lock);
-                    pthread_mutex_unlock(&fd->ref_lock);
-                    return NULL;
-                }
-
-                /* unsorted data implies cache ref indefinitely, to avoid
-                 * continually loading and unloading.
-                 */
-                if (fd->unsorted)
-                    cram_ref_incr_locked(fd->refs, id);
-            }
-
-            fd->ref = NULL; /* We never access it directly */
-            fd->ref_start = 1;
-            fd->ref_end   = r->length;
-            fd->ref_id    = id;
-
-            cp = fd->refs->ref_id[id]->seq + ostart-1;
-        } else {
-            fd->ref = NULL;
-            cp = NULL;
-        }
-
-        RP("%d cram_get_ref returning for id %d, count %d\n", gettid(), id, (int)r->count);
-
-        pthread_mutex_unlock(&fd->refs->lock);
-        pthread_mutex_unlock(&fd->ref_lock);
-        return cp;
-    }
-
-    /*
-     * Otherwise we're not sharing, we don't have a copy of it already and
-     * we're only asking for a small portion of it.
-     *
-     * In this case load up just that segment ourselves, freeing any old
-     * small segments in the process.
-     */
-
-    /* Unmapped ref ID */
-    if (id < 0 || !fd->refs->fn) {
-        if (fd->ref_free) {
-            free(fd->ref_free);
-            fd->ref_free = NULL;
-        }
-        fd->ref = NULL;
-        fd->ref_id = id;
-        pthread_mutex_unlock(&fd->refs->lock);
-        pthread_mutex_unlock(&fd->ref_lock);
-        return NULL;
-    }
-
-    /* Open file if it's not already the current open reference */
-    if (strcmp(fd->refs->fn, r->fn) || fd->refs->fp == NULL) {
-        if (fd->refs->fp)
-            if (bgzf_close(fd->refs->fp) != 0)
-                return NULL;
-        fd->refs->fn = r->fn;
-        if (!(fd->refs->fp = bgzf_open_ref(fd->refs->fn, "r", r->is_md5))) {
-            pthread_mutex_unlock(&fd->refs->lock);
-            pthread_mutex_unlock(&fd->ref_lock);
-            return NULL;
-        }
-    }
-
-    if (!(fd->ref = load_ref_portion(fd->refs->fp, r, start, end))) {
-        pthread_mutex_unlock(&fd->refs->lock);
-        pthread_mutex_unlock(&fd->ref_lock);
-        return NULL;
-    }
-
-    if (fd->ref_free)
-        free(fd->ref_free);
-
-    fd->ref_id    = id;
-    fd->ref_start = start;
-    fd->ref_end   = end;
-    fd->ref_free = fd->ref;
-    seq = fd->ref;
-
-    pthread_mutex_unlock(&fd->refs->lock);
-    pthread_mutex_unlock(&fd->ref_lock);
-
-    return seq ? seq + ostart - start : NULL;
-}
-
-/*
- * If fd has been opened for reading, it may be permitted to specify 'fn'
- * as NULL and let the code auto-detect the reference by parsing the
- * SAM header @SQ lines.
- */
-int cram_load_reference(cram_fd *fd, char *fn) {
-    int ret = 0;
-
-    if (fn) {
-        fd->refs = refs_load_fai(fd->refs, fn,
-                                 !(fd->embed_ref && fd->mode == 'r'));
-        fn = fd->refs ? fd->refs->fn : NULL;
-        if (!fn)
-            ret = -1;
-        sanitise_SQ_lines(fd);
-    }
-    fd->ref_fn = fn;
-
-    if ((!fd->refs || (fd->refs->nref == 0 && !fn)) && fd->header) {
-        if (fd->refs)
-            refs_free(fd->refs);
-        if (!(fd->refs = refs_create()))
-            return -1;
-        if (-1 == refs_from_header(fd))
-            return -1;
-    }
-
-    if (fd->header)
-        if (-1 == refs2id(fd->refs, fd->header))
-            return -1;
-
-    return ret;
-}
-
-/* ----------------------------------------------------------------------
- * Containers
- */
-
-/*
- * Creates a new container, specifying the maximum number of slices
- * and records permitted.
- *
- * Returns cram_container ptr on success
- *         NULL on failure
- */
-cram_container *cram_new_container(int nrec, int nslice) {
-    cram_container *c = calloc(1, sizeof(*c));
-    enum cram_DS_ID id;
-
-    if (!c)
-        return NULL;
-
-    c->curr_ref = -2;
-
-    c->max_c_rec = nrec * nslice;
-    c->curr_c_rec = 0;
-
-    c->max_rec = nrec;
-    c->record_counter = 0;
-    c->num_bases = 0;
-    c->s_num_bases = 0;
-
-    c->max_slice = nslice;
-    c->curr_slice = 0;
-
-    c->pos_sorted = 1;
-    c->max_apos   = 0;
-    c->multi_seq  = 0;
-    c->qs_seq_orient = 1;
-
-    c->bams = NULL;
-
-    if (!(c->slices = calloc(nslice != 0 ? nslice : 1, sizeof(cram_slice *))))
-        goto err;
-    c->slice = NULL;
-
-    if (!(c->comp_hdr = cram_new_compression_header()))
-        goto err;
-    c->comp_hdr_block = NULL;
-
-    for (id = DS_RN; id < DS_TN; id++)
-        if (!(c->stats[id] = cram_stats_create())) goto err;
-
-    //c->aux_B_stats = cram_stats_create();
-
-    if (!(c->tags_used = kh_init(m_tagmap)))
-        goto err;
-    c->refs_used = 0;
-
-    return c;
-
- err:
-    if (c) {
-        if (c->slices)
-            free(c->slices);
-        free(c);
-    }
-    return NULL;
-}
-
-void cram_free_container(cram_container *c) {
-    enum cram_DS_ID id;
-    int i;
-
-    if (!c)
-        return;
-
-    if (c->refs_used)
-        free(c->refs_used);
-
-    if (c->landmark)
-        free(c->landmark);
-
-    if (c->comp_hdr)
-        cram_free_compression_header(c->comp_hdr);
-
-    if (c->comp_hdr_block)
-        cram_free_block(c->comp_hdr_block);
-
-    // Free the slices; filled out by encoder only
-    if (c->slices) {
-        for (i = 0; i < c->max_slice; i++) {
-            if (c->slices[i])
-                cram_free_slice(c->slices[i]);
-            if (c->slices[i] == c->slice)
-                c->slice = NULL;
-        }
-        free(c->slices);
-    }
-
-    // Free the current slice; set by both encoder & decoder
-    if (c->slice) {
-        cram_free_slice(c->slice);
-        c->slice = NULL;
-    }
-
-    for (id = DS_RN; id < DS_TN; id++)
-        if (c->stats[id]) cram_stats_free(c->stats[id]);
-
-    //if (c->aux_B_stats) cram_stats_free(c->aux_B_stats);
-
-    if (c->tags_used) {
-        khint_t k;
-
-        for (k = kh_begin(c->tags_used); k != kh_end(c->tags_used); k++) {
-            if (!kh_exist(c->tags_used, k))
-                continue;
-
-            cram_tag_map *tm = (cram_tag_map *)kh_val(c->tags_used, k);
-            if (tm) {
-                cram_codec *c = tm->codec;
-
-                if (c) c->free(c);
-                free(tm);
-            }
-        }
-
-        kh_destroy(m_tagmap, c->tags_used);
-    }
-
-    free(c);
-}
-
-/*
- * Reads a container header.
- *
- * Returns cram_container on success
- *         NULL on failure or no container left (fd->err == 0).
- */
-cram_container *cram_read_container(cram_fd *fd) {
-    cram_container c2, *c;
-    int i, s;
-    size_t rd = 0;
-    uint32_t crc = 0;
-
-    fd->err = 0;
-    fd->eof = 0;
-
-    memset(&c2, 0, sizeof(c2));
-    if (CRAM_MAJOR_VERS(fd->version) == 1) {
-        if ((s = fd->vv.varint_decode32_crc(fd, &c2.length, &crc)) == -1) {
-            fd->eof = fd->empty_container ? 1 : 2;
-            return NULL;
-        } else {
-            rd+=s;
-        }
-    } else if (CRAM_MAJOR_VERS(fd->version) < 4) {
-        uint32_t len;
-        if ((s = int32_decode(fd, &c2.length)) == -1) {
-            if (CRAM_MAJOR_VERS(fd->version) == 2 &&
-                CRAM_MINOR_VERS(fd->version) == 0)
-                fd->eof = 1; // EOF blocks arrived in v2.1
-            else
-                fd->eof = fd->empty_container ? 1 : 2;
-            return NULL;
-        } else {
-            rd+=s;
-        }
-        len = le_int4(c2.length);
-        crc = crc32(0L, (unsigned char *)&len, 4);
-    } else {
-        if ((s = fd->vv.varint_decode32_crc(fd, &c2.length, &crc))   == -1) {
-            fd->eof = fd->empty_container ? 1 : 2;
-            return NULL;
-        } else {
-            rd+=s;
-        }
-    }
-    if ((s = fd->vv.varint_decode32s_crc(fd, &c2.ref_seq_id, &crc))   == -1) return NULL; else rd+=s;
-    if (CRAM_MAJOR_VERS(fd->version) >= 4) {
-        int64_t i64;
-        if ((s = fd->vv.varint_decode64_crc(fd, &i64, &crc))== -1) return NULL; else rd+=s;
-        c2.ref_seq_start = i64;
-        if ((s = fd->vv.varint_decode64_crc(fd, &i64, &crc)) == -1) return NULL; else rd+=s;
-        c2.ref_seq_span = i64;
-    } else {
-        int32_t i32;
-        if ((s = fd->vv.varint_decode32_crc(fd, &i32, &crc))== -1) return NULL; else rd+=s;
-        c2.ref_seq_start = i32;
-        if ((s = fd->vv.varint_decode32_crc(fd, &i32, &crc)) == -1) return NULL; else rd+=s;
-        c2.ref_seq_span = i32;
-    }
-    if ((s = fd->vv.varint_decode32_crc(fd, &c2.num_records, &crc))  == -1) return NULL; else rd+=s;
-
-    if (CRAM_MAJOR_VERS(fd->version) == 1) {
-        c2.record_counter = 0;
-        c2.num_bases = 0;
-    } else {
-        if (CRAM_MAJOR_VERS(fd->version) >= 3) {
-            if ((s = fd->vv.varint_decode64_crc(fd, &c2.record_counter, &crc)) == -1)
-                return NULL;
-            else
-                rd += s;
-        } else {
-            int32_t i32;
-            if ((s = fd->vv.varint_decode32_crc(fd, &i32, &crc)) == -1)
-                return NULL;
-            else
-                rd += s;
-            c2.record_counter = i32;
-        }
-
-        if ((s = fd->vv.varint_decode64_crc(fd, &c2.num_bases, &crc))== -1)
-            return NULL;
-        else
-            rd += s;
-    }
-    if ((s = fd->vv.varint_decode32_crc(fd, &c2.num_blocks, &crc))   == -1)
-        return NULL;
-    else
-        rd+=s;
-    if ((s = fd->vv.varint_decode32_crc(fd, &c2.num_landmarks, &crc))== -1)
-        return NULL;
-    else
-        rd+=s;
-
-    if (c2.num_landmarks < 0 || c2.num_landmarks >= SIZE_MAX / sizeof(int32_t))
-        return NULL;
-
-    if (!(c = calloc(1, sizeof(*c))))
-        return NULL;
-
-    *c = c2;
-
-    if (c->num_landmarks && !(c->landmark = malloc(c->num_landmarks * sizeof(int32_t)))) {
-        fd->err = errno;
-        cram_free_container(c);
-        return NULL;
-    }
-    for (i = 0; i < c->num_landmarks; i++) {
-        if ((s = fd->vv.varint_decode32_crc(fd, &c->landmark[i], &crc)) == -1) {
-            cram_free_container(c);
-            return NULL;
-        } else {
-            rd += s;
-        }
-    }
-
-    if (CRAM_MAJOR_VERS(fd->version) >= 3) {
-        if (-1 == int32_decode(fd, (int32_t *)&c->crc32)) {
-            cram_free_container(c);
-            return NULL;
-        } else {
-            rd+=4;
-        }
-
-        if (crc != c->crc32) {
-            hts_log_error("Container header CRC32 failure");
-            cram_free_container(c);
-            return NULL;
-        }
-    }
-
-    c->offset = rd;
-    c->slices = NULL;
-    c->slice = NULL;
-    c->curr_slice = 0;
-    c->max_slice = c->num_landmarks;
-    c->slice_rec = 0;
-    c->curr_rec = 0;
-    c->max_rec = 0;
-
-    if (c->ref_seq_id == -2) {
-        c->multi_seq = 1;
-        fd->multi_seq = 1;
-    }
-
-    fd->empty_container =
-        (c->num_records == 0 &&
-         c->ref_seq_id == -1 &&
-         c->ref_seq_start == 0x454f46 /* EOF */) ? 1 : 0;
-
-    return c;
-}
-
-
-/* MAXIMUM storage size needed for the container. */
-int cram_container_size(cram_container *c) {
-    return 55 + 5*c->num_landmarks;
-}
-
-
-/*
- * Stores the container structure in dat and returns *size as the
- * number of bytes written to dat[].  The input size of dat is also
- * held in *size and should be initialised to cram_container_size(c).
- *
- * Returns 0 on success;
- *        -1 on failure
- */
-int cram_store_container(cram_fd *fd, cram_container *c, char *dat, int *size)
-{
-    char *cp = (char *)dat;
-    int i;
-
-    // Check the input buffer is large enough according to our stated
-    // requirements. (NOTE: it may actually take less.)
-    if (cram_container_size(c) > *size)
-        return -1;
-
-    if (CRAM_MAJOR_VERS(fd->version) == 1) {
-        cp += itf8_put(cp, c->length);
-    } else {
-        *(int32_t *)cp = le_int4(c->length);
-        cp += 4;
-    }
-    if (c->multi_seq) {
-        cp += fd->vv.varint_put32(cp, NULL, -2);
-        cp += fd->vv.varint_put32(cp, NULL, 0);
-        cp += fd->vv.varint_put32(cp, NULL, 0);
-    } else {
-        cp += fd->vv.varint_put32s(cp, NULL, c->ref_seq_id);
-        if (CRAM_MAJOR_VERS(fd->version) >= 4) {
-            cp += fd->vv.varint_put64(cp, NULL, c->ref_seq_start);
-            cp += fd->vv.varint_put64(cp, NULL, c->ref_seq_span);
-        } else {
-            cp += fd->vv.varint_put32(cp, NULL, c->ref_seq_start);
-            cp += fd->vv.varint_put32(cp, NULL, c->ref_seq_span);
-        }
-    }
-    cp += fd->vv.varint_put32(cp, NULL, c->num_records);
-    if (CRAM_MAJOR_VERS(fd->version) == 2) {
-        cp += fd->vv.varint_put64(cp, NULL, c->record_counter);
-    } else if (CRAM_MAJOR_VERS(fd->version) >= 3) {
-        cp += fd->vv.varint_put32(cp, NULL, c->record_counter);
-    }
-    cp += fd->vv.varint_put64(cp, NULL, c->num_bases);
-    cp += fd->vv.varint_put32(cp, NULL, c->num_blocks);
-    cp += fd->vv.varint_put32(cp, NULL, c->num_landmarks);
-    for (i = 0; i < c->num_landmarks; i++)
-        cp += fd->vv.varint_put32(cp, NULL, c->landmark[i]);
-
-    if (CRAM_MAJOR_VERS(fd->version) >= 3) {
-        c->crc32 = crc32(0L, (uc *)dat, cp-dat);
-        cp[0] =  c->crc32        & 0xff;
-        cp[1] = (c->crc32 >>  8) & 0xff;
-        cp[2] = (c->crc32 >> 16) & 0xff;
-        cp[3] = (c->crc32 >> 24) & 0xff;
-        cp += 4;
-    }
-
-    *size = cp-dat; // actual used size
-
-    return 0;
-}
-
-
-/*
- * Writes a container structure.
- *
- * Returns 0 on success
- *        -1 on failure
- */
-int cram_write_container(cram_fd *fd, cram_container *c) {
-    char buf_a[1024], *buf = buf_a, *cp;
-    int i;
-
-    if (61 + c->num_landmarks * 10 >= 1024) {
-        buf = malloc(61 + c->num_landmarks * 10);
-        if (!buf)
-            return -1;
-    }
-    cp = buf;
-
-    if (CRAM_MAJOR_VERS(fd->version) == 1) {
-        cp += itf8_put(cp, c->length);
-    } else if (CRAM_MAJOR_VERS(fd->version) <= 3) {
-        *(int32_t *)cp = le_int4(c->length);
-        cp += 4;
-    } else {
-        cp += fd->vv.varint_put32(cp, NULL, c->length);
-    }
-    if (c->multi_seq) {
-        cp += fd->vv.varint_put32(cp, NULL, (uint32_t)-2);
-        cp += fd->vv.varint_put32(cp, NULL, 0);
-        cp += fd->vv.varint_put32(cp, NULL, 0);
-    } else {
-        cp += fd->vv.varint_put32s(cp, NULL, c->ref_seq_id);
-        if (CRAM_MAJOR_VERS(fd->version) >= 4) {
-            cp += fd->vv.varint_put64(cp, NULL, c->ref_seq_start);
-            cp += fd->vv.varint_put64(cp, NULL, c->ref_seq_span);
-        } else {
-            cp += fd->vv.varint_put32(cp, NULL, c->ref_seq_start);
-            cp += fd->vv.varint_put32(cp, NULL, c->ref_seq_span);
-        }
-    }
-    cp += fd->vv.varint_put32(cp, NULL, c->num_records);
-    if (CRAM_MAJOR_VERS(fd->version) >= 3)
-        cp += fd->vv.varint_put64(cp, NULL, c->record_counter);
-    else
-        cp += fd->vv.varint_put32(cp, NULL, c->record_counter);
-    cp += fd->vv.varint_put64(cp, NULL, c->num_bases);
-    cp += fd->vv.varint_put32(cp, NULL, c->num_blocks);
-    cp += fd->vv.varint_put32(cp, NULL, c->num_landmarks);
-    for (i = 0; i < c->num_landmarks; i++)
-        cp += fd->vv.varint_put32(cp, NULL, c->landmark[i]);
-
-    if (CRAM_MAJOR_VERS(fd->version) >= 3) {
-        c->crc32 = crc32(0L, (uc *)buf, cp-buf);
-        cp[0] =  c->crc32        & 0xff;
-        cp[1] = (c->crc32 >>  8) & 0xff;
-        cp[2] = (c->crc32 >> 16) & 0xff;
-        cp[3] = (c->crc32 >> 24) & 0xff;
-        cp += 4;
-    }
-
-    if (cp-buf != hwrite(fd->fp, buf, cp-buf)) {
-        if (buf != buf_a)
-            free(buf);
-        return -1;
-    }
-
-    if (buf != buf_a)
-        free(buf);
-
-    return 0;
-}
-
-// common component shared by cram_flush_container{,_mt}
-static int cram_flush_container2(cram_fd *fd, cram_container *c) {
-    int i, j;
-
-    if (c->curr_slice > 0 && !c->slices)
-        return -1;
-
-    //fprintf(stderr, "Writing container %d, sum %u\n", c->record_counter, sum);
-
-    off_t c_offset = htell(fd->fp); // File offset of container
-
-    /* Write the container struct itself */
-    if (0 != cram_write_container(fd, c))
-        return -1;
-
-    off_t hdr_size = htell(fd->fp) - c_offset;
-
-    /* And the compression header */
-    if (0 != cram_write_block(fd, c->comp_hdr_block))
-        return -1;
-
-    /* Followed by the slice blocks */
-    off_t file_offset = htell(fd->fp);
-    for (i = 0; i < c->curr_slice; i++) {
-        cram_slice *s = c->slices[i];
-        off_t spos = file_offset - c_offset - hdr_size;
-
-        if (0 != cram_write_block(fd, s->hdr_block))
-            return -1;
-
-        for (j = 0; j < s->hdr->num_blocks; j++) {
-            if (0 != cram_write_block(fd, s->block[j]))
-                return -1;
-        }
-
-        file_offset = htell(fd->fp);
-        off_t sz = file_offset - c_offset - hdr_size - spos;
-
-        if (fd->idxfp) {
-            if (cram_index_slice(fd, c, s, fd->idxfp, c_offset, spos, sz) < 0)
-                return -1;
-        }
-    }
-
-    return 0;
-}
-
-/*
- * Flushes a completely or partially full container to disk, writing
- * container structure, header and blocks. This also calls the encoder
- * functions.
- *
- * Returns 0 on success
- *        -1 on failure
- */
-int cram_flush_container(cram_fd *fd, cram_container *c) {
-    /* Encode the container blocks and generate compression header */
-    if (0 != cram_encode_container(fd, c))
-        return -1;
-
-    return cram_flush_container2(fd, c);
-}
-
-typedef struct {
-    cram_fd *fd;
-    cram_container *c;
-} cram_job;
-
-void *cram_flush_thread(void *arg) {
-    cram_job *j = (cram_job *)arg;
-
-    /* Encode the container blocks and generate compression header */
-    if (0 != cram_encode_container(j->fd, j->c)) {
-        hts_log_error("Call to cram_encode_container failed");
-        return NULL;
-    }
-
-    return arg;
-}
-
-static int cram_flush_result(cram_fd *fd) {
-    int i, ret = 0;
-    hts_tpool_result *r;
-    cram_container *lc = NULL;
-
-    // NB: we can have one result per slice, not per container,
-    // so we need to free the container only after all slices
-    // within it have been freed.  (Automatic via reference counting.)
-    while ((r = hts_tpool_next_result(fd->rqueue))) {
-        cram_job *j = (cram_job *)hts_tpool_result_data(r);
-        cram_container *c;
-
-        if (!j) {
-            hts_tpool_delete_result(r, 0);
-            return -1;
-        }
-
-        fd = j->fd;
-        c = j->c;
-
-        if (fd->mode == 'w')
-            if (0 != cram_flush_container2(fd, c))
-                return -1;
-
-        // Free the slices; filled out by encoder only
-        if (c->slices) {
-            for (i = 0; i < c->max_slice; i++) {
-                if (c->slices[i])
-                    cram_free_slice(c->slices[i]);
-                if (c->slices[i] == c->slice)
-                    c->slice = NULL;
-                c->slices[i] = NULL;
-            }
-        }
-
-        // Free the current slice; set by both encoder & decoder
-        if (c->slice) {
-            cram_free_slice(c->slice);
-            c->slice = NULL;
-        }
-        c->curr_slice = 0;
-
-        // Our jobs will be in order, so we free the last
-        // container when our job has switched to a new one.
-        if (c != lc) {
-            if (lc) {
-                if (fd->ctr == lc)
-                    fd->ctr = NULL;
-                if (fd->ctr_mt == lc)
-                    fd->ctr_mt = NULL;
-                cram_free_container(lc);
-            }
-            lc = c;
-        }
-
-        hts_tpool_delete_result(r, 1);
-    }
-    if (lc) {
-        if (fd->ctr == lc)
-            fd->ctr = NULL;
-        if (fd->ctr_mt == lc)
-            fd->ctr_mt = NULL;
-        cram_free_container(lc);
-    }
-
-    return ret;
-}
-
-// Note: called while metrics_lock is held.
-// Will be left in this state too, but may temporarily unlock.
-void reset_metrics(cram_fd *fd) {
-    int i;
-
-    if (fd->pool) {
-        // If multi-threaded we have multiple blocks being
-        // compressed already and several on the to-do list
-        // (fd->rqueue->pending).  It's tricky to reset the
-        // metrics exactly the correct point, so instead we
-        // just flush the pool, reset, and then continue again.
-
-        // Don't bother starting a new trial before then though.
-        for (i = 0; i < DS_END; i++) {
-            cram_metrics *m = fd->m[i];
-            if (!m)
-                continue;
-            m->next_trial = 999;
-        }
-
-        pthread_mutex_unlock(&fd->metrics_lock);
-        hts_tpool_process_flush(fd->rqueue);
-        pthread_mutex_lock(&fd->metrics_lock);
-    }
-
-    for (i = 0; i < DS_END; i++) {
-        cram_metrics *m = fd->m[i];
-        if (!m)
-            continue;
-
-        m->trial = NTRIALS;
-        m->next_trial = TRIAL_SPAN;
-        m->revised_method = 0;
-        m->unpackable = 0;
-
-        memset(m->sz, 0, sizeof(m->sz));
-    }
-}
-
-int cram_flush_container_mt(cram_fd *fd, cram_container *c) {
-    cram_job *j;
-
-    // At the junction of mapped to unmapped data the compression
-    // methods may need to change due to very different statistical
-    // properties; particularly BA if minhash sorted.
-    //
-    // However with threading we'll have several in-flight blocks
-    // arriving out of order.
-    //
-    // So we do one trial reset of NThreads to last for NThreads
-    // duration to get us over this transition period, followed
-    // by another retrial of the usual ntrials & trial span.
-    pthread_mutex_lock(&fd->metrics_lock);
-    if (c->n_mapped < 0.3*c->curr_rec &&
-        fd->last_mapped > 0.7*c->max_rec) {
-        reset_metrics(fd);
-    }
-    fd->last_mapped = c->n_mapped * (c->max_rec+1)/(c->curr_rec+1) ;
-    pthread_mutex_unlock(&fd->metrics_lock);
-
-    if (!fd->pool)
-        return cram_flush_container(fd, c);
-
-    if (!(j = malloc(sizeof(*j))))
-        return -1;
-    j->fd = fd;
-    j->c = c;
-
-    // Flush the job.  Note our encoder queue may be full, so we
-    // either have to keep trying in non-blocking mode (what we do) or
-    // use a dedicated separate thread for draining the queue.
-    for (;;) {
-        errno = 0;
-        hts_tpool_dispatch2(fd->pool, fd->rqueue, cram_flush_thread, j, 1);
-        int pending = (errno == EAGAIN);
-        if (cram_flush_result(fd) != 0)
-            return -1;
-        if (!pending)
-            break;
-
-        usleep(1000);
-    }
-
-    return 0;
-}
-
-/* ----------------------------------------------------------------------
- * Compression headers; the first part of the container
- */
-
-/*
- * Creates a new blank container compression header
- *
- * Returns header ptr on success
- *         NULL on failure
- */
-cram_block_compression_hdr *cram_new_compression_header(void) {
-    cram_block_compression_hdr *hdr = calloc(1, sizeof(*hdr));
-    if (!hdr)
-        return NULL;
-
-    if (!(hdr->TD_blk = cram_new_block(CORE, 0))) {
-        free(hdr);
-        return NULL;
-    }
-
-    if (!(hdr->TD_hash = kh_init(m_s2i))) {
-        cram_free_block(hdr->TD_blk);
-        free(hdr);
-        return NULL;
-    }
-
-    if (!(hdr->TD_keys = string_pool_create(8192))) {
-        kh_destroy(m_s2i, hdr->TD_hash);
-        cram_free_block(hdr->TD_blk);
-        free(hdr);
-        return NULL;
-    }
-
-    return hdr;
-}
-
-void cram_free_compression_header(cram_block_compression_hdr *hdr) {
-    int i;
-
-    if (hdr->landmark)
-        free(hdr->landmark);
-
-    if (hdr->preservation_map)
-        kh_destroy(map, hdr->preservation_map);
-
-    for (i = 0; i < CRAM_MAP_HASH; i++) {
-        cram_map *m, *m2;
-        for (m = hdr->rec_encoding_map[i]; m; m = m2) {
-            m2 = m->next;
-            if (m->codec)
-                m->codec->free(m->codec);
-            free(m);
-        }
-    }
-
-    for (i = 0; i < CRAM_MAP_HASH; i++) {
-        cram_map *m, *m2;
-        for (m = hdr->tag_encoding_map[i]; m; m = m2) {
-            m2 = m->next;
-            if (m->codec)
-                m->codec->free(m->codec);
-            free(m);
-        }
-    }
-
-    for (i = 0; i < DS_END; i++) {
-        if (hdr->codecs[i])
-            hdr->codecs[i]->free(hdr->codecs[i]);
-    }
-
-    if (hdr->TL)
-        free(hdr->TL);
-    if (hdr->TD_blk)
-        cram_free_block(hdr->TD_blk);
-    if (hdr->TD_hash)
-        kh_destroy(m_s2i, hdr->TD_hash);
-    if (hdr->TD_keys)
-        string_pool_destroy(hdr->TD_keys);
-
-    free(hdr);
-}
-
-
-/* ----------------------------------------------------------------------
- * Slices and slice headers
- */
-
-void cram_free_slice_header(cram_block_slice_hdr *hdr) {
-    if (!hdr)
-        return;
-
-    if (hdr->block_content_ids)
-        free(hdr->block_content_ids);
-
-    free(hdr);
-
-    return;
-}
-
-void cram_free_slice(cram_slice *s) {
-    if (!s)
-        return;
-
-    if (s->hdr_block)
-        cram_free_block(s->hdr_block);
-
-    if (s->block) {
-        int i;
-
-        if (s->hdr) {
-            for (i = 0; i < s->hdr->num_blocks; i++) {
-                if (i > 0 && s->block[i] == s->block[0])
-                    continue;
-                cram_free_block(s->block[i]);
-            }
-        }
-        free(s->block);
-    }
-
-    if (s->block_by_id)
-        free(s->block_by_id);
-
-    if (s->hdr)
-        cram_free_slice_header(s->hdr);
-
-    if (s->seqs_blk)
-        cram_free_block(s->seqs_blk);
-
-    if (s->qual_blk)
-        cram_free_block(s->qual_blk);
-
-    if (s->name_blk)
-        cram_free_block(s->name_blk);
-
-    if (s->aux_blk)
-        cram_free_block(s->aux_blk);
-
-    if (s->base_blk)
-        cram_free_block(s->base_blk);
-
-    if (s->soft_blk)
-        cram_free_block(s->soft_blk);
-
-    if (s->cigar)
-        free(s->cigar);
-
-    if (s->crecs)
-        free(s->crecs);
-
-    if (s->features)
-        free(s->features);
-
-    if (s->TN)
-        free(s->TN);
-
-    if (s->pair_keys)
-        string_pool_destroy(s->pair_keys);
-
-    if (s->pair[0])
-        kh_destroy(m_s2i, s->pair[0]);
-    if (s->pair[1])
-        kh_destroy(m_s2i, s->pair[1]);
-
-    if (s->aux_block)
-        free(s->aux_block);
-
-    free(s);
-}
-
-/*
- * Creates a new empty slice in memory, for subsequent writing to
- * disk.
- *
- * Returns cram_slice ptr on success
- *         NULL on failure
- */
-cram_slice *cram_new_slice(enum cram_content_type type, int nrecs) {
-    cram_slice *s = calloc(1, sizeof(*s));
-    if (!s)
-        return NULL;
-
-    if (!(s->hdr = (cram_block_slice_hdr *)calloc(1, sizeof(*s->hdr))))
-        goto err;
-    s->hdr->content_type = type;
-
-    s->hdr_block = NULL;
-    s->block = NULL;
-    s->block_by_id = NULL;
-    s->last_apos = 0;
-    if (!(s->crecs = malloc(nrecs * sizeof(cram_record))))  goto err;
-    s->cigar_alloc = 1024;
-    if (!(s->cigar = malloc(s->cigar_alloc * sizeof(*s->cigar)))) goto err;
-    s->ncigar = 0;
-
-    if (!(s->seqs_blk = cram_new_block(EXTERNAL, 0)))       goto err;
-    if (!(s->qual_blk = cram_new_block(EXTERNAL, DS_QS)))   goto err;
-    if (!(s->name_blk = cram_new_block(EXTERNAL, DS_RN)))   goto err;
-    if (!(s->aux_blk  = cram_new_block(EXTERNAL, DS_aux)))  goto err;
-    if (!(s->base_blk = cram_new_block(EXTERNAL, DS_IN)))   goto err;
-    if (!(s->soft_blk = cram_new_block(EXTERNAL, DS_SC)))   goto err;
-
-    s->features = NULL;
-    s->nfeatures = s->afeatures = 0;
-
-#ifndef TN_external
-    s->TN = NULL;
-    s->nTN = s->aTN = 0;
-#endif
-
-    // Volatile keys as we do realloc in dstring
-    if (!(s->pair_keys = string_pool_create(8192))) goto err;
-    if (!(s->pair[0] = kh_init(m_s2i)))             goto err;
-    if (!(s->pair[1] = kh_init(m_s2i)))             goto err;
-
-#ifdef BA_external
-    s->BA_len = 0;
-#endif
-
-    return s;
-
- err:
-    if (s)
-        cram_free_slice(s);
-
-    return NULL;
-}
-
-/*
- * Loads an entire slice.
- * FIXME: In 1.0 the native unit of slices within CRAM is broken
- * as slices contain references to objects in other slices.
- * To work around this while keeping the slice oriented outer loop
- * we read all slices and stitch them together into a fake large
- * slice instead.
- *
- * Returns cram_slice ptr on success
- *         NULL on failure
- */
-cram_slice *cram_read_slice(cram_fd *fd) {
-    cram_block *b = cram_read_block(fd);
-    cram_slice *s = calloc(1, sizeof(*s));
-    int i, n, max_id, min_id;
-
-    if (!b || !s)
-        goto err;
-
-    s->hdr_block = b;
-    switch (b->content_type) {
-    case MAPPED_SLICE:
-    case UNMAPPED_SLICE:
-        if (!(s->hdr = cram_decode_slice_header(fd, b)))
-            goto err;
-        break;
-
-    default:
-        hts_log_error("Unexpected block of type %s",
-                      cram_content_type2str(b->content_type));
-        goto err;
-    }
-
-    if (s->hdr->num_blocks < 1) {
-        hts_log_error("Slice does not include any data blocks");
-        goto err;
-    }
-
-    s->block = calloc(n = s->hdr->num_blocks, sizeof(*s->block));
-    if (!s->block)
-        goto err;
-
-    for (max_id = i = 0, min_id = INT_MAX; i < n; i++) {
-        if (!(s->block[i] = cram_read_block(fd)))
-            goto err;
-
-        if (s->block[i]->content_type == EXTERNAL) {
-            if (max_id < s->block[i]->content_id)
-                max_id = s->block[i]->content_id;
-            if (min_id > s->block[i]->content_id)
-                min_id = s->block[i]->content_id;
-        }
-    }
-
-    if (!(s->block_by_id = calloc(512, sizeof(s->block[0]))))
-        goto err;
-
-    for (i = 0; i < n; i++) {
-        if (s->block[i]->content_type != EXTERNAL)
-            continue;
-        uint32_t v = s->block[i]->content_id;
-        if (v >= 256)
-            v = 256 + v % 251;
-        s->block_by_id[v] = s->block[i];
-    }
-
-    /* Initialise encoding/decoding tables */
-    s->cigar_alloc = 1024;
-    if (!(s->cigar = malloc(s->cigar_alloc * sizeof(*s->cigar)))) goto err;
-    s->ncigar = 0;
-
-    if (!(s->seqs_blk = cram_new_block(EXTERNAL, 0)))      goto err;
-    if (!(s->qual_blk = cram_new_block(EXTERNAL, DS_QS)))  goto err;
-    if (!(s->name_blk = cram_new_block(EXTERNAL, DS_RN)))  goto err;
-    if (!(s->aux_blk  = cram_new_block(EXTERNAL, DS_aux))) goto err;
-    if (!(s->base_blk = cram_new_block(EXTERNAL, DS_IN)))  goto err;
-    if (!(s->soft_blk = cram_new_block(EXTERNAL, DS_SC)))  goto err;
-
-    s->crecs = NULL;
-
-    s->last_apos = s->hdr->ref_seq_start;
-    s->decode_md = fd->decode_md;
-
-    return s;
-
- err:
-    if (b)
-        cram_free_block(b);
-    if (s) {
-        s->hdr_block = NULL;
-        cram_free_slice(s);
-    }
-    return NULL;
-}
-
-
-/* ----------------------------------------------------------------------
- * CRAM file definition (header)
- */
-
-/*
- * Reads a CRAM file definition structure.
- * Returns file_def ptr on success
- *         NULL on failure
- */
-cram_file_def *cram_read_file_def(cram_fd *fd) {
-    cram_file_def *def = malloc(sizeof(*def));
-    if (!def)
-        return NULL;
-
-    if (26 != hread(fd->fp, &def->magic[0], 26)) {
-        free(def);
-        return NULL;
-    }
-
-    if (memcmp(def->magic, "CRAM", 4) != 0) {
-        free(def);
-        return NULL;
-    }
-
-    if (def->major_version > 4) {
-        hts_log_error("CRAM version number mismatch. Expected 1.x, 2.x, 3.x or 4.x, got %d.%d",
-                      def->major_version, def->minor_version);
-        free(def);
-        return NULL;
-    }
-
-    fd->first_container += 26;
-    fd->curr_position = fd->first_container;
-    fd->last_slice = 0;
-
-    return def;
-}
-
-/*
- * Writes a cram_file_def structure to cram_fd.
- * Returns 0 on success
- *        -1 on failure
- */
-int cram_write_file_def(cram_fd *fd, cram_file_def *def) {
-    return (hwrite(fd->fp, &def->magic[0], 26) == 26) ? 0 : -1;
-}
-
-void cram_free_file_def(cram_file_def *def) {
-    if (def) free(def);
-}
-
-/* ----------------------------------------------------------------------
- * SAM header I/O
- */
-
-
-/*
- * Reads the SAM header from the first CRAM data block.
- * Also performs minimal parsing to extract read-group
- * and sample information.
-
- * Returns SAM hdr ptr on success
- *         NULL on failure
- */
-sam_hdr_t *cram_read_SAM_hdr(cram_fd *fd) {
-    int32_t header_len;
-    char *header;
-    sam_hdr_t *hdr;
-
-    /* 1.1 onwards stores the header in the first block of a container */
-    if (CRAM_MAJOR_VERS(fd->version) == 1) {
-        /* Length */
-        if (-1 == int32_decode(fd, &header_len))
-            return NULL;
-
-        /* Alloc and read */
-        if (header_len < 0 || NULL == (header = malloc((size_t) header_len+1)))
-            return NULL;
-
-        if (header_len != hread(fd->fp, header, header_len)) {
-            free(header);
-            return NULL;
-        }
-        header[header_len] = '\0';
-
-        fd->first_container += 4 + header_len;
-    } else {
-        cram_container *c = cram_read_container(fd);
-        cram_block *b;
-        int i;
-        int64_t len;
-
-        if (!c)
-            return NULL;
-
-        fd->first_container += c->length + c->offset;
-        fd->curr_position = fd->first_container;
-
-        if (c->num_blocks < 1) {
-            cram_free_container(c);
-            return NULL;
-        }
-
-        if (!(b = cram_read_block(fd))) {
-            cram_free_container(c);
-            return NULL;
-        }
-        if (cram_uncompress_block(b) != 0) {
-            cram_free_container(c);
-            cram_free_block(b);
-            return NULL;
-        }
-
-        len = b->comp_size + 2 + 4*(CRAM_MAJOR_VERS(fd->version) >= 3) +
-            fd->vv.varint_size(b->content_id) +
-            fd->vv.varint_size(b->uncomp_size) +
-            fd->vv.varint_size(b->comp_size);
-
-        /* Extract header from 1st block */
-        if (-1 == int32_get_blk(b, &header_len) ||
-            header_len < 0 || /* Spec. says signed...  why? */
-            b->uncomp_size - 4 < header_len) {
-            cram_free_container(c);
-            cram_free_block(b);
-            return NULL;
-        }
-        if (NULL == (header = malloc((size_t) header_len+1))) {
-            cram_free_container(c);
-            cram_free_block(b);
-            return NULL;
-        }
-        memcpy(header, BLOCK_END(b), header_len);
-        header[header_len] = '\0';
-        cram_free_block(b);
-
-        /* Consume any remaining blocks */
-        for (i = 1; i < c->num_blocks; i++) {
-            if (!(b = cram_read_block(fd))) {
-                cram_free_container(c);
-                free(header);
-                return NULL;
-            }
-            len += b->comp_size + 2 + 4*(CRAM_MAJOR_VERS(fd->version) >= 3) +
-                fd->vv.varint_size(b->content_id) +
-                fd->vv.varint_size(b->uncomp_size) +
-                fd->vv.varint_size(b->comp_size);
-            cram_free_block(b);
-        }
-
-        if (c->length > 0 && len > 0 && c->length > len) {
-            // Consume padding
-            char *pads = malloc(c->length - len);
-            if (!pads) {
-                cram_free_container(c);
-                free(header);
-                return NULL;
-            }
-
-            if (c->length - len != hread(fd->fp, pads, c->length - len)) {
-                cram_free_container(c);
-                free(header);
-                free(pads);
-                return NULL;
-            }
-            free(pads);
-        }
-
-        cram_free_container(c);
-    }
-
-    /* Parse */
-    hdr = sam_hdr_init();
-    if (!hdr) {
-        free(header);
-        return NULL;
-    }
-
-    if (-1 == sam_hdr_add_lines(hdr, header, header_len)) {
-        free(header);
-        sam_hdr_destroy(hdr);
-        return NULL;
-    }
-
-    hdr->l_text = header_len;
-    hdr->text = header;
-
-    return hdr;
-
-}
-
-/*
- * Converts 'in' to a full pathname to store in out.
- * Out must be at least PATH_MAX bytes long.
- */
-static void full_path(char *out, char *in) {
-    size_t in_l = strlen(in);
-    if (hisremote(in)) {
-        if (in_l > PATH_MAX) {
-            hts_log_error("Reference path is longer than %d", PATH_MAX);
-            return;
-        }
-        strncpy(out, in, PATH_MAX-1);
-        out[PATH_MAX-1] = 0;
-        return;
-    }
-    if (*in == '/' ||
-        // Windows paths
-        (in_l > 3 && toupper_c(*in) >= 'A'  && toupper_c(*in) <= 'Z' &&
-         in[1] == ':' && (in[2] == '/' || in[2] == '\\'))) {
-        strncpy(out, in, PATH_MAX-1);
-        out[PATH_MAX-1] = 0;
-    } else {
-        int len;
-
-        // unable to get dir or out+in is too long
-        if (!getcwd(out, PATH_MAX) ||
-            (len = strlen(out))+1+strlen(in) >= PATH_MAX) {
-            strncpy(out, in, PATH_MAX-1);
-            out[PATH_MAX-1] = 0;
-            return;
-        }
-
-        sprintf(out+len, "/%.*s", PATH_MAX - 2 - len, in);
-
-        // FIXME: cope with `pwd`/../../../foo.fa ?
-    }
-}
-
-/*
- * Writes a CRAM SAM header.
- * Returns 0 on success
- *        -1 on failure
- */
-int cram_write_SAM_hdr(cram_fd *fd, sam_hdr_t *hdr) {
-    size_t header_len;
-    int blank_block = (CRAM_MAJOR_VERS(fd->version) >= 3);
-
-    /* Write CRAM MAGIC if not yet written. */
-    if (fd->file_def->major_version == 0) {
-        fd->file_def->major_version = CRAM_MAJOR_VERS(fd->version);
-        fd->file_def->minor_version = CRAM_MINOR_VERS(fd->version);
-        if (0 != cram_write_file_def(fd, fd->file_def))
-            return -1;
-    }
-
-    /* 1.0 requires an UNKNOWN read-group */
-    if (CRAM_MAJOR_VERS(fd->version) == 1) {
-        if (!sam_hrecs_find_rg(hdr->hrecs, "UNKNOWN"))
-            if (sam_hdr_add_line(hdr, "RG",
-                            "ID", "UNKNOWN", "SM", "UNKNOWN", NULL))
-                return -1;
-    }
-
-    /* Fix M5 strings */
-    if (fd->refs && !fd->no_ref) {
-        int i;
-        for (i = 0; i < hdr->hrecs->nref; i++) {
-            sam_hrec_type_t *ty;
-            char *ref;
-
-            if (!(ty = sam_hrecs_find_type_id(hdr->hrecs, "SQ", "SN", hdr->hrecs->ref[i].name)))
-                return -1;
-
-            if (!sam_hrecs_find_key(ty, "M5", NULL)) {
-                char unsigned buf[16];
-                char buf2[33];
-                int rlen;
-                hts_md5_context *md5;
-
-                if (!fd->refs ||
-                    !fd->refs->ref_id ||
-                    !fd->refs->ref_id[i]) {
-                    return -1;
-                }
-                rlen = fd->refs->ref_id[i]->length;
-                if (!(md5 = hts_md5_init()))
-                    return -1;
-                ref = cram_get_ref(fd, i, 1, rlen);
-                if (NULL == ref) return -1;
-                rlen = fd->refs->ref_id[i]->length; /* In case it just loaded */
-                hts_md5_update(md5, ref, rlen);
-                hts_md5_final(buf, md5);
-                hts_md5_destroy(md5);
-                cram_ref_decr(fd->refs, i);
-
-                hts_md5_hex(buf2, buf);
-                if (sam_hdr_update_line(hdr, "SQ", "SN", hdr->hrecs->ref[i].name, "M5", buf2, NULL))
-                    return -1;
-            }
-
-            if (fd->ref_fn) {
-                char ref_fn[PATH_MAX];
-                full_path(ref_fn, fd->ref_fn);
-                if (sam_hdr_update_line(hdr, "SQ", "SN", hdr->hrecs->ref[i].name, "UR", ref_fn, NULL))
-                    return -1;
-            }
-        }
-    }
-
-    /* Length */
-    header_len = sam_hdr_length(hdr);
-    if (header_len > INT32_MAX) {
-        hts_log_error("Header is too long for CRAM format");
-        return -1;
-    }
-    if (CRAM_MAJOR_VERS(fd->version) == 1) {
-        if (-1 == int32_encode(fd, header_len))
-            return -1;
-
-        /* Text data */
-        if (header_len != hwrite(fd->fp, sam_hdr_str(hdr), header_len))
-            return -1;
-    } else {
-        /* Create block(s) inside a container */
-        cram_block *b = cram_new_block(FILE_HEADER, 0);
-        cram_container *c = cram_new_container(0, 0);
-        int padded_length;
-        char *pads;
-        int is_cram_3 = (CRAM_MAJOR_VERS(fd->version) >= 3);
-
-        if (!b || !c) {
-            if (b) cram_free_block(b);
-            if (c) cram_free_container(c);
-            return -1;
-        }
-
-        if (int32_put_blk(b, header_len) < 0)
-            return -1;
-        if (header_len)
-            BLOCK_APPEND(b, sam_hdr_str(hdr), header_len);
-        BLOCK_UPLEN(b);
-
-        // Compress header block if V3.0 and above
-        if (CRAM_MAJOR_VERS(fd->version) >= 3)
-            if (cram_compress_block(fd, b, NULL, -1, -1) < 0)
-                return -1;
-
-        if (blank_block) {
-            c->length = b->comp_size + 2 + 4*is_cram_3 +
-                fd->vv.varint_size(b->content_id)   +
-                fd->vv.varint_size(b->uncomp_size)  +
-                fd->vv.varint_size(b->comp_size);
-
-            c->num_blocks = 2;
-            c->num_landmarks = 2;
-            if (!(c->landmark = malloc(2*sizeof(*c->landmark)))) {
-                cram_free_block(b);
-                cram_free_container(c);
-                return -1;
-            }
-            c->landmark[0] = 0;
-            c->landmark[1] = c->length;
-
-            // Plus extra storage for uncompressed secondary blank block
-            padded_length = MIN(c->length*.5, 10000);
-            c->length += padded_length + 2 + 4*is_cram_3 +
-                fd->vv.varint_size(b->content_id) +
-                fd->vv.varint_size(padded_length)*2;
-        } else {
-            // Pad the block instead.
-            c->num_blocks = 1;
-            c->num_landmarks = 1;
-            if (!(c->landmark = malloc(sizeof(*c->landmark))))
-                return -1;
-            c->landmark[0] = 0;
-
-            padded_length = MAX(c->length*1.5, 10000) - c->length;
-
-            c->length = b->comp_size + padded_length +
-                2 + 4*is_cram_3 +
-                fd->vv.varint_size(b->content_id)   +
-                fd->vv.varint_size(b->uncomp_size)  +
-                fd->vv.varint_size(b->comp_size);
-
-            if (NULL == (pads = calloc(1, padded_length))) {
-                cram_free_block(b);
-                cram_free_container(c);
-                return -1;
-            }
-            BLOCK_APPEND(b, pads, padded_length);
-            BLOCK_UPLEN(b);
-            free(pads);
-        }
-
-        if (-1 == cram_write_container(fd, c)) {
-            cram_free_block(b);
-            cram_free_container(c);
-            return -1;
-        }
-
-        if (-1 == cram_write_block(fd, b)) {
-            cram_free_block(b);
-            cram_free_container(c);
-            return -1;
-        }
-
-        if (blank_block) {
-            BLOCK_RESIZE(b, padded_length);
-            memset(BLOCK_DATA(b), 0, padded_length);
-            BLOCK_SIZE(b) = padded_length;
-            BLOCK_UPLEN(b);
-            b->method = RAW;
-            if (-1 == cram_write_block(fd, b)) {
-                cram_free_block(b);
-                cram_free_container(c);
-                return -1;
-            }
-        }
-
-        cram_free_block(b);
-        cram_free_container(c);
-    }
-
-    if (-1 == refs_from_header(fd))
-        return -1;
-    if (-1 == refs2id(fd->refs, fd->header))
-        return -1;
-
-    if (0 != hflush(fd->fp))
-        return -1;
-
-    RP("=== Finishing saving header ===\n");
-
-    return 0;
-
- block_err:
-    return -1;
-}
-
-/* ----------------------------------------------------------------------
- * The top-level cram opening, closing and option handling
- */
-
-/*
- * Sets CRAM variable sized integer decode function tables.
- * CRAM 1, 2, and 3.x all used ITF8 for uint32 and UTF8 for uint64.
- * CRAM 4.x uses the same encoding mechanism for 32-bit and 64-bit
- * (or anything inbetween), but also now supports signed values.
- *
- * Version is the CRAM major version number.
- * vv is the vector table (probably &cram_fd->vv)
- */
-static void cram_init_varint(varint_vec *vv, int version) {
-    if (version >= 4) {
-        vv->varint_get32 = uint7_get_32; // FIXME: varint.h API should be size agnostic
-        vv->varint_get32s = sint7_get_32;
-        vv->varint_get64 = uint7_get_64;
-        vv->varint_get64s = sint7_get_64;
-        vv->varint_put32 = uint7_put_32;
-        vv->varint_put32s = sint7_put_32;
-        vv->varint_put64 = uint7_put_64;
-        vv->varint_put64s = sint7_put_64;
-        vv->varint_put32_blk = uint7_put_blk_32;
-        vv->varint_put32s_blk = sint7_put_blk_32;
-        vv->varint_put64_blk = uint7_put_blk_64;
-        vv->varint_put64s_blk = sint7_put_blk_64;
-        vv->varint_size = uint7_size;
-        vv->varint_decode32_crc = uint7_decode_crc32;
-        vv->varint_decode32s_crc = sint7_decode_crc32;
-        vv->varint_decode64_crc = uint7_decode_crc64;
-    } else {
-        vv->varint_get32 = safe_itf8_get;
-        vv->varint_get32s = safe_itf8_get;
-        vv->varint_get64 = safe_ltf8_get;
-        vv->varint_get64s = safe_ltf8_get;
-        vv->varint_put32 = safe_itf8_put;
-        vv->varint_put32s = safe_itf8_put;
-        vv->varint_put64 = safe_ltf8_put;
-        vv->varint_put64s = safe_ltf8_put;
-        vv->varint_put32_blk = itf8_put_blk;
-        vv->varint_put32s_blk = itf8_put_blk;
-        vv->varint_put64_blk = ltf8_put_blk;
-        vv->varint_put64s_blk = ltf8_put_blk;
-        vv->varint_size = itf8_size;
-        vv->varint_decode32_crc = itf8_decode_crc;
-        vv->varint_decode32s_crc = itf8_decode_crc;
-        vv->varint_decode64_crc = ltf8_decode_crc;
-    }
-}
-
-/*
- * Initialises the lookup tables. These could be global statics, but they're
- * clumsy to setup in a multi-threaded environment unless we generate
- * verbatim code and include that.
- */
-static void cram_init_tables(cram_fd *fd) {
-    int i;
-
-    memset(fd->L1, 4, 256);
-    fd->L1['A'] = 0; fd->L1['a'] = 0;
-    fd->L1['C'] = 1; fd->L1['c'] = 1;
-    fd->L1['G'] = 2; fd->L1['g'] = 2;
-    fd->L1['T'] = 3; fd->L1['t'] = 3;
-
-    memset(fd->L2, 5, 256);
-    fd->L2['A'] = 0; fd->L2['a'] = 0;
-    fd->L2['C'] = 1; fd->L2['c'] = 1;
-    fd->L2['G'] = 2; fd->L2['g'] = 2;
-    fd->L2['T'] = 3; fd->L2['t'] = 3;
-    fd->L2['N'] = 4; fd->L2['n'] = 4;
-
-    if (CRAM_MAJOR_VERS(fd->version) == 1) {
-        for (i = 0; i < 0x200; i++) {
-            int f = 0;
-
-            if (i & CRAM_FPAIRED)      f |= BAM_FPAIRED;
-            if (i & CRAM_FPROPER_PAIR) f |= BAM_FPROPER_PAIR;
-            if (i & CRAM_FUNMAP)       f |= BAM_FUNMAP;
-            if (i & CRAM_FREVERSE)     f |= BAM_FREVERSE;
-            if (i & CRAM_FREAD1)       f |= BAM_FREAD1;
-            if (i & CRAM_FREAD2)       f |= BAM_FREAD2;
-            if (i & CRAM_FSECONDARY)   f |= BAM_FSECONDARY;
-            if (i & CRAM_FQCFAIL)      f |= BAM_FQCFAIL;
-            if (i & CRAM_FDUP)         f |= BAM_FDUP;
-
-            fd->bam_flag_swap[i]  = f;
-        }
-
-        for (i = 0; i < 0x1000; i++) {
-            int g = 0;
-
-            if (i & BAM_FPAIRED)           g |= CRAM_FPAIRED;
-            if (i & BAM_FPROPER_PAIR)  g |= CRAM_FPROPER_PAIR;
-            if (i & BAM_FUNMAP)        g |= CRAM_FUNMAP;
-            if (i & BAM_FREVERSE)      g |= CRAM_FREVERSE;
-            if (i & BAM_FREAD1)        g |= CRAM_FREAD1;
-            if (i & BAM_FREAD2)        g |= CRAM_FREAD2;
-            if (i & BAM_FSECONDARY)    g |= CRAM_FSECONDARY;
-            if (i & BAM_FQCFAIL)       g |= CRAM_FQCFAIL;
-            if (i & BAM_FDUP)          g |= CRAM_FDUP;
-
-            fd->cram_flag_swap[i] = g;
-        }
-    } else {
-        /* NOP */
-        for (i = 0; i < 0x1000; i++)
-            fd->bam_flag_swap[i] = i;
-        for (i = 0; i < 0x1000; i++)
-            fd->cram_flag_swap[i] = i;
-    }
-
-    memset(fd->cram_sub_matrix, 4, 32*32);
-    for (i = 0; i < 32; i++) {
-        fd->cram_sub_matrix[i]['A'&0x1f]=0;
-        fd->cram_sub_matrix[i]['C'&0x1f]=1;
-        fd->cram_sub_matrix[i]['G'&0x1f]=2;
-        fd->cram_sub_matrix[i]['T'&0x1f]=3;
-        fd->cram_sub_matrix[i]['N'&0x1f]=4;
-    }
-    for (i = 0; i < 20; i+=4) {
-        int j;
-        for (j = 0; j < 20; j++) {
-            fd->cram_sub_matrix["ACGTN"[i>>2]&0x1f][j]=3;
-            fd->cram_sub_matrix["ACGTN"[i>>2]&0x1f][j]=3;
-            fd->cram_sub_matrix["ACGTN"[i>>2]&0x1f][j]=3;
-            fd->cram_sub_matrix["ACGTN"[i>>2]&0x1f][j]=3;
-        }
-        fd->cram_sub_matrix["ACGTN"[i>>2]&0x1f][CRAM_SUBST_MATRIX[i+0]&0x1f]=0;
-        fd->cram_sub_matrix["ACGTN"[i>>2]&0x1f][CRAM_SUBST_MATRIX[i+1]&0x1f]=1;
-        fd->cram_sub_matrix["ACGTN"[i>>2]&0x1f][CRAM_SUBST_MATRIX[i+2]&0x1f]=2;
-        fd->cram_sub_matrix["ACGTN"[i>>2]&0x1f][CRAM_SUBST_MATRIX[i+3]&0x1f]=3;
-    }
-
-    cram_init_varint(&fd->vv, CRAM_MAJOR_VERS(fd->version));
-}
-
-// Default version numbers for CRAM
-static int major_version = 3;
-static int minor_version = 0;
-
-/*
- * Opens a CRAM file for read (mode "rb") or write ("wb").
- * The filename may be "-" to indicate stdin or stdout.
- *
- * Returns file handle on success
- *         NULL on failure.
- */
-cram_fd *cram_open(const char *filename, const char *mode) {
-    hFILE *fp;
-    cram_fd *fd;
-    char fmode[3]= { mode[0], '\0', '\0' };
-
-    if (strlen(mode) > 1 && (mode[1] == 'b' || mode[1] == 'c')) {
-        fmode[1] = 'b';
-    }
-
-    fp = hopen(filename, fmode);
-    if (!fp)
-        return NULL;
-
-    fd = cram_dopen(fp, filename, mode);
-    if (!fd)
-        hclose_abruptly(fp);
-
-    return fd;
-}
-
-/* Opens an existing stream for reading or writing.
- *
- * Returns file handle on success;
- *         NULL on failure.
- */
-cram_fd *cram_dopen(hFILE *fp, const char *filename, const char *mode) {
-    int i;
-    char *cp;
-    cram_fd *fd = calloc(1, sizeof(*fd));
-    if (!fd)
-        return NULL;
-
-    fd->level = CRAM_DEFAULT_LEVEL;
-    for (i = 0; mode[i]; i++) {
-        if (mode[i] >= '0' && mode[i] <= '9') {
-            fd->level = mode[i] - '0';
-            break;
-        }
-    }
-
-    fd->fp = fp;
-    fd->mode = *mode;
-    fd->first_container = 0;
-    fd->curr_position = 0;
-
-    if (fd->mode == 'r') {
-        /* Reader */
-
-        if (!(fd->file_def = cram_read_file_def(fd)))
-            goto err;
-
-        fd->version = fd->file_def->major_version * 256 +
-            fd->file_def->minor_version;
-
-        cram_init_tables(fd);
-
-        if (!(fd->header = cram_read_SAM_hdr(fd))) {
-            cram_free_file_def(fd->file_def);
-            goto err;
-        }
-
-    } else {
-        /* Writer */
-        cram_file_def *def = calloc(1, sizeof(*def));
-        if (!def)
-            return NULL;
-
-        fd->file_def = def;
-
-        def->magic[0] = 'C';
-        def->magic[1] = 'R';
-        def->magic[2] = 'A';
-        def->magic[3] = 'M';
-        def->major_version = 0; // Indicator to write file def later.
-        def->minor_version = 0;
-        memset(def->file_id, 0, 20);
-        strncpy(def->file_id, filename, 20);
-
-        fd->version = major_version * 256 + minor_version;
-        cram_init_tables(fd);
-
-        /* SAM header written later along with this file_def */
-    }
-
-    fd->prefix = strdup((cp = strrchr(filename, '/')) ? cp+1 : filename);
-    if (!fd->prefix)
-        goto err;
-    fd->first_base = fd->last_base = -1;
-    fd->record_counter = 0;
-
-    fd->ctr = NULL;
-    fd->ctr_mt = NULL;
-    fd->refs  = refs_create();
-    if (!fd->refs)
-        goto err;
-    fd->ref_id = -2;
-    fd->ref = NULL;
-
-    fd->decode_md = 0;
-    fd->seqs_per_slice = SEQS_PER_SLICE;
-    fd->bases_per_slice = BASES_PER_SLICE;
-    fd->slices_per_container = SLICE_PER_CNT;
-    fd->embed_ref = 0;
-    fd->no_ref = 0;
-    fd->ap_delta = 0;
-    fd->ignore_md5 = 0;
-    fd->lossy_read_names = 0;
-    fd->use_bz2 = 0;
-    fd->use_rans = (CRAM_MAJOR_VERS(fd->version) >= 3);
-    fd->use_tok = (CRAM_MAJOR_VERS(fd->version) >= 3) && (CRAM_MINOR_VERS(fd->version) >= 1);
-    fd->use_lzma = 0;
-    fd->multi_seq = -1;
-    fd->multi_seq_user = -1;
-    fd->unsorted   = 0;
-    fd->shared_ref = 0;
-    fd->store_md = 0;
-    fd->store_nm = 0;
-    fd->last_RI_count = 0;
-
-    fd->index       = NULL;
-    fd->own_pool    = 0;
-    fd->pool        = NULL;
-    fd->rqueue      = NULL;
-    fd->job_pending = NULL;
-    fd->ooc         = 0;
-    fd->required_fields = INT_MAX;
-
-    for (i = 0; i < DS_END; i++) {
-        fd->m[i] = cram_new_metrics();
-        if (!fd->m[i])
-            goto err;
-    }
-
-    if (!(fd->tags_used = kh_init(m_metrics)))
-        goto err;
-
-    fd->range.refid = -2; // no ref.
-    fd->eof = 1;          // See samtools issue #150
-    fd->ref_fn = NULL;
-
-    fd->bl = NULL;
-
-    /* Initialise dummy refs from the @SQ headers */
-    if (-1 == refs_from_header(fd))
-        goto err;
-
-    return fd;
-
- err:
-    if (fd)
-        free(fd);
-
-    return NULL;
-}
-
-/*
- * Seek within a CRAM file.
- *
- * Returns 0 on success
- *        -1 on failure
- */
-int cram_seek(cram_fd *fd, off_t offset, int whence) {
-    char buf[65536];
-
-    fd->ooc = 0;
-
-    cram_drain_rqueue(fd);
-
-    if (hseek(fd->fp, offset, whence) >= 0) {
-        return 0;
-    }
-
-    if (!(whence == SEEK_CUR && offset >= 0))
-        return -1;
-
-    /* Couldn't fseek, but we're in SEEK_CUR mode so read instead */
-    while (offset > 0) {
-        int len = MIN(65536, offset);
-        if (len != hread(fd->fp, buf, len))
-            return -1;
-        offset -= len;
-    }
-
-    return 0;
-}
-
-/*
- * Flushes a CRAM file.
- * Useful for when writing to stdout without wishing to close the stream.
- *
- * Returns 0 on success
- *        -1 on failure
- */
-int cram_flush(cram_fd *fd) {
-    if (!fd)
-        return -1;
-
-    if (fd->mode == 'w' && fd->ctr) {
-        if(fd->ctr->slice)
-            cram_update_curr_slice(fd->ctr);
-
-        if (-1 == cram_flush_container_mt(fd, fd->ctr))
-            return -1;
-    }
-
-    return 0;
-}
-
-/*
- * Writes an EOF block to a CRAM file.
- *
- * Returns 0 on success
- *        -1 on failure
- */
-int cram_write_eof_block(cram_fd *fd) {
-    // EOF block is a container with special values to aid detection
-    if (CRAM_MAJOR_VERS(fd->version) >= 2) {
-        // Empty container with
-        //   ref_seq_id -1
-        //   start pos 0x454f46 ("EOF")
-        //   span 0
-        //   nrec 0
-        //   counter 0
-        //   nbases 0
-        //   1 block (landmark 0)
-        //   (CRC32)
-        cram_container c;
-        memset(&c, 0, sizeof(c));
-        c.ref_seq_id = -1;
-        c.ref_seq_start = 0x454f46; // "EOF"
-        c.ref_seq_span = 0;
-        c.record_counter = 0;
-        c.num_bases = 0;
-        c.num_blocks = 1;
-        int32_t land[1] = {0};
-        c.landmark = land;
-
-        // An empty compression header block with
-        //   method raw (0)
-        //   type comp header (1)
-        //   content id 0
-        //   block contents size 6
-        //   raw size 6
-        //     empty preservation map (01 00)
-        //     empty data series map (01 00)
-        //     empty tag map (01 00)
-        //   block CRC
-        cram_block_compression_hdr ch;
-        memset(&ch, 0, sizeof(ch));
-        c.comp_hdr_block = cram_encode_compression_header(fd, &c, &ch);
-
-        c.length = c.comp_hdr_block->byte            // Landmark[0]
-            + 5                                      // block struct
-            + 4*(CRAM_MAJOR_VERS(fd->version) >= 3); // CRC
-        if (cram_write_container(fd, &c) < 0 ||
-            cram_write_block(fd, c.comp_hdr_block) < 0) {
-            cram_close(fd);
-            cram_free_block(c.comp_hdr_block);
-            return -1;
-        }
-        cram_free_block(c.comp_hdr_block);
-
-        // V2.1 bytes
-        // 0b 00 00 00 ff ff ff ff 0f // Cont HDR: size, ref seq id
-        // e0 45 4f 46 00 00 00       // Cont HDR: pos, span, nrec, counter
-        // 00 01 00                   // Cont HDR: nbase, nblk, landmark
-        // 00 01 00 06 06             // Comp.HDR blk
-        // 01 00 01 00 01 00          // Comp.HDR blk
-
-        // V3.0 bytes:
-        // 0f 00 00 00 ff ff ff ff 0f // Cont HDR: size, ref seq id
-        // e0 45 4f 46 00 00 00       // Cont HDR: pos, span, nrec, counter
-        // 00 01 00                   // Cont HDR: nbase, nblk, landmark
-        // 05 bd d9 4f                // CRC32
-        // 00 01 00 06 06             // Comp.HDR blk
-        // 01 00 01 00 01 00          // Comp.HDR blk
-        // ee 63 01 4b                // CRC32
-
-        // V4.0 bytes:
-        // 0f 00 00 00 8f ff ff ff    // Cont HDR: size, ref seq id
-        // 82 95 9e 46 00 00 00       // Cont HDR: pos, span, nrec, counter
-        // 00 01 00                   // Cont HDR: nbase, nblk, landmark
-        // ac d6 05 bc                // CRC32
-        // 00 01 00 06 06             // Comp.HDR blk
-        // 01 00 01 00 01 00          // Comp.HDR blk
-        // ee 63 01 4b                // CRC32
-    }
-
-    return 0;
-}
-/*
- * Closes a CRAM file.
- * Returns 0 on success
- *        -1 on failure
- */
-int cram_close(cram_fd *fd) {
-    spare_bams *bl, *next;
-    int i;
-
-    if (!fd)
-        return -1;
-
-    if (fd->mode == 'w' && fd->ctr) {
-        if(fd->ctr->slice)
-            cram_update_curr_slice(fd->ctr);
-
-        if (-1 == cram_flush_container_mt(fd, fd->ctr))
-            return -1;
-    }
-
-    if (fd->mode != 'w')
-        cram_drain_rqueue(fd);
-
-    if (fd->pool && fd->eof >= 0 && fd->rqueue) {
-        hts_tpool_process_flush(fd->rqueue);
-
-        if (0 != cram_flush_result(fd))
-            return -1;
-
-        if (fd->mode == 'w')
-            fd->ctr = NULL; // prevent double freeing
-
-        pthread_mutex_destroy(&fd->metrics_lock);
-        pthread_mutex_destroy(&fd->ref_lock);
-        pthread_mutex_destroy(&fd->bam_list_lock);
-
-        //fprintf(stderr, "CRAM: destroy queue %p\n", fd->rqueue);
-
-        hts_tpool_process_destroy(fd->rqueue);
-    }
-
-    if (fd->mode == 'w') {
-        /* Write EOF block */
-        if (0 != cram_write_eof_block(fd))
-            return -1;
-    }
-
-    for (bl = fd->bl; bl; bl = next) {
-        int i, max_rec = fd->seqs_per_slice * fd->slices_per_container;
-
-        next = bl->next;
-        for (i = 0; i < max_rec; i++) {
-            if (bl->bams[i])
-                bam_free(bl->bams[i]);
-        }
-        free(bl->bams);
-        free(bl);
-    }
-
-    if (hclose(fd->fp) != 0)
-        return -1;
-
-    if (fd->file_def)
-        cram_free_file_def(fd->file_def);
-
-    if (fd->header)
-        sam_hdr_destroy(fd->header);
-
-    free(fd->prefix);
-
-    if (fd->ctr)
-        cram_free_container(fd->ctr);
-
-    if (fd->ctr_mt && fd->ctr_mt != fd->ctr)
-        cram_free_container(fd->ctr_mt);
-
-    if (fd->refs)
-        refs_free(fd->refs);
-    if (fd->ref_free)
-        free(fd->ref_free);
-
-    for (i = 0; i < DS_END; i++)
-        if (fd->m[i])
-            free(fd->m[i]);
-
-    if (fd->tags_used) {
-        khint_t k;
-
-        for (k = kh_begin(fd->tags_used); k != kh_end(fd->tags_used); k++) {
-            if (kh_exist(fd->tags_used, k))
-                free(kh_val(fd->tags_used, k));
-        }
-
-        kh_destroy(m_metrics, fd->tags_used);
-    }
-
-    if (fd->index)
-        cram_index_free(fd);
-
-    if (fd->own_pool && fd->pool)
-        hts_tpool_destroy(fd->pool);
-
-    if (fd->idxfp)
-        if (bgzf_close(fd->idxfp) < 0)
-            return -1;
-
-    free(fd);
-    return 0;
-}
-
-/*
- * Returns 1 if we hit an EOF while reading.
- */
-int cram_eof(cram_fd *fd) {
-    return fd->eof;
-}
-
-
-/*
- * Sets options on the cram_fd. See CRAM_OPT_* definitions in cram_structs.h.
- * Use this immediately after opening.
- *
- * Returns 0 on success
- *        -1 on failure
- */
-int cram_set_option(cram_fd *fd, enum hts_fmt_option opt, ...) {
-    int r;
-    va_list args;
-
-    va_start(args, opt);
-    r = cram_set_voption(fd, opt, args);
-    va_end(args);
-
-    return r;
-}
-
-/*
- * Sets options on the cram_fd. See CRAM_OPT_* definitions in cram_structs.h.
- * Use this immediately after opening.
- *
- * Returns 0 on success
- *        -1 on failure
- */
-int cram_set_voption(cram_fd *fd, enum hts_fmt_option opt, va_list args) {
-    refs_t *refs;
-
-    if (!fd) {
-        errno = EBADF;
-        return -1;
-    }
-
-    switch (opt) {
-    case CRAM_OPT_DECODE_MD:
-        fd->decode_md = va_arg(args, int);
-        break;
-
-    case CRAM_OPT_PREFIX:
-        if (fd->prefix)
-            free(fd->prefix);
-        if (!(fd->prefix = strdup(va_arg(args, char *))))
-            return -1;
-        break;
-
-    case CRAM_OPT_VERBOSITY:
-        break;
-
-    case CRAM_OPT_SEQS_PER_SLICE:
-        fd->seqs_per_slice = va_arg(args, int);
-        if (fd->bases_per_slice == BASES_PER_SLICE)
-            fd->bases_per_slice = fd->seqs_per_slice * 500;
-        break;
-
-    case CRAM_OPT_BASES_PER_SLICE:
-        fd->bases_per_slice = va_arg(args, int);
-        break;
-
-    case CRAM_OPT_SLICES_PER_CONTAINER:
-        fd->slices_per_container = va_arg(args, int);
-        break;
-
-    case CRAM_OPT_EMBED_REF:
-        fd->embed_ref = va_arg(args, int);
-        break;
-
-    case CRAM_OPT_NO_REF:
-        fd->no_ref = va_arg(args, int);
-        break;
-
-    case CRAM_OPT_POS_DELTA:
-        fd->ap_delta = va_arg(args, int);
-        break;
-
-    case CRAM_OPT_IGNORE_MD5:
-        fd->ignore_md5 = va_arg(args, int);
-        break;
-
-    case CRAM_OPT_LOSSY_NAMES:
-        fd->lossy_read_names = va_arg(args, int);
-        // Currently lossy read names required paired (attached) reads.
-        // TLEN 0 or being 1 out causes read pairs to be detached, breaking
-        // the lossy read name compression, so we have extra options to
-        // slacken the exact TLEN round-trip checks.
-        fd->tlen_approx = fd->lossy_read_names;
-        fd->tlen_zero = fd->lossy_read_names;
-        break;
-
-    case CRAM_OPT_USE_BZIP2:
-        fd->use_bz2 = va_arg(args, int);
-        break;
-
-    case CRAM_OPT_USE_RANS:
-        fd->use_rans = va_arg(args, int);
-        break;
-
-    case CRAM_OPT_USE_TOK:
-        fd->use_tok = va_arg(args, int);
-        break;
-
-    case CRAM_OPT_USE_FQZ:
-        fd->use_fqz = va_arg(args, int);
-        break;
-
-    case CRAM_OPT_USE_ARITH:
-        fd->use_arith = va_arg(args, int);
-        break;
-
-    case CRAM_OPT_USE_LZMA:
-        fd->use_lzma = va_arg(args, int);
-        break;
-
-    case CRAM_OPT_SHARED_REF:
-        fd->shared_ref = 1;
-        refs = va_arg(args, refs_t *);
-        if (refs != fd->refs) {
-            if (fd->refs)
-                refs_free(fd->refs);
-            fd->refs = refs;
-            fd->refs->count++;
-        }
-        break;
-
-    case CRAM_OPT_RANGE: {
-        int r = cram_seek_to_refpos(fd, va_arg(args, cram_range *));
-        pthread_mutex_lock(&fd->range_lock);
-        if (fd->range.refid != -2)
-            fd->required_fields |= SAM_POS;
-        pthread_mutex_unlock(&fd->range_lock);
-        return r;
-    }
-
-    case CRAM_OPT_RANGE_NOSEEK: {
-        // As per CRAM_OPT_RANGE, but no seeking
-        pthread_mutex_lock(&fd->range_lock);
-        cram_range *r = va_arg(args, cram_range *);
-        fd->range = *r;
-        if (r->refid == HTS_IDX_NOCOOR) {
-            fd->range.refid = -1;
-            fd->range.start = 0;
-        } else if (r->refid == HTS_IDX_START || r->refid == HTS_IDX_REST) {
-            fd->range.refid = -2; // special case in cram_next_slice
-        }
-        if (fd->range.refid != -2)
-            fd->required_fields |= SAM_POS;
-        fd->ooc = 0;
-        fd->eof = 0;
-        pthread_mutex_unlock(&fd->range_lock);
-        return 0;
-    }
-
-    case CRAM_OPT_REFERENCE:
-        return cram_load_reference(fd, va_arg(args, char *));
-
-    case CRAM_OPT_VERSION: {
-        int major, minor;
-        char *s = va_arg(args, char *);
-        if (2 != sscanf(s, "%d.%d", &major, &minor)) {
-            hts_log_error("Malformed version string %s", s);
-            return -1;
-        }
-        if (!((major == 1 &&  minor == 0) ||
-              (major == 2 && (minor == 0 || minor == 1)) ||
-              (major == 3 && (minor == 0 || minor == 1)) ||
-              (major == 4 &&  minor == 0))) {
-            hts_log_error("Unknown version string; use 1.0, 2.0, 2.1, 3.0, 3.1 or 4.0");
-            errno = EINVAL;
-            return -1;
-        }
-
-        if (major > 3 || (major == 3 && minor > 0)) {
-            hts_log_warning(
-                "CRAM version %s is still a draft and subject to change.\n"
-                "This is a technology demonstration that should not be "
-                "used for archival data.", s);
-        }
-
-        fd->version = major*256 + minor;
-
-        fd->use_rans = (CRAM_MAJOR_VERS(fd->version) >= 3) ? 1 : 0;
-
-        fd->use_tok = ((CRAM_MAJOR_VERS(fd->version) == 3 &&
-                        CRAM_MINOR_VERS(fd->version) >= 1) ||
-                        CRAM_MAJOR_VERS(fd->version) >= 4) ? 1 : 0;
-        cram_init_tables(fd);
-
-        break;
-    }
-
-    case CRAM_OPT_MULTI_SEQ_PER_SLICE:
-        fd->multi_seq_user = fd->multi_seq = va_arg(args, int);
-        break;
-
-    case CRAM_OPT_NTHREADS: {
-        int nthreads =  va_arg(args, int);
-        if (nthreads >= 1) {
-            if (!(fd->pool = hts_tpool_init(nthreads)))
-                return -1;
-
-            fd->rqueue = hts_tpool_process_init(fd->pool, nthreads*2, 0);
-            pthread_mutex_init(&fd->metrics_lock, NULL);
-            pthread_mutex_init(&fd->ref_lock, NULL);
-            pthread_mutex_init(&fd->range_lock, NULL);
-            pthread_mutex_init(&fd->bam_list_lock, NULL);
-            fd->shared_ref = 1;
-            fd->own_pool = 1;
-        }
-        break;
-    }
-
-    case CRAM_OPT_THREAD_POOL: {
-        htsThreadPool *p = va_arg(args, htsThreadPool *);
-        fd->pool = p ? p->pool : NULL;
-        if (fd->pool) {
-            fd->rqueue = hts_tpool_process_init(fd->pool,
-                                                p->qsize ? p->qsize : hts_tpool_size(fd->pool)*2,
-                                                0);
-            pthread_mutex_init(&fd->metrics_lock, NULL);
-            pthread_mutex_init(&fd->ref_lock, NULL);
-            pthread_mutex_init(&fd->range_lock, NULL);
-            pthread_mutex_init(&fd->bam_list_lock, NULL);
-        }
-        fd->shared_ref = 1; // Needed to avoid clobbering ref between threads
-        fd->own_pool = 0;
-
-        //fd->qsize = 1;
-        //fd->decoded = calloc(fd->qsize, sizeof(cram_container *));
-        //hts_tpool_dispatch(fd->pool, cram_decoder_thread, fd);
-        break;
-    }
-
-    case CRAM_OPT_REQUIRED_FIELDS:
-        fd->required_fields = va_arg(args, int);
-        if (fd->range.refid != -2)
-            fd->required_fields |= SAM_POS;
-        break;
-
-    case CRAM_OPT_STORE_MD:
-        fd->store_md = va_arg(args, int);
-        break;
-
-    case CRAM_OPT_STORE_NM:
-        fd->store_nm = va_arg(args, int);
-        break;
-
-    case HTS_OPT_COMPRESSION_LEVEL:
-        fd->level = va_arg(args, int);
-        break;
-
-    case HTS_OPT_PROFILE: {
-        enum hts_profile_option prof = va_arg(args, int);
-        switch (prof) {
-        case HTS_PROFILE_FAST:
-            if (fd->level == CRAM_DEFAULT_LEVEL) fd->level = 1;
-            fd->use_tok = 0;
-            fd->seqs_per_slice = 10000;
-            break;
-
-        case HTS_PROFILE_NORMAL:
-            break;
-
-        case HTS_PROFILE_SMALL:
-            if (fd->level == CRAM_DEFAULT_LEVEL) fd->level = 6;
-            fd->use_bz2 = 1;
-            fd->use_fqz = 1;
-            fd->seqs_per_slice = 25000;
-            break;
-
-        case HTS_PROFILE_ARCHIVE:
-            if (fd->level == CRAM_DEFAULT_LEVEL) fd->level = 7;
-            fd->use_bz2 = 1;
-            fd->use_fqz = 1;
-            fd->use_arith = 1;
-            if (fd->level > 7)
-                fd->use_lzma = 1;
-            fd->seqs_per_slice = 100000;
-            break;
-        }
-
-        if (fd->bases_per_slice == BASES_PER_SLICE)
-            fd->bases_per_slice = fd->seqs_per_slice * 500;
-        break;
-    }
-
-    default:
-        hts_log_error("Unknown CRAM option code %d", opt);
-        errno = EINVAL;
-        return -1;
-    }
-
-    return 0;
-}
-
-int cram_check_EOF(cram_fd *fd)
-{
-    // Byte 9 in these templates is & with 0x0f to resolve differences
-    // between ITF-8 interpretations between early Java and C
-    // implementations of CRAM
-    static const unsigned char TEMPLATE_2_1[30] = {
-        0x0b, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0x0f, 0xe0,
-        0x45, 0x4f, 0x46, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00,
-        0x01, 0x00, 0x06, 0x06, 0x01, 0x00, 0x01, 0x00, 0x01, 0x00
-    };
-    static const unsigned char TEMPLATE_3[38] = {
-        0x0f, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0x0f, 0xe0,
-        0x45, 0x4f, 0x46, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x05,
-        0xbd, 0xd9, 0x4f, 0x00, 0x01, 0x00, 0x06, 0x06, 0x01, 0x00,
-        0x01, 0x00, 0x01, 0x00, 0xee, 0x63, 0x01, 0x4b
-    };
-
-    unsigned char buf[38]; // max(sizeof TEMPLATE_*)
-
-    uint8_t major = CRAM_MAJOR_VERS(fd->version);
-    uint8_t minor = CRAM_MINOR_VERS(fd->version);
-
-    const unsigned char *template;
-    ssize_t template_len;
-    if ((major < 2) ||
-        (major == 2 && minor == 0)) {
-        return 3; // No EOF support in cram versions less than 2.1
-    } else if (major == 2 && minor == 1) {
-        template = TEMPLATE_2_1;
-        template_len = sizeof TEMPLATE_2_1;
-    } else {
-        template = TEMPLATE_3;
-        template_len = sizeof TEMPLATE_3;
-    }
-
-    off_t offset = htell(fd->fp);
-    if (hseek(fd->fp, -template_len, SEEK_END) < 0) {
-        if (errno == ESPIPE) {
-            hclearerr(fd->fp);
-            return 2;
-        }
-        else {
-            return -1;
-        }
-    }
-    if (hread(fd->fp, buf, template_len) != template_len) return -1;
-    if (hseek(fd->fp, offset, SEEK_SET) < 0) return -1;
-    buf[8] &= 0x0f;
-    return (memcmp(template, buf, template_len) == 0)? 1 : 0;
-}
diff -ruN stringtie.orig/htslib/cram/cram_io.h stringtie/htslib/cram/cram_io.h
--- stringtie.orig/htslib/cram/cram_io.h	2024-02-28 13:57:39.701246126 +0100
+++ stringtie/htslib/cram/cram_io.h	1970-01-01 01:00:00.000000000 +0100
@@ -1,650 +0,0 @@
-/*
-Copyright (c) 2012-2020 Genome Research Ltd.
-Author: James Bonfield <jkb@sanger.ac.uk>
-
-Redistribution and use in source and binary forms, with or without
-modification, are permitted provided that the following conditions are met:
-
-   1. Redistributions of source code must retain the above copyright notice,
-this list of conditions and the following disclaimer.
-
-   2. Redistributions in binary form must reproduce the above copyright notice,
-this list of conditions and the following disclaimer in the documentation
-and/or other materials provided with the distribution.
-
-   3. Neither the names Genome Research Ltd and Wellcome Trust Sanger
-Institute nor the names of its contributors may be used to endorse or promote
-products derived from this software without specific prior written permission.
-
-THIS SOFTWARE IS PROVIDED BY GENOME RESEARCH LTD AND CONTRIBUTORS "AS IS" AND
-ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
-WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
-DISCLAIMED. IN NO EVENT SHALL GENOME RESEARCH LTD OR CONTRIBUTORS BE LIABLE
-FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
-DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
-SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
-CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
-OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
-OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-*/
-
-/*! \file
- * Include cram.h instead.
- *
- * This is an internal part of the CRAM system and is automatically included
- * when you #include cram.h.
- *
- * Implements the low level CRAM I/O primitives.
- * This includes basic data types such as byte, int, ITF-8,
- * maps, bitwise I/O, etc.
- */
-
-#ifndef CRAM_IO_H
-#define CRAM_IO_H
-
-#include <stdint.h>
-
-#include "misc.h"
-
-#ifdef __cplusplus
-extern "C" {
-#endif
-
-/**@{ ----------------------------------------------------------------------
- * ITF8 encoding and decoding.
- *
- * Also see the itf8_get and itf8_put macros.
- */
-
-/*! INTERNAL: Converts two characters into an integer for use in switch{} */
-#define CRAM_KEY(a,b) ((((unsigned char) a)<<8)|(((unsigned char) b)))
-
-/*! Reads an integer in ITF-8 encoding from 'fd' and stores it in
- * *val.
- *
- * @return
- * Returns the number of bytes read on success;
- *        -1 on failure
- */
-int itf8_decode(cram_fd *fd, int32_t *val);
-
-extern const int itf8_bytes[16];
-extern const int ltf8_bytes[256];
-
-/*! Pushes a value in ITF8 format onto the end of a block.
- *
- * This shouldn't be used for high-volume data as it is not the fastest
- * method.
- *
- * @return
- * Returns the number of bytes written
- */
-int itf8_put_blk(cram_block *blk, int32_t val);
-int ltf8_put_blk(cram_block *blk, int64_t val);
-
-/*! Pulls a literal 32-bit value from a block.
- *
- * @returns the number of bytes decoded;
- *         -1 on failure.
- */
-int int32_get_blk(cram_block *b, int32_t *val);
-
-/*! Pushes a literal 32-bit value onto the end of a block.
- *
- * @return
- * Returns 0 on success;
- *        -1 on failure.
- */
-int int32_put_blk(cram_block *blk, int32_t val);
-
-
-/**@}*/
-/**@{ ----------------------------------------------------------------------
- * CRAM blocks - the dynamically growable data block. We have code to
- * create, update, (un)compress and read/write.
- *
- * These are derived from the deflate_interlaced.c blocks, but with the
- * CRAM extension of content types and IDs.
- */
-
-/*! Allocates a new cram_block structure with a specified content_type and
- * id.
- *
- * @return
- * Returns block pointer on success;
- *         NULL on failure
- */
-cram_block *cram_new_block(enum cram_content_type content_type,
-                           int content_id);
-
-/*! Reads a block from a cram file.
- *
- * @return
- * Returns cram_block pointer on success;
- *         NULL on failure
- */
-cram_block *cram_read_block(cram_fd *fd);
-
-/*! Writes a CRAM block.
- *
- * @return
- * Returns 0 on success;
- *        -1 on failure
- */
-int cram_write_block(cram_fd *fd, cram_block *b);
-
-/*! Frees a CRAM block, deallocating internal data too.
- */
-void cram_free_block(cram_block *b);
-
-/*! Uncompress a memory block using Zlib.
- *
- * @return
- * Returns 0 on success;
- *        -1 on failure
- */
-char *zlib_mem_inflate(char *cdata, size_t csize, size_t *size);
-
-/*! Uncompresses a CRAM block, if compressed.
- *
- * @return
- * Returns 0 on success;
- *        -1 on failure
- */
-int cram_uncompress_block(cram_block *b);
-
-/*! Compresses a block.
- *
- * Compresses a block using one of two different zlib strategies. If we only
- * want one choice set strat2 to be -1.
- *
- * The logic here is that sometimes Z_RLE does a better job than Z_FILTERED
- * or Z_DEFAULT_STRATEGY on quality data. If so, we'd rather use it as it is
- * significantly faster.
- *
- * @return
- * Returns 0 on success;
- *        -1 on failure
- */
-int cram_compress_block(cram_fd *fd, cram_block *b, cram_metrics *metrics,
-                        int method, int level);
-int cram_compress_block2(cram_fd *fd, cram_slice *s,
-                         cram_block *b, cram_metrics *metrics,
-                         int method, int level);
-
-cram_metrics *cram_new_metrics(void);
-char *cram_block_method2str(enum cram_block_method_int m);
-char *cram_content_type2str(enum cram_content_type t);
-
-/*
- * Find an external block by its content_id
- */
-
-static inline cram_block *cram_get_block_by_id(cram_slice *slice, int id) {
-  //fprintf(stderr, "%d\t%p\n", id, slice->block_by_id);
-    uint32_t v = id;
-    if (slice->block_by_id && v < 256) {
-        return slice->block_by_id[v];
-    } else {
-        v = 256 + v % 251;
-        if (slice->block_by_id &&
-            slice->block_by_id[v] &&
-            slice->block_by_id[v]->content_id == id)
-            return slice->block_by_id[v];
-
-        // Otherwise a linear search in case of collision
-        int i;
-        for (i = 0; i < slice->hdr->num_blocks; i++) {
-            cram_block *b = slice->block[i];
-            if (b && b->content_type == EXTERNAL && b->content_id == id)
-                return b;
-        }
-    }
-    return NULL;
-}
-
-/* --- Accessor macros for manipulating blocks on a byte by byte basis --- */
-
-/* Block size and data pointer. */
-#define BLOCK_SIZE(b) ((b)->byte)
-#define BLOCK_DATA(b) ((b)->data)
-
-/* Returns the address one past the end of the block */
-#define BLOCK_END(b) (&(b)->data[(b)->byte])
-
-/* Make block exactly 'l' bytes long */
-static inline int block_resize_exact(cram_block *b, size_t len) {
-    unsigned char *tmp = realloc(b->data, len);
-    if (!tmp)
-        return -1;
-    b->alloc = len;
-    b->data = tmp;
-    return 0;
-}
-
-/* Request block to be at least 'l' bytes long */
-static inline int block_resize(cram_block *b, size_t len) {
-    if (b->alloc > len)
-        return 0;
-
-    size_t alloc = b->alloc;
-    while (alloc <= len)
-        alloc = alloc ? alloc*1.5 : 1024;
-
-    return block_resize_exact(b, alloc);
-}
-
-
-/* Ensure the block can hold at least another 'l' bytes */
-static inline int block_grow(cram_block *b, size_t len) {
-    return block_resize(b, BLOCK_SIZE(b) + len);
-}
-
-/* Append string 's' of length 'l'. */
-static inline int block_append(cram_block *b, const void *s, size_t len) {
-    if (block_grow(b, len) < 0)
-        return -1;
-
-    if (len) {
-        memcpy(BLOCK_END(b), s, len);
-        BLOCK_SIZE(b) += len;
-    }
-
-    return 0;
-}
-
-/* Append as single character 'c' */
-static inline int block_append_char(cram_block *b, char c) {
-    if (block_grow(b, 1) < 0)
-        return -1;
-
-    b->data[b->byte++] = c;
-    return 0;
-}
-
-/* Append a single unsigned integer */
-static inline unsigned char *append_uint32(unsigned char *cp, uint32_t i);
-static inline int block_append_uint(cram_block *b, unsigned int i) {
-    if (block_grow(b, 11) < 0)
-        return -1;
-
-    unsigned char *cp = &b->data[b->byte];
-    b->byte += append_uint32(cp, i) - cp;
-    return 0;
-}
-
-// Versions of above with built in goto block_err calls.
-#define BLOCK_RESIZE_EXACT(b,l) if (block_resize_exact((b),(l))<0) goto block_err
-#define BLOCK_RESIZE(b,l)       if (block_resize((b),(l))      <0) goto block_err
-#define BLOCK_GROW(b,l)         if (block_grow((b),(l))        <0) goto block_err
-#define BLOCK_APPEND(b,s,l)     if (block_append((b),(s),(l))  <0) goto block_err
-#define BLOCK_APPEND_CHAR(b,c)  if (block_append_char((b),(c)) <0) goto block_err
-#define BLOCK_APPEND_UINT(b,i)  if (block_append_uint((b),(i)) <0) goto block_err
-
-static inline unsigned char *append_uint32(unsigned char *cp, uint32_t i) {
-    uint32_t j;
-
-    if (i == 0) {
-        *cp++ = '0';
-        return cp;
-    }
-
-    if (i < 100)        goto b1;
-    if (i < 10000)      goto b3;
-    if (i < 1000000)    goto b5;
-    if (i < 100000000)  goto b7;
-
-    if ((j = i / 1000000000)) {*cp++ = j + '0'; i -= j*1000000000; goto x8;}
-    if ((j = i / 100000000))  {*cp++ = j + '0'; i -= j*100000000;  goto x7;}
- b7:if ((j = i / 10000000))   {*cp++ = j + '0'; i -= j*10000000;   goto x6;}
-    if ((j = i / 1000000))    {*cp++ = j + '0', i -= j*1000000;    goto x5;}
- b5:if ((j = i / 100000))     {*cp++ = j + '0', i -= j*100000;     goto x4;}
-    if ((j = i / 10000))      {*cp++ = j + '0', i -= j*10000;      goto x3;}
- b3:if ((j = i / 1000))       {*cp++ = j + '0', i -= j*1000;       goto x2;}
-    if ((j = i / 100))        {*cp++ = j + '0', i -= j*100;        goto x1;}
- b1:if ((j = i / 10))         {*cp++ = j + '0', i -= j*10;         goto x0;}
-    if (i)                     *cp++ = i + '0';
-    return cp;
-
- x8: *cp++ = i / 100000000 + '0', i %= 100000000;
- x7: *cp++ = i / 10000000  + '0', i %= 10000000;
- x6: *cp++ = i / 1000000   + '0', i %= 1000000;
- x5: *cp++ = i / 100000    + '0', i %= 100000;
- x4: *cp++ = i / 10000     + '0', i %= 10000;
- x3: *cp++ = i / 1000      + '0', i %= 1000;
- x2: *cp++ = i / 100       + '0', i %= 100;
- x1: *cp++ = i / 10        + '0', i %= 10;
- x0: *cp++ = i             + '0';
-
-    return cp;
-}
-
-static inline unsigned char *append_sub32(unsigned char *cp, uint32_t i) {
-    *cp++ = i / 100000000 + '0', i %= 100000000;
-    *cp++ = i / 10000000  + '0', i %= 10000000;
-    *cp++ = i / 1000000   + '0', i %= 1000000;
-    *cp++ = i / 100000    + '0', i %= 100000;
-    *cp++ = i / 10000     + '0', i %= 10000;
-    *cp++ = i / 1000      + '0', i %= 1000;
-    *cp++ = i / 100       + '0', i %= 100;
-    *cp++ = i / 10        + '0', i %= 10;
-    *cp++ = i             + '0';
-
-    return cp;
-}
-
-static inline unsigned char *append_uint64(unsigned char *cp, uint64_t i) {
-    uint64_t j;
-
-    if (i <= 0xffffffff)
-        return append_uint32(cp, i);
-
-    if ((j = i/1000000000) > 1000000000) {
-        cp = append_uint32(cp, j/1000000000);
-        j %= 1000000000;
-        cp = append_sub32(cp, j);
-    } else {
-        cp = append_uint32(cp, i / 1000000000);
-    }
-    cp = append_sub32(cp, i % 1000000000);
-
-    return cp;
-}
-
-#define BLOCK_UPLEN(b) \
-    (b)->comp_size = (b)->uncomp_size = BLOCK_SIZE((b))
-
-/**@}*/
-/**@{ ----------------------------------------------------------------------
- * Reference sequence handling
- */
-
-/*! Loads a reference set from fn and stores in the cram_fd.
- *
- * @return
- * Returns 0 on success;
- *        -1 on failure
- */
-int cram_load_reference(cram_fd *fd, char *fn);
-
-/*! Generates a lookup table in refs based on the SQ headers in sam_hdr_t.
- *
- * Indexes references by the order they appear in a BAM file. This may not
- * necessarily be the same order they appear in the fasta reference file.
- *
- * @return
- * Returns 0 on success;
- *        -1 on failure
- */
-int refs2id(refs_t *r, sam_hdr_t *hdr);
-
-void refs_free(refs_t *r);
-
-/*! Returns a portion of a reference sequence from start to end inclusive.
- *
- * The returned pointer is owned by the cram_file fd and should not be freed
- * by the caller. It is valid only until the next cram_get_ref is called
- * with the same fd parameter (so is thread-safe if given multiple files).
- *
- * To return the entire reference sequence, specify start as 1 and end
- * as 0.
- *
- * @return
- * Returns reference on success;
- *         NULL on failure
- */
-char *cram_get_ref(cram_fd *fd, int id, int start, int end);
-void cram_ref_incr(refs_t *r, int id);
-void cram_ref_decr(refs_t *r, int id);
-/**@}*/
-/**@{ ----------------------------------------------------------------------
- * Containers
- */
-
-/*! Creates a new container, specifying the maximum number of slices
- * and records permitted.
- *
- * @return
- * Returns cram_container ptr on success;
- *         NULL on failure
- */
-cram_container *cram_new_container(int nrec, int nslice);
-void cram_free_container(cram_container *c);
-
-/*! Reads a container header.
- *
- * @return
- * Returns cram_container on success;
- *         NULL on failure or no container left (fd->err == 0).
- */
-cram_container *cram_read_container(cram_fd *fd);
-
-/*! Writes a container structure.
- *
- * @return
- * Returns 0 on success;
- *        -1 on failure
- */
-int cram_write_container(cram_fd *fd, cram_container *h);
-
-/*! Flushes a container to disk.
- *
- * Flushes a completely or partially full container to disk, writing
- * container structure, header and blocks. This also calls the encoder
- * functions.
- *
- * @return
- * Returns 0 on success;
- *        -1 on failure
- */
-int cram_flush_container(cram_fd *fd, cram_container *c);
-int cram_flush_container_mt(cram_fd *fd, cram_container *c);
-
-
-/**@}*/
-/**@{ ----------------------------------------------------------------------
- * Compression headers; the first part of the container
- */
-
-/*! Creates a new blank container compression header
- *
- * @return
- * Returns header ptr on success;
- *         NULL on failure
- */
-cram_block_compression_hdr *cram_new_compression_header(void);
-
-/*! Frees a cram_block_compression_hdr */
-void cram_free_compression_header(cram_block_compression_hdr *hdr);
-
-
-/**@}*/
-/**@{ ----------------------------------------------------------------------
- * Slices and slice headers
- */
-
-/*! Frees a slice header */
-void cram_free_slice_header(cram_block_slice_hdr *hdr);
-
-/*! Frees a slice */
-void cram_free_slice(cram_slice *s);
-
-/*! Creates a new empty slice in memory, for subsequent writing to
- * disk.
- *
- * @return
- * Returns cram_slice ptr on success;
- *         NULL on failure
- */
-cram_slice *cram_new_slice(enum cram_content_type type, int nrecs);
-
-/*! Loads an entire slice.
- *
- * FIXME: In 1.0 the native unit of slices within CRAM is broken
- * as slices contain references to objects in other slices.
- * To work around this while keeping the slice oriented outer loop
- * we read all slices and stitch them together into a fake large
- * slice instead.
- *
- * @return
- * Returns cram_slice ptr on success;
- *         NULL on failure
- */
-cram_slice *cram_read_slice(cram_fd *fd);
-
-
-
-/**@}*/
-/**@{ ----------------------------------------------------------------------
- * CRAM file definition (header)
- */
-
-/*! Reads a CRAM file definition structure.
- *
- * @return
- * Returns file_def ptr on success;
- *         NULL on failure
- */
-cram_file_def *cram_read_file_def(cram_fd *fd);
-
-/*! Writes a cram_file_def structure to cram_fd.
- *
- * @return
- * Returns 0 on success;
- *        -1 on failure
- */
-int cram_write_file_def(cram_fd *fd, cram_file_def *def);
-
-/*! Frees a cram_file_def structure. */
-void cram_free_file_def(cram_file_def *def);
-
-
-/**@}*/
-/**@{ ----------------------------------------------------------------------
- * SAM header I/O
- */
-
-/*! Reads the SAM header from the first CRAM data block.
- *
- * Also performs minimal parsing to extract read-group
- * and sample information.
- *
- * @return
- * Returns SAM hdr ptr on success;
- *         NULL on failure
- */
-sam_hdr_t *cram_read_SAM_hdr(cram_fd *fd);
-
-/*! Writes a CRAM SAM header.
- *
- * @return
- * Returns 0 on success;
- *        -1 on failure
- */
-int cram_write_SAM_hdr(cram_fd *fd, sam_hdr_t *hdr);
-
-
-/**@}*/
-/**@{ ----------------------------------------------------------------------
- * The top-level cram opening, closing and option handling
- */
-
-/*! Opens a CRAM file for read (mode "rb") or write ("wb").
- *
- * The filename may be "-" to indicate stdin or stdout.
- *
- * @return
- * Returns file handle on success;
- *         NULL on failure.
- */
-cram_fd *cram_open(const char *filename, const char *mode);
-
-/*! Opens an existing stream for reading or writing.
- *
- * @return
- * Returns file handle on success;
- *         NULL on failure.
- */
-cram_fd *cram_dopen(struct hFILE *fp, const char *filename, const char *mode);
-
-/*! Closes a CRAM file.
- *
- * @return
- * Returns 0 on success;
- *        -1 on failure
- */
-int cram_close(cram_fd *fd);
-
-/*
- * Seek within a CRAM file.
- *
- * Returns 0 on success
- *        -1 on failure
- */
-int cram_seek(cram_fd *fd, off_t offset, int whence);
-
-/*
- * Flushes a CRAM file.
- * Useful for when writing to stdout without wishing to close the stream.
- *
- * Returns 0 on success
- *        -1 on failure
- */
-int cram_flush(cram_fd *fd);
-
-/*! Checks for end of file on a cram_fd stream.
- *
- * @return
- * Returns 0 if not at end of file
- *         1 if we hit an expected EOF (end of range or EOF block)
- *         2 for other EOF (end of stream without EOF block)
- */
-int cram_eof(cram_fd *fd);
-
-/*! Sets options on the cram_fd.
- *
- * See CRAM_OPT_* definitions in cram_structs.h.
- * Use this immediately after opening.
- *
- * @return
- * Returns 0 on success;
- *        -1 on failure
- */
-int cram_set_option(cram_fd *fd, enum hts_fmt_option opt, ...);
-
-/*! Sets options on the cram_fd.
- *
- * See CRAM_OPT_* definitions in cram_structs.h.
- * Use this immediately after opening.
- *
- * @return
- * Returns 0 on success;
- *        -1 on failure
- */
-int cram_set_voption(cram_fd *fd, enum hts_fmt_option opt, va_list args);
-
-/*!
- * Attaches a header to a cram_fd.
- *
- * This should be used when creating a new cram_fd for writing where
- * we have an sam_hdr_t already constructed (eg from a file we've read
- * in).
- *
- * @return
- * Returns 0 on success;
- *        -1 on failure
- */
-int cram_set_header2(cram_fd *fd, const sam_hdr_t *hdr);
-
-/*!
- * Returns the hFILE connected to a cram_fd.
- */
-static inline struct hFILE *cram_hfile(cram_fd *fd) {
-    return fd->fp;
-}
-
-#ifdef __cplusplus
-}
-#endif
-
-#endif /* CRAM_IO_H */
diff -ruN stringtie.orig/htslib/cram/cram_samtools.h stringtie/htslib/cram/cram_samtools.h
--- stringtie.orig/htslib/cram/cram_samtools.h	2024-02-28 13:57:39.701246126 +0100
+++ stringtie/htslib/cram/cram_samtools.h	1970-01-01 01:00:00.000000000 +0100
@@ -1,75 +0,0 @@
-/*
-Copyright (c) 2010-2013, 2018, 2020 Genome Research Ltd.
-Author: James Bonfield <jkb@sanger.ac.uk>
-
-Redistribution and use in source and binary forms, with or without
-modification, are permitted provided that the following conditions are met:
-
-   1. Redistributions of source code must retain the above copyright notice,
-this list of conditions and the following disclaimer.
-
-   2. Redistributions in binary form must reproduce the above copyright notice,
-this list of conditions and the following disclaimer in the documentation
-and/or other materials provided with the distribution.
-
-   3. Neither the names Genome Research Ltd and Wellcome Trust Sanger
-Institute nor the names of its contributors may be used to endorse or promote
-products derived from this software without specific prior written permission.
-
-THIS SOFTWARE IS PROVIDED BY GENOME RESEARCH LTD AND CONTRIBUTORS "AS IS" AND
-ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
-WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
-DISCLAIMED. IN NO EVENT SHALL GENOME RESEARCH LTD OR CONTRIBUTORS BE LIABLE
-FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
-DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
-SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
-CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
-OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
-OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-*/
-
-#ifndef CRAM_SAMTOOLS_H
-#define CRAM_SAMTOOLS_H
-
-/* Samtools compatible API */
-#define bam_blk_size(b)  ((b)->l_data)
-#define bam_set_blk_size(b,v) ((b)->data_len = (v))
-
-#define bam_ref(b)       (b)->core.tid
-#define bam_pos(b)       (b)->core.pos
-#define bam_mate_pos(b)  (b)->core.mpos
-#define bam_mate_ref(b)  (b)->core.mtid
-#define bam_ins_size(b)  (b)->core.isize
-#define bam_seq_len(b)   (b)->core.l_qseq
-#define bam_cigar_len(b) (b)->core.n_cigar
-#define bam_flag(b)      (b)->core.flag
-#define bam_bin(b)       (b)->core.bin
-#define bam_map_qual(b)  (b)->core.qual
-#define bam_name_len(b)  ((b)->core.l_qname - (b)->core.l_extranul)
-#define bam_name(b)      bam_get_qname((b))
-#define bam_qual(b)      bam_get_qual((b))
-#define bam_seq(b)       bam_get_seq((b))
-#define bam_cigar(b)     bam_get_cigar((b))
-#define bam_aux(b)       bam_get_aux((b))
-
-#define bam_free(b)      bam_destroy1((b))
-
-#define bam_reg2bin(beg,end) hts_reg2bin((beg),(end),14,5)
-
-#include "../htslib/sam.h"
-
-enum cigar_op {
-    BAM_CMATCH_=BAM_CMATCH,
-    BAM_CINS_=BAM_CINS,
-    BAM_CDEL_=BAM_CDEL,
-    BAM_CREF_SKIP_=BAM_CREF_SKIP,
-    BAM_CSOFT_CLIP_=BAM_CSOFT_CLIP,
-    BAM_CHARD_CLIP_=BAM_CHARD_CLIP,
-    BAM_CPAD_=BAM_CPAD,
-    BAM_CBASE_MATCH=BAM_CEQUAL,
-    BAM_CBASE_MISMATCH=BAM_CDIFF
-};
-
-typedef bam1_t bam_seq_t;
-
-#endif /* CRAM_SAMTOOLS_H */
diff -ruN stringtie.orig/htslib/cram/cram_stats.c stringtie/htslib/cram/cram_stats.c
--- stringtie.orig/htslib/cram/cram_stats.c	2024-02-28 13:57:39.701246126 +0100
+++ stringtie/htslib/cram/cram_stats.c	1970-01-01 01:00:00.000000000 +0100
@@ -1,226 +0,0 @@
-/*
-Copyright (c) 2012-2014, 2016, 2018, 2020 Genome Research Ltd.
-Author: James Bonfield <jkb@sanger.ac.uk>
-
-Redistribution and use in source and binary forms, with or without
-modification, are permitted provided that the following conditions are met:
-
-   1. Redistributions of source code must retain the above copyright notice,
-this list of conditions and the following disclaimer.
-
-   2. Redistributions in binary form must reproduce the above copyright notice,
-this list of conditions and the following disclaimer in the documentation
-and/or other materials provided with the distribution.
-
-   3. Neither the names Genome Research Ltd and Wellcome Trust Sanger
-Institute nor the names of its contributors may be used to endorse or promote
-products derived from this software without specific prior written permission.
-
-THIS SOFTWARE IS PROVIDED BY GENOME RESEARCH LTD AND CONTRIBUTORS "AS IS" AND
-ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
-WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
-DISCLAIMED. IN NO EVENT SHALL GENOME RESEARCH LTD OR CONTRIBUTORS BE LIABLE
-FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
-DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
-SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
-CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
-OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
-OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-*/
-
-#define HTS_BUILDING_LIBRARY // Enables HTSLIB_EXPORT, see htslib/hts_defs.h
-#include <config.h>
-
-#include <stdio.h>
-#include <errno.h>
-#include <assert.h>
-#include <stdlib.h>
-#include <string.h>
-#include <zlib.h>
-#include <sys/types.h>
-#include <sys/stat.h>
-#include <math.h>
-#include <inttypes.h>
-
-#include "cram.h"
-#include "os.h"
-
-cram_stats *cram_stats_create(void) {
-    return calloc(1, sizeof(cram_stats));
-}
-
-int cram_stats_add(cram_stats *st, int64_t val) {
-    st->nsamp++;
-
-    //assert(val >= 0);
-
-    if (val < MAX_STAT_VAL && val >= 0) {
-        st->freqs[val]++;
-    } else {
-        khint_t k;
-        int r;
-
-        if (!st->h) {
-            st->h = kh_init(m_i2i);
-            if (!st->h)
-                return -1;
-        }
-
-        k = kh_put(m_i2i, st->h, val, &r);
-        if (r == 0)
-            kh_val(st->h, k)++;
-        else if (r != -1)
-            kh_val(st->h, k) = 1;
-        else
-            return -1;
-    }
-    return 0;
-}
-
-void cram_stats_del(cram_stats *st, int64_t val) {
-    st->nsamp--;
-
-    //assert(val >= 0);
-
-    if (val < MAX_STAT_VAL && val >= 0) {
-        st->freqs[val]--;
-        assert(st->freqs[val] >= 0);
-    } else if (st->h) {
-        khint_t k = kh_get(m_i2i, st->h, val);
-
-        if (k != kh_end(st->h)) {
-            if (--kh_val(st->h, k) == 0)
-                kh_del(m_i2i, st->h, k);
-        } else {
-            hts_log_warning("Failed to remove val %"PRId64" from cram_stats", val);
-            st->nsamp++;
-        }
-    } else {
-        hts_log_warning("Failed to remove val %"PRId64" from cram_stats", val);
-        st->nsamp++;
-    }
-}
-
-#if DEBUG_CRAM_STATS
-void cram_stats_dump(cram_stats *st) {
-    int i;
-    fprintf(stderr, "cram_stats:\n");
-    for (i = 0; i < MAX_STAT_VAL; i++) {
-        if (!st->freqs[i])
-            continue;
-        fprintf(stderr, "\t%d\t%d\n", i, st->freqs[i]);
-    }
-    if (st->h) {
-        khint_t k;
-        for (k = kh_begin(st->h); k != kh_end(st->h); k++) {
-            if (!kh_exist(st->h, k))
-                continue;
-
-            fprintf(stderr, "\t%d\t%d\n", kh_key(st->h, k), kh_val(st->h, k));
-        }
-    }
-}
-#endif
-
-/*
- * Computes entropy from integer frequencies for various encoding methods and
- * picks the best encoding.
- *
- * FIXME: we could reuse some of the code here for the actual encoding
- * parameters too. Eg the best 'k' for SUBEXP or the code lengths for huffman.
- *
- * Returns the best codec to use.
- */
-enum cram_encoding cram_stats_encoding(cram_fd *fd, cram_stats *st) {
-    int nvals, i, ntot = 0, max_val = 0, min_val = INT_MAX;
-    int *vals = NULL, *freqs = NULL, vals_alloc = 0;
-
-#if DEBUG_CRAM_STATS
-    cram_stats_dump(st);
-#endif
-
-    /* Count number of unique symbols */
-    for (nvals = i = 0; i < MAX_STAT_VAL; i++) {
-        if (!st->freqs[i])
-            continue;
-        if (nvals >= vals_alloc) {
-            vals_alloc = vals_alloc ? vals_alloc*2 : 1024;
-            int *vals_tmp  = realloc(vals,  vals_alloc * sizeof(int));
-            int *freqs_tmp = realloc(freqs, vals_alloc * sizeof(int));
-            if (!vals_tmp || !freqs_tmp) {
-                free(vals_tmp  ? vals_tmp  : vals);
-                free(freqs_tmp ? freqs_tmp : freqs);
-                return E_HUFFMAN; // Cannot do much else atm
-            }
-            vals = vals_tmp;
-            freqs = freqs_tmp;
-        }
-        vals[nvals] = i;
-        freqs[nvals] = st->freqs[i];
-        ntot += freqs[nvals];
-        if (max_val < i) max_val = i;
-        if (min_val > i) min_val = i;
-        nvals++;
-    }
-    if (st->h) {
-        khint_t k;
-        int i;
-
-        for (k = kh_begin(st->h); k != kh_end(st->h); k++) {
-            if (!kh_exist(st->h, k))
-                continue;
-
-            if (nvals >= vals_alloc) {
-                vals_alloc = vals_alloc ? vals_alloc*2 : 1024;
-                int *vals_tmp  = realloc(vals,  vals_alloc * sizeof(int));
-                int *freqs_tmp = realloc(freqs, vals_alloc * sizeof(int));
-                if (!vals_tmp || !freqs_tmp) {
-                    free(vals_tmp  ? vals_tmp  : vals);
-                    free(freqs_tmp ? freqs_tmp : freqs);
-                    return E_HUFFMAN; // Cannot do much else atm
-                }
-                vals = vals_tmp;
-                freqs = freqs_tmp;
-            }
-            i = kh_key(st->h, k);
-            vals[nvals]=i;
-            freqs[nvals] = kh_val(st->h, k);
-            ntot += freqs[nvals];
-            if (max_val < i) max_val = i;
-            if (min_val > i) min_val = i;
-            nvals++;
-        }
-    }
-
-    st->nvals = nvals;
-    st->min_val = min_val;
-    st->max_val = max_val;
-    assert(ntot == st->nsamp);
-
-    free(vals);
-    free(freqs);
-
-    /*
-     * Simple policy that everything is external unless it can be
-     * encoded using zero bits as a unary item huffman table.
-     */
-    if (CRAM_MAJOR_VERS(fd->version) >= 4) {
-        // Note, we're assuming integer data here as we don't have the
-        // type passed in.  Cram_encoder_init does know the type and
-        // will convert to E_CONST_BYTE or E_EXTERNAL as appropriate.
-        if (nvals == 1)
-            return E_CONST_INT;
-        else if (nvals == 0 || min_val < 0)
-            return E_VARINT_SIGNED;
-        else
-            return E_VARINT_UNSIGNED;
-    } else {
-        return nvals <= 1 ? E_HUFFMAN : E_EXTERNAL;
-    }
-}
-
-void cram_stats_free(cram_stats *st) {
-    if (st->h)
-        kh_destroy(m_i2i, st->h);
-    free(st);
-}
diff -ruN stringtie.orig/htslib/cram/cram_stats.h stringtie/htslib/cram/cram_stats.h
--- stringtie.orig/htslib/cram/cram_stats.h	2024-02-28 13:57:39.701246126 +0100
+++ stringtie/htslib/cram/cram_stats.h	1970-01-01 01:00:00.000000000 +0100
@@ -1,59 +0,0 @@
-/*
-Copyright (c) 2012-2013, 2018 Genome Research Ltd.
-Author: James Bonfield <jkb@sanger.ac.uk>
-
-Redistribution and use in source and binary forms, with or without
-modification, are permitted provided that the following conditions are met:
-
-   1. Redistributions of source code must retain the above copyright notice,
-this list of conditions and the following disclaimer.
-
-   2. Redistributions in binary form must reproduce the above copyright notice,
-this list of conditions and the following disclaimer in the documentation
-and/or other materials provided with the distribution.
-
-   3. Neither the names Genome Research Ltd and Wellcome Trust Sanger
-Institute nor the names of its contributors may be used to endorse or promote
-products derived from this software without specific prior written permission.
-
-THIS SOFTWARE IS PROVIDED BY GENOME RESEARCH LTD AND CONTRIBUTORS "AS IS" AND
-ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
-WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
-DISCLAIMED. IN NO EVENT SHALL GENOME RESEARCH LTD OR CONTRIBUTORS BE LIABLE
-FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
-DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
-SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
-CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
-OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
-OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-*/
-
-#ifndef CRAM_STATS_H
-#define CRAM_STATS_H
-
-#ifdef __cplusplus
-extern "C" {
-#endif
-
-cram_stats *cram_stats_create(void);
-int cram_stats_add(cram_stats *st, int64_t val);
-void cram_stats_del(cram_stats *st, int64_t val);
-void cram_stats_dump(cram_stats *st);
-void cram_stats_free(cram_stats *st);
-
-/*
- * Computes entropy from integer frequencies for various encoding methods and
- * picks the best encoding.
- *
- * FIXME: we could reuse some of the code here for the actual encoding
- * parameters too. Eg the best 'k' for SUBEXP or the code lengths for huffman.
- *
- * Returns the best codec to use.
- */
-enum cram_encoding cram_stats_encoding(cram_fd *fd, cram_stats *st);
-
-#ifdef __cplusplus
-}
-#endif
-
-#endif
diff -ruN stringtie.orig/htslib/cram/cram_structs.h stringtie/htslib/cram/cram_structs.h
--- stringtie.orig/htslib/cram/cram_structs.h	2024-02-28 13:57:39.701246126 +0100
+++ stringtie/htslib/cram/cram_structs.h	1970-01-01 01:00:00.000000000 +0100
@@ -1,967 +0,0 @@
-/*
-Copyright (c) 2012-2016, 2018-2020 Genome Research Ltd.
-Author: James Bonfield <jkb@sanger.ac.uk>
-
-Redistribution and use in source and binary forms, with or without
-modification, are permitted provided that the following conditions are met:
-
-   1. Redistributions of source code must retain the above copyright notice,
-this list of conditions and the following disclaimer.
-
-   2. Redistributions in binary form must reproduce the above copyright notice,
-this list of conditions and the following disclaimer in the documentation
-and/or other materials provided with the distribution.
-
-   3. Neither the names Genome Research Ltd and Wellcome Trust Sanger
-Institute nor the names of its contributors may be used to endorse or promote
-products derived from this software without specific prior written permission.
-
-THIS SOFTWARE IS PROVIDED BY GENOME RESEARCH LTD AND CONTRIBUTORS "AS IS" AND
-ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
-WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
-DISCLAIMED. IN NO EVENT SHALL GENOME RESEARCH LTD OR CONTRIBUTORS BE LIABLE
-FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
-DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
-SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
-CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
-OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
-OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-*/
-
-#ifndef HTSLIB_CRAM_STRUCTS_H
-#define HTSLIB_CRAM_STRUCTS_H
-
-/*
- * Defines in-memory structs for the basic file-format objects in the
- * CRAM format.
- *
- * The basic file format is:
- *     File-def SAM-hdr Container Container ...
- *
- * Container:
- *     Service-block data-block data-block ...
- *
- * Multiple blocks in a container are grouped together as slices,
- * also sometimes referred to as landmarks in the spec.
- */
-
-
-#include <pthread.h>
-#include <stdint.h>
-#include <sys/types.h>
-
-#include "../htslib/thread_pool.h"
-#include "../htslib/cram.h"
-#include "string_alloc.h"
-#include "mFILE.h"
-#include "../htslib/khash.h"
-
-#ifdef __cplusplus
-extern "C" {
-#endif
-
-// Generic hash-map integer -> integer
-KHASH_MAP_INIT_INT64(m_i2i, int)
-
-// Generic hash-set integer -> (existence)
-KHASH_SET_INIT_INT(s_i2i)
-
-// For brevity
-typedef unsigned char uc;
-
-/*
- * A union for the preservation map. Required for khash.
- */
-typedef union {
-    int i;
-    char *p;
-} pmap_t;
-
-// Generates static functions here which isn't ideal, but we have no way
-// currently to declare the kh_map_t structure here without also declaring a
-// duplicate in the .c files due to the nature of the KHASH macros.
-KHASH_MAP_INIT_STR(map, pmap_t)
-
-struct hFILE;
-
-#define SEQS_PER_SLICE 10000
-#define BASES_PER_SLICE (SEQS_PER_SLICE*500)
-#define SLICE_PER_CNT  1
-
-#define CRAM_SUBST_MATRIX "CGTNAGTNACTNACGNACGT"
-
-#define MAX_STAT_VAL 1024
-//#define MAX_STAT_VAL 16
-typedef struct cram_stats {
-    int freqs[MAX_STAT_VAL];
-    khash_t(m_i2i) *h;
-    int nsamp; // total number of values added
-    int nvals; // total number of unique values added
-    int64_t min_val, max_val;
-} cram_stats;
-
-/* NB: matches java impl, not the spec */
-enum cram_encoding {
-    E_NULL               = 0,
-    E_EXTERNAL           = 1,  // Only for BYTE type in CRAM 4
-    E_GOLOMB             = 2,  // Not in CRAM 4
-    E_HUFFMAN            = 3,  // Not in CRAM 4
-    E_BYTE_ARRAY_LEN     = 4,
-    E_BYTE_ARRAY_STOP    = 5,
-    E_BETA               = 6,  // Not in CRAM 4
-    E_SUBEXP             = 7,  // Not in CRAM 4
-    E_GOLOMB_RICE        = 8,  // Not in CRAM 4
-    E_GAMMA              = 9,  // Not in CRAM 4
-
-    // CRAM 4 specific codecs
-    E_VARINT_UNSIGNED    = 41, // Specialisation of EXTERNAL
-    E_VARINT_SIGNED      = 42, // Specialisation of EXTERNAL
-    E_CONST_BYTE         = 43, // Alternative to HUFFMAN with 1 symbol
-    E_CONST_INT          = 44, // Alternative to HUFFMAN with 1 symbol
-
-    // More experimental ideas, not documented in spec yet
-    E_XHUFFMAN           = 50, // To external block
-    E_XPACK              = 51, // Transform to sub-codec
-    E_XRLE               = 52, // Transform to sub-codec
-    E_XDELTA             = 53, // Transform to sub-codec
-
-    // Total number of codecs, not a real one.
-    E_NUM_CODECS,
-};
-
-enum cram_external_type {
-    E_INT                = 1,
-    E_LONG               = 2,
-    E_BYTE               = 3,
-    E_BYTE_ARRAY         = 4,
-    E_BYTE_ARRAY_BLOCK   = 5,
-    E_SINT               = 6, // signed INT
-    E_SLONG              = 7, // signed LONG
-};
-
-/* External IDs used by this implementation (only assumed during writing) */
-enum cram_DS_ID {
-    DS_CORE   = 0,
-    DS_aux    = 1, // aux_blk
-    DS_aux_OQ = 2,
-    DS_aux_BQ = 3,
-    DS_aux_BD = 4,
-    DS_aux_BI = 5,
-    DS_aux_FZ = 6, // also ZM:B
-    DS_aux_oq = 7, // other qualities
-    DS_aux_os = 8, // other sequences
-    DS_aux_oz = 9, // other strings
-    DS_ref,
-    DS_RN, // name_blk
-    DS_QS, // qual_blk
-    DS_IN, // base_blk
-    DS_SC, // soft_blk
-
-    DS_BF, // start loop
-    DS_CF,
-    DS_AP,
-    DS_RG,
-    DS_MQ,
-    DS_NS,
-    DS_MF,
-    DS_TS,
-    DS_NP,
-    DS_NF,
-    DS_RL,
-    DS_FN,
-    DS_FC,
-    DS_FP,
-    DS_DL,
-    DS_BA,
-    DS_BS,
-    DS_TL,
-    DS_RI,
-    DS_RS,
-    DS_PD,
-    DS_HC,
-    DS_BB,
-    DS_QQ,
-
-    DS_TN, // end loop
-
-    DS_RN_len,
-    DS_SC_len,
-    DS_BB_len,
-    DS_QQ_len,
-
-    DS_TC, // CRAM v1.0 tags
-    DS_TM, // test
-    DS_TV, // test
-
-    DS_END,
-};
-
-/* "File Definition Structure" */
-struct cram_file_def {
-    char    magic[4];
-    uint8_t major_version;
-    uint8_t minor_version;
-    char    file_id[20] HTS_NONSTRING; // Filename or SHA1 checksum
-};
-
-#define CRAM_MAJOR_VERS(v) ((v) >> 8)
-#define CRAM_MINOR_VERS(v) ((v) & 0xff)
-
-struct cram_slice;
-
-// Internal version of htslib/cram.h enum.
-// Note these have to match the laout of methmap and methcost in
-// cram_io.c:cram_compress_block2
-enum cram_block_method_int {
-    // Public methods as defined in the CRAM spec.
-    BM_ERROR = -1,
-
-    // CRAM 2.x and 3.0
-    RAW      = 0,
-    GZIP     = 1,
-    BZIP2    = 2,
-    LZMA     = 3,
-    RANS     = 4, RANS0 = RANS,
-
-    // CRAM 3.1 onwards
-    RANSPR   = 5, RANS_PR0  = RANSPR,
-    ARITH    = 6, ARITH_PR0 = ARITH,
-    FQZ      = 7,
-    TOK3     = 8,
-    // BSC = 9, ZSTD = 10
-
-    // Methods not externalised, but used in metrics.
-    // Externally they become one of the above methods.
-    GZIP_RLE = 11,
-    GZIP_1,      // Z_DEFAULT_STRATEGY level 1, NB: not externalised in CRAM
-
-    FQZ_b, FQZ_c, FQZ_d, // Various preset FQZ methods
-
-  //RANS0,       // Order 0
-    RANS1,
-
-  //RANS_PR0,    // Order 0
-    RANS_PR1,    // Order 1
-    RANS_PR64,   // O0 + RLE
-    RANS_PR9,    // O1 + X4
-    RANS_PR128,  // O0 + Pack
-    RANS_PR129,  // O1 + Pack
-    RANS_PR192,  // O0 + RLE + pack
-    RANS_PR193,  // O1 + RLE + pack
-
-  //TOK3,   // tok+rans
-    TOKA,   // tok+arith
-
-  //ARITH_PR0,   // Order 0
-    ARITH_PR1,   // Order 1
-    ARITH_PR64,  // O0 + RLE
-    ARITH_PR9,   // O1 + X4
-    ARITH_PR128, // O0 + Pack
-    ARITH_PR129, // O1 + Pack
-    ARITH_PR192, // O0 + RLE + pack
-    ARITH_PR193, // O1 + RLE + pack
-
-    // NB: must end on no more than 31 unless we change to a
-    // 64-bit method type.
-};
-
-/* Now in htslib/cram.h
-enum cram_content_type {
-    CT_ERROR           = -1,
-    FILE_HEADER        = 0,
-    COMPRESSION_HEADER = 1,
-    MAPPED_SLICE       = 2,
-    UNMAPPED_SLICE     = 3, // CRAM V1.0 only
-    EXTERNAL           = 4,
-    CORE               = 5,
-};
-*/
-
-/* Maximum simultaneous codecs allowed, 1 per bit */
-#define CRAM_MAX_METHOD 32
-
-/* Compression metrics */
-struct cram_metrics {
-    // number of trials and time to next trial
-    int trial;
-    int next_trial;
-    int consistency;
-
-    // aggregate sizes during trials
-    int sz[CRAM_MAX_METHOD];
-
-    // resultant method from trials
-    int method, revised_method;
-    int strat;
-
-    // Revisions of method, to allow culling of continually failing ones.
-    int cnt[CRAM_MAX_METHOD];
-
-    double extra[CRAM_MAX_METHOD];
-
-    // Not amenable to rANS bit-packing techniques; cardinality > 16
-    int unpackable;
-};
-
-// Hash aux key (XX:i) to cram_metrics
-KHASH_MAP_INIT_INT(m_metrics, cram_metrics*)
-
-
-/* Block */
-struct cram_block {
-    enum cram_block_method_int  method, orig_method;
-    enum cram_content_type  content_type;
-    int32_t  content_id;
-    int32_t  comp_size;
-    int32_t  uncomp_size;
-    uint32_t crc32;
-    int32_t  idx; /* offset into data */
-    unsigned char    *data;
-
-    // For bit I/O
-    size_t alloc;
-    size_t byte;
-    int bit;
-
-    // To aid compression
-    cram_metrics *m; // used to track aux block compression only
-
-    int crc32_checked;
-    uint32_t crc_part;
-};
-
-struct cram_codec; /* defined in cram_codecs.h */
-struct cram_map;
-
-#define CRAM_MAP_HASH 32
-#define CRAM_MAP(a,b) (((a)*3+(b))&(CRAM_MAP_HASH-1))
-
-/* Compression header block */
-struct cram_block_compression_hdr {
-    int32_t ref_seq_id;
-    int64_t ref_seq_start;
-    int64_t ref_seq_span;
-    int32_t num_records;
-    int32_t num_landmarks;
-    int32_t *landmark;
-
-    /* Flags from preservation map */
-    int read_names_included;
-    int AP_delta;
-    // indexed by ref-base and subst. code
-    char substitution_matrix[5][4];
-    int no_ref;
-    int qs_seq_orient; // 1 => same as seq. 0 => original orientation
-
-    // TD Dictionary as a concatenated block
-    cram_block *TD_blk;          // Tag Dictionary
-    int nTL;                     // number of TL entries in TD
-    unsigned char **TL;          // array of size nTL, pointer into TD_blk.
-    khash_t(m_s2i) *TD_hash;     // Keyed on TD strings, map to TL[] indices
-    string_alloc_t *TD_keys;     // Pooled keys for TD hash.
-
-    khash_t(map) *preservation_map;
-    struct cram_map *rec_encoding_map[CRAM_MAP_HASH];
-    struct cram_map *tag_encoding_map[CRAM_MAP_HASH];
-
-    struct cram_codec *codecs[DS_END];
-
-    char *uncomp; // A single block of uncompressed data
-    size_t uncomp_size, uncomp_alloc;
-
-    // Total codec count, used for index to block_by_id for transforms
-    int ncodecs;
-};
-
-typedef struct cram_map {
-    int key;    /* 0xe0 + 3 bytes */
-    enum cram_encoding encoding;
-    int offset; /* Offset into a single block of memory */
-    int size;   /* Size */
-    struct cram_codec *codec;
-    struct cram_map *next; // for noddy internal hash
-} cram_map;
-
-typedef struct cram_tag_map {
-    struct cram_codec *codec;
-    cram_block *blk;
-    cram_block *blk2;
-    cram_metrics *m;
-} cram_tag_map;
-
-// Hash aux key (XX:i) to cram_tag_map
-KHASH_MAP_INIT_INT(m_tagmap, cram_tag_map*)
-
-/* Mapped or unmapped slice header block */
-struct cram_block_slice_hdr {
-    enum cram_content_type content_type;
-    int32_t ref_seq_id;     /* if content_type == MAPPED_SLICE */
-    int64_t ref_seq_start;  /* if content_type == MAPPED_SLICE */
-    int64_t ref_seq_span;   /* if content_type == MAPPED_SLICE */
-    int32_t num_records;
-    int64_t record_counter;
-    int32_t num_blocks;
-    int32_t num_content_ids;
-    int32_t *block_content_ids;
-    int32_t ref_base_id;    /* if content_type == MAPPED_SLICE */
-    unsigned char md5[16];
-};
-
-struct ref_entry;
-
-/*
- * Container.
- *
- * Conceptually a container is split into slices, and slices into blocks.
- * However on disk it's just a list of blocks and we need to query the
- * block types to identify the start/end points of the slices.
- *
- * OR... are landmarks the start/end points of slices?
- */
-struct cram_container {
-    int32_t  length;
-    int32_t  ref_seq_id;
-    int64_t  ref_seq_start;
-    int64_t  ref_seq_span;
-    int64_t  record_counter;
-    int64_t  num_bases;
-    int32_t  num_records;
-    int32_t  num_blocks;
-    int32_t  num_landmarks;
-    int32_t *landmark;
-
-    /* Size of container header above */
-    size_t   offset;
-
-    /* Compression header is always the first block? */
-    cram_block_compression_hdr *comp_hdr;
-    cram_block *comp_hdr_block;
-
-    /* For construction purposes */
-    int max_slice, curr_slice;   // maximum number of slices
-    int curr_slice_mt;           // Curr_slice when reading ahead (via threads)
-    int max_rec, curr_rec;       // current and max recs per slice
-    int max_c_rec, curr_c_rec;   // current and max recs per container
-    int slice_rec;               // rec no. for start of this slice
-    int curr_ref;                // current ref ID. -2 for no previous
-    int64_t last_pos;                // last record position
-    struct cram_slice **slices, *slice;
-    int pos_sorted;              // boolean, 1=>position sorted data
-    int64_t max_apos;                // maximum position, used if pos_sorted==0
-    int last_slice;              // number of reads in last slice (0 for 1st)
-    int multi_seq;               // true if packing multi seqs per cont/slice
-    int unsorted;                // true is AP_delta is 0.
-    int qs_seq_orient;           // 1 => same as seq. 0 => original orientation
-
-    /* Copied from fd before encoding, to allow multi-threading */
-    int ref_start, first_base, last_base, ref_id, ref_end;
-    char *ref;
-    //struct ref_entry *ref;
-
-    /* For multi-threading */
-    bam_seq_t **bams;
-
-    /* Statistics for encoding */
-    cram_stats *stats[DS_END];
-
-    khash_t(m_tagmap) *tags_used; // set of tag types in use, for tag encoding map
-    int *refs_used;       // array of frequency of ref seq IDs
-
-    uint32_t crc32;       // CRC32
-
-    uint64_t s_num_bases; // number of bases in this slice
-
-    uint32_t n_mapped;    // Number of mapped reads
-};
-
-/*
- * A single cram record
- */
-typedef struct cram_record {
-    struct cram_slice *s; // Filled out by cram_decode only
-
-    int32_t ref_id;       // fixed for all recs in slice?
-    int32_t flags;        // BF
-    int32_t cram_flags;   // CF
-    int32_t len;          // RL
-    int64_t apos;         // AP
-    int32_t rg;           // RG
-    int32_t name;         // RN; idx to s->names_blk
-    int32_t name_len;
-    int32_t mate_line;    // index to another cram_record
-    int32_t mate_ref_id;
-    int64_t mate_pos;     // NP
-    int64_t tlen;         // TS
-    int64_t explicit_tlen;// TS, but PNEXT/RNEXT still need auto-computing
-
-    // Auxiliary data
-    int32_t ntags;        // TC
-    int32_t aux;          // idx to s->aux_blk
-    int32_t aux_size;     // total size of packed ntags in aux_blk
-#ifndef TN_external
-    int32_t TN_idx;       // TN; idx to s->TN;
-#else
-    int32_t tn;           // idx to s->tn_blk
-#endif
-    int     TL;
-
-    int32_t seq;          // idx to s->seqs_blk
-    int32_t qual;         // idx to s->qual_blk
-    int32_t cigar;        // idx to s->cigar
-    int32_t ncigar;
-    int64_t aend;         // alignment end
-    int32_t mqual;        // MQ
-
-    int32_t feature;      // idx to s->feature
-    int32_t nfeature;     // number of features
-    int32_t mate_flags;   // MF
-} cram_record;
-
-// Accessor macros as an analogue of the bam ones
-#define cram_qname(c)    (&(c)->s->name_blk->data[(c)->name])
-#define cram_seq(c)      (&(c)->s->seqs_blk->data[(c)->seq])
-#define cram_qual(c)     (&(c)->s->qual_blk->data[(c)->qual])
-#define cram_aux(c)      (&(c)->s->aux_blk->data[(c)->aux])
-#define cram_seqi(c,i)   (cram_seq((c))[(i)])
-#define cram_name_len(c) ((c)->name_len)
-#define cram_strand(c)   (((c)->flags & BAM_FREVERSE) != 0)
-#define cram_mstrand(c)  (((c)->flags & BAM_FMREVERSE) != 0)
-#define cram_cigar(c)    (&((cr)->s->cigar)[(c)->cigar])
-
-/*
- * A feature is a base difference, used for the sequence reference encoding.
- * (We generate these internally when writing CRAM.)
- */
-typedef union cram_feature {
-    struct {
-        int pos;
-        int code;
-        int base;    // substitution code
-    } X;
-    struct {
-        int pos;
-        int code;
-        int base;    // actual base & qual
-        int qual;
-    } B;
-    struct {
-        int pos;
-        int code;
-        int seq_idx; // index to s->seqs_blk
-        int len;
-    } b;
-    struct {
-        int pos;
-        int code;
-        int qual;
-    } Q;
-    struct {
-        int pos;
-        int code;
-        int len;
-        int seq_idx; // soft-clip multiple bases
-    } S;
-    struct {
-        int pos;
-        int code;
-        int len;
-        int seq_idx; // insertion multiple bases
-    } I;
-    struct {
-        int pos;
-        int code;
-        int base; // insertion single base
-    } i;
-    struct {
-        int pos;
-        int code;
-        int len;
-    } D;
-    struct {
-        int pos;
-        int code;
-        int len;
-    } N;
-    struct {
-        int pos;
-        int code;
-        int len;
-    } P;
-    struct {
-        int pos;
-        int code;
-        int len;
-    } H;
-} cram_feature;
-
-/*
- * A slice is really just a set of blocks, but it
- * is the logical unit for decoding a number of
- * sequences.
- */
-struct cram_slice {
-    cram_block_slice_hdr *hdr;
-    cram_block *hdr_block;
-    cram_block **block;
-    cram_block **block_by_id;
-
-    /* State used during encoding/decoding */
-    int64_t last_apos, max_apos;
-
-    /* Array of decoded cram records */
-    cram_record *crecs;
-
-    /* An dynamically growing buffers for data pointed
-     * to by crecs[] array.
-     */
-    uint32_t  *cigar;
-    uint32_t   cigar_alloc;
-    uint32_t   ncigar;
-
-    cram_feature *features;
-    int           nfeatures;
-    int           afeatures; // allocated size of features
-
-#ifndef TN_external
-    // TN field (Tag Name)
-    uint32_t      *TN;
-    int           nTN, aTN;  // used and allocated size for TN[]
-#else
-    cram_block *tn_blk;
-    int tn_id;
-#endif
-
-    // For variable sized elements which are always external blocks.
-    cram_block *name_blk;
-    cram_block *seqs_blk;
-    cram_block *qual_blk;
-    cram_block *base_blk;
-    cram_block *soft_blk;
-    cram_block *aux_blk;       // BAM aux block, created while decoding CRAM
-
-    string_alloc_t *pair_keys; // Pooled keys for pair hash.
-    khash_t(m_s2i) *pair[2];   // for identifying read-pairs in this slice.
-
-    char *ref;                 // slice of current reference
-    int ref_start;             // start position of current reference;
-    int ref_end;               // end position of current reference;
-    int ref_id;
-
-    // For going from BAM to CRAM; an array of auxiliary blocks per type
-    int naux_block;
-    cram_block **aux_block;
-
-    unsigned int data_series; // See cram_fields enum
-    int decode_md;
-
-    int max_rec, curr_rec;       // current and max recs per slice
-    int slice_num;               // To be copied into c->curr_slice in decode
-};
-
-/*-----------------------------------------------------------------------------
- * Consider moving reference handling to cram_refs.[ch]
- */
-// from fa.fai / samtools faidx files
-typedef struct ref_entry {
-    char *name;
-    char *fn;
-    int64_t length;
-    int64_t offset;
-    int bases_per_line;
-    int line_length;
-    int64_t count;         // for shared references so we know to dealloc seq
-    char *seq;
-    mFILE *mf;
-    int is_md5;            // Reference comes from a raw seq found by MD5
-} ref_entry;
-
-KHASH_MAP_INIT_STR(refs, ref_entry*)
-
-// References structure.
-struct refs_t {
-    string_alloc_t *pool;  // String pool for holding filenames and SN vals
-
-    khash_t(refs) *h_meta; // ref_entry*, index by name
-    ref_entry **ref_id;    // ref_entry*, index by ID
-    int nref;              // number of ref_entry
-
-    char *fn;              // current file opened
-    BGZF *fp;              // and the hFILE* to go with it.
-
-    int count;             // how many cram_fd sharing this refs struct
-
-    pthread_mutex_t lock;  // Mutex for multi-threaded updating
-    ref_entry *last;       // Last queried sequence
-    int last_id;           // Used in cram_ref_decr_locked to delay free
-};
-
-/*-----------------------------------------------------------------------------
- * CRAM index
- *
- * Detect format by number of entries per line.
- * 5 => 1.0 (refid, start, nseq, C offset, slice)
- * 6 => 1.1 (refid, start, span, C offset, S offset, S size)
- *
- * Indices are stored in a nested containment list, which is trivial to set
- * up as the indices are on sorted data so we're appending to the nclist
- * in sorted order. Basically if a slice entirely fits within a previous
- * slice then we append to that slices list. This is done recursively.
- *
- * Lists are sorted on two dimensions: ref id + slice coords.
- */
-typedef struct cram_index {
-    int nslice, nalloc;   // total number of slices
-    struct cram_index *e; // array of size nslice
-
-    int     refid;  // 1.0                 1.1
-    int     start;  // 1.0                 1.1
-    int     end;    //                     1.1
-    int     nseq;   // 1.0 - undocumented
-    int     slice;  // 1.0 landmark index, 1.1 landmark value
-    int     len;    //                     1.1 - size of slice in bytes
-    int64_t offset; // 1.0                 1.1
-    int64_t next;   // derived: offset of next container.
-} cram_index;
-
-typedef struct {
-    int refid;
-    int64_t start;
-    int64_t end;
-} cram_range;
-
-/*-----------------------------------------------------------------------------
- */
-/* CRAM File handle */
-
-typedef struct spare_bams {
-    bam_seq_t **bams;
-    struct spare_bams *next;
-} spare_bams;
-
-struct cram_fd;
-typedef struct varint_vec {
-    // Returns number of bytes decoded from fd, 0 on error
-    int (*varint_decode32_crc)(struct cram_fd *fd, int32_t *val_p, uint32_t *crc);
-    int (*varint_decode32s_crc)(struct cram_fd *fd, int32_t *val_p, uint32_t *crc);
-    int (*varint_decode64_crc)(struct cram_fd *fd, int64_t *val_p, uint32_t *crc);
-
-    // Returns the value and increments *cp.  Sets err to 1 iff an error occurs.
-    // NOTE: Does not set err to 0 on success.
-    int64_t (*varint_get32) (char **cp, const char *endp, int *err);
-    int64_t (*varint_get32s)(char **cp, const char *endp, int *err);
-    int64_t (*varint_get64) (char **cp, const char *endp, int *err);
-    int64_t (*varint_get64s)(char **cp, const char *endp, int *err);
-
-    // Returns the number of bytes written, <= 0 on error.
-    int (*varint_put32) (char *cp, const char *endp, int32_t val_p);
-    int (*varint_put32s)(char *cp, const char *endp, int32_t val_p);
-    int (*varint_put64) (char *cp, const char *endp, int64_t val_p);
-    int (*varint_put64s)(char *cp, const char *endp, int64_t val_p);
-
-    // Returns the number of bytes written, <= 0 on error.
-    int (*varint_put32_blk) (cram_block *blk, int32_t val_p);
-    int (*varint_put32s_blk)(cram_block *blk, int32_t val_p);
-    int (*varint_put64_blk) (cram_block *blk, int64_t val_p);
-    int (*varint_put64s_blk)(cram_block *blk, int64_t val_p);
-
-    // Returns number of bytes needed to encode 'val'
-    int (*varint_size)(int64_t val);
-} varint_vec;
-
-struct cram_fd {
-    struct hFILE  *fp;
-    int            mode;     // 'r' or 'w'
-    int            version;
-    cram_file_def *file_def;
-    sam_hdr_t     *header;
-
-    char          *prefix;
-    int64_t        record_counter;
-    int            err;
-
-    // Most recent compression header decoded
-    //cram_block_compression_hdr *comp_hdr;
-    //cram_block_slice_hdr       *slice_hdr;
-
-    // Current container being processed
-    cram_container *ctr;
-
-    // Current container used for decoder threads
-    cram_container *ctr_mt;
-
-    // positions for encoding or decoding
-    int first_base, last_base;
-
-    // cached reference portion
-    refs_t *refs;              // ref meta-data structure
-    char *ref, *ref_free;      // current portion held in memory
-    int   ref_id;
-    int   ref_start;
-    int   ref_end;
-    char *ref_fn;   // reference fasta filename
-
-    // compression level and metrics
-    int level;
-    cram_metrics *m[DS_END];
-    khash_t(m_metrics) *tags_used; // cram_metrics[], per tag types in use.
-
-    // options
-    int decode_md; // Whether to export MD and NM tags
-    int seqs_per_slice;
-    int bases_per_slice;
-    int slices_per_container;
-    int embed_ref;
-    int no_ref;
-    int ignore_md5;
-    int use_bz2;
-    int use_rans;
-    int use_lzma;
-    int use_fqz;
-    int use_tok;
-    int use_arith;
-    int shared_ref;
-    unsigned int required_fields;
-    int store_md;
-    int store_nm;
-    cram_range range;
-
-    // lookup tables, stored here so we can be trivially multi-threaded
-    unsigned int bam_flag_swap[0x1000]; // cram -> bam flags
-    unsigned int cram_flag_swap[0x1000];// bam -> cram flags
-    unsigned char L1[256];              // ACGT{*} ->0123{4}
-    unsigned char L2[256];              // ACGTN{*}->01234{5}
-    char cram_sub_matrix[32][32];       // base substitution codes
-
-    int         index_sz;
-    cram_index *index;                  // array, sizeof index_sz
-    off_t first_container;
-    off_t curr_position;
-    int eof;
-    int last_slice;                     // number of recs encoded in last slice
-    int last_RI_count;                  // number of references encoded in last container
-    int multi_seq;                      // -1 is auto, 0 is one ref per container, 1 is multi...
-    int multi_seq_user;                 // Original user setting (CRAM_OPT_MULTI_SEQ_PER_SLICE)
-    int unsorted;
-    int last_mapped;                    // number of mapped reads in last container
-    int empty_container;                // Marker for EOF block
-
-    // thread pool
-    int own_pool;
-    hts_tpool *pool;
-    hts_tpool_process *rqueue;
-    pthread_mutex_t metrics_lock;
-    pthread_mutex_t ref_lock;
-    pthread_mutex_t range_lock;
-    spare_bams *bl;
-    pthread_mutex_t bam_list_lock;
-    void *job_pending;
-    int ooc;                            // out of containers.
-
-    int lossy_read_names;               // boolean
-    int tlen_approx;                    // max TLEN calculation offset.
-    int tlen_zero;                      // If true, permit tlen 0 (=> tlen calculated)
-
-    BGZF *idxfp;                        // File pointer for on-the-fly index creation
-
-    // variable integer decoding callbacks.
-    // This changed in CRAM4.0 to a data-size agnostic encoding.
-    varint_vec vv;
-
-    // Force AP delta even on non positional sorted data.
-    // This can be beneficial for pairs where pairs are nearby each other.
-    // We suffer with delta to unrelated things (previous pair), but gain
-    // in delta between them.  (Ideal would be a per read setting.)
-    int ap_delta;
-};
-
-// Translation of required fields to cram data series
-enum cram_fields {
-    CRAM_BF = 0x00000001,
-    CRAM_AP = 0x00000002,
-    CRAM_FP = 0x00000004,
-    CRAM_RL = 0x00000008,
-    CRAM_DL = 0x00000010,
-    CRAM_NF = 0x00000020,
-    CRAM_BA = 0x00000040,
-    CRAM_QS = 0x00000080,
-    CRAM_FC = 0x00000100,
-    CRAM_FN = 0x00000200,
-    CRAM_BS = 0x00000400,
-    CRAM_IN = 0x00000800,
-    CRAM_RG = 0x00001000,
-    CRAM_MQ = 0x00002000,
-    CRAM_TL = 0x00004000,
-    CRAM_RN = 0x00008000,
-    CRAM_NS = 0x00010000,
-    CRAM_NP = 0x00020000,
-    CRAM_TS = 0x00040000,
-    CRAM_MF = 0x00080000,
-    CRAM_CF = 0x00100000,
-    CRAM_RI = 0x00200000,
-    CRAM_RS = 0x00400000,
-    CRAM_PD = 0x00800000,
-    CRAM_HC = 0x01000000,
-    CRAM_SC = 0x02000000,
-    CRAM_BB = 0x04000000,
-    CRAM_BB_len = 0x08000000,
-    CRAM_QQ = 0x10000000,
-    CRAM_QQ_len = 0x20000000,
-    CRAM_aux= 0x40000000,
-    CRAM_ALL= 0x7fffffff,
-};
-
-// A CIGAR opcode, but not necessarily the implications of it. Eg FC/FP may
-// encode a base difference, but we don't need to know what it is for CIGAR.
-// If we have a soft-clip or insertion, we do need SC/IN though to know how
-// long that array is.
-#define CRAM_CIGAR (CRAM_FN | CRAM_FP | CRAM_FC | CRAM_DL | CRAM_IN | \
-                    CRAM_SC | CRAM_HC | CRAM_PD | CRAM_RS | CRAM_RL | CRAM_BF)
-
-#define CRAM_SEQ (CRAM_CIGAR | CRAM_BA | CRAM_BS | \
-                  CRAM_RL    | CRAM_AP | CRAM_BB)
-
-#define CRAM_QUAL (CRAM_CIGAR | CRAM_RL | CRAM_AP | CRAM_QS | CRAM_QQ)
-
-/* BF bitfields */
-/* Corrected in 1.1. Use bam_flag_swap[bf] and BAM_* macros for 1.0 & 1.1 */
-#define CRAM_FPAIRED      256
-#define CRAM_FPROPER_PAIR 128
-#define CRAM_FUNMAP        64
-#define CRAM_FREVERSE      32
-#define CRAM_FREAD1        16
-#define CRAM_FREAD2         8
-#define CRAM_FSECONDARY     4
-#define CRAM_FQCFAIL        2
-#define CRAM_FDUP           1
-
-#define DS_aux_S "\001"
-#define DS_aux_OQ_S "\002"
-#define DS_aux_BQ_S "\003"
-#define DS_aux_BD_S "\004"
-#define DS_aux_BI_S "\005"
-#define DS_aux_FZ_S "\006"
-#define DS_aux_oq_S "\007"
-#define DS_aux_os_S "\010"
-#define DS_aux_oz_S "\011"
-
-#define CRAM_M_REVERSE  1
-#define CRAM_M_UNMAP    2
-
-
-/* CF bitfields */
-#define CRAM_FLAG_PRESERVE_QUAL_SCORES (1<<0)
-#define CRAM_FLAG_DETACHED             (1<<1)
-#define CRAM_FLAG_MATE_DOWNSTREAM      (1<<2)
-#define CRAM_FLAG_NO_SEQ               (1<<3)
-#define CRAM_FLAG_EXPLICIT_TLEN        (1<<4)
-#define CRAM_FLAG_MASK                 ((1<<5)-1)
-
-/* Internal only */
-#define CRAM_FLAG_STATS_ADDED          (1<<30)
-#define CRAM_FLAG_DISCARD_NAME         (1U<<31)
-
-#ifdef __cplusplus
-}
-#endif
-
-#endif /* HTSLIB_CRAM_STRUCTS_H */
diff -ruN stringtie.orig/htslib/cram/mFILE.c stringtie/htslib/cram/mFILE.c
--- stringtie.orig/htslib/cram/mFILE.c	2024-02-28 13:57:39.701246126 +0100
+++ stringtie/htslib/cram/mFILE.c	1970-01-01 01:00:00.000000000 +0100
@@ -1,668 +0,0 @@
-/*
-Copyright (c) 2005-2006, 2008-2009, 2013, 2015, 2017-2019 Genome Research Ltd.
-Author: James Bonfield <jkb@sanger.ac.uk>
-
-Redistribution and use in source and binary forms, with or without
-modification, are permitted provided that the following conditions are met:
-
-   1. Redistributions of source code must retain the above copyright notice,
-this list of conditions and the following disclaimer.
-
-   2. Redistributions in binary form must reproduce the above copyright notice,
-this list of conditions and the following disclaimer in the documentation
-and/or other materials provided with the distribution.
-
-   3. Neither the names Genome Research Ltd and Wellcome Trust Sanger
-Institute nor the names of its contributors may be used to endorse or promote
-products derived from this software without specific prior written permission.
-
-THIS SOFTWARE IS PROVIDED BY GENOME RESEARCH LTD AND CONTRIBUTORS "AS IS" AND
-ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
-WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
-DISCLAIMED. IN NO EVENT SHALL GENOME RESEARCH LTD OR CONTRIBUTORS BE LIABLE
-FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
-DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
-SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
-CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
-OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
-OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-*/
-
-#define HTS_BUILDING_LIBRARY // Enables HTSLIB_EXPORT, see htslib/hts_defs.h
-#include <config.h>
-
-#include <stdio.h>
-#include <stdlib.h>
-#include <errno.h>
-#include <string.h>
-#include <sys/types.h>
-#include <sys/stat.h>
-#include <fcntl.h>
-#include <unistd.h>
-#include <stdarg.h>
-
-#include "../htslib/hts_log.h"
-#include "os.h"
-#include "mFILE.h"
-
-#ifdef HAVE_MMAP
-#include <sys/mman.h>
-#endif
-
-/*
- * This file contains memory-based versions of the most commonly used
- * (by io_lib) stdio functions.
- *
- * Actual file IO takes place either on opening or closing an mFILE.
- *
- * Coupled to this are a bunch of rather scary macros which can be obtained
- * by including stdio_hack.h. It is recommended though that you use mFILE.h
- * instead and replace fopen with mfopen (etc). This is more or less
- * mandatory if you wish to use both FILE and mFILE structs in a single file.
- */
-
-static mFILE *m_channel[3];  /* stdin, stdout and stderr fakes */
-
-/*
- * Reads the entirety of fp into memory. If 'fn' exists it is the filename
- * associated with fp. This will be used for more optimal reading (via a
- * stat to identify the size and a single read). Otherwise we use successive
- * reads until EOF.
- *
- * Returns a malloced buffer on success of length *size
- *         NULL on failure
- */
-static char *mfload(FILE *fp, const char *fn, size_t *size, int binary) {
-    struct stat sb;
-    char *data = NULL;
-    size_t allocated = 0, used = 0;
-    int bufsize = 8192;
-
-#ifdef _WIN32
-    if (binary)
-        _setmode(_fileno(fp), _O_BINARY);
-    else
-        _setmode(_fileno(fp), _O_TEXT);
-#endif
-
-    if (fn && -1 != stat(fn, &sb)) {
-        data = malloc(allocated = sb.st_size);
-        if (!data)
-            return NULL;
-        bufsize = sb.st_size;
-    } else {
-        fn = NULL;
-    }
-
-    do {
-        size_t len;
-        if (used + bufsize > allocated) {
-            allocated += bufsize;
-            char *datan = realloc(data, allocated);
-            if (datan) {
-                data = datan;
-            } else {
-                free(data);
-                return NULL;
-            }
-        }
-        len = fread(data + used, 1, allocated - used, fp);
-        if (len > 0)
-            used += len;
-    } while (!feof(fp) && (fn == NULL || used < sb.st_size));
-
-    *size = used;
-
-    return data;
-}
-
-
-#ifdef HAVE_MMAP
-/*
- * mmaps in the file, but only for reading currently.
- *
- * Returns 0 on success
- *        -1 on failure
- */
-int mfmmap(mFILE *mf, FILE *fp, const char *fn) {
-    struct stat sb;
-
-    if (stat(fn, &sb) != 0)
-        return -1;
-
-    mf->size = sb.st_size;
-    mf->data = mmap(NULL, mf->size, PROT_READ, MAP_SHARED,
-                    fileno(fp), 0);
-
-    if (!mf->data || mf->data == (void *)-1)
-        return -1;
-
-    mf->alloced = 0;
-    return 0;
-}
-#endif
-
-
-/*
- * Creates and returns m_channel[0].
- * We initialise this on the first attempted read, which then slurps in
- * all of stdin until EOF is met.
- */
-mFILE *mstdin(void) {
-    if (m_channel[0])
-        return m_channel[0];
-
-    m_channel[0] = mfcreate(NULL, 0);
-    if (NULL == m_channel[0]) return NULL;
-    m_channel[0]->fp = stdin;
-    return m_channel[0];
-}
-
-static void init_mstdin(void) {
-    static int done_stdin = 0;
-    if (done_stdin)
-        return;
-
-    m_channel[0]->data = mfload(stdin, NULL, &m_channel[0]->size, 1);
-    m_channel[0]->mode = MF_READ;
-    done_stdin = 1;
-}
-
-/*
- * Creates and returns m_channel[1]. This is the fake for stdout. It starts as
- * an empty buffer which is physically written out only when mfflush or
- * mfclose are called.
- */
-mFILE *mstdout(void) {
-    if (m_channel[1])
-        return m_channel[1];
-
-    m_channel[1] = mfcreate(NULL, 0);
-    if (NULL == m_channel[1]) return NULL;
-    m_channel[1]->fp = stdout;
-    m_channel[1]->mode = MF_WRITE;
-    return m_channel[1];
-}
-
-/*
- * Stderr as an mFILE.
- * The code handles stderr by returning m_channel[2], but also checking
- * for stderr in fprintf (the common usage of it) to auto-flush.
- */
-mFILE *mstderr(void) {
-    if (m_channel[2])
-        return m_channel[2];
-
-    m_channel[2] = mfcreate(NULL, 0);
-    if (NULL == m_channel[2]) return NULL;
-    m_channel[2]->fp = stderr;
-    m_channel[2]->mode = MF_WRITE;
-    return m_channel[2];
-}
-
-
-/*
- * For creating existing mFILE pointers directly from memory buffers.
- */
-mFILE *mfcreate(char *data, int size) {
-    mFILE *mf = (mFILE *)malloc(sizeof(*mf));
-    if (NULL == mf) return NULL;
-    mf->fp = NULL;
-    mf->data = data;
-    mf->alloced = size;
-    mf->size = size;
-    mf->eof = 0;
-    mf->offset = 0;
-    mf->flush_pos = 0;
-    mf->mode = MF_READ | MF_WRITE;
-    return mf;
-}
-
-/*
- * Recreate an existing mFILE to house new data/size.
- * It also rewinds the file.
- */
-void mfrecreate(mFILE *mf, char *data, int size) {
-    if (mf->data)
-        free(mf->data);
-    mf->data = data;
-    mf->size = size;
-    mf->alloced = size;
-    mf->eof = 0;
-    mf->offset = 0;
-    mf->flush_pos = 0;
-}
-
-
-/*
- * Creates a new mFILE to contain the contents of the FILE pointer.
- * This mFILE is purely for in-memory operations and has no links to the
- * original FILE* it came from. It also doesn't close the FILE pointer.
- * Consider using mfreopen() is you need different behaviour.
- *
- * Returns mFILE * on success
- *         NULL on failure.
- */
-mFILE *mfcreate_from(const char *path, const char *mode_str, FILE *fp) {
-    mFILE *mf;
-
-    /* Open using mfreopen() */
-    if (NULL == (mf = mfreopen(path, mode_str, fp)))
-        return NULL;
-
-    /* Disassociate from the input stream */
-    mf->fp = NULL;
-
-    return mf;
-}
-
-/*
- * Converts a FILE * to an mFILE *.
- * Use this for wrapper functions to turn external prototypes requiring
- * FILE * as an argument into internal code using mFILE *.
- */
-mFILE *mfreopen(const char *path, const char *mode_str, FILE *fp) {
-    mFILE *mf;
-    int r = 0, w = 0, a = 0, b = 0, x = 0, mode = 0;
-
-    /* Parse mode:
-     * r = read file contents (if truncated => don't read)
-     * w = write on close
-     * a = position at end of buffer
-     * x = position at same location as the original fp, don't seek on flush
-     * + = for update (read and write)
-     * m = mmap (read only)
-     */
-    if (strchr(mode_str, 'r'))
-        r = 1, mode |= MF_READ;
-    if (strchr(mode_str, 'w'))
-        w = 1, mode |= MF_WRITE | MF_TRUNC;
-    if (strchr(mode_str, 'a'))
-        w = a = 1, mode |= MF_WRITE | MF_APPEND;
-    if (strchr(mode_str, 'b'))
-        b = 1, mode |= MF_BINARY;
-    if (strchr(mode_str, 'x'))
-        x = 1;
-    if (strchr(mode_str, '+')) {
-        w = 1, mode |= MF_READ | MF_WRITE;
-        if (a)
-            r = 1;
-    }
-#ifdef HAVE_MMAP
-    if (strchr(mode_str, 'm'))
-        if (!w) mode |= MF_MMAP;
-#endif
-
-    if (r) {
-        mf = mfcreate(NULL, 0);
-        if (NULL == mf) return NULL;
-        if (!(mode & MF_TRUNC)) {
-#ifdef HAVE_MMAP
-            if (mode & MF_MMAP) {
-                if (mfmmap(mf, fp, path) == -1) {
-                    mf->data = NULL;
-                    mode &= ~MF_MMAP;
-                }
-            }
-#endif
-            if (!mf->data) {
-                mf->data = mfload(fp, path, &mf->size, b);
-                if (!mf->data) {
-                    free(mf);
-                    return NULL;
-                }
-                mf->alloced = mf->size;
-                if (!a)
-                    fseek(fp, 0, SEEK_SET);
-            }
-        }
-    } else if (w) {
-        /* Write - initialise the data structures */
-        mf = mfcreate(NULL, 0);
-        if (NULL == mf) return NULL;
-    } else {
-        hts_log_error("Must specify either r, w or a for mode");
-        return NULL;
-    }
-    mf->fp = fp;
-    mf->mode = mode;
-
-    if (x) {
-        mf->mode |= MF_MODEX;
-    }
-
-    if (a) {
-        mf->flush_pos = mf->size;
-        fseek(fp, 0, SEEK_END);
-    }
-
-    return mf;
-}
-
-/*
- * Opens a file. If we have read access (r or a+) then it loads the entire
- * file into memory. If We have write access then the pathname is stored.
- * We do not actually write until an mfclose, which then checks this pathname.
- */
-mFILE *mfopen(const char *path, const char *mode) {
-    FILE *fp;
-
-    if (NULL == (fp = fopen(path, mode)))
-        return NULL;
-    return mfreopen(path, mode, fp);
-}
-
-/*
- * Closes an mFILE. If the filename is known (implying write access) then this
- * also writes the data to disk.
- *
- * Stdout is handled by calling mfflush which writes to stdout if appropriate.
- */
-int mfclose(mFILE *mf) {
-    if (!mf)
-        return -1;
-
-    mfflush(mf);
-
-#ifdef HAVE_MMAP
-    if ((mf->mode & MF_MMAP) && mf->data) {
-        /* Mmaped */
-        munmap(mf->data, mf->size);
-        mf->data = NULL;
-    }
-#endif
-
-    if (mf->fp)
-        fclose(mf->fp);
-
-    mfdestroy(mf);
-
-    return 0;
-}
-
-/*
- * Closes the file pointer contained within the mFILE without destroying
- * the in-memory data.
- *
- * Attempting to do this on an mmaped buffer is an error.
- */
-int mfdetach(mFILE *mf) {
-    if (!mf)
-        return -1;
-
-    mfflush(mf);
-    if (mf->mode & MF_MMAP)
-        return -1;
-
-    if (mf->fp) {
-        fclose(mf->fp);
-        mf->fp = NULL;
-    }
-
-    return 0;
-}
-
-/*
- * Destroys an mFILE structure but does not flush or close it
- */
-int mfdestroy(mFILE *mf) {
-    if (!mf)
-        return -1;
-
-    if (mf->data)
-        free(mf->data);
-    free(mf);
-
-    return 0;
-}
-
-/*
- * Steals that data out of an mFILE.  The mFILE itself will be closed.
- * It is up to the caller to free the stolen buffer.  If size_out is
- * not NULL, mf->size will be stored in it.
- * This is more-or-less the opposite of mfcreate().
- *
- * Note, we cannot steal the allocated buffer from an mmaped mFILE.
- */
-
-void *mfsteal(mFILE *mf, size_t *size_out) {
-    void *data;
-
-    if (!mf) return NULL;
-
-    data = mf->data;
-
-    if (NULL != size_out) *size_out = mf->size;
-
-    if (mfdetach(mf) != 0)
-        return NULL;
-
-    mf->data = NULL;
-    mfdestroy(mf);
-
-    return data;
-}
-
-/*
- * Seek/tell functions. Nothing more than updating and reporting an
- * in-memory index. NB we can seek on stdin or stdout even provided we
- * haven't been flushing.
- */
-int mfseek(mFILE *mf, long offset, int whence) {
-    switch (whence) {
-    case SEEK_SET:
-        mf->offset = offset;
-        break;
-    case SEEK_CUR:
-        mf->offset += offset;
-        break;
-    case SEEK_END:
-        mf->offset = mf->size + offset;
-        break;
-    default:
-        errno = EINVAL;
-        return -1;
-    }
-
-    mf->eof = 0;
-    return 0;
-}
-
-long mftell(mFILE *mf) {
-    return mf->offset;
-}
-
-void mrewind(mFILE *mf) {
-    mf->offset = 0;
-    mf->eof = 0;
-}
-
-/*
- * mftruncate is not directly a translation of ftruncate as the latter
- * takes a file descriptor instead of a FILE *. It performs the analogous
- * role though.
- *
- * If offset is -1 then the file is truncated to be the current file
- * offset.
- */
-void mftruncate(mFILE *mf, long offset) {
-    mf->size = offset != -1 ? offset : mf->offset;
-    if (mf->offset > mf->size)
-        mf->offset = mf->size;
-}
-
-int mfeof(mFILE *mf) {
-    return mf->eof;
-}
-
-/*
- * mFILE read/write functions. Basically these turn fread/fwrite syntax
- * into memcpy statements, with appropriate memory handling for writing.
- */
-size_t mfread(void *ptr, size_t size, size_t nmemb, mFILE *mf) {
-    size_t len;
-    char *cptr = (char *)ptr;
-
-    if (mf == m_channel[0]) init_mstdin();
-
-    if (mf->size <= mf->offset)
-        return 0;
-
-    len = size * nmemb <= mf->size - mf->offset
-        ? size * nmemb
-        : mf->size - mf->offset;
-    if (!size)
-        return 0;
-
-    memcpy(cptr, &mf->data[mf->offset], len);
-    mf->offset += len;
-
-    if (len != size * nmemb) {
-        mf->eof = 1;
-    }
-
-    return len / size;
-}
-
-size_t mfwrite(void *ptr, size_t size, size_t nmemb, mFILE *mf) {
-    if (!(mf->mode & MF_WRITE))
-        return 0;
-
-    /* Append mode => forced all writes to end of file */
-    if (mf->mode & MF_APPEND)
-        mf->offset = mf->size;
-
-    /* Make sure we have enough room */
-    while (size * nmemb + mf->offset > mf->alloced) {
-        size_t new_alloced = mf->alloced ? mf->alloced * 2 : 1024;
-        void * new_data = realloc(mf->data, new_alloced);
-        if (NULL == new_data) return 0;
-        mf->alloced = new_alloced;
-        mf->data    = new_data;
-    }
-
-    /* Record where we need to reflush from */
-    if (mf->offset < mf->flush_pos)
-        mf->flush_pos = mf->offset;
-
-    /* Copy the data over */
-    memcpy(&mf->data[mf->offset], ptr, size * nmemb);
-    mf->offset += size * nmemb;
-    if (mf->size < mf->offset)
-        mf->size = mf->offset;
-
-    return nmemb;
-}
-
-int mfgetc(mFILE *mf) {
-    if (mf == m_channel[0]) init_mstdin();
-    if (mf->offset < mf->size) {
-        return (unsigned char)mf->data[mf->offset++];
-    }
-
-    mf->eof = 1;
-    return -1;
-}
-
-int mungetc(int c, mFILE *mf) {
-    if (mf->offset > 0) {
-        mf->data[--mf->offset] = c;
-        return c;
-    }
-
-    mf->eof = 1;
-    return -1;
-}
-
-char *mfgets(char *s, int size, mFILE *mf) {
-    int i;
-
-    if (mf == m_channel[0]) init_mstdin();
-    *s = 0;
-    for (i = 0; i < size-1;) {
-        if (mf->offset < mf->size) {
-            s[i] = mf->data[mf->offset++];
-            if (s[i++] == '\n')
-                break;
-        } else {
-            mf->eof = 1;
-            break;
-        }
-    }
-
-    s[i] = 0;
-    return i ? s : NULL;
-}
-
-/*
- * Flushes an mFILE. If this is a real open of a file in write mode then
- * mFILE->fp will be set. We then write out any new data in mFILE since the
- * last flush. We cannot tell what may have been modified as we don't keep
- * track of that, so we typically rewrite out the entire file contents between
- * the last flush_pos and the end of file.
- *
- * For stderr/stdout we also reset the offsets so we cannot modify things
- * we've already output.
- */
-int mfflush(mFILE *mf) {
-    if (!mf->fp)
-        return 0;
-
-    /* FIXME: only do this when opened in write mode */
-    if (mf == m_channel[1] || mf == m_channel[2]) {
-        if (mf->flush_pos < mf->size) {
-            size_t bytes = mf->size - mf->flush_pos;
-            if (fwrite(mf->data + mf->flush_pos, 1, bytes, mf->fp) < bytes)
-                return -1;
-            if (0 != fflush(mf->fp))
-                return -1;
-        }
-
-        /* Stdout & stderr are non-seekable streams so throw away the data */
-        mf->offset = mf->size = mf->flush_pos = 0;
-    }
-
-    /* only flush when opened in write mode */
-    if (mf->mode & MF_WRITE) {
-        if (mf->flush_pos < mf->size) {
-            size_t bytes = mf->size - mf->flush_pos;
-            if (!(mf->mode & MF_MODEX)) {
-                fseek(mf->fp, mf->flush_pos, SEEK_SET);
-            }
-            if (fwrite(mf->data + mf->flush_pos, 1, bytes, mf->fp) < bytes)
-                return -1;
-            if (0 != fflush(mf->fp))
-                return -1;
-        }
-        if (ftell(mf->fp) != -1 &&
-            ftruncate(fileno(mf->fp), ftell(mf->fp)) == -1)
-            return -1;
-        mf->flush_pos = mf->size;
-    }
-
-    return 0;
-}
-
-/*
- * Converts an mFILE from binary to ascii mode by replacing all
- * cr-nl with nl.
- *
- * Primarily used on windows when we've uncompressed a binary file which
- * happens to be a text file (eg Experiment File). Previously we would have
- * seeked back to the start and used _setmode(fileno(fp), _O_TEXT).
- *
- * Side effect: resets offset and flush_pos back to the start.
- */
-void mfascii(mFILE *mf) {
-    size_t p1, p2;
-
-    for (p1 = p2 = 1; p1 < mf->size; p1++, p2++) {
-        if (mf->data[p1] == '\n' && mf->data[p1-1] == '\r') {
-            p2--; /* delete the \r */
-        }
-        mf->data[p2] = mf->data[p1];
-    }
-    mf->size = p2;
-
-    mf->offset = mf->flush_pos = 0;
-}
diff -ruN stringtie.orig/htslib/cram/mFILE.h stringtie/htslib/cram/mFILE.h
--- stringtie.orig/htslib/cram/mFILE.h	2024-02-28 13:57:39.701246126 +0100
+++ stringtie/htslib/cram/mFILE.h	1970-01-01 01:00:00.000000000 +0100
@@ -1,93 +0,0 @@
-/*
-Copyright (c) 2005-2006, 2008-2009, 2013, 2018 Genome Research Ltd.
-Author: James Bonfield <jkb@sanger.ac.uk>
-
-Redistribution and use in source and binary forms, with or without
-modification, are permitted provided that the following conditions are met:
-
-   1. Redistributions of source code must retain the above copyright notice,
-this list of conditions and the following disclaimer.
-
-   2. Redistributions in binary form must reproduce the above copyright notice,
-this list of conditions and the following disclaimer in the documentation
-and/or other materials provided with the distribution.
-
-   3. Neither the names Genome Research Ltd and Wellcome Trust Sanger
-Institute nor the names of its contributors may be used to endorse or promote
-products derived from this software without specific prior written permission.
-
-THIS SOFTWARE IS PROVIDED BY GENOME RESEARCH LTD AND CONTRIBUTORS "AS IS" AND
-ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
-WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
-DISCLAIMED. IN NO EVENT SHALL GENOME RESEARCH LTD OR CONTRIBUTORS BE LIABLE
-FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
-DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
-SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
-CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
-OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
-OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-*/
-
-#ifndef CRAM_MFILE_H
-#define CRAM_MFILE_H
-
-#include <stdio.h>
-
-#ifdef __cplusplus
-extern "C" {
-#endif
-
-typedef struct {
-    FILE *fp;
-    char *data;
-    size_t alloced;
-    int eof;
-    int mode; /* open mode in MF_?? define bit pattern */
-    size_t size;
-    size_t offset;
-    size_t flush_pos;
-} mFILE;
-
-// Work around a clash with winuser.h
-#ifdef MF_APPEND
-#  undef MF_APPEND
-#endif
-
-#define MF_READ    1
-#define MF_WRITE   2
-#define MF_APPEND  4
-#define MF_BINARY  8
-#define MF_TRUNC  16
-#define MF_MODEX  32
-#define MF_MMAP   64
-
-mFILE *mfreopen(const char *path, const char *mode, FILE *fp);
-mFILE *mfopen(const char *path, const char *mode);
-int mfdetach(mFILE *mf);
-int mfclose(mFILE *mf);
-int mfdestroy(mFILE *mf);
-int mfseek(mFILE *mf, long offset, int whence);
-long mftell(mFILE *mf);
-void mrewind(mFILE *mf);
-void mftruncate(mFILE *mf, long offset);
-int mfeof(mFILE *mf);
-size_t mfread(void *ptr, size_t size, size_t nmemb, mFILE *mf);
-size_t mfwrite(void *ptr, size_t size, size_t nmemb, mFILE *mf);
-int mfgetc(mFILE *mf);
-int mungetc(int c, mFILE *mf);
-mFILE *mfcreate(char *data, int size);
-mFILE *mfcreate_from(const char *path, const char *mode_str, FILE *fp);
-void mfrecreate(mFILE *mf, char *data, int size);
-void *mfsteal(mFILE *mf, size_t *size_out);
-char *mfgets(char *s, int size, mFILE *mf);
-int mfflush(mFILE *mf);
-mFILE *mstdin(void);
-mFILE *mstdout(void);
-mFILE *mstderr(void);
-void mfascii(mFILE *mf);
-
-#ifdef __cplusplus
-}
-#endif
-
-#endif /* CRAM_MFILE_H */
diff -ruN stringtie.orig/htslib/cram/misc.h stringtie/htslib/cram/misc.h
--- stringtie.orig/htslib/cram/misc.h	2024-02-28 13:57:39.701246126 +0100
+++ stringtie/htslib/cram/misc.h	1970-01-01 01:00:00.000000000 +0100
@@ -1,77 +0,0 @@
-/*
-Copyright (c) 1994-1997, 2001-2002 MEDICAL RESEARCH COUNCIL
-All rights reserved
-
-Redistribution and use in source and binary forms, with or without
-modification, are permitted provided that the following conditions are met:
-
-   1 Redistributions of source code must retain the above copyright notice,
-this list of conditions and the following disclaimer.
-
-   2 Redistributions in binary form must reproduce the above copyright notice,
-this list of conditions and the following disclaimer in the documentation
-and/or other materials provided with the distribution.
-
-   3 Neither the name of the MEDICAL RESEARCH COUNCIL, THE LABORATORY OF
-MOLECULAR BIOLOGY nor the names of its contributors may be used to endorse or
-promote products derived from this software without specific prior written
-permission.
-
-THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
-ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
-WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
-DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
-ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
-(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
-LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
-ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
-(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
-SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- */
-
-/*
-Copyright (c) 2003-2013, 2018-2019 Genome Research Ltd.
-
-Author: James Bonfield <jkb@sanger.ac.uk>
-
-Redistribution and use in source and binary forms, with or without
-modification, are permitted provided that the following conditions are met:
-
-   1. Redistributions of source code must retain the above copyright notice,
-this list of conditions and the following disclaimer.
-
-   2. Redistributions in binary form must reproduce the above copyright notice,
-this list of conditions and the following disclaimer in the documentation
-and/or other materials provided with the distribution.
-
-   3. Neither the names Genome Research Ltd and Wellcome Trust Sanger
-Institute nor the names of its contributors may be used to endorse or promote
-products derived from this software without specific prior written permission.
-
-THIS SOFTWARE IS PROVIDED BY GENOME RESEARCH LTD AND CONTRIBUTORS "AS IS" AND
-ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
-WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
-DISCLAIMED. IN NO EVENT SHALL GENOME RESEARCH LTD OR CONTRIBUTORS BE LIABLE
-FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
-DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
-SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
-CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
-OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
-OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-*/
-
-#ifndef CRAM_MISC_H
-#define CRAM_MISC_H
-
-#ifdef __cplusplus
-extern "C" {
-#endif
-
-#define MIN(A,B) ( ( (A) < (B) ) ? (A) : (B) )
-#define MAX(A,B) ( ( (A) > (B) ) ? (A) : (B) )
-
-#ifdef __cplusplus
-}
-#endif
-
-#endif /* CRAM_MISC_H */
diff -ruN stringtie.orig/htslib/cram/open_trace_file.c stringtie/htslib/cram/open_trace_file.c
--- stringtie.orig/htslib/cram/open_trace_file.c	2024-02-28 13:57:39.701246126 +0100
+++ stringtie/htslib/cram/open_trace_file.c	1970-01-01 01:00:00.000000000 +0100
@@ -1,438 +0,0 @@
-/*
-Author: James Bonfield
-
-Copyright (c) 2000-2001 MEDICAL RESEARCH COUNCIL
-All rights reserved
-
-Redistribution and use in source and binary forms, with or without
-modification, are permitted provided that the following conditions are met:
-
-   1. Redistributions of source code must retain the above copyright notice,
-this list of conditions and the following disclaimer.
-
-   2. Redistributions in binary form must reproduce the above copyright notice,
-this list of conditions and the following disclaimer in the documentation
-and/or other materials provided with the distribution.
-
-   3. Neither the name of the MEDICAL RESEARCH COUNCIL, THE LABORATORY OF
-MOLECULAR BIOLOGY nor the names of its contributors may be used to endorse or
-promote products derived from this software without specific prior written
-permission.
-
-THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
-ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
-WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
-DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
-ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
-(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
-LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
-ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
-(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
-SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-*/
-
-/*
-Copyright (c) 2008, 2009, 2013, 2014-2015, 2018-2020 Genome Research Ltd.
-Author: James Bonfield <jkb@sanger.ac.uk>
-
-Redistribution and use in source and binary forms, with or without
-modification, are permitted provided that the following conditions are met:
-
-   1. Redistributions of source code must retain the above copyright notice,
-this list of conditions and the following disclaimer.
-
-   2. Redistributions in binary form must reproduce the above copyright notice,
-this list of conditions and the following disclaimer in the documentation
-and/or other materials provided with the distribution.
-
-   3. Neither the names Genome Research Ltd and Wellcome Trust Sanger
-Institute nor the names of its contributors may be used to endorse or promote
-products derived from this software without specific prior written permission.
-
-THIS SOFTWARE IS PROVIDED BY GENOME RESEARCH LTD AND CONTRIBUTORS "AS IS" AND
-ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
-WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
-DISCLAIMED. IN NO EVENT SHALL GENOME RESEARCH LTD OR CONTRIBUTORS BE LIABLE
-FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
-DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
-SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
-CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
-OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
-OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-*/
-
-#define HTS_BUILDING_LIBRARY // Enables HTSLIB_EXPORT, see htslib/hts_defs.h
-#include <config.h>
-
-#include <stdlib.h>
-#include <stdio.h>
-#include <string.h>
-#include <unistd.h>
-#include <limits.h>
-#include <errno.h>
-#include <sys/types.h>
-#include <sys/stat.h>
-
-#include "os.h"
-#ifndef PATH_MAX
-#  define PATH_MAX 1024
-#endif
-
-#include "open_trace_file.h"
-#include "misc.h"
-#include "../htslib/hfile.h"
-#include "../htslib/hts_log.h"
-#include "../htslib/hts.h"
-
-/*
- * Returns whether the path refers to a regular file.
- */
-static int is_file(char *fn) {
-    struct stat buf;
-    if ( stat(fn,&buf) ) return 0;
-    return S_ISREG(buf.st_mode);
-}
-
-/*
- * Tokenises the search path splitting on colons (unix) or semicolons
- * (windows).
- * We also  explicitly add a "./" to the end of the search path
- *
- * Returns: A new search path with items separated by nul chars. Two nul
- *          chars in a row represent the end of the tokenised path.
- * Returns NULL for a failure.
- *
- * The returned data has been malloced. It is up to the caller to free this
- * memory.
- */
-char *tokenise_search_path(const char *searchpath) {
-    char *newsearch;
-    unsigned int i, j;
-    size_t len;
-    char path_sep = HTS_PATH_SEPARATOR_CHAR;
-
-    if (!searchpath)
-        searchpath="";
-
-    newsearch = (char *)malloc((len = strlen(searchpath))+5);
-    if (!newsearch)
-        return NULL;
-
-    for (i = 0, j = 0; i < len; i++) {
-        /* "::" => ":". Used for escaping colons in http://foo */
-        if (i < len-1 && searchpath[i] == ':' && searchpath[i+1] == ':') {
-            newsearch[j++] = ':';
-            i++;
-            continue;
-        }
-
-        /* Handle http:// and ftp:// too without :: */
-        if (path_sep == ':') {
-            if ((i == 0 || (i > 0 && searchpath[i-1] == ':')) &&
-                (!strncmp(&searchpath[i], "http:",     5) ||
-                 !strncmp(&searchpath[i], "https:",    6) ||
-                 !strncmp(&searchpath[i], "ftp:",      4) ||
-                 !strncmp(&searchpath[i], "|http:",    6) ||
-                 !strncmp(&searchpath[i], "|https:",   7) ||
-                 !strncmp(&searchpath[i], "|ftp:",     5) ||
-                 !strncmp(&searchpath[i], "URL=http:", 9) ||
-                 !strncmp(&searchpath[i], "URL=https:",10)||
-                 !strncmp(&searchpath[i], "URL=ftp:",  8))) {
-                do {
-                    newsearch[j++] = searchpath[i];
-                } while (i<len && searchpath[i++] != ':');
-                if (searchpath[i] == ':')
-                    i++;
-                if (searchpath[i]=='/')
-                    newsearch[j++] = searchpath[i++];
-                if (searchpath[i]=='/')
-                    newsearch[j++] = searchpath[i++];
-                // Look for host:port
-                do {
-                    newsearch[j++] = searchpath[i++];
-                } while (i<len && searchpath[i] != ':' && searchpath[i] != '/');
-                newsearch[j++] = searchpath[i++];
-                if (searchpath[i] == ':')
-                    i++;
-            }
-        }
-
-        if (searchpath[i] == path_sep) {
-            /* Skip blank path components */
-            if (j && newsearch[j-1] != 0)
-                newsearch[j++] = 0;
-        } else {
-            newsearch[j++] = searchpath[i];
-        }
-    }
-
-    if (j)
-        newsearch[j++] = 0;
-    newsearch[j++] = '.';
-    newsearch[j++] = '/';
-    newsearch[j++] = 0;
-    newsearch[j++] = 0;
-
-    return newsearch;
-}
-
-static char *expand_path(const char *file, char *dirname, int max_s_digits);
-
-mFILE *find_file_url(const char *file, char *url) {
-    char *path = NULL, buf[8192];
-    mFILE *mf = NULL;
-    ssize_t len;
-    hFILE *hf = NULL;
-
-    /* Expand %s for the trace name.  Only one digit is allowed between
-       The % and s to avoid ambiguity with percent-encoded URLs */
-
-    path = expand_path(file, url, 1);
-    if (!path)
-        return NULL;
-
-    if (!(hf = hopen(path, "r"))) {
-        if (errno != ENOENT)
-            hts_log_warning("Failed to open reference \"%s\": %s", path, strerror(errno));
-        goto fail;
-    }
-
-    if (NULL == (mf = mfcreate(NULL, 0)))
-        goto fail;
-    while ((len = hread(hf, buf, sizeof(buf))) > 0) {
-        if (mfwrite(buf, len, 1, mf) <= 0) {
-            hclose_abruptly(hf);
-            goto fail;
-        }
-    }
-    if (hclose(hf) < 0 || len < 0) {
-        hts_log_warning("Failed to read reference \"%s\": %s", path, strerror(errno));
-        goto fail;
-    }
-
-    free(path);
-    mrewind(mf);
-    return mf;
-
- fail:
-    mfdestroy(mf);
-    free(path);
-    return NULL;
-}
-
-/*
- * Takes a dirname possibly including % rules and appends the filename
- * to it.
- *
- * Returns expanded pathname or NULL for malloc failure.
- */
-static char *expand_path(const char *file, char *dirname, int max_s_digits) {
-    size_t len = strlen(dirname);
-    size_t lenf = strlen(file);
-    char *cp, *path;
-
-    path = malloc(len+lenf+2); // worst expansion DIR/FILE
-    if (!path) {
-        hts_log_error("Out of memory");
-        return NULL;
-    }
-
-    if (dirname[len-1] == '/')
-        len--;
-
-    /* Special case for "./" or absolute filenames */
-    if (*file == '/' || (len==1 && *dirname == '.')) {
-        sprintf(path, "%s", file);
-    } else {
-        /* Handle %[0-9]*s expansions, if required */
-        char *path_end = path;
-        *path = 0;
-        while ((cp = strchr(dirname, '%'))) {
-            char *endp;
-            long l = strtol(cp+1, &endp, 10);
-            if (*endp != 's' || endp - cp - 1 > max_s_digits) {
-                strncpy(path_end, dirname, (endp+1)-dirname);
-                path_end += (endp+1)-dirname;
-                dirname = endp+1;
-                continue;
-            }
-
-            strncpy(path_end, dirname, cp-dirname);
-            path_end += cp-dirname;
-            if (l) {
-                strncpy(path_end, file, l);
-                path_end += MIN(strlen(file), l);
-                file     += MIN(strlen(file), l);
-            } else {
-                strcpy(path_end, file);
-                path_end += strlen(file);
-                file     += strlen(file);
-            }
-            len -= (endp+1) - dirname;
-            dirname = endp+1;
-        }
-        strncpy(path_end, dirname, len);
-        path_end += MIN(strlen(dirname), len);
-        *path_end = 0;
-        if (*file) {
-            *path_end++ = '/';
-            strcpy(path_end, file);
-        }
-    }
-
-    //fprintf(stderr, "*PATH=\"%s\"\n", path);
-    return path;
-}
-
-/*
- * Searches for file in the directory 'dirname'. If it finds it, it opens
- * it. This also searches for compressed versions of the file in dirname
- * too.
- *
- * Returns mFILE pointer if found
- *         NULL if not
- */
-static mFILE *find_file_dir(const char *file, char *dirname) {
-    char *path;
-    mFILE *mf = NULL;
-
-    path = expand_path(file, dirname, INT_MAX);
-    if (!path)
-        return NULL;
-
-    if (is_file(path))
-        mf = mfopen(path, "rbm");
-
-    free(path);
-    return mf;
-}
-
-/*
- * ------------------------------------------------------------------------
- * Public functions below.
- */
-
-/*
- * Opens a trace file named 'file'. This is initially looked for as a
- * pathname relative to a file named "relative_to". This may (for
- * example) be the name of an experiment file referencing the trace
- * file. In this case by passing relative_to as the experiment file
- * filename the trace file will be picked up in the same directory as
- * the experiment file. Relative_to may be supplied as NULL.
- *
- * 'file' is looked for at relative_to, then the current directory, and then
- * all of the locations listed in 'path' (which is a colon separated list).
- * If 'path' is NULL it uses the RAWDATA environment variable instead.
- *
- * Returns a mFILE pointer when found.
- *           NULL otherwise.
- */
-mFILE *open_path_mfile(const char *file, char *path, char *relative_to) {
-    char *newsearch;
-    char *ele;
-    mFILE *fp;
-
-    /* Use path first */
-    if (!path)
-        path = getenv("RAWDATA");
-    if (NULL == (newsearch = tokenise_search_path(path)))
-        return NULL;
-
-    /*
-     * Step through the search path testing out each component.
-     * We now look through each path element treating some prefixes as
-     * special, otherwise we treat the element as a directory.
-     */
-    for (ele = newsearch; *ele; ele += strlen(ele)+1) {
-        char *ele2;
-
-        /*
-         * '|' prefixing a path component indicates that we do not
-         * wish to perform the compression extension searching in that
-         * location.
-         *
-         * NB: this has been removed from the htslib implementation.
-         */
-        if (*ele == '|') {
-            ele2 = ele+1;
-        } else {
-            ele2 = ele;
-        }
-
-        if (0 == strncmp(ele2, "URL=", 4)) {
-            if ((fp = find_file_url(file, ele2+4))) {
-                free(newsearch);
-                return fp;
-            }
-        } else if (!strncmp(ele2, "http:", 5) ||
-                   !strncmp(ele2, "https:", 6) ||
-                   !strncmp(ele2, "ftp:", 4)) {
-            if ((fp = find_file_url(file, ele2))) {
-                free(newsearch);
-                return fp;
-            }
-        } else if ((fp = find_file_dir(file, ele2))) {
-            free(newsearch);
-            return fp;
-        }
-    }
-
-    free(newsearch);
-
-    /* Look in the same location as the incoming 'relative_to' filename */
-    if (relative_to) {
-        char *cp;
-        char relative_path[PATH_MAX+1];
-        strcpy(relative_path, relative_to);
-        if ((cp = strrchr(relative_path, '/')))
-            *cp = 0;
-        if ((fp = find_file_dir(file, relative_path)))
-            return fp;
-    }
-
-    return NULL;
-}
-
-
-/*
- * As per open_path_mfile, but searching only for local filenames.
- * This is useful as we may avoid doing a full mfopen and loading
- * the entire file into memory.
- *
- * Returns the expanded pathname if found.
- *         NULL if not
- */
-char *find_path(const char *file, const char *path) {
-    char *newsearch;
-    char *ele;
-    char *outpath = NULL;
-
-    /* Use path first */
-    if (!path)
-        path = getenv("RAWDATA");
-    if (NULL == (newsearch = tokenise_search_path(path)))
-        return NULL;
-
-    for (ele = newsearch; *ele; ele += strlen(ele)+1) {
-        char *ele2 = (*ele == '|') ? ele+1 : ele;
-
-        if (!strncmp(ele2, "URL=", 4) ||
-            !strncmp(ele2, "http:", 5) ||
-            !strncmp(ele2, "https:", 6) ||
-            !strncmp(ele2, "ftp:", 4)) {
-            continue;
-        } else {
-            outpath = expand_path(file, ele2, INT_MAX);
-            if (is_file(outpath)) {
-                free(newsearch);
-                return outpath;
-            } else {
-                free(outpath);
-            }
-        }
-    }
-
-    free(newsearch);
-
-    return NULL;
-}
diff -ruN stringtie.orig/htslib/cram/open_trace_file.h stringtie/htslib/cram/open_trace_file.h
--- stringtie.orig/htslib/cram/open_trace_file.h	2024-02-28 13:57:39.701246126 +0100
+++ stringtie/htslib/cram/open_trace_file.h	1970-01-01 01:00:00.000000000 +0100
@@ -1,125 +0,0 @@
-/*
-Author: James Bonfield
-
-Copyright (c) 2000-2001 MEDICAL RESEARCH COUNCIL
-All rights reserved
-
-Redistribution and use in source and binary forms, with or without
-modification, are permitted provided that the following conditions are met:
-
-   . Redistributions of source code must retain the above copyright notice,
-this list of conditions and the following disclaimer.
-
-   . Redistributions in binary form must reproduce the above copyright notice,
-this list of conditions and the following disclaimer in the documentation
-and/or other materials provided with the distribution.
-
-   . Neither the name of the MEDICAL RESEARCH COUNCIL, THE LABORATORY OF
-MOLECULAR BIOLOGY nor the names of its contributors may be used to endorse or
-promote products derived from this software without specific prior written
-permission.
-
-THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
-ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
-WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
-DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
-ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
-(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
-LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
-ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
-(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
-SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-*/
-
-/*
-Copyright (c) 2008, 2009, 2013, 2018 Genome Research Ltd.
-Author: James Bonfield <jkb@sanger.ac.uk>
-
-Redistribution and use in source and binary forms, with or without
-modification, are permitted provided that the following conditions are met:
-
-   1. Redistributions of source code must retain the above copyright notice,
-this list of conditions and the following disclaimer.
-
-   2. Redistributions in binary form must reproduce the above copyright notice,
-this list of conditions and the following disclaimer in the documentation
-and/or other materials provided with the distribution.
-
-   3. Neither the names Genome Research Ltd and Wellcome Trust Sanger
-Institute nor the names of its contributors may be used to endorse or promote
-products derived from this software without specific prior written permission.
-
-THIS SOFTWARE IS PROVIDED BY GENOME RESEARCH LTD AND CONTRIBUTORS "AS IS" AND
-ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
-WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
-DISCLAIMED. IN NO EVENT SHALL GENOME RESEARCH LTD OR CONTRIBUTORS BE LIABLE
-FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
-DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
-SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
-CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
-OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
-OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-*/
-
-#ifndef OPEN_TRACE_FILE_H
-#define OPEN_TRACE_FILE_H
-
-#include "mFILE.h"
-
-#ifdef __cplusplus
-extern "C" {
-#endif
-
-/*
- * Tokenises the search path splitting on colons (unix) or semicolons
- * (windows).
- * We also  explicitly add a "./" to the end of the search path
- *
- * Returns: A new search path with items separated by nul chars. Two nul
- *          chars in a row represent the end of the tokenised path.
- * Returns NULL for a failure.
- *
- * The returned data has been malloced. It is up to the caller to free this
- * memory.
- */
-char *tokenise_search_path(const char *searchpath);
-
-/*
- * Opens a trace file named 'file'. This is initially looked for as a
- * pathname relative to a file named "relative_to". This may (for
- * example) be the name of an experiment file referencing the trace
- * file. In this case by passing relative_to as the experiment file
- * filename the trace file will be picked up in the same directory as
- * the experiment file. Relative_to may be supplied as NULL.
- *
- * 'file' is looked for at relative_to, then the current directory, and then
- * all of the locations listed in 'path' (which is a colon separated list).
- * If 'path' is NULL it uses the RAWDATA environment variable instead.
- *
- * Returns a mFILE pointer when found.
- *           NULL otherwise.
- */
-mFILE *open_path_mfile(const char *file, char *path, char *relative_to);
-
-/*
- * Returns a mFILE containing the entire contents of the url;
- *         NULL on failure.
- */
-mFILE *find_file_url(const char *file, char *url);
-
-
-/*
- * As per open_path_mfile, but searching only for local filenames.
- * This is useful as we may avoid doing a full mfopen and loading
- * the entire file into memory.
- *
- * Returns the expanded pathname if found.
- *         NULL if not
- */
-char *find_path(const char *file, const char *path);
-
-#ifdef __cplusplus
-}
-#endif
-
-#endif /* OPEN_TRACE_FILE_H */
diff -ruN stringtie.orig/htslib/cram/os.h stringtie/htslib/cram/os.h
--- stringtie.orig/htslib/cram/os.h	2024-02-28 13:57:39.701246126 +0100
+++ stringtie/htslib/cram/os.h	1970-01-01 01:00:00.000000000 +0100
@@ -1,205 +0,0 @@
-/*
-Copyright (c) 1993, 1995-2002 MEDICAL RESEARCH COUNCIL
-All rights reserved
-
-Redistribution and use in source and binary forms, with or without
-modification, are permitted provided that the following conditions are met:
-
-   1 Redistributions of source code must retain the above copyright notice,
-this list of conditions and the following disclaimer.
-
-   2 Redistributions in binary form must reproduce the above copyright notice,
-this list of conditions and the following disclaimer in the documentation
-and/or other materials provided with the distribution.
-
-   3 Neither the name of the MEDICAL RESEARCH COUNCIL, THE LABORATORY OF
-MOLECULAR BIOLOGY nor the names of its contributors may be used to endorse or
-promote products derived from this software without specific prior written
-permission.
-
-THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
-ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
-WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
-DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
-ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
-(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
-LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
-ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
-(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
-SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-*/
-
-/*
-Copyright (c) 2004, 2006, 2009-2011, 2013, 2017-2018 Genome Research Ltd.
-Author: James Bonfield <jkb@sanger.ac.uk>
-
-Redistribution and use in source and binary forms, with or without
-modification, are permitted provided that the following conditions are met:
-
-   1. Redistributions of source code must retain the above copyright notice,
-this list of conditions and the following disclaimer.
-
-   2. Redistributions in binary form must reproduce the above copyright notice,
-this list of conditions and the following disclaimer in the documentation
-and/or other materials provided with the distribution.
-
-   3. Neither the names Genome Research Ltd and Wellcome Trust Sanger
-Institute nor the names of its contributors may be used to endorse or promote
-products derived from this software without specific prior written permission.
-
-THIS SOFTWARE IS PROVIDED BY GENOME RESEARCH LTD AND CONTRIBUTORS "AS IS" AND
-ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
-WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
-DISCLAIMED. IN NO EVENT SHALL GENOME RESEARCH LTD OR CONTRIBUTORS BE LIABLE
-FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
-DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
-SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
-CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
-OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
-OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-*/
-
-/*
- * File: os.h
- *
- * Author:
- *         MRC Laboratory of Molecular Biology
- *         Hills Road
- *         Cambridge CB2 2QH
- *         United Kingdom
- *
- * Description: operating system specific type definitions
- *
- */
-
-#ifndef CRAM_OS_H
-#define CRAM_OS_H
-
-#include <limits.h>
-#include <stdint.h>
-
-#include "../htslib/hts_endian.h"
-
-#ifdef __cplusplus
-extern "C" {
-#endif
-
-
-/*-----------------------------------------------------------------------------
- * Byte swapping macros
- */
-
-/*
- * Our new swap runs at the same speed on Ultrix, but substantially faster
- * (300% for swap_int4, ~50% for swap_int2) on an Alpha (due to the lack of
- * decent 'char' support).
- *
- * They also have the ability to swap in situ (src == dst). Newer code now
- * relies on this so don't change back!
- */
-#define iswap_int8(x)                           \
-    (((x & 0x00000000000000ffLL) << 56) +       \
-     ((x & 0x000000000000ff00LL) << 40) +       \
-     ((x & 0x0000000000ff0000LL) << 24) +       \
-     ((x & 0x00000000ff000000LL) <<  8) +       \
-     ((x & 0x000000ff00000000LL) >>  8) +       \
-     ((x & 0x0000ff0000000000LL) >> 24) +       \
-     ((x & 0x00ff000000000000LL) >> 40) +       \
-     ((x & 0xff00000000000000LL) >> 56))
-
-#define iswap_int4(x)                           \
-    (((x & 0x000000ff) << 24) +                 \
-     ((x & 0x0000ff00) <<  8) +                 \
-     ((x & 0x00ff0000) >>  8) +                 \
-     ((x & 0xff000000) >> 24))
-
-#define iswap_int2(x)                           \
-    (((x & 0x00ff) << 8) +                      \
-     ((x & 0xff00) >> 8))
-
-/*
- * Linux systems may use byteswap.h to get assembly versions of byte-swap
- * on intel systems. This can be as trivial as the bswap opcode, which works
- * out at over 2-times faster than iswap_int4 above.
- */
-#if 0
-#if defined(__linux__)
-#    include <byteswap.h>
-#    undef iswap_int8
-#    undef iswap_int4
-#    undef iswap_int2
-#    define iswap_int8 bswap_64
-#    define iswap_int4 bswap_32
-#    define iswap_int2 bswap_16
-#endif
-#endif
-
-
-/*
- * Macros to specify that data read in is of a particular endianness.
- * The macros here swap to the appropriate order for the particular machine
- * running the macro and return the new answer. These may also be used when
- * writing to a file to specify that we wish to write in (eg) big endian
- * format.
- *
- * This leads to efficient code as most of the time these macros are
- * trivial.
- */
-#if defined(HTS_BIG_ENDIAN)
-#define le_int4(x) iswap_int4((x))
-#define le_int2(x) iswap_int2((x))
-#elif defined(HTS_LITTLE_ENDIAN)
-#define le_int4(x) (x)
-#define le_int2(x) (x)
-#else
-static inline uint32_t le_int4(uint32_t x) {
-    return le_to_u32((uint8_t *) &x);
-}
-static inline uint16_t le_int2(uint16_t x) {
-    return le_to_u16((uint8_t *) &x);
-}
-#endif
-
-/*-----------------------------------------------------------------------------
- * Operating system specifics.
- * These ought to be done by autoconf, but are legacy code.
- */
-/*
- * SunOS 4.x
- * Even though we use the ANSI gcc, we make use the the standard SunOS 4.x
- * libraries and include files, which are non-ansi
- */
-#if defined(__sun__) && !defined(__svr4__)
-#define SEEK_SET 0
-#define SEEK_CUR 1
-#define SEEK_END 2
-#endif
-
-/*
- * Microsoft Visual C++
- * Windows
- */
-#if defined(_MSC_VER)
-#define popen _popen
-#define pclose _pclose
-#define ftruncate(fd,len) _chsize(fd,len)
-#endif
-
-
-/*
- * Microsoft Windows running MinGW
- */
-#if defined(__MINGW32__)
-#include <io.h>
-#define mkdir(filename,mode) mkdir((filename))
-#define sysconf(x) 512
-#ifndef ftruncate
-#  define ftruncate(fd,len) _chsize(fd,len)
-#endif
-#endif
-
-#ifdef __cplusplus
-}
-#endif
-
-#endif /* CRAM_OS_H */
diff -ruN stringtie.orig/htslib/cram/pooled_alloc.c stringtie/htslib/cram/pooled_alloc.c
--- stringtie.orig/htslib/cram/pooled_alloc.c	2024-02-28 13:57:39.701246126 +0100
+++ stringtie/htslib/cram/pooled_alloc.c	1970-01-01 01:00:00.000000000 +0100
@@ -1,205 +0,0 @@
-/*
-Copyright (c) 2009, 2013, 2015, 2018-2019 Genome Research Ltd.
-Author: Rob Davies <rmd@sanger.ac.uk>
-
-Redistribution and use in source and binary forms, with or without
-modification, are permitted provided that the following conditions are met:
-
-   1. Redistributions of source code must retain the above copyright notice,
-this list of conditions and the following disclaimer.
-
-   2. Redistributions in binary form must reproduce the above copyright notice,
-this list of conditions and the following disclaimer in the documentation
-and/or other materials provided with the distribution.
-
-   3. Neither the names Genome Research Ltd and Wellcome Trust Sanger
-Institute nor the names of its contributors may be used to endorse or promote
-products derived from this software without specific prior written permission.
-
-THIS SOFTWARE IS PROVIDED BY GENOME RESEARCH LTD AND CONTRIBUTORS "AS IS" AND
-ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
-WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
-DISCLAIMED. IN NO EVENT SHALL GENOME RESEARCH LTD OR CONTRIBUTORS BE LIABLE
-FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
-DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
-SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
-CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
-OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
-OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-*/
-
-#define HTS_BUILDING_LIBRARY // Enables HTSLIB_EXPORT, see htslib/hts_defs.h
-#include <config.h>
-
-#include <stdlib.h>
-#include <stdio.h>
-#include <stdint.h>
-
-#include "pooled_alloc.h"
-#include "misc.h"
-
-//#define DISABLE_POOLED_ALLOC
-//#define TEST_MAIN
-
-#define PSIZE 1024*1024
-
-// credit to http://graphics.stanford.edu/~seander/bithacks.html
-static int next_power_2(unsigned int v) {
-    v--;
-    v |= v >> 1;
-    v |= v >> 2;
-    v |= v >> 4;
-    v |= v >> 8;
-    v |= v >> 16;
-    v++;
-
-    return v;
-}
-
-/*
- * Creates a pool.
- * Pool allocations are approx minimum of 1024*dsize or PSIZE.
- * (Assumes we're not trying to use pools for >= 2Gb or more)
- */
-pool_alloc_t *pool_create(size_t dsize) {
-    pool_alloc_t *p;
-
-    if (NULL == (p = (pool_alloc_t *)malloc(sizeof(*p))))
-        return NULL;
-
-    /* Minimum size is a pointer, for free list */
-    dsize = (dsize + sizeof(void *) - 1) & ~(sizeof(void *)-1);
-    if (dsize < sizeof(void *))
-        dsize = sizeof(void *);
-    p->dsize = dsize;
-    p->psize = MIN(PSIZE, next_power_2(p->dsize*1024));
-
-    p->npools = 0;
-    p->pools = NULL;
-    p->free  = NULL;
-
-    return p;
-}
-
-void pool_destroy(pool_alloc_t *p) {
-    size_t i;
-
-    for (i = 0; i < p->npools; i++) {
-        free(p->pools[i].pool);
-    }
-    free(p->pools);
-    free(p);
-}
-
-#ifndef DISABLE_POOLED_ALLOC
-
-static pool_t *new_pool(pool_alloc_t *p) {
-    size_t n = p->psize / p->dsize;
-    pool_t *pool;
-
-    pool = realloc(p->pools, (p->npools + 1) * sizeof(*p->pools));
-    if (NULL == pool) return NULL;
-    p->pools = pool;
-    pool = &p->pools[p->npools];
-
-    pool->pool = malloc(n * p->dsize);
-    if (NULL == pool->pool) return NULL;
-
-    pool->used = 0;
-
-    p->npools++;
-
-    return pool;
-}
-
-void *pool_alloc(pool_alloc_t *p) {
-    pool_t *pool;
-    void *ret;
-
-    /* Look on free list */
-    if (NULL != p->free) {
-        ret = p->free;
-        p->free = *((void **)p->free);
-        return ret;
-    }
-
-    /* Look for space in the last pool */
-    if (p->npools) {
-        pool = &p->pools[p->npools - 1];
-        if (pool->used + p->dsize < p->psize) {
-            ret = ((char *) pool->pool) + pool->used;
-            pool->used += p->dsize;
-            return ret;
-        }
-    }
-
-    /* Need a new pool */
-    pool = new_pool(p);
-    if (NULL == pool) return NULL;
-
-    pool->used = p->dsize;
-    return pool->pool;
-}
-
-void pool_free(pool_alloc_t *p, void *ptr) {
-    *(void **)ptr = p->free;
-    p->free = ptr;
-}
-
-#else
-
-void *pool_alloc(pool_alloc_t *p) {
-    return malloc(p->dsize);
-}
-
-void pool_free(pool_alloc_t *p, void *ptr) {
-    free(ptr);
-}
-
-#endif
-
-#ifdef TEST_MAIN
-typedef struct {
-    int x, y, z;
-} xyz;
-
-#define NP 10000
-int main(void) {
-    int i;
-    xyz *item;
-    xyz **items;
-    pool_alloc_t *p = pool_create(sizeof(xyz));
-
-    items = (xyz **)malloc(NP * sizeof(*items));
-
-    for (i = 0; i < NP; i++) {
-        item = pool_alloc(p);
-        item->x = i;
-        item->y = i+1;
-        item->z = i+2;
-        items[i] = item;
-    }
-
-    for (i = 0; i < NP; i++) {
-        item = items[i];
-        if (i % 3)
-            pool_free(p, item);
-    }
-
-    for (i = 0; i < NP; i++) {
-        item = pool_alloc(p);
-        item->x = 1000000+i;
-        item->y = 1000000+i+1;
-        item->z = 1000000+i+2;
-    }
-
-    for (i = 0; i < NP; i++) {
-        item = items[i];
-        printf("%d\t%d\t%d\t%d\n", i, item->x, item->y, item->z);
-        pool_free(p, item);
-    }
-
-    free(items);
-    return 0;
-}
-#endif
diff -ruN stringtie.orig/htslib/cram/pooled_alloc.h stringtie/htslib/cram/pooled_alloc.h
--- stringtie.orig/htslib/cram/pooled_alloc.h	2024-02-28 13:57:39.701246126 +0100
+++ stringtie/htslib/cram/pooled_alloc.h	1970-01-01 01:00:00.000000000 +0100
@@ -1,66 +0,0 @@
-/*
-Copyright (c) 2009, 2013, 2018 Genome Research Ltd.
-Author: Rob Davies <rmd@sanger.ac.uk>
-
-Redistribution and use in source and binary forms, with or without
-modification, are permitted provided that the following conditions are met:
-
-   1. Redistributions of source code must retain the above copyright notice,
-this list of conditions and the following disclaimer.
-
-   2. Redistributions in binary form must reproduce the above copyright notice,
-this list of conditions and the following disclaimer in the documentation
-and/or other materials provided with the distribution.
-
-   3. Neither the names Genome Research Ltd and Wellcome Trust Sanger
-Institute nor the names of its contributors may be used to endorse or promote
-products derived from this software without specific prior written permission.
-
-THIS SOFTWARE IS PROVIDED BY GENOME RESEARCH LTD AND CONTRIBUTORS "AS IS" AND
-ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
-WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
-DISCLAIMED. IN NO EVENT SHALL GENOME RESEARCH LTD OR CONTRIBUTORS BE LIABLE
-FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
-DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
-SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
-CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
-OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
-OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-*/
-
-#ifndef POOLED_ALLOC_H
-#define POOLED_ALLOC_H
-
-#include <stddef.h>
-
-#ifdef __cplusplus
-extern "C" {
-#endif
-
-/*
- * Implements a pooled block allocator where all items are the same size,
- * but we need many of them.
- */
-typedef struct {
-    void   *pool;
-    size_t  used;
-} pool_t;
-
-typedef struct {
-    size_t dsize;
-    size_t psize;
-    size_t npools;
-    pool_t *pools;
-    void *free;
-} pool_alloc_t;
-
-pool_alloc_t *pool_create(size_t dsize);
-void pool_destroy(pool_alloc_t *p);
-void *pool_alloc(pool_alloc_t *p);
-void pool_free(pool_alloc_t *p, void *ptr);
-
-#ifdef __cplusplus
-}
-#endif
-
-#endif /* POOLED_ALLOC_H */
diff -ruN stringtie.orig/htslib/cram/string_alloc.c stringtie/htslib/cram/string_alloc.c
--- stringtie.orig/htslib/cram/string_alloc.c	2024-02-28 13:57:39.701246126 +0100
+++ stringtie/htslib/cram/string_alloc.c	1970-01-01 01:00:00.000000000 +0100
@@ -1,162 +0,0 @@
-/*
-Copyright (c) 2010, 2013, 2018-2019 Genome Research Ltd.
-Author: Andrew Whitwham <aw7@sanger.ac.uk>
-
-Redistribution and use in source and binary forms, with or without
-modification, are permitted provided that the following conditions are met:
-
-   1. Redistributions of source code must retain the above copyright notice,
-this list of conditions and the following disclaimer.
-
-   2. Redistributions in binary form must reproduce the above copyright notice,
-this list of conditions and the following disclaimer in the documentation
-and/or other materials provided with the distribution.
-
-   3. Neither the names Genome Research Ltd and Wellcome Trust Sanger
-Institute nor the names of its contributors may be used to endorse or promote
-products derived from this software without specific prior written permission.
-
-THIS SOFTWARE IS PROVIDED BY GENOME RESEARCH LTD AND CONTRIBUTORS "AS IS" AND
-ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
-WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
-DISCLAIMED. IN NO EVENT SHALL GENOME RESEARCH LTD OR CONTRIBUTORS BE LIABLE
-FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
-DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
-SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
-CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
-OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
-OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-*/
-
-
-/*
-   A pooled string allocator intended to cut down on the
-   memory overhead of many small string allocations.
-
-   Andrew Whitwham, September 2010.
-*/
-
-#define HTS_BUILDING_LIBRARY // Enables HTSLIB_EXPORT, see htslib/hts_defs.h
-#include <config.h>
-
-#include <string.h>
-#include <stdlib.h>
-#include <stdio.h>
-
-#include "string_alloc.h"
-
-#define MIN_STR_SIZE 1024
-
-
-/* creates the string pool. max_length is the initial size
-   a single string can be.  The max_length can grow as
-   needed */
-
-string_alloc_t *string_pool_create(size_t max_length) {
-    string_alloc_t *a_str;
-
-    if (NULL == (a_str = (string_alloc_t *)malloc(sizeof(*a_str)))) {
-        return NULL;
-    }
-
-    if (max_length < MIN_STR_SIZE) max_length = MIN_STR_SIZE;
-
-    a_str->nstrings    = 0;
-    a_str->max_strings = 0;
-    a_str->max_length  = max_length;
-    a_str->strings     = NULL;
-
-    return a_str;
-}
-
-
-/* internal function to do the actual memory allocation */
-
-static string_t *new_string_pool(string_alloc_t *a_str) {
-    string_t *str;
-
-    if (a_str->nstrings == a_str->max_strings) {
-        size_t new_max = (a_str->max_strings | (a_str->max_strings >> 2)) + 1;
-        str = realloc(a_str->strings, new_max * sizeof(*a_str->strings));
-
-        if (NULL == str) return NULL;
-
-        a_str->strings = str;
-        a_str->max_strings = new_max;
-    }
-
-    str = &a_str->strings[a_str->nstrings];
-
-    str->str = malloc(a_str->max_length);
-
-    if (NULL == str->str) return NULL;
-
-    str->used = 0;
-    a_str->nstrings++;
-
-    return str;
-}
-
-
-/* free allocated memory */
-
-void string_pool_destroy(string_alloc_t *a_str) {
-    size_t i;
-
-    for (i = 0; i < a_str->nstrings; i++) {
-        free(a_str->strings[i].str);
-    }
-
-    free(a_str->strings);
-    free(a_str);
-}
-
-
-/* allocate space for a string */
-
-char *string_alloc(string_alloc_t *a_str, size_t length) {
-    string_t *str;
-    char *ret;
-
-    if (length <= 0) return NULL;
-
-    // add to last string pool if we have space
-    if (a_str->nstrings) {
-        str = &a_str->strings[a_str->nstrings - 1];
-
-        if (str->used + length < a_str->max_length) {
-            ret = str->str + str->used;
-            str->used += length;
-            return ret;
-        }
-    }
-
-    // increase the max length if needs be
-    if (length > a_str->max_length) a_str->max_length = length;
-
-    // need a new string pool
-    str = new_string_pool(a_str);
-
-    if (NULL == str) return NULL;
-
-    str->used = length;
-    return str->str;
-}
-
-
-/* equivalent to strdup */
-
-char *string_dup(string_alloc_t *a_str, const char *instr) {
-    return string_ndup(a_str, instr, strlen(instr));
-}
-
-char *string_ndup(string_alloc_t *a_str, const char *instr, size_t len) {
-    char *str = string_alloc(a_str, len + 1);
-
-    if (NULL == str) return NULL;
-
-    memcpy(str, instr, len);
-    str[len] = 0;
-
-    return str;
-}
diff -ruN stringtie.orig/htslib/cram/string_alloc.h stringtie/htslib/cram/string_alloc.h
--- stringtie.orig/htslib/cram/string_alloc.h	2024-02-28 13:57:39.701246126 +0100
+++ stringtie/htslib/cram/string_alloc.h	1970-01-01 01:00:00.000000000 +0100
@@ -1,69 +0,0 @@
-/*
-Copyright (c) 2010, 2013, 2018 Genome Research Ltd.
-Author: Andrew Whitwham <aw7@sanger.ac.uk>
-
-Redistribution and use in source and binary forms, with or without
-modification, are permitted provided that the following conditions are met:
-
-   1. Redistributions of source code must retain the above copyright notice,
-this list of conditions and the following disclaimer.
-
-   2. Redistributions in binary form must reproduce the above copyright notice,
-this list of conditions and the following disclaimer in the documentation
-and/or other materials provided with the distribution.
-
-   3. Neither the names Genome Research Ltd and Wellcome Trust Sanger
-Institute nor the names of its contributors may be used to endorse or promote
-products derived from this software without specific prior written permission.
-
-THIS SOFTWARE IS PROVIDED BY GENOME RESEARCH LTD AND CONTRIBUTORS "AS IS" AND
-ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
-WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
-DISCLAIMED. IN NO EVENT SHALL GENOME RESEARCH LTD OR CONTRIBUTORS BE LIABLE
-FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
-DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
-SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
-CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
-OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
-OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-*/
-
-#ifndef STRING_ALLOC_H
-#define STRING_ALLOC_H
-
-#include <stdlib.h>
-
-#ifdef __cplusplus
-extern "C" {
-#endif
-
-/*
- * A pooled string allocator intended to cut down on the
- * memory overhead of many small string allocations.
- *
- * Andrew Whitwham, September 2010.
- */
-
-typedef struct {
-    char *str;
-    size_t used;
-} string_t;
-
-typedef struct {
-    size_t max_length;
-    size_t nstrings;
-    size_t max_strings;
-    string_t *strings;
-} string_alloc_t;
-
-string_alloc_t *string_pool_create(size_t max_length);
-void string_pool_destroy(string_alloc_t *a_str);
-char *string_alloc(string_alloc_t *a_str, size_t length);
-char *string_dup(string_alloc_t *a_str, const char *instr);
-char *string_ndup(string_alloc_t *a_str, const char *instr, size_t len);
-
-#ifdef __cplusplus
-}
-#endif
-
-#endif
diff -ruN stringtie.orig/htslib/errmod.c stringtie/htslib/errmod.c
--- stringtie.orig/htslib/errmod.c	2024-02-28 13:57:39.701246126 +0100
+++ stringtie/htslib/errmod.c	1970-01-01 01:00:00.000000000 +0100
@@ -1,208 +0,0 @@
-/*  errmod.c -- revised MAQ error model.
-
-    Copyright (C) 2010 Broad Institute.
-    Copyright (C) 2012, 2013, 2016-2017, 2019 Genome Research Ltd.
-
-    Author: Heng Li <lh3@sanger.ac.uk>
-
-Permission is hereby granted, free of charge, to any person obtaining a copy
-of this software and associated documentation files (the "Software"), to deal
-in the Software without restriction, including without limitation the rights
-to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
-copies of the Software, and to permit persons to whom the Software is
-furnished to do so, subject to the following conditions:
-
-The above copyright notice and this permission notice shall be included in
-all copies or substantial portions of the Software.
-
-THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
-IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
-FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
-THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
-LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
-FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
-DEALINGS IN THE SOFTWARE.  */
-
-#define HTS_BUILDING_LIBRARY // Enables HTSLIB_EXPORT, see htslib/hts_defs.h
-#include <config.h>
-
-#include <math.h>
-#include "htslib/hts.h"
-#include "htslib/ksort.h"
-#include "htslib/hts_os.h" // for drand48
-
-KSORT_INIT_STATIC_GENERIC(uint16_t)
-
-struct errmod_t {
-    double depcorr;
-    /* table of constants generated for given depcorr and eta */
-    double *fk, *beta, *lhet;
-};
-
-typedef struct {
-    double fsum[16], bsum[16];
-    uint32_t c[16];
-} call_aux_t;
-
-/* \Gamma(n) = (n-1)! */
-#define lfact(n) lgamma(n+1)
-
-/* generates a success * trials table of bionomial probability densities (log transformed) */
-static double* logbinomial_table( const int n_size )
-{
-    /* prob distribution for binom var is p(k) = {n! \over k! (n-k)! } p^k (1-p)^{n-k} */
-    /* this calcs p(k) = {log(n!) - log(k!) - log((n-k)!) */
-    int k, n;
-    double *logbinom = (double*)calloc(n_size * n_size, sizeof(double));
-    if (!logbinom) return NULL;
-    for (n = 1; n < n_size; ++n) {
-        double lfn = lfact(n);
-        for (k = 1; k <= n; ++k)
-            logbinom[n<<8|k] = lfn - lfact(k) - lfact(n-k);
-    }
-    return logbinom;
-}
-
-static int cal_coef(errmod_t *em, double depcorr, double eta)
-{
-    int k, n, q;
-    double sum, sum1;
-    double *lC;
-
-    // initialize ->fk
-    em->fk = (double*)calloc(256, sizeof(double));
-    if (!em->fk) return -1;
-    em->fk[0] = 1.0;
-    for (n = 1; n < 256; ++n)
-        em->fk[n] = pow(1. - depcorr, n) * (1.0 - eta) + eta;
-
-    // initialize ->beta
-    em->beta = (double*)calloc(256 * 256 * 64, sizeof(double));
-    if (!em->beta) return -1;
-
-    lC = logbinomial_table( 256 );
-    if (!lC) return -1;
-
-    for (q = 1; q < 64; ++q) {
-        double e = pow(10.0, -q/10.0);
-        double le = log(e);
-        double le1 = log(1.0 - e);
-        for (n = 1; n <= 255; ++n) {
-            double *beta = em->beta + (q<<16|n<<8);
-            sum1 = lC[n<<8|n] + n*le;
-            beta[n] = HUGE_VAL;
-            for (k = n - 1; k >= 0; --k, sum1 = sum) {
-                sum = sum1 + log1p(exp(lC[n<<8|k] + k*le + (n-k)*le1 - sum1));
-                beta[k] = -10. / M_LN10 * (sum1 - sum);
-            }
-        }
-    }
-
-    // initialize ->lhet
-    em->lhet = (double*)calloc(256 * 256, sizeof(double));
-    if (!em->lhet) {
-        free(lC);
-        return -1;
-    }
-    for (n = 0; n < 256; ++n)
-        for (k = 0; k < 256; ++k)
-            em->lhet[n<<8|k] = lC[n<<8|k] - M_LN2 * n;
-    free(lC);
-    return 0;
-}
-
-/**
- * Create errmod_t object with obj.depcorr set to depcorr and initialise
- */
-errmod_t *errmod_init(double depcorr)
-{
-    errmod_t *em;
-    em = (errmod_t*)calloc(1, sizeof(errmod_t));
-    if (!em) return NULL;
-    em->depcorr = depcorr;
-    cal_coef(em, depcorr, 0.03);
-    return em;
-}
-
-/**
- * Deallocate an errmod_t object
- */
-void errmod_destroy(errmod_t *em)
-{
-    if (em == 0) return;
-    free(em->lhet); free(em->fk); free(em->beta);
-    free(em);
-}
-
-//
-// em: error model to fit to data
-// m: number of alleles across all samples
-// n: number of bases observed in sample
-// bases[i]: bases observed in pileup [6 bit quality|1 bit strand|4 bit base]
-// q[i*m+j]: (Output) phred-scaled likelihood of each genotype (i,j)
-int errmod_cal(const errmod_t *em, int n, int m, uint16_t *bases, float *q)
-{
-    // Aux
-    // aux.c is total count of each base observed (ignoring strand)
-    call_aux_t aux;
-    // Loop variables
-    int i, j, k;
-    // The total count of each base observed per strand
-    int w[32];
-
-    memset(q, 0, m * m * sizeof(float)); // initialise q to 0
-    if (n == 0) return 0;
-    // This section randomly downsamples to 255 depth so as not to go beyond our precalculated matrix
-    if (n > 255) { // if we exceed 255 bases observed then shuffle them to sample and only keep the first 255
-        ks_shuffle(uint16_t, n, bases);
-        n = 255;
-    }
-    ks_introsort(uint16_t, n, bases);
-    /* zero out w and aux */
-    memset(w, 0, 32 * sizeof(int));
-    memset(&aux, 0, sizeof(call_aux_t));
-
-    for (j = n - 1; j >= 0; --j) { // calculate esum and fsum
-        uint16_t b = bases[j];
-        /* extract quality and cap at 63 */
-        int qual = b>>5 < 4? 4 : b>>5;
-        if (qual > 63) qual = 63;
-        /* extract base ORed with strand */
-        int basestrand = b&0x1f;
-        /* extract base */
-        int base = b&0xf;
-        aux.fsum[base] += em->fk[w[basestrand]];
-        aux.bsum[base] += em->fk[w[basestrand]] * em->beta[qual<<16|n<<8|aux.c[base]];
-        ++aux.c[base];
-        ++w[basestrand];
-    }
-
-    // generate likelihood
-    for (j = 0; j < m; ++j) {
-        float tmp1, tmp3;
-        int tmp2;
-        // homozygous
-        for (k = 0, tmp1 = tmp3 = 0.0, tmp2 = 0; k < m; ++k) {
-            if (k == j) continue;
-            tmp1 += aux.bsum[k]; tmp2 += aux.c[k]; tmp3 += aux.fsum[k];
-        }
-        if (tmp2) {
-            q[j*m+j] = tmp1;
-        }
-        // heterozygous
-        for (k = j + 1; k < m; ++k) {
-            int cjk = aux.c[j] + aux.c[k];
-            for (i = 0, tmp2 = 0, tmp1 = tmp3 = 0.0; i < m; ++i) {
-                if (i == j || i == k) continue;
-                tmp1 += aux.bsum[i]; tmp2 += aux.c[i]; tmp3 += aux.fsum[i];
-            }
-            if (tmp2) {
-                q[j*m+k] = q[k*m+j] = -4.343 * em->lhet[cjk<<8|aux.c[k]] + tmp1;
-            } else q[j*m+k] = q[k*m+j] = -4.343 * em->lhet[cjk<<8|aux.c[k]]; // all the bases are either j or k
-        }
-        /* clamp to greater than 0 */
-        for (k = 0; k < m; ++k) if (q[j*m+k] < 0.0) q[j*m+k] = 0.0;
-    }
-
-    return 0;
-}
diff -ruN stringtie.orig/htslib/faidx.c stringtie/htslib/faidx.c
--- stringtie.orig/htslib/faidx.c	2024-02-28 13:57:39.701246126 +0100
+++ stringtie/htslib/faidx.c	1970-01-01 01:00:00.000000000 +0100
@@ -1,951 +0,0 @@
-/*  faidx.c -- FASTA and FASTQ random access.
-
-    Copyright (C) 2008, 2009, 2013-2020 Genome Research Ltd.
-    Portions copyright (C) 2011 Broad Institute.
-
-    Author: Heng Li <lh3@sanger.ac.uk>
-
-Permission is hereby granted, free of charge, to any person obtaining a copy
-of this software and associated documentation files (the "Software"), to deal
-in the Software without restriction, including without limitation the rights
-to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
-copies of the Software, and to permit persons to whom the Software is
-furnished to do so, subject to the following conditions:
-
-The above copyright notice and this permission notice shall be included in
-all copies or substantial portions of the Software.
-
-THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
-IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
-FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
-THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
-LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
-FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
-DEALINGS IN THE SOFTWARE.  */
-
-#define HTS_BUILDING_LIBRARY // Enables HTSLIB_EXPORT, see htslib/hts_defs.h
-#include <config.h>
-
-#include <ctype.h>
-#include <string.h>
-#include <stdlib.h>
-#include <stdio.h>
-#include <inttypes.h>
-#include <errno.h>
-#include <limits.h>
-#include <unistd.h>
-#include <assert.h>
-
-#include "htslib/bgzf.h"
-#include "htslib/faidx.h"
-#include "htslib/hfile.h"
-#include "htslib/khash.h"
-#include "htslib/kstring.h"
-#include "hts_internal.h"
-
-typedef struct {
-    int id; // faidx_t->name[id] is for this struct.
-    uint32_t line_len, line_blen;
-    uint64_t len;
-    uint64_t seq_offset;
-    uint64_t qual_offset;
-} faidx1_t;
-KHASH_MAP_INIT_STR(s, faidx1_t)
-
-struct faidx_t {
-    BGZF *bgzf;
-    int n, m;
-    char **name;
-    khash_t(s) *hash;
-    enum fai_format_options format;
-};
-
-static int fai_name2id(void *v, const char *ref)
-{
-    faidx_t *fai = (faidx_t *)v;
-    khint_t k = kh_get(s, fai->hash, ref);
-    return k == kh_end(fai->hash) ? -1 : kh_val(fai->hash, k).id;
-}
-
-static inline int fai_insert_index(faidx_t *idx, const char *name, uint64_t len, uint32_t line_len, uint32_t line_blen, uint64_t seq_offset, uint64_t qual_offset)
-{
-    if (!name) {
-        hts_log_error("Malformed line");
-        return -1;
-    }
-
-    char *name_key = strdup(name);
-    int absent;
-    khint_t k = kh_put(s, idx->hash, name_key, &absent);
-    faidx1_t *v = &kh_value(idx->hash, k);
-
-    if (! absent) {
-        hts_log_warning("Ignoring duplicate sequence \"%s\" at byte offset %" PRIu64, name, seq_offset);
-        free(name_key);
-        return 0;
-    }
-
-    if (idx->n == idx->m) {
-        char **tmp;
-        idx->m = idx->m? idx->m<<1 : 16;
-        if (!(tmp = (char**)realloc(idx->name, sizeof(char*) * idx->m))) {
-            hts_log_error("Out of memory");
-            return -1;
-        }
-        idx->name = tmp;
-    }
-    v->id = idx->n;
-    idx->name[idx->n++] = name_key;
-    v->len = len;
-    v->line_len = line_len;
-    v->line_blen = line_blen;
-    v->seq_offset = seq_offset;
-    v->qual_offset = qual_offset;
-
-    return 0;
-}
-
-
-static faidx_t *fai_build_core(BGZF *bgzf) {
-    kstring_t name = { 0, 0, NULL };
-    int c, read_done, line_num;
-    faidx_t *idx;
-    uint64_t seq_offset, qual_offset;
-    uint64_t seq_len, qual_len;
-    uint64_t char_len, cl, line_len, ll;
-    enum read_state {OUT_READ, IN_NAME, IN_SEQ, SEQ_END, IN_QUAL} state;
-
-    idx = (faidx_t*)calloc(1, sizeof(faidx_t));
-    idx->hash = kh_init(s);
-    idx->format = FAI_NONE;
-
-    state = OUT_READ, read_done = 0, line_num = 1;
-    seq_offset = qual_offset = seq_len = qual_len = char_len = cl = line_len = ll = 0;
-
-    while ((c = bgzf_getc(bgzf)) >= 0) {
-        switch (state) {
-            case OUT_READ:
-                switch (c) {
-                    case '>':
-                        if (idx->format == FAI_FASTQ) {
-                            hts_log_error("Found '>' in a FASTQ file, error at line %d", line_num);
-                            goto fail;
-                        }
-
-                        idx->format = FAI_FASTA;
-                        state = IN_NAME;
-                    break;
-
-                    case '@':
-                        if (idx->format == FAI_FASTA) {
-                            hts_log_error("Found '@' in a FASTA file, error at line %d", line_num);
-                            goto fail;
-                        }
-
-                        idx->format = FAI_FASTQ;
-                        state = IN_NAME;
-                    break;
-
-                    case '\r':
-                        // Blank line with cr-lf ending?
-                        if ((c = bgzf_getc(bgzf)) == '\n') {
-                            line_num++;
-                        } else {
-                            hts_log_error("Format error, carriage return not followed by new line at line %d", line_num);
-                            goto fail;
-                        }
-                    break;
-
-                    case '\n':
-                        // just move onto the next line
-                        line_num++;
-                    break;
-
-                    default: {
-                        char s[4] = { '"', c, '"', '\0' };
-                        hts_log_error("Format error, unexpected %s at line %d", isprint(c) ? s : "character", line_num);
-                        goto fail;
-                    }
-                }
-            break;
-
-            case IN_NAME:
-                if (read_done) {
-                    if (fai_insert_index(idx, name.s, seq_len, line_len, char_len, seq_offset, qual_offset) != 0)
-                        goto fail;
-
-                    read_done = 0;
-                }
-
-                name.l = 0;
-
-                do {
-                    if (!isspace(c)) {
-                        kputc(c, &name);
-                    } else if (name.l > 0 || c == '\n') {
-                        break;
-                    }
-                } while ((c = bgzf_getc(bgzf)) >= 0);
-
-                kputsn("", 0, &name);
-
-                if (c < 0) {
-                    hts_log_error("The last entry '%s' has no sequence", name.s);
-                    goto fail;
-                }
-
-                // read the rest of the line if necessary
-                if (c != '\n') while ((c = bgzf_getc(bgzf)) >= 0 && c != '\n');
-
-                state = IN_SEQ; seq_len = qual_len = char_len = line_len = 0;
-                seq_offset = bgzf_utell(bgzf);
-                line_num++;
-            break;
-
-            case IN_SEQ:
-                if (idx->format == FAI_FASTA) {
-                    if (c == '\n') {
-                        state = OUT_READ;
-                        line_num++;
-                        continue;
-                    } else if (c == '>') {
-                        state = IN_NAME;
-                        continue;
-                    }
-                } else if (idx->format == FAI_FASTQ) {
-                    if (c == '+') {
-                        state = IN_QUAL;
-                        if (c != '\n') while ((c = bgzf_getc(bgzf)) >= 0 && c != '\n');
-                        qual_offset = bgzf_utell(bgzf);
-                        line_num++;
-                        continue;
-                    } else if (c == '\n') {
-                        hts_log_error("Inlined empty line is not allowed in sequence '%s' at line %d", name.s, line_num);
-                        goto fail;
-                    }
-                }
-
-                ll = cl = 0;
-
-                if (idx->format == FAI_FASTA) read_done = 1;
-
-                do {
-                    ll++;
-                    if (isgraph(c)) cl++;
-                } while ((c = bgzf_getc(bgzf)) >= 0 && c != '\n');
-
-                ll++; seq_len += cl;
-
-                if (line_len == 0) {
-                    line_len = ll;
-                    char_len = cl;
-                } else if (line_len > ll) {
-
-                    if (idx->format == FAI_FASTA)
-                        state = OUT_READ;
-                    else
-                        state = SEQ_END;
-
-                } else if (line_len < ll) {
-                    hts_log_error("Different line length in sequence '%s'", name.s);
-                    goto fail;
-                }
-
-                line_num++;
-            break;
-
-            case SEQ_END:
-                if (c == '+') {
-                    state = IN_QUAL;
-                    while ((c = bgzf_getc(bgzf)) >= 0 && c != '\n');
-                    qual_offset = bgzf_utell(bgzf);
-                    line_num++;
-                } else {
-                    hts_log_error("Format error, expecting '+', got '%c' at line %d", c, line_num);
-                    goto fail;
-                }
-            break;
-
-            case IN_QUAL:
-                if (c == '\n') {
-                    if (!read_done) {
-                        hts_log_error("Inlined empty line is not allowed in quality of sequence '%s'", name.s);
-                        goto fail;
-                    }
-
-                    state = OUT_READ;
-                    line_num++;
-                    continue;
-                } else if (c == '@' && read_done) {
-                    state = IN_NAME;
-                    continue;
-                }
-
-                ll = cl = 0;
-
-                do {
-                    ll++;
-                    if (isgraph(c)) cl++;
-                } while ((c = bgzf_getc(bgzf)) >= 0 && c != '\n');
-
-                ll++; qual_len += cl;
-
-                if (line_len < ll) {
-                    hts_log_error("Quality line length too long in '%s' at line %d", name.s, line_num);
-                    goto fail;
-                } else if (qual_len == seq_len) {
-                    read_done = 1;
-                } else if (qual_len > seq_len) {
-                    hts_log_error("Quality length longer than sequence in '%s' at line %d", name.s, line_num);
-                    goto fail;
-                } else if (line_len > ll) {
-                    hts_log_error("Quality line length too short in '%s' at line %d", name.s, line_num);
-                    goto fail;
-                }
-
-                line_num++;
-            break;
-        }
-    }
-
-    if (read_done) {
-        if (fai_insert_index(idx, name.s, seq_len, line_len, char_len, seq_offset, qual_offset) != 0)
-            goto fail;
-    } else {
-        goto fail;
-    }
-
-    free(name.s);
-    return idx;
-
-fail:
-    free(name.s);
-    fai_destroy(idx);
-    return NULL;
-}
-
-
-static int fai_save(const faidx_t *fai, hFILE *fp) {
-    khint_t k;
-    int i;
-    char buf[96]; // Must be big enough for format below.
-
-    for (i = 0; i < fai->n; ++i) {
-        faidx1_t x;
-        k = kh_get(s, fai->hash, fai->name[i]);
-        assert(k < kh_end(fai->hash));
-        x = kh_value(fai->hash, k);
-
-        if (fai->format == FAI_FASTA) {
-            snprintf(buf, sizeof(buf),
-                 "\t%"PRIu64"\t%"PRIu64"\t%"PRIu32"\t%"PRIu32"\n",
-                 x.len, x.seq_offset, x.line_blen, x.line_len);
-        } else {
-            snprintf(buf, sizeof(buf),
-                 "\t%"PRIu64"\t%"PRIu64"\t%"PRIu32"\t%"PRIu32"\t%"PRIu64"\n",
-                 x.len, x.seq_offset, x.line_blen, x.line_len, x.qual_offset);
-        }
-
-        if (hputs(fai->name[i], fp) != 0) return -1;
-        if (hputs(buf, fp) != 0) return -1;
-    }
-    return 0;
-}
-
-
-static faidx_t *fai_read(hFILE *fp, const char *fname, int format)
-{
-    faidx_t *fai;
-    char *buf = NULL, *p;
-    ssize_t l, lnum = 1;
-
-    fai = (faidx_t*)calloc(1, sizeof(faidx_t));
-    if (!fai) return NULL;
-
-    fai->hash = kh_init(s);
-    if (!fai->hash) goto fail;
-
-    buf = (char*)calloc(0x10000, 1);
-    if (!buf) goto fail;
-
-    while ((l = hgetln(buf, 0x10000, fp)) > 0) {
-        uint32_t line_len, line_blen, n;
-        uint64_t len;
-        uint64_t seq_offset;
-        uint64_t qual_offset = 0;
-
-        for (p = buf; *p && !isspace_c(*p); ++p);
-
-        if (p - buf < l) {
-            *p = 0; ++p;
-        }
-
-        if (format == FAI_FASTA) {
-            n = sscanf(p, "%"SCNu64"%"SCNu64"%"SCNu32"%"SCNu32, &len, &seq_offset, &line_blen, &line_len);
-
-            if (n != 4) {
-                hts_log_error("Could not understand FASTA index %s line %zd", fname, lnum);
-                goto fail;
-            }
-        } else {
-            n = sscanf(p, "%"SCNu64"%"SCNu64"%"SCNu32"%"SCNu32"%"SCNu64, &len, &seq_offset, &line_blen, &line_len, &qual_offset);
-
-            if (n != 5) {
-                if (n == 4) {
-                    hts_log_error("Possibly this is a FASTA index, try using faidx.  Problem in %s line %zd", fname, lnum);
-                } else {
-                    hts_log_error("Could not understand FASTQ index %s line %zd", fname, lnum);
-                }
-
-                goto fail;
-            }
-        }
-
-        if (fai_insert_index(fai, buf, len, line_len, line_blen, seq_offset, qual_offset) != 0) {
-            goto fail;
-        }
-
-        if (buf[l - 1] == '\n') ++lnum;
-    }
-
-    if (l < 0) {
-        hts_log_error("Error while reading %s: %s", fname, strerror(errno));
-        goto fail;
-    }
-    free(buf);
-    return fai;
-
- fail:
-    free(buf);
-    fai_destroy(fai);
-    return NULL;
-}
-
-void fai_destroy(faidx_t *fai)
-{
-    int i;
-    if (!fai) return;
-    for (i = 0; i < fai->n; ++i) free(fai->name[i]);
-    free(fai->name);
-    kh_destroy(s, fai->hash);
-    if (fai->bgzf) bgzf_close(fai->bgzf);
-    free(fai);
-}
-
-
-static int fai_build3_core(const char *fn, const char *fnfai, const char *fngzi)
-{
-    kstring_t fai_kstr = { 0, 0, NULL };
-    kstring_t gzi_kstr = { 0, 0, NULL };
-    BGZF *bgzf = NULL;
-    hFILE *fp = NULL;
-    faidx_t *fai = NULL;
-    int save_errno, res;
-    char *file_type;
-
-    bgzf = bgzf_open(fn, "r");
-
-    if ( !bgzf ) {
-        hts_log_error("Failed to open the file %s", fn);
-        goto fail;
-    }
-
-    if ( bgzf->is_compressed ) {
-        if (bgzf_index_build_init(bgzf) != 0) {
-            hts_log_error("Failed to allocate bgzf index");
-            goto fail;
-        }
-    }
-
-    fai = fai_build_core(bgzf);
-
-    if ( !fai ) {
-        if (bgzf->is_compressed && bgzf->is_gzip) {
-            hts_log_error("Cannot index files compressed with gzip, please use bgzip");
-        }
-        goto fail;
-    }
-
-    if (fai->format == FAI_FASTA) {
-        file_type   = "FASTA";
-    } else {
-        file_type   = "FASTQ";
-    }
-
-    if (!fnfai) {
-        if (ksprintf(&fai_kstr, "%s.fai", fn) < 0) goto fail;
-        fnfai = fai_kstr.s;
-    }
-
-    if (!fngzi) {
-        if (ksprintf(&gzi_kstr, "%s.gzi", fn) < 0) goto fail;
-        fngzi = gzi_kstr.s;
-    }
-
-    if ( bgzf->is_compressed ) {
-        if (bgzf_index_dump(bgzf, fngzi, NULL) < 0) {
-            hts_log_error("Failed to make bgzf index %s", fngzi);
-            goto fail;
-        }
-    }
-
-    res = bgzf_close(bgzf);
-    bgzf = NULL;
-
-    if (res < 0) {
-        hts_log_error("Error on closing %s : %s", fn, strerror(errno));
-        goto fail;
-    }
-
-    fp = hopen(fnfai, "wb");
-
-    if ( !fp ) {
-        hts_log_error("Failed to open %s index %s : %s", file_type, fnfai, strerror(errno));
-        goto fail;
-    }
-
-    if (fai_save(fai, fp) != 0) {
-        hts_log_error("Failed to write %s index %s : %s", file_type, fnfai, strerror(errno));
-        goto fail;
-    }
-
-    if (hclose(fp) != 0) {
-        hts_log_error("Failed on closing %s index %s : %s", file_type, fnfai, strerror(errno));
-        goto fail;
-    }
-
-    free(fai_kstr.s);
-    free(gzi_kstr.s);
-    fai_destroy(fai);
-    return 0;
-
- fail:
-    save_errno = errno;
-    free(fai_kstr.s);
-    free(gzi_kstr.s);
-    bgzf_close(bgzf);
-    fai_destroy(fai);
-    errno = save_errno;
-    return -1;
-}
-
-
-int fai_build3(const char *fn, const char *fnfai, const char *fngzi) {
-    return fai_build3_core(fn, fnfai, fngzi);
-}
-
-
-int fai_build(const char *fn) {
-    return fai_build3(fn, NULL, NULL);
-}
-
-
-static faidx_t *fai_load3_core(const char *fn, const char *fnfai, const char *fngzi,
-                   int flags, int format)
-{
-    kstring_t fai_kstr = { 0, 0, NULL };
-    kstring_t gzi_kstr = { 0, 0, NULL };
-    hFILE *fp = NULL;
-    faidx_t *fai = NULL;
-    int res, gzi_index_needed = 0;
-    char *file_type;
-
-    if (format == FAI_FASTA) {
-        file_type   = "FASTA";
-    } else {
-        file_type   = "FASTQ";
-    }
-
-    if (fn == NULL)
-        return NULL;
-
-    if (fnfai == NULL) {
-        if (ksprintf(&fai_kstr, "%s.fai", fn) < 0) goto fail;
-        fnfai = fai_kstr.s;
-    }
-    if (fngzi == NULL) {
-        if (ksprintf(&gzi_kstr, "%s.gzi", fn) < 0) goto fail;
-        fngzi = gzi_kstr.s;
-    }
-
-    fp = hopen(fnfai, "rb");
-
-    if (fp) {
-        // index file present, check if a compressed index is needed
-        hFILE *gz = NULL;
-        BGZF *bgzf = bgzf_open(fn, "rb");
-
-        if (bgzf == 0) {
-            hts_log_error("Failed to open %s file %s", file_type, fn);
-            goto fail;
-        }
-
-        if (bgzf_compression(bgzf) == 2) { // BGZF compression
-            if ((gz = hopen(fngzi, "rb")) == 0) {
-
-                if (!(flags & FAI_CREATE) || errno != ENOENT) {
-                    hts_log_error("Failed to open %s index %s: %s", file_type, fngzi, strerror(errno));
-                    bgzf_close(bgzf);
-                    goto fail;
-                }
-
-                gzi_index_needed = 1;
-                res = hclose(fp); // closed as going to be re-indexed
-
-                if (res < 0) {
-                    hts_log_error("Failed on closing %s index %s : %s", file_type, fnfai, strerror(errno));
-                    goto fail;
-                }
-            } else {
-                res = hclose(gz);
-
-                if (res < 0) {
-                    hts_log_error("Failed on closing %s index %s : %s", file_type, fngzi, strerror(errno));
-                    goto fail;
-                }
-            }
-        }
-
-        bgzf_close(bgzf);
-    }
-
-    if (fp == 0 || gzi_index_needed) {
-        if (!(flags & FAI_CREATE) || errno != ENOENT) {
-            hts_log_error("Failed to open %s index %s: %s", file_type, fnfai, strerror(errno));
-            goto fail;
-        }
-
-        hts_log_info("Build %s index", file_type);
-
-        if (fai_build3_core(fn, fnfai, fngzi) < 0) {
-            goto fail;
-        }
-
-        fp = hopen(fnfai, "rb");
-        if (fp == 0) {
-            hts_log_error("Failed to open %s index %s: %s", file_type, fnfai, strerror(errno));
-            goto fail;
-        }
-    }
-
-    fai = fai_read(fp, fnfai, format);
-    if (fai == NULL) {
-        hts_log_error("Failed to read %s index %s", file_type, fnfai);
-        goto fail;
-    }
-
-    res = hclose(fp);
-    fp = NULL;
-    if (res < 0) {
-        hts_log_error("Failed on closing %s index %s : %s", file_type, fnfai, strerror(errno));
-        goto fail;
-    }
-
-    fai->bgzf = bgzf_open(fn, "rb");
-    if (fai->bgzf == 0) {
-        hts_log_error("Failed to open %s file %s", file_type, fn);
-        goto fail;
-    }
-
-    if ( fai->bgzf->is_compressed==1 ) {
-        if ( bgzf_index_load(fai->bgzf, fngzi, NULL) < 0 ) {
-            hts_log_error("Failed to load .gzi index: %s", fngzi);
-            goto fail;
-        }
-    }
-    free(fai_kstr.s);
-    free(gzi_kstr.s);
-    return fai;
-
- fail:
-    if (fai) fai_destroy(fai);
-    if (fp) hclose_abruptly(fp);
-    free(fai_kstr.s);
-    free(gzi_kstr.s);
-    return NULL;
-}
-
-
-faidx_t *fai_load3(const char *fn, const char *fnfai, const char *fngzi,
-                   int flags) {
-    return fai_load3_core(fn, fnfai, fngzi, flags, FAI_FASTA);
-}
-
-
-faidx_t *fai_load(const char *fn)
-{
-    return fai_load3(fn, NULL, NULL, FAI_CREATE);
-}
-
-
-faidx_t *fai_load3_format(const char *fn, const char *fnfai, const char *fngzi,
-                   int flags, enum fai_format_options format) {
-    return fai_load3_core(fn, fnfai, fngzi, flags, format);
-}
-
-
-faidx_t *fai_load_format(const char *fn, enum fai_format_options format) {
-    return fai_load3_format(fn, NULL, NULL, FAI_CREATE, format);
-}
-
-
-static char *fai_retrieve(const faidx_t *fai, const faidx1_t *val,
-                          uint64_t offset, hts_pos_t beg, hts_pos_t end, hts_pos_t *len) {
-    char *s;
-    size_t l;
-    int c = 0;
-    int ret;
-
-    if ((uint64_t) end - (uint64_t) beg >= SIZE_MAX - 2) {
-        hts_log_error("Range %"PRId64"..%"PRId64" too big", beg, end);
-        *len = -1;
-        return NULL;
-    }
-
-    ret = bgzf_useek(fai->bgzf,
-                     offset
-                     + beg / val->line_blen * val->line_len
-                     + beg % val->line_blen, SEEK_SET);
-
-    if (ret < 0) {
-        *len = -1;
-        hts_log_error("Failed to retrieve block. (Seeking in a compressed, .gzi unindexed, file?)");
-        return NULL;
-    }
-
-    l = 0;
-    s = (char*)malloc((size_t) end - beg + 2);
-    if (!s) {
-        *len = -1;
-        return NULL;
-    }
-
-    while ( l < end - beg && (c=bgzf_getc(fai->bgzf))>=0 )
-        if (isgraph(c)) s[l++] = c;
-    if (c < 0) {
-        hts_log_error("Failed to retrieve block: %s",
-            c == -1 ? "unexpected end of file" : "error reading file");
-        free(s);
-        *len = -1;
-        return NULL;
-    }
-
-    s[l] = '\0';
-    *len = l < INT_MAX ? l : INT_MAX;
-    return s;
-}
-
-static int fai_get_val(const faidx_t *fai, const char *str,
-                       hts_pos_t *len, faidx1_t *val, hts_pos_t *fbeg, hts_pos_t *fend) {
-    khiter_t iter;
-    khash_t(s) *h;
-    int id;
-    hts_pos_t beg, end;
-
-    if (!fai_parse_region(fai, str, &id, &beg, &end, 0)) {
-        hts_log_warning("Reference %s not found in FASTA file, returning empty sequence", str);
-        *len = -2;
-        return 1;
-    }
-
-    h = fai->hash;
-    iter = kh_get(s, h, faidx_iseq(fai, id));
-    if (iter >= kh_end(h)) {
-        // should have already been caught above
-        abort();
-    }
-    *val = kh_value(h, iter);
-
-    if (beg >= val->len) beg = val->len;
-    if (end >= val->len) end = val->len;
-    if (beg > end) beg = end;
-
-    *fbeg = beg;
-    *fend = end;
-
-    return 0;
-}
-
-
-char *fai_fetch64(const faidx_t *fai, const char *str, hts_pos_t *len)
-{
-    faidx1_t val;
-    int64_t beg, end;
-
-    if (fai_get_val(fai, str, len, &val, &beg, &end)) {
-        return NULL;
-    }
-
-    // now retrieve the sequence
-    return fai_retrieve(fai, &val, val.seq_offset, beg, end, len);
-}
-
-char *fai_fetch(const faidx_t *fai, const char *str, int *len)
-{
-    hts_pos_t len64;
-    char *ret = fai_fetch64(fai, str, &len64);
-    *len = len64; // trunc
-    return ret;
-}
-
-char *fai_fetchqual64(const faidx_t *fai, const char *str, hts_pos_t *len) {
-    faidx1_t val;
-    int64_t beg, end;
-
-    if (fai_get_val(fai, str, len, &val, &beg, &end)) {
-        return NULL;
-    }
-
-    // now retrieve the sequence
-    return fai_retrieve(fai, &val, val.qual_offset, beg, end, len);
-}
-
-char *fai_fetchqual(const faidx_t *fai, const char *str, int *len) {
-    hts_pos_t len64;
-    char *ret = fai_fetchqual64(fai, str, &len64);
-    *len = len64; // trunc
-    return ret;
-}
-
-int faidx_fetch_nseq(const faidx_t *fai)
-{
-    return fai->n;
-}
-
-int faidx_nseq(const faidx_t *fai)
-{
-    return fai->n;
-}
-
-const char *faidx_iseq(const faidx_t *fai, int i)
-{
-    return fai->name[i];
-}
-
-int faidx_seq_len(const faidx_t *fai, const char *seq)
-{
-    khint_t k = kh_get(s, fai->hash, seq);
-    if ( k == kh_end(fai->hash) ) return -1;
-    return kh_val(fai->hash, k).len;
-}
-
-static int faidx_adjust_position(const faidx_t *fai, faidx1_t *val, const char *c_name, hts_pos_t *p_beg_i, hts_pos_t *p_end_i, hts_pos_t *len) {
-    khiter_t iter;
-
-    // Adjust position
-    iter = kh_get(s, fai->hash, c_name);
-
-    if (iter == kh_end(fai->hash)) {
-        *len = -2;
-        hts_log_error("The sequence \"%s\" was not found", c_name);
-        return 1;
-    }
-
-    *val = kh_value(fai->hash, iter);
-
-    if(*p_end_i < *p_beg_i)
-        *p_beg_i = *p_end_i;
-
-    if(*p_beg_i < 0)
-        *p_beg_i = 0;
-    else if(val->len <= *p_beg_i)
-        *p_beg_i = val->len - 1;
-
-    if(*p_end_i < 0)
-        *p_end_i = 0;
-    else if(val->len <= *p_end_i)
-        *p_end_i = val->len - 1;
-
-    return 0;
-}
-
-char *faidx_fetch_seq64(const faidx_t *fai, const char *c_name, hts_pos_t p_beg_i, hts_pos_t p_end_i, hts_pos_t *len)
-{
-    faidx1_t val;
-
-    // Adjust position
-    if (faidx_adjust_position(fai, &val, c_name, &p_beg_i, &p_end_i, len)) {
-        return NULL;
-    }
-
-    // Now retrieve the sequence
-    return fai_retrieve(fai, &val, val.seq_offset, p_beg_i, p_end_i + 1, len);
-}
-
-char *faidx_fetch_seq(const faidx_t *fai, const char *c_name, int p_beg_i, int p_end_i, int *len)
-{
-    hts_pos_t len64;
-    char *ret = faidx_fetch_seq64(fai, c_name, p_beg_i, p_end_i, &len64);
-    *len = len64;  // trunc
-    return ret;
-}
-
-char *faidx_fetch_qual64(const faidx_t *fai, const char *c_name, hts_pos_t p_beg_i, hts_pos_t p_end_i, hts_pos_t *len)
-{
-    faidx1_t val;
-
-    // Adjust position
-    if (faidx_adjust_position(fai, &val, c_name, &p_beg_i, &p_end_i, len)) {
-        return NULL;
-    }
-
-    // Now retrieve the sequence
-    return fai_retrieve(fai, &val, val.qual_offset, p_beg_i, p_end_i + 1, len);
-}
-
-char *faidx_fetch_qual(const faidx_t *fai, const char *c_name, int p_beg_i, int p_end_i, int *len)
-{
-    hts_pos_t len64;
-    char *ret = faidx_fetch_qual64(fai, c_name, p_beg_i, p_end_i, &len64);
-    *len = len64;  // trunc
-    return ret;
-}
-
-int faidx_has_seq(const faidx_t *fai, const char *seq)
-{
-    khiter_t iter = kh_get(s, fai->hash, seq);
-    if (iter == kh_end(fai->hash)) return 0;
-    return 1;
-}
-
-const char *fai_parse_region(const faidx_t *fai, const char *s,
-                             int *tid, hts_pos_t *beg, hts_pos_t *end,
-                             int flags)
-{
-    return hts_parse_region(s, tid, beg, end, (hts_name2id_f)fai_name2id, (void *)fai, flags);
-}
-
-void fai_set_cache_size(faidx_t *fai, int cache_size) {
-    bgzf_set_cache_size(fai->bgzf, cache_size);
-}
-
-char *fai_path(const char *fa) {
-    char *fai = NULL;
-    if (!fa) {
-        hts_log_error("No reference file specified");
-    } else {
-        char *fai_tmp = strstr(fa, HTS_IDX_DELIM);
-        if (fai_tmp) {
-            fai_tmp += strlen(HTS_IDX_DELIM);
-            fai = strdup(fai_tmp);
-            if (!fai)
-                hts_log_error("Failed to allocate memory");
-        } else {
-            if (hisremote(fa)) {
-                fai = hts_idx_locatefn(fa, ".fai");       // get the remote fai file name, if any, but do not download the file
-                if (!fai)
-                    hts_log_error("Failed to locate index file for remote reference file '%s'", fa);
-            } else{
-                if (hts_idx_check_local(fa, HTS_FMT_FAI, &fai) == 0 && fai) {
-                    if (fai_build3(fa, fai, NULL) == -1) {      // create local fai file by indexing local fasta
-                        hts_log_error("Failed to build index file for reference file '%s'", fa);
-                        free(fai);
-                        fai = NULL;
-                    }
-                }
-            }
-        }
-    }
-
-    return fai;
-}
diff -ruN stringtie.orig/htslib/header.c stringtie/htslib/header.c
--- stringtie.orig/htslib/header.c	2024-02-28 13:57:39.701246126 +0100
+++ stringtie/htslib/header.c	1970-01-01 01:00:00.000000000 +0100
@@ -1,2735 +0,0 @@
-/*
-Copyright (c) 2018-2020 Genome Research Ltd.
-Authors: James Bonfield <jkb@sanger.ac.uk>, Valeriu Ohan <vo2@sanger.ac.uk>
-
-Redistribution and use in source and binary forms, with or without
-modification, are permitted provided that the following conditions are met:
-
-   1. Redistributions of source code must retain the above copyright notice,
-this list of conditions and the following disclaimer.
-
-   2. Redistributions in binary form must reproduce the above copyright notice,
-this list of conditions and the following disclaimer in the documentation
-and/or other materials provided with the distribution.
-
-   3. Neither the names Genome Research Ltd and Wellcome Trust Sanger
-Institute nor the names of its contributors may be used to endorse or promote
-products derived from this software without specific prior written permission.
-
-THIS SOFTWARE IS PROVIDED BY GENOME RESEARCH LTD AND CONTRIBUTORS "AS IS" AND
-ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
-WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
-DISCLAIMED. IN NO EVENT SHALL GENOME RESEARCH LTD OR CONTRIBUTORS BE LIABLE
-FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
-DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
-SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
-CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
-OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
-OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-*/
-
-#define HTS_BUILDING_LIBRARY // Enables HTSLIB_EXPORT, see htslib/hts_defs.h
-#include <config.h>
-
-#include <string.h>
-#include <assert.h>
-#include <errno.h>
-#include "textutils_internal.h"
-#include "header.h"
-
-// Hash table for removing multiple lines from the header
-KHASH_SET_INIT_STR(rm)
-// Used for long refs in SAM files
-KHASH_DECLARE(s2i, kh_cstr_t, int64_t)
-
-typedef khash_t(rm) rmhash_t;
-
-static int sam_hdr_link_pg(sam_hdr_t *bh);
-
-static int sam_hrecs_vupdate(sam_hrecs_t *hrecs, sam_hrec_type_t *type, va_list ap);
-static int sam_hrecs_update(sam_hrecs_t *hrecs, sam_hrec_type_t *type, ...);
-
-
-#define MAX_ERROR_QUOTE 320 // Prevent over-long error messages
-static void sam_hrecs_error(const char *msg, const char *line, size_t len, size_t lno) {
-    int j;
-
-    if (len > MAX_ERROR_QUOTE)
-        len = MAX_ERROR_QUOTE;
-    for (j = 0; j < len && line[j] != '\n'; j++)
-        ;
-    hts_log_error("%s at line %zd: \"%.*s\"", msg, lno, j, line);
-}
-
-/* ==== Static methods ==== */
-
-static int sam_hrecs_init_type_order(sam_hrecs_t *hrecs, char *type_list) {
-    if (!hrecs)
-        return -1;
-
-    if (!type_list) {
-        hrecs->type_count = 5;
-        hrecs->type_order = calloc(hrecs->type_count, 3);
-        if (!hrecs->type_order)
-            return -1;
-        memcpy(hrecs->type_order[0], "HD", 2);
-        memcpy(hrecs->type_order[1], "SQ", 2);
-        memcpy(hrecs->type_order[2], "RG", 2);
-        memcpy(hrecs->type_order[3], "PG", 2);
-        memcpy(hrecs->type_order[4], "CO", 2);
-    }
-
-    return 0;
-}
-
-static int sam_hrecs_add_ref_altnames(sam_hrecs_t *hrecs, int nref, const char *list) {
-    const char *token;
-    ks_tokaux_t aux;
-
-    if (!list)
-        return 0;
-
-    for (token = kstrtok(list, ",", &aux); token; token = kstrtok(NULL, NULL, &aux)) {
-        if (aux.p == token)
-            continue;
-
-        char *name = string_ndup(hrecs->str_pool, token, aux.p - token);
-        if (!name)
-            return -1;
-        int r;
-        khint_t k = kh_put(m_s2i, hrecs->ref_hash, name, &r);
-        if (r < 0) return -1;
-
-        if (r > 0)
-            kh_val(hrecs->ref_hash, k) = nref;
-        else if (kh_val(hrecs->ref_hash, k) != nref)
-            hts_log_warning("Duplicate entry AN:\"%s\" in sam header", name);
-    }
-
-    return 0;
-}
-
-static void sam_hrecs_remove_ref_altnames(sam_hrecs_t *hrecs, int expected, const char *list) {
-    const char *token, *sn;
-    ks_tokaux_t aux;
-    kstring_t str = KS_INITIALIZE;
-
-    if (expected < 0 || expected >= hrecs->nref)
-        return;
-    sn = hrecs->ref[expected].name;
-
-    for (token = kstrtok(list, ",", &aux); token; token = kstrtok(NULL, NULL, &aux)) {
-        kputsn(token, aux.p - token, ks_clear(&str));
-        khint_t k = kh_get(m_s2i, hrecs->ref_hash, str.s);
-        if (k != kh_end(hrecs->ref_hash)
-            && kh_val(hrecs->ref_hash, k) == expected
-            && strcmp(sn, str.s) != 0)
-            kh_del(m_s2i, hrecs->ref_hash, k);
-    }
-
-    free(str.s);
-}
-
-/* Updates the hash tables in the sam_hrecs_t structure.
- *
- * Returns 0 on success;
- *        -1 on failure
- */
-static int sam_hrecs_update_hashes(sam_hrecs_t *hrecs,
-                                   khint32_t type,
-                                   sam_hrec_type_t *h_type) {
-    /* Add to reference hash? */
-    if (type == TYPEKEY("SQ")) {
-        sam_hrec_tag_t *tag = h_type->tag;
-        int nref = hrecs->nref;
-        const char *name = NULL;
-        const char *altnames = NULL;
-        hts_pos_t len = -1;
-        int r;
-        khint_t k;
-
-        while (tag) {
-            if (tag->str[0] == 'S' && tag->str[1] == 'N') {
-                assert(tag->len >= 3);
-                name = tag->str+3;
-            } else if (tag->str[0] == 'L' && tag->str[1] == 'N') {
-                assert(tag->len >= 3);
-                len = strtoll(tag->str+3, NULL, 10);
-            } else if (tag->str[0] == 'A' && tag->str[1] == 'N') {
-                assert(tag->len >= 3);
-                altnames = tag->str+3;
-            }
-            tag = tag->next;
-        }
-
-        if (!name) {
-            hts_log_error("Header includes @SQ line with no SN: tag");
-            return -1; // SN should be present, according to spec.
-        }
-
-        if (len == -1) {
-            hts_log_error("Header includes @SQ line \"%s\" with no LN: tag",
-                          name);
-            return -1; // LN should be present, according to spec.
-        }
-
-        // Seen already?
-        k = kh_get(m_s2i, hrecs->ref_hash, name);
-        if (k < kh_end(hrecs->ref_hash)) {
-            nref = kh_val(hrecs->ref_hash, k);
-            int ref_changed_flag = 0;
-
-            // Check for hash entry added by sam_hrecs_refs_from_targets_array()
-            if (hrecs->ref[nref].ty == NULL) {
-                // Attach header line to existing stub entry.
-                hrecs->ref[nref].ty = h_type;
-                // Check lengths match; correct if not.
-                if (len != hrecs->ref[nref].len) {
-                    char tmp[32];
-                    snprintf(tmp, sizeof(tmp), "%" PRIhts_pos,
-                             hrecs->ref[nref].len);
-                    if (sam_hrecs_update(hrecs, h_type, "LN", tmp, NULL) < 0)
-                        return -1;
-                    ref_changed_flag = 1;
-                }
-                if (sam_hrecs_add_ref_altnames(hrecs, nref, altnames) < 0)
-                    return -1;
-
-                if (ref_changed_flag && (hrecs->refs_changed < 0 || hrecs->refs_changed > nref))
-                    hrecs->refs_changed = nref;
-                return 0;
-            }
-
-            // Check to see if an existing entry is being updated
-            if (hrecs->ref[nref].ty == h_type) {
-                if (hrecs->ref[nref].len != len) {
-                    hrecs->ref[nref].len = len;
-                    ref_changed_flag = 1;
-                }
-                if (!hrecs->ref[nref].name || strcmp(hrecs->ref[nref].name, name)) {
-                    hrecs->ref[nref].name = name;
-                    ref_changed_flag = 1;
-                }
-                if (sam_hrecs_add_ref_altnames(hrecs, nref, altnames) < 0)
-                    return -1;
-
-                if (ref_changed_flag && (hrecs->refs_changed < 0 || hrecs->refs_changed > nref))
-                    hrecs->refs_changed = nref;
-                return 0;
-            }
-
-            // If here, the name is a duplicate.
-            // Check to see if it matches the SN: tag from the earlier record.
-            if (strcmp(hrecs->ref[nref].name, name) == 0) {
-                hts_log_error("Duplicate entry \"%s\" in sam header",
-                                name);
-                return -1;
-            }
-
-            // Clash with an already-seen altname
-            // As SN: should be preferred to AN: add this as a new
-            // record and update the hash entry to point to it.
-            hts_log_warning("Ref name SN:\"%s\" is a duplicate of an existing AN key", name);
-            nref = hrecs->nref;
-        }
-
-        if (nref == hrecs->ref_sz) {
-            size_t new_sz = hrecs->ref_sz >= 4 ? hrecs->ref_sz + (hrecs->ref_sz / 4) : 32;
-            sam_hrec_sq_t *new_ref = realloc(hrecs->ref, sizeof(*hrecs->ref) * new_sz);
-            if (!new_ref)
-                return -1;
-            hrecs->ref = new_ref;
-            hrecs->ref_sz = new_sz;
-        }
-
-        hrecs->ref[nref].name = name;
-        hrecs->ref[nref].len  = len;
-        hrecs->ref[nref].ty = h_type;
-
-        k = kh_put(m_s2i, hrecs->ref_hash, hrecs->ref[nref].name, &r);
-        if (-1 == r) return -1;
-        kh_val(hrecs->ref_hash, k) = nref;
-
-        if (sam_hrecs_add_ref_altnames(hrecs, nref, altnames) < 0)
-            return -1;
-
-        if (hrecs->refs_changed < 0 || hrecs->refs_changed > hrecs->nref)
-            hrecs->refs_changed = hrecs->nref;
-        hrecs->nref++;
-    }
-
-    /* Add to read-group hash? */
-    if (type == TYPEKEY("RG")) {
-        sam_hrec_tag_t *tag = sam_hrecs_find_key(h_type, "ID", NULL);
-        int nrg = hrecs->nrg, r;
-        khint_t k;
-
-        if (!tag) {
-            hts_log_error("Header includes @RG line with no ID: tag");
-            return -1;  // ID should be present, according to spec.
-        }
-        assert(tag->str && tag->len >= 3);
-
-        // Seen already?
-        k = kh_get(m_s2i, hrecs->rg_hash, tag->str + 3);
-        if (k < kh_end(hrecs->rg_hash)) {
-            nrg = kh_val(hrecs->rg_hash, k);
-            assert(hrecs->rg[nrg].ty != NULL);
-            if (hrecs->rg[nrg].ty != h_type) {
-                hts_log_warning("Duplicate entry \"%s\" in sam header",
-                                tag->str + 3);
-            } else {
-                hrecs->rg[nrg].name = tag->str + 3;
-                hrecs->rg[nrg].name_len = tag->len - 3;
-            }
-            return 0;
-        }
-
-        if (nrg == hrecs->rg_sz) {
-            size_t new_sz = hrecs->rg_sz >= 4 ? hrecs->rg_sz + hrecs->rg_sz / 4 : 4;
-            sam_hrec_rg_t *new_rg = realloc(hrecs->rg, sizeof(*hrecs->rg) * new_sz);
-            if (!new_rg)
-                return -1;
-            hrecs->rg = new_rg;
-            hrecs->rg_sz = new_sz;
-        }
-
-        hrecs->rg[nrg].name = tag->str + 3;
-        hrecs->rg[nrg].name_len = tag->len - 3;
-        hrecs->rg[nrg].ty   = h_type;
-        hrecs->rg[nrg].id   = nrg;
-
-        k = kh_put(m_s2i, hrecs->rg_hash, hrecs->rg[nrg].name, &r);
-        if (-1 == r) return -1;
-        kh_val(hrecs->rg_hash, k) = nrg;
-
-        hrecs->nrg++;
-    }
-
-    /* Add to program hash? */
-    if (type == TYPEKEY("PG")) {
-        sam_hrec_tag_t *tag;
-        sam_hrec_pg_t *new_pg;
-        int npg = hrecs->npg;
-
-        if (npg == hrecs->pg_sz) {
-            size_t new_sz = hrecs->pg_sz >= 4 ? hrecs->pg_sz + hrecs->pg_sz / 4 : 4;
-            new_pg = realloc(hrecs->pg, sizeof(*hrecs->pg) * new_sz);
-            if (!new_pg)
-                return -1;
-            hrecs->pg = new_pg;
-            hrecs->pg_sz = new_sz;
-        }
-
-        tag = h_type->tag;
-        hrecs->pg[npg].name = NULL;
-        hrecs->pg[npg].name_len = 0;
-        hrecs->pg[npg].ty  = h_type;
-        hrecs->pg[npg].id   = npg;
-        hrecs->pg[npg].prev_id = -1;
-
-        while (tag) {
-            if (tag->str[0] == 'I' && tag->str[1] == 'D') {
-                assert(tag->len >= 3);
-                hrecs->pg[npg].name = tag->str + 3;
-                hrecs->pg[npg].name_len = tag->len - 3;
-            } else if (tag->str[0] == 'P' && tag->str[1] == 'P') {
-                // Resolve later if needed
-                khint_t k;
-                k = kh_get(m_s2i, hrecs->pg_hash, tag->str+3);
-
-                if (k != kh_end(hrecs->pg_hash)) {
-                    int p_id = kh_val(hrecs->pg_hash, k);
-                    hrecs->pg[npg].prev_id = hrecs->pg[p_id].id;
-
-                    /* Unmark previous entry as a PG termination */
-                    if (hrecs->npg_end > 0 &&
-                        hrecs->pg_end[hrecs->npg_end-1] == p_id) {
-                        hrecs->npg_end--;
-                    } else {
-                        int i;
-                        for (i = 0; i < hrecs->npg_end; i++) {
-                            if (hrecs->pg_end[i] == p_id) {
-                                memmove(&hrecs->pg_end[i], &hrecs->pg_end[i+1],
-                                        (hrecs->npg_end-i-1)*sizeof(*hrecs->pg_end));
-                                hrecs->npg_end--;
-                            }
-                        }
-                    }
-                } else {
-                    hrecs->pg[npg].prev_id = -1;
-                }
-            }
-            tag = tag->next;
-        }
-
-        if (hrecs->pg[npg].name) {
-            khint_t k;
-            int r;
-            k = kh_put(m_s2i, hrecs->pg_hash, hrecs->pg[npg].name, &r);
-            if (-1 == r) return -1;
-            kh_val(hrecs->pg_hash, k) = npg;
-        } else {
-            return -1; // ID should be present, according to spec.
-        }
-
-        /* Add to npg_end[] array. Remove later if we find a PP line */
-        if (hrecs->npg_end >= hrecs->npg_end_alloc) {
-            int *new_pg_end;
-            int  new_alloc = hrecs->npg_end_alloc ? hrecs->npg_end_alloc*2 : 4;
-
-            new_pg_end = realloc(hrecs->pg_end, new_alloc * sizeof(int));
-            if (!new_pg_end)
-                return -1;
-            hrecs->npg_end_alloc = new_alloc;
-            hrecs->pg_end = new_pg_end;
-        }
-        hrecs->pg_end[hrecs->npg_end++] = npg;
-
-        hrecs->npg++;
-    }
-
-    return 0;
-}
-
-static int sam_hrecs_remove_hash_entry(sam_hrecs_t *hrecs, khint32_t type, sam_hrec_type_t *h_type) {
-    if (!hrecs || !h_type)
-        return -1;
-
-    sam_hrec_tag_t *tag;
-    const char *key = NULL;
-    khint_t k;
-
-    /* Remove name and any alternative names from reference hash */
-    if (type == TYPEKEY("SQ")) {
-        const char *altnames = NULL;
-
-        tag = h_type->tag;
-
-        while (tag) {
-            if (tag->str[0] == 'S' && tag->str[1] == 'N') {
-                assert(tag->len >= 3);
-                key = tag->str + 3;
-            } else if (tag->str[0] == 'A' && tag->str[1] == 'N') {
-                assert(tag->len >= 3);
-                altnames = tag->str + 3;
-            }
-            tag = tag->next;
-        }
-
-        if (key) {
-            k = kh_get(m_s2i, hrecs->ref_hash, key);
-            if (k != kh_end(hrecs->ref_hash)) {
-                int idx = kh_val(hrecs->ref_hash, k);
-                if (idx + 1 < hrecs->nref)
-                    memmove(&hrecs->ref[idx], &hrecs->ref[idx+1],
-                            sizeof(sam_hrec_sq_t)*(hrecs->nref - idx - 1));
-                if (altnames)
-                    sam_hrecs_remove_ref_altnames(hrecs, idx, altnames);
-                kh_del(m_s2i, hrecs->ref_hash, k);
-                hrecs->nref--;
-                if (hrecs->refs_changed < 0 || hrecs->refs_changed > idx)
-                    hrecs->refs_changed = idx;
-                for (k = 0; k < kh_end(hrecs->ref_hash); k++) {
-                    if (kh_exist(hrecs->ref_hash, k)
-                        && kh_value(hrecs->ref_hash, k) > idx) {
-                        kh_value(hrecs->ref_hash, k)--;
-                    }
-                }
-            }
-        }
-    }
-
-    /* Remove from read-group hash */
-    if (type == TYPEKEY("RG")) {
-        tag = h_type->tag;
-
-        while (tag) {
-            if (tag->str[0] == 'I' && tag->str[1] == 'D') {
-                assert(tag->len >= 3);
-                key = tag->str + 3;
-                k = kh_get(m_s2i, hrecs->rg_hash, key);
-                if (k != kh_end(hrecs->rg_hash)) {
-                    int idx = kh_val(hrecs->rg_hash, k);
-                    if (idx + 1 < hrecs->nrg)
-                        memmove(&hrecs->rg[idx], &hrecs->rg[idx+1], sizeof(sam_hrec_rg_t)*(hrecs->nrg - idx - 1));
-                    kh_del(m_s2i, hrecs->rg_hash, k);
-                    hrecs->nrg--;
-                    for (k = 0; k < kh_end(hrecs->rg_hash); k++) {
-                        if (kh_exist(hrecs->rg_hash, k)
-                            && kh_value(hrecs->rg_hash, k) > idx) {
-                            kh_value(hrecs->rg_hash, k)--;
-                        }
-                    }
-                }
-                break;
-            }
-            tag = tag->next;
-        }
-    }
-
-    return 0;
-}
-
-/** Add a header record to the global line ordering
- *
- * If @p after is not NULL, the new record will be inserted after this one,
- * otherwise it will go at the end.
- *
- * An exception is an HD record, which will always be put first unless
- * one is already present.
- */
-static void sam_hrecs_global_list_add(sam_hrecs_t *hrecs,
-                                      sam_hrec_type_t *h_type,
-                                      sam_hrec_type_t *after) {
-    const khint32_t hd_type = TYPEKEY("HD");
-    int update_first_line = 0;
-
-    // First line seen
-    if (!hrecs->first_line) {
-        hrecs->first_line = h_type->global_next = h_type->global_prev = h_type;
-        return;
-    }
-
-    // @HD goes at the top (unless there's one already)
-    if (h_type->type == hd_type && hrecs->first_line->type != hd_type) {
-        after = hrecs->first_line->global_prev;
-        update_first_line = 1;
-    }
-
-    // If no instructions given, put it at the end
-    if (!after)
-        after = hrecs->first_line->global_prev;
-
-    h_type->global_prev = after;
-    h_type->global_next = after->global_next;
-    h_type->global_prev->global_next = h_type;
-    h_type->global_next->global_prev = h_type;
-
-    if (update_first_line)
-        hrecs->first_line = h_type;
-}
-
-/*! Add header record with a va_list interface.
- *
- * Adds a single record to a SAM header.
- *
- * This takes a header record type, a va_list argument and one or more
- * key,value pairs, ending with the NULL key.
- *
- * Eg. sam_hrecs_vadd(h, "SQ", args, "ID", "foo", "LN", "100", NULL).
- *
- * The purpose of the additional va_list parameter is to permit other
- * varargs functions to call this while including their own additional
- * parameters; an example is in sam_hdr_add_pg().
- *
- * Note: this function invokes va_arg at least once, making the value
- * of ap indeterminate after the return. The caller should call
- * va_start/va_end before/after calling this function or use va_copy.
- *
- * @return
- * Returns >= 0 on success;
- *        -1 on failure
- */
-static int sam_hrecs_vadd(sam_hrecs_t *hrecs, const char *type, va_list ap, ...) {
-    va_list args;
-    sam_hrec_type_t *h_type;
-    sam_hrec_tag_t *h_tag, *last=NULL;
-    int new;
-    khint32_t type_i = TYPEKEY(type), k;
-
-    if (!strncmp(type, "HD", 2) && (h_type = sam_hrecs_find_type_id(hrecs, "HD", NULL, NULL)))
-        return sam_hrecs_vupdate(hrecs, h_type, ap);
-
-    if (!(h_type = pool_alloc(hrecs->type_pool)))
-        return -1;
-    k = kh_put(sam_hrecs_t, hrecs->h, type_i, &new);
-    if (new < 0)
-        return -1;
-
-    h_type->type = type_i;
-
-    // Form the ring, either with self or other lines of this type
-    if (!new) {
-        sam_hrec_type_t *t = kh_val(hrecs->h, k), *p;
-        p = t->prev;
-
-        assert(p->next == t);
-        p->next = h_type;
-        h_type->prev = p;
-
-        t->prev = h_type;
-        h_type->next = t;
-    } else {
-        kh_val(hrecs->h, k) = h_type;
-        h_type->prev = h_type->next = h_type;
-    }
-    h_type->tag = NULL;
-
-    // Add to global line ordering after any existing line of the same type,
-    // or at the end if no line of this type exists yet.
-    sam_hrecs_global_list_add(hrecs, h_type, !new ? h_type->prev : NULL);
-
-    // Check linked-list invariants
-    assert(h_type->prev->next == h_type);
-    assert(h_type->next->prev == h_type);
-    assert(h_type->global_prev->global_next == h_type);
-    assert(h_type->global_next->global_prev == h_type);
-
-    // Any ... varargs
-    va_start(args, ap);
-    for (;;) {
-        char *key, *val = NULL, *str;
-
-        if (!(key = (char *)va_arg(args, char *)))
-            break;
-        if (strncmp(type, "CO", 2) && !(val = (char *)va_arg(args, char *)))
-            break;
-        if (*val == '\0')
-            continue;
-
-        if (!(h_tag = pool_alloc(hrecs->tag_pool)))
-            return -1;
-
-        if (strncmp(type, "CO", 2)) {
-            h_tag->len = 3 + strlen(val);
-            str = string_alloc(hrecs->str_pool, h_tag->len+1);
-            if (!str || snprintf(str, h_tag->len+1, "%2.2s:%s", key, val) < 0)
-                return -1;
-            h_tag->str = str;
-        } else {
-            h_tag->len = strlen(key);
-            h_tag->str = string_ndup(hrecs->str_pool, key, h_tag->len);
-            if (!h_tag->str)
-                return -1;
-        }
-
-        h_tag->next = NULL;
-        if (last)
-            last->next = h_tag;
-        else
-            h_type->tag = h_tag;
-
-        last = h_tag;
-    }
-    va_end(args);
-
-    // Plus the specified va_list params
-    for (;;) {
-        char *key, *val = NULL, *str;
-
-        if (!(key = (char *)va_arg(ap, char *)))
-            break;
-        if (strncmp(type, "CO", 2) && !(val = (char *)va_arg(ap, char *)))
-            break;
-
-        if (!(h_tag = pool_alloc(hrecs->tag_pool)))
-            return -1;
-
-        if (strncmp(type, "CO", 2)) {
-            h_tag->len = 3 + strlen(val);
-            str = string_alloc(hrecs->str_pool, h_tag->len+1);
-            if (!str || snprintf(str, h_tag->len+1, "%2.2s:%s", key, val) < 0)
-                return -1;
-            h_tag->str = str;
-        } else {
-            h_tag->len = strlen(key);
-            h_tag->str = string_ndup(hrecs->str_pool, key, h_tag->len);
-            if (!h_tag->str)
-                return -1;
-        }
-
-        h_tag->next = NULL;
-        if (last)
-            last->next = h_tag;
-        else
-            h_type->tag = h_tag;
-
-        last = h_tag;
-    }
-
-    if (-1 == sam_hrecs_update_hashes(hrecs, TYPEKEY(type), h_type))
-        return -1;
-
-    if (!strncmp(type, "PG", 2))
-        hrecs->pgs_changed = 1;
-
-    hrecs->dirty = 1;
-
-    return 0;
-}
-
-// As sam_hrecs_vadd(), but without the extra va_list parameter
-static int sam_hrecs_add(sam_hrecs_t *hrecs, const char *type, ...) {
-    va_list args;
-    int res;
-    va_start(args, type);
-    res = sam_hrecs_vadd(hrecs, type, args, NULL);
-    va_end(args);
-    return res;
-}
-
-/*
- * Function for deallocating a list of tags
- */
-
-static void sam_hrecs_free_tags(sam_hrecs_t *hrecs, sam_hrec_tag_t *tag) {
-    if (!hrecs || !tag)
-        return;
-    if (tag->next)
-        sam_hrecs_free_tags(hrecs, tag->next);
-
-    pool_free(hrecs->tag_pool, tag);
-}
-
-static int sam_hrecs_remove_line(sam_hrecs_t *hrecs, const char *type_name, sam_hrec_type_t *type_found) {
-    if (!hrecs || !type_name || !type_found)
-        return -1;
-
-    khint32_t itype = TYPEKEY(type_name);
-    khint_t k = kh_get(sam_hrecs_t, hrecs->h, itype);
-    if (k == kh_end(hrecs->h))
-        return -1;
-
-    // Remove from global list (remembering it could be the only line)
-    if (hrecs->first_line == type_found) {
-        hrecs->first_line = (type_found->global_next != type_found
-                             ? type_found->global_next : NULL);
-    }
-    type_found->global_next->global_prev = type_found->global_prev;
-    type_found->global_prev->global_next = type_found->global_next;
-
-    /* single element in the list */
-    if (type_found->prev == type_found || type_found->next == type_found) {
-        kh_del(sam_hrecs_t, hrecs->h, k);
-    } else {
-        type_found->prev->next = type_found->next;
-        type_found->next->prev = type_found->prev;
-        if (kh_val(hrecs->h, k) == type_found) { //first element
-            kh_val(hrecs->h, k) = type_found->next;
-        }
-    }
-
-    if (!strncmp(type_name, "SQ", 2) || !strncmp(type_name, "RG", 2))
-        sam_hrecs_remove_hash_entry(hrecs, itype, type_found);
-
-    sam_hrecs_free_tags(hrecs, type_found->tag);
-    pool_free(hrecs->type_pool, type_found);
-
-    hrecs->dirty = 1;
-
-    return 0;
-}
-
-// Paste together a line from the parsed data structures
-static int build_header_line(const sam_hrec_type_t *ty, kstring_t *ks) {
-    sam_hrec_tag_t *tag;
-    int r = 0;
-    char c[2]= { ty->type >> 8, ty->type & 0xff };
-
-    r |= (kputc_('@', ks) == EOF);
-    r |= (kputsn(c, 2, ks) == EOF);
-    for (tag = ty->tag; tag; tag = tag->next) {
-        r |= (kputc_('\t', ks) == EOF);
-        r |= (kputsn(tag->str, tag->len, ks) == EOF);
-    }
-
-    return r;
-}
-
-static int sam_hrecs_rebuild_lines(const sam_hrecs_t *hrecs, kstring_t *ks) {
-    const sam_hrec_type_t *t1, *t2;
-
-    if (!hrecs->first_line)
-        return kputsn("", 0, ks) >= 0 ? 0 : -1;
-
-    t1 = t2 = hrecs->first_line;
-    do {
-        if (build_header_line(t1, ks) != 0)
-            return -1;
-        if (kputc('\n', ks) < 0)
-            return -1;
-
-        t1 = t1->global_next;
-    } while (t1 != t2);
-
-    return 0;
-}
-
-static int sam_hrecs_parse_lines(sam_hrecs_t *hrecs, const char *hdr, size_t len) {
-    size_t i, lno;
-
-    if (!hrecs || len > SSIZE_MAX)
-        return -1;
-
-    if (!len)
-        len = strlen(hdr);
-
-    if (len < 3) {
-        if (len == 0 || *hdr == '\0') return 0;
-        sam_hrecs_error("Header line too short", hdr, len, 1);
-        return -1;
-    }
-
-    for (i = 0, lno = 1; i < len - 3 && hdr[i] != '\0'; i++, lno++) {
-        khint32_t type;
-        khint_t k;
-
-        int l_start = i, new;
-        sam_hrec_type_t *h_type;
-        sam_hrec_tag_t *h_tag, *last;
-
-        if (hdr[i] != '@') {
-            sam_hrecs_error("Header line does not start with '@'",
-                          &hdr[l_start], len - l_start, lno);
-            return -1;
-        }
-
-        if (!isalpha_c(hdr[i+1]) || !isalpha_c(hdr[i+2])) {
-            sam_hrecs_error("Header line does not have a two character key",
-                          &hdr[l_start], len - l_start, lno);
-            return -1;
-        }
-        type = TYPEKEY(&hdr[i+1]);
-
-        i += 3;
-        if (i == len || hdr[i] == '\n')
-            continue;
-
-        // Add the header line type
-        if (!(h_type = pool_alloc(hrecs->type_pool)))
-            return -1;
-        k = kh_put(sam_hrecs_t, hrecs->h, type, &new);
-        if (new < 0)
-            return -1;
-
-        h_type->type = type;
-
-        // Add to end of global list
-        sam_hrecs_global_list_add(hrecs, h_type, NULL);
-
-        // Form the ring, either with self or other lines of this type
-        if (!new) {
-            sam_hrec_type_t *t = kh_val(hrecs->h, k), *p;
-            p = t->prev;
-
-            assert(p->next == t);
-            p->next = h_type;
-            h_type->prev = p;
-
-            t->prev = h_type;
-            h_type->next = t;
-        } else {
-            kh_val(hrecs->h, k) = h_type;
-            h_type->prev = h_type->next = h_type;
-        }
-
-        // Parse the tags on this line
-        last = NULL;
-        if (type == TYPEKEY("CO")) {
-            size_t j;
-
-            if (i == len || hdr[i] != '\t') {
-                sam_hrecs_error("Missing tab",
-                              &hdr[l_start], len - l_start, lno);
-                return -1;
-            }
-
-            for (j = ++i; j < len && hdr[j] != '\0' && hdr[j] != '\n'; j++)
-                ;
-
-            if (!(h_type->tag = h_tag = pool_alloc(hrecs->tag_pool)))
-                return -1;
-            h_tag->str = string_ndup(hrecs->str_pool, &hdr[i], j-i);
-            h_tag->len = j-i;
-            h_tag->next = NULL;
-            if (!h_tag->str)
-                return -1;
-
-            i = j;
-
-        } else {
-            do {
-                size_t j;
-
-                if (i == len || hdr[i] != '\t') {
-                    sam_hrecs_error("Missing tab",
-                                  &hdr[l_start], len - l_start, lno);
-                    return -1;
-                }
-
-                for (j = ++i; j < len && hdr[j] != '\0' && hdr[j] != '\n' && hdr[j] != '\t'; j++)
-                    ;
-
-                if (j - i < 3 || hdr[i + 2] != ':') {
-                    sam_hrecs_error("Malformed key:value pair",
-                                   &hdr[l_start], len - l_start, lno);
-                    return -1;
-                }
-
-                if (!(h_tag = pool_alloc(hrecs->tag_pool)))
-                    return -1;
-                h_tag->str = string_ndup(hrecs->str_pool, &hdr[i], j-i);
-                h_tag->len = j-i;
-                h_tag->next = NULL;
-                if (!h_tag->str)
-                    return -1;
-
-                if (last)
-                    last->next = h_tag;
-                else
-                    h_type->tag = h_tag;
-
-                last = h_tag;
-                i = j;
-            } while (i < len && hdr[i] != '\0' && hdr[i] != '\n');
-        }
-
-        /* Update RG/SQ hashes */
-        if (-1 == sam_hrecs_update_hashes(hrecs, type, h_type))
-            return -1;
-    }
-
-    return 0;
-}
-
-/*! Update sam_hdr_t target_name and target_len arrays
- *
- *  @return 0 on success; -1 on failure
- */
-int sam_hdr_update_target_arrays(sam_hdr_t *bh, const sam_hrecs_t *hrecs,
-                                 int refs_changed) {
-    if (!bh || !hrecs)
-        return -1;
-
-    if (refs_changed < 0)
-        return 0;
-
-    // Grow arrays if necessary
-    if (bh->n_targets < hrecs->nref) {
-        char **new_names = realloc(bh->target_name,
-                                   hrecs->nref * sizeof(*new_names));
-        if (!new_names)
-            return -1;
-        bh->target_name = new_names;
-        uint32_t *new_lens = realloc(bh->target_len,
-                                     hrecs->nref * sizeof(*new_lens));
-        if (!new_lens)
-            return -1;
-        bh->target_len = new_lens;
-    }
-
-    // Update names and lengths where changed
-    // hrecs->refs_changed is the first ref that has been updated, so ones
-    // before that can be skipped.
-    int i;
-    khint_t k;
-    khash_t(s2i) *long_refs = (khash_t(s2i) *) bh->sdict;
-    for (i = refs_changed; i < hrecs->nref; i++) {
-        if (i >= bh->n_targets
-            || strcmp(bh->target_name[i], hrecs->ref[i].name) != 0) {
-            if (i < bh->n_targets)
-                free(bh->target_name[i]);
-            bh->target_name[i] = strdup(hrecs->ref[i].name);
-            if (!bh->target_name[i])
-                return -1;
-        }
-        if (hrecs->ref[i].len < UINT32_MAX) {
-            bh->target_len[i] = hrecs->ref[i].len;
-
-            if (!long_refs)
-                continue;
-
-            // Check if we have an old length, if so remove it.
-            k = kh_get(s2i, long_refs, bh->target_name[i]);
-            if (k < kh_end(long_refs))
-                kh_del(s2i, long_refs, k);
-        } else {
-            bh->target_len[i] = UINT32_MAX;
-            if (bh->hrecs != hrecs) {
-                // Called from sam_hdr_dup; need to add sdict entries
-                if (!long_refs) {
-                    if (!(bh->sdict = long_refs = kh_init(s2i)))
-                        return -1;
-                }
-
-                // Add / update length
-                int absent;
-                k = kh_put(s2i, long_refs, bh->target_name[i], &absent);
-                if (absent < 0)
-                    return -1;
-                kh_val(long_refs, k) = hrecs->ref[i].len;
-            }
-        }
-    }
-
-    // Free up any names that have been removed
-    for (; i < bh->n_targets; i++) {
-        if (long_refs) {
-            k = kh_get(s2i, long_refs, bh->target_name[i]);
-            if (k < kh_end(long_refs))
-                kh_del(s2i, long_refs, k);
-        }
-        free(bh->target_name[i]);
-    }
-
-    bh->n_targets = hrecs->nref;
-    return 0;
-}
-
-static int rebuild_target_arrays(sam_hdr_t *bh) {
-    if (!bh || !bh->hrecs)
-        return -1;
-
-    sam_hrecs_t *hrecs = bh->hrecs;
-    if (hrecs->refs_changed < 0)
-        return 0;
-
-    if (sam_hdr_update_target_arrays(bh, hrecs, hrecs->refs_changed) != 0)
-        return -1;
-
-    hrecs->refs_changed = -1;
-    return 0;
-}
-
-/// Populate hrecs refs array from header target_name, target_len arrays
-/**
- * @return 0 on success; -1 on failure
- *
- * Pre-fills the refs hash from the target arrays.  For BAM files this
- * will ensure that they are in the correct order as the target arrays
- * are the canonical source for converting target ids to names and lengths.
- *
- * The added entries do not link to a header line. sam_hrecs_update_hashes()
- * will add the links later for lines found in the text header.
- *
- * This should be called before the text header is parsed.
- */
-static int sam_hrecs_refs_from_targets_array(sam_hrecs_t *hrecs,
-                                             const sam_hdr_t *bh) {
-    int32_t tid = 0;
-
-    if (!hrecs || !bh)
-        return -1;
-
-    // This should always be called before parsing the text header
-    // so the ref array should start off empty, and we don't have to try
-    // to reconcile any existing data.
-    if (hrecs->nref > 0) {
-        hts_log_error("Called with non-empty ref array");
-        return -1;
-    }
-
-    if (hrecs->ref_sz < bh->n_targets) {
-        sam_hrec_sq_t *new_ref = realloc(hrecs->ref,
-                                         bh->n_targets * sizeof(*new_ref));
-        if (!new_ref)
-            return -1;
-
-        hrecs->ref = new_ref;
-        hrecs->ref_sz = bh->n_targets;
-    }
-
-    for (tid = 0; tid < bh->n_targets; tid++) {
-        khint_t k;
-        int r;
-        hrecs->ref[tid].name = string_dup(hrecs->str_pool, bh->target_name[tid]);
-        if (!hrecs->ref[tid].name) goto fail;
-        if (bh->target_len[tid] < UINT32_MAX || !bh->sdict) {
-            hrecs->ref[tid].len  = bh->target_len[tid];
-        } else {
-            khash_t(s2i) *long_refs = (khash_t(s2i) *) bh->sdict;
-            k = kh_get(s2i, long_refs, hrecs->ref[tid].name);
-            if (k < kh_end(long_refs)) {
-                hrecs->ref[tid].len = kh_val(long_refs, k);
-            } else {
-                hrecs->ref[tid].len = UINT32_MAX;
-            }
-        }
-        hrecs->ref[tid].ty   = NULL;
-        k = kh_put(m_s2i, hrecs->ref_hash, hrecs->ref[tid].name, &r);
-        if (r < 0) goto fail;
-        if (r == 0) {
-            hts_log_error("Duplicate entry \"%s\" in target list",
-                            hrecs->ref[tid].name);
-            return -1;
-        } else {
-            kh_val(hrecs->ref_hash, k) = tid;
-        }
-    }
-    hrecs->nref = bh->n_targets;
-    return 0;
-
- fail: {
-        int32_t i;
-        hts_log_error("%s", strerror(errno));
-        for (i = 0; i < tid; i++) {
-            khint_t k;
-            if (!hrecs->ref[i].name) continue;
-            k = kh_get(m_s2i, hrecs->ref_hash, hrecs->ref[tid].name);
-            if (k < kh_end(hrecs->ref_hash)) kh_del(m_s2i, hrecs->ref_hash, k);
-        }
-        hrecs->nref = 0;
-        return -1;
-    }
-}
-
-/*
- * Add SQ header records for any references in the hrecs->ref array that
- * were added by sam_hrecs_refs_from_targets_array() but have not
- * been linked to an @SQ line by sam_hrecs_update_hashes() yet.
- *
- * This may be needed either because:
- *
- *   - A bam file was read that had entries in its refs list with no
- *     corresponding @SQ line.
- *
- *   - A program constructed a sam_hdr_t which has target_name and target_len
- *     array entries with no corresponding @SQ line in text.
- */
-static int add_stub_ref_sq_lines(sam_hrecs_t *hrecs) {
-    int tid;
-    char len[32];
-
-    for (tid = 0; tid < hrecs->nref; tid++) {
-        if (hrecs->ref[tid].ty == NULL) {
-            snprintf(len, sizeof(len), "%"PRIhts_pos, hrecs->ref[tid].len);
-            if (sam_hrecs_add(hrecs, "SQ",
-                              "SN", hrecs->ref[tid].name,
-                              "LN", len, NULL) != 0)
-                return -1;
-
-            // Check that the stub has actually been filled
-            if(hrecs->ref[tid].ty == NULL) {
-                hts_log_error("Reference stub with tid=%d, name=\"%s\", len=%"PRIhts_pos" could not be filled",
-                        tid, hrecs->ref[tid].name, hrecs->ref[tid].len);
-                return -1;
-            }
-        }
-    }
-    return 0;
-}
-
-int sam_hdr_fill_hrecs(sam_hdr_t *bh) {
-    sam_hrecs_t *hrecs = sam_hrecs_new();
-
-    if (!hrecs)
-        return -1;
-
-    if (bh->target_name && bh->target_len && bh->n_targets > 0) {
-        if (sam_hrecs_refs_from_targets_array(hrecs, bh) != 0) {
-            sam_hrecs_free(hrecs);
-            return -1;
-        }
-    }
-
-    // Parse existing header text
-    if (bh->text && bh->l_text > 0) {
-        if (sam_hrecs_parse_lines(hrecs, bh->text, bh->l_text) != 0) {
-            sam_hrecs_free(hrecs);
-            return -1;
-        }
-    }
-
-    if (add_stub_ref_sq_lines(hrecs) < 0) {
-        sam_hrecs_free(hrecs);
-        return -1;
-    }
-
-    bh->hrecs = hrecs;
-
-    if (hrecs->refs_changed >= 0 && rebuild_target_arrays(bh) != 0)
-        return -1;
-
-    return 0;
-}
-
-/** Remove outdated header text
-
-    @param bh     BAM header
-
-    This is called when API functions have changed the header so that the
-    text version is no longer valid.
- */
-static void redact_header_text(sam_hdr_t *bh) {
-    assert(bh->hrecs && bh->hrecs->dirty);
-    bh->l_text = 0;
-    free(bh->text);
-    bh->text = NULL;
-}
-
-/** Find nth header record of a given type
-
-    @param type   Header type (SQ, RG etc.)
-    @param idx    0-based index
-
-    @return sam_hrec_type_t pointer to the record on success
-            NULL if no record exists with the given type and index
- */
-
-static sam_hrec_type_t *sam_hrecs_find_type_pos(sam_hrecs_t *hrecs,
-                                                const char *type, int idx) {
-    sam_hrec_type_t *first, *itr;
-
-    if (idx < 0)
-        return NULL;
-
-    if (type[0] == 'S' && type[1] == 'Q')
-        return idx < hrecs->nref ? hrecs->ref[idx].ty : NULL;
-
-    if (type[0] == 'R' && type[1] == 'G')
-        return idx < hrecs->nrg ? hrecs->rg[idx].ty : NULL;
-
-    if (type[0] == 'P' && type[1] == 'G')
-        return idx < hrecs->npg ? hrecs->pg[idx].ty : NULL;
-
-    first = itr = sam_hrecs_find_type_id(hrecs, type, NULL, NULL);
-    if (!first)
-        return NULL;
-
-    while (idx > 0) {
-        itr = itr->next;
-        if (itr == first)
-            break;
-        --idx;
-    }
-
-    return idx == 0 ? itr : NULL;
-}
-
-/* ==== Public methods ==== */
-
-size_t sam_hdr_length(sam_hdr_t *bh) {
-    if (!bh || -1 == sam_hdr_rebuild(bh))
-        return SIZE_MAX;
-
-    return bh->l_text;
-}
-
-const char *sam_hdr_str(sam_hdr_t *bh) {
-    if (!bh || -1 == sam_hdr_rebuild(bh))
-        return NULL;
-
-    return bh->text;
-}
-
-int sam_hdr_nref(const sam_hdr_t *bh) {
-    if (!bh)
-        return -1;
-
-    return bh->hrecs ? bh->hrecs->nref : bh->n_targets;
-}
-
-/*
- * Reconstructs the text representation from the header hash table.
- * Returns 0 on success
- *        -1 on failure
- */
-int sam_hdr_rebuild(sam_hdr_t *bh) {
-    sam_hrecs_t *hrecs;
-    if (!bh)
-        return -1;
-
-    if (!(hrecs = bh->hrecs))
-        return bh->text ? 0 : -1;
-
-    if (hrecs->refs_changed >= 0) {
-        if (rebuild_target_arrays(bh) < 0) {
-            hts_log_error("Header target array rebuild has failed");
-            return -1;
-        }
-    }
-
-    /* If header text wasn't changed or header is empty, don't rebuild it. */
-    if (!hrecs->dirty)
-        return 0;
-
-    if (hrecs->pgs_changed && sam_hdr_link_pg(bh) < 0) {
-        hts_log_error("Linking @PG lines has failed");
-        return -1;
-    }
-
-    kstring_t ks = KS_INITIALIZE;
-    if (sam_hrecs_rebuild_text(hrecs, &ks) != 0) {
-        ks_free(&ks);
-        hts_log_error("Header text rebuild has failed");
-        return -1;
-    }
-
-    hrecs->dirty = 0;
-
-    /* Sync */
-    free(bh->text);
-    bh->l_text = ks_len(&ks);
-    bh->text = ks_release(&ks);
-
-    return 0;
-}
-
-/*
- * Appends a formatted line to an existing SAM header.
- * Line is a full SAM header record, eg "@SQ\tSN:foo\tLN:100", with
- * optional new-line. If it contains more than 1 line then multiple lines
- * will be added in order.
- *
- * Input text is of maximum length len or as terminated earlier by a NUL.
- * len may be 0 if unknown, in which case lines must be NUL-terminated.
- *
- * Returns 0 on success
- *        -1 on failure
- */
-int sam_hdr_add_lines(sam_hdr_t *bh, const char *lines, size_t len) {
-    sam_hrecs_t *hrecs;
-
-    if (!bh || !lines)
-        return -1;
-
-    if (len == 0 && *lines == '\0')
-        return 0;
-
-    if (!(hrecs = bh->hrecs)) {
-        if (sam_hdr_fill_hrecs(bh) != 0)
-            return -1;
-        hrecs = bh->hrecs;
-    }
-
-    if (sam_hrecs_parse_lines(hrecs, lines, len) != 0)
-        return -1;
-
-    if (hrecs->refs_changed >= 0 && rebuild_target_arrays(bh) != 0)
-        return -1;
-
-    hrecs->dirty = 1;
-    redact_header_text(bh);
-
-    return 0;
-}
-
-/*
- * Adds a single line to a SAM header.
- * Specify type and one or more key,value pairs, ending with the NULL key.
- * Eg. sam_hdr_add_line(h, "SQ", "ID", "foo", "LN", "100", NULL).
- *
- * Returns 0 on success
- *        -1 on failure
- */
-int sam_hdr_add_line(sam_hdr_t *bh, const char *type, ...) {
-    va_list args;
-    sam_hrecs_t *hrecs;
-
-    if (!bh || !type)
-        return -1;
-
-    if (!(hrecs = bh->hrecs)) {
-        if (sam_hdr_fill_hrecs(bh) != 0)
-            return -1;
-        hrecs = bh->hrecs;
-    }
-
-    va_start(args, type);
-    int ret = sam_hrecs_vadd(hrecs, type, args, NULL);
-    va_end(args);
-
-    if (ret == 0) {
-        if (hrecs->refs_changed >= 0 && rebuild_target_arrays(bh) != 0)
-            return -1;
-
-        if (hrecs->dirty)
-            redact_header_text(bh);
-    }
-
-    return ret;
-}
-
-/*
- * Returns a complete line of formatted text for a specific head type/ID
- * combination. If ID_key is NULL then it returns the first line of the specified
- * type.
- */
-int sam_hdr_find_line_id(sam_hdr_t *bh, const char *type,
-                      const char *ID_key, const char *ID_val, kstring_t *ks) {
-    sam_hrecs_t *hrecs;
-    if (!bh || !type)
-        return -2;
-
-    if (!(hrecs = bh->hrecs)) {
-        if (sam_hdr_fill_hrecs(bh) != 0)
-            return -2;
-        hrecs = bh->hrecs;
-    }
-
-    sam_hrec_type_t *ty = sam_hrecs_find_type_id(hrecs, type, ID_key, ID_val);
-    if (!ty)
-        return -1;
-
-    ks->l = 0;
-    if (build_header_line(ty, ks) < 0) {
-        return -2;
-    }
-
-    return 0;
-}
-
-int sam_hdr_find_line_pos(sam_hdr_t *bh, const char *type,
-                          int pos, kstring_t *ks) {
-    sam_hrecs_t *hrecs;
-    if (!bh || !type)
-        return -2;
-
-    if (!(hrecs = bh->hrecs)) {
-        if (sam_hdr_fill_hrecs(bh) != 0)
-            return -2;
-        hrecs = bh->hrecs;
-    }
-
-    sam_hrec_type_t *ty = sam_hrecs_find_type_pos(hrecs, type, pos);
-    if (!ty)
-        return -1;
-
-    ks->l = 0;
-    if (build_header_line(ty, ks) < 0) {
-        return -2;
-    }
-
-    return 0;
-}
-
-/*
- * Remove a line from the header by specifying a tag:value that uniquely
- * identifies a line, i.e. the @SQ line containing "SN:ref1".
- * @SQ line is uniquely identified by SN tag.
- * @RG line is uniquely identified by ID tag.
- * @PG line is uniquely identified by ID tag.
- *
- * Returns 0 on success and -1 on error
- */
-
-int sam_hdr_remove_line_id(sam_hdr_t *bh, const char *type, const char *ID_key, const char *ID_value) {
-    sam_hrecs_t *hrecs;
-    if (!bh || !type)
-        return -1;
-
-    if (!(hrecs = bh->hrecs)) {
-        if (sam_hdr_fill_hrecs(bh) != 0)
-            return -1;
-        hrecs = bh->hrecs;
-    }
-
-    if (!strncmp(type, "PG", 2)) {
-        hts_log_warning("Removing PG lines is not supported!");
-        return -1;
-    }
-
-    sam_hrec_type_t *type_found = sam_hrecs_find_type_id(hrecs, type, ID_key, ID_value);
-    if (!type_found)
-        return 0;
-
-    int ret = sam_hrecs_remove_line(hrecs, type, type_found);
-    if (ret == 0) {
-        if (hrecs->refs_changed >= 0 && rebuild_target_arrays(bh) != 0)
-            return -1;
-
-        if (hrecs->dirty)
-            redact_header_text(bh);
-    }
-
-    return ret;
-}
-
-/*
- * Remove a line from the header by specifying the position in the type
- * group, i.e. 3rd @SQ line.
- *
- * Returns 0 on success and -1 on error
- */
-
-int sam_hdr_remove_line_pos(sam_hdr_t *bh, const char *type, int position) {
-    sam_hrecs_t *hrecs;
-    if (!bh || !type || position <= 0)
-        return -1;
-
-    if (!(hrecs = bh->hrecs)) {
-        if (sam_hdr_fill_hrecs(bh) != 0)
-            return -1;
-        hrecs = bh->hrecs;
-    }
-
-    if (!strncmp(type, "PG", 2)) {
-        hts_log_warning("Removing PG lines is not supported!");
-        return -1;
-    }
-
-    sam_hrec_type_t *type_found = sam_hrecs_find_type_pos(hrecs, type,
-                                                          position);
-    if (!type_found)
-        return -1;
-
-    int ret = sam_hrecs_remove_line(hrecs, type, type_found);
-    if (ret == 0) {
-        if (hrecs->refs_changed >= 0 && rebuild_target_arrays(bh) != 0)
-            return -1;
-
-        if (hrecs->dirty)
-            redact_header_text(bh);
-    }
-
-    return ret;
-}
-
-/*
- * Check if sam_hdr_update_line() is being used to change the name of
- * a record, and if the new name is going to clash with an existing one.
- *
- * If ap includes repeated keys, we go with the last one as sam_hrecs_vupdate()
- * will go through them all and leave the final one in place.
- *
- * Returns 0 if the name does not change
- *         1 if the name changes but does not clash
- *        -1 if the name changes and the new one is already in use
- */
-static int check_for_name_update(sam_hrecs_t *hrecs, sam_hrec_type_t *rec,
-                                 va_list ap, const char **old_name,
-                                 const char **new_name,
-                                 char id_tag_out[3],
-                                 khash_t(m_s2i) **hash_out) {
-    char *key, *val;
-    const char *id_tag;
-    sam_hrec_tag_t *tag, *prev;
-    khash_t(m_s2i) *hash;
-    khint_t k;
-    int ret = 0;
-
-    if        (rec->type == TYPEKEY("SQ")) {
-        id_tag = "SN"; hash = hrecs->ref_hash;
-    } else if (rec->type == TYPEKEY("RG")) {
-        id_tag = "ID"; hash = hrecs->rg_hash;
-    } else if (rec->type == TYPEKEY("PG")) {
-        id_tag = "ID"; hash = hrecs->pg_hash;
-    } else {
-        return 0;
-    }
-
-    memcpy(id_tag_out, id_tag, 3);
-    *hash_out = hash;
-
-    tag = sam_hrecs_find_key(rec, id_tag, &prev);
-    if (!tag)
-        return 0;
-    assert(tag->len >= 3);
-    *old_name = tag->str + 3;
-
-    while ((key = va_arg(ap, char *)) != NULL) {
-        val = va_arg(ap, char *);
-        if (!val) val = "";
-        if (strcmp(key, id_tag) != 0) continue;
-        if (strcmp(val, tag->str + 3) == 0) { ret = 0; continue; }
-        k = kh_get(m_s2i, hash, val);
-        ret = k < kh_end(hash) ? -1 : 1;
-        *new_name = val;
-    }
-    return ret;
-}
-
-int sam_hdr_update_line(sam_hdr_t *bh, const char *type,
-        const char *ID_key, const char *ID_value, ...) {
-    sam_hrecs_t *hrecs;
-    if (!bh)
-        return -1;
-
-    if (!(hrecs = bh->hrecs)) {
-        if (sam_hdr_fill_hrecs(bh) != 0)
-            return -1;
-        hrecs = bh->hrecs;
-    }
-
-    int ret, rename;
-    sam_hrec_type_t *ty = sam_hrecs_find_type_id(hrecs, type, ID_key, ID_value);
-    if (!ty)
-        return -1;
-
-    va_list args;
-    const char *old_name = "?", *new_name = "?";
-    char id_tag[3];
-    khash_t(m_s2i) *hash = NULL;
-    va_start(args, ID_value);
-    rename = check_for_name_update(hrecs, ty, args,
-                                   &old_name, &new_name, id_tag, &hash);
-    va_end(args);
-    if (rename < 0) {
-        hts_log_error("Cannot rename @%s \"%s\" to \"%s\" : already exists",
-                      type, old_name, new_name);
-        return -1;
-    }
-    if (rename > 0 && TYPEKEY(type) == TYPEKEY("PG")) {
-        // This is just too complicated
-        hts_log_error("Renaming @PG records is not supported");
-        return -1;
-    }
-    va_start(args, ID_value);
-    ret = sam_hrecs_vupdate(hrecs, ty, args);
-    va_end(args);
-
-    if (ret)
-        return ret;
-
-    // TODO Account for @SQ-AN altnames
-
-    if (rename) {
-        // Adjust the hash table to point to the new name
-        // sam_hrecs_update_hashes() should sort out everything else
-        khint_t k = kh_get(m_s2i, hash, old_name);
-        sam_hrec_tag_t *new_tag = sam_hrecs_find_key(ty, id_tag, NULL);
-        int r, pos;
-        assert(k < kh_end(hash));        // Or we wouldn't have found it earlier
-        assert(new_tag && new_tag->str); // id_tag should exist
-        assert(new_tag->len > 3);
-        pos = kh_val(hash, k);
-        kh_del(m_s2i, hash, k);
-        k = kh_put(m_s2i, hash, new_tag->str + 3, &r);
-        if (r < 1) {
-            hts_log_error("Failed to rename item in hash table");
-            return -1;
-        }
-        kh_val(hash, k) = pos;
-    }
-
-    ret = sam_hrecs_update_hashes(hrecs, TYPEKEY(type), ty);
-
-    if (!ret && hrecs->refs_changed >= 0)
-        ret = rebuild_target_arrays(bh);
-
-    if (!ret && hrecs->dirty)
-        redact_header_text(bh);
-
-    return ret;
-}
-
-int sam_hdr_remove_except(sam_hdr_t *bh, const char *type, const char *ID_key, const char *ID_value) {
-    sam_hrecs_t *hrecs;
-    if (!bh || !type)
-        return -1;
-
-    if (!(hrecs = bh->hrecs)) {
-        if (sam_hdr_fill_hrecs(bh) != 0)
-            return -1;
-        hrecs = bh->hrecs;
-    }
-
-    sam_hrec_type_t *step;
-    int ret = 1, remove_all = (ID_key == NULL);
-
-    if (!strncmp(type, "PG", 2) || !strncmp(type, "CO", 2)) {
-        hts_log_warning("Removing PG or CO lines is not supported!");
-        return -1;
-    }
-
-    sam_hrec_type_t *type_found = sam_hrecs_find_type_id(hrecs, type, ID_key, ID_value);
-    if (!type_found) { // remove all line of this type
-        khint_t k = kh_get(sam_hrecs_t, hrecs->h, TYPEKEY(type));
-        if (k == kh_end(hrecs->h))
-            return 0;
-        type_found =  kh_val(hrecs->h, k);
-        if (!type_found)
-            return 0;
-        remove_all = 1;
-    }
-
-    step = type_found->next;
-    while (step != type_found) {
-        sam_hrec_type_t *to_remove = step;
-        step = step->next;
-        ret &= sam_hrecs_remove_line(hrecs, type, to_remove);
-    }
-
-    if (remove_all)
-        ret &= sam_hrecs_remove_line(hrecs, type, type_found);
-
-    if (!ret && hrecs->dirty)
-        redact_header_text(bh);
-
-    return 0;
-}
-
-int sam_hdr_remove_lines(sam_hdr_t *bh, const char *type, const char *id, void *vrh) {
-    sam_hrecs_t *hrecs;
-    rmhash_t *rh = (rmhash_t *)vrh;
-
-    if (!bh || !type)
-        return -1;
-    if (!rh) // remove all lines
-        return sam_hdr_remove_except(bh, type, NULL, NULL);
-    if (!id)
-        return -1;
-
-    if (!(hrecs = bh->hrecs)) {
-        if (sam_hdr_fill_hrecs(bh) != 0)
-            return -1;
-        hrecs = bh->hrecs;
-    }
-
-    khint_t k = kh_get(sam_hrecs_t, hrecs->h, TYPEKEY(type));
-    if (k == kh_end(hrecs->h)) // nothing to remove from
-        return 0;
-
-    sam_hrec_type_t *head = kh_val(hrecs->h, k);
-    if (!head) {
-        hts_log_error("Header inconsistency");
-        return -1;
-    }
-
-    int ret = 0;
-    sam_hrec_type_t *step = head->next;
-    while (step != head) {
-        sam_hrec_tag_t *tag = sam_hrecs_find_key(step, id, NULL);
-        if (tag && tag->str && tag->len >= 3) {
-           k = kh_get(rm, rh, tag->str+3);
-           if (k == kh_end(rh)) { // value is not in the hash table, so remove
-               sam_hrec_type_t *to_remove = step;
-               step = step->next;
-               ret |= sam_hrecs_remove_line(hrecs, type, to_remove);
-           } else {
-               step = step->next;
-           }
-        } else { // tag is not on the line, so skip to next line
-            step = step->next;
-        }
-    }
-
-    // process the first line
-    sam_hrec_tag_t * tag = sam_hrecs_find_key(head, id, NULL);
-    if (tag && tag->str && tag->len >= 3) {
-       k = kh_get(rm, rh, tag->str+3);
-       if (k == kh_end(rh)) { // value is not in the hash table, so remove
-           sam_hrec_type_t *to_remove = head;
-           head = head->next;
-           ret |= sam_hrecs_remove_line(hrecs, type, to_remove);
-       }
-    }
-
-    if (!ret && hrecs->dirty)
-        redact_header_text(bh);
-
-    return ret;
-}
-
-int sam_hdr_count_lines(sam_hdr_t *bh, const char *type) {
-    int count;
-    sam_hrec_type_t *first_ty, *itr_ty;
-
-    if (!bh || !type)
-        return -1;
-
-    if (!bh->hrecs) {
-        if (sam_hdr_fill_hrecs(bh) != 0)
-            return -1;
-    }
-
-    // Deal with types that have counts
-    switch (type[0]) {
-    case 'S':
-        if (type[1] == 'Q')
-            return bh->hrecs->nref;
-        break;
-    case 'R':
-        if (type[1] == 'G')
-            return bh->hrecs->nrg;
-        break;
-    case 'P':
-        if (type[1] == 'G')
-            return bh->hrecs->npg;
-        break;
-    default:
-        break;
-    }
-
-    first_ty = sam_hrecs_find_type_id(bh->hrecs, type, NULL, NULL);
-    if (!first_ty)
-        return 0;
-
-    count = 1;
-    for (itr_ty = first_ty->next;
-         itr_ty && itr_ty != first_ty; itr_ty = itr_ty->next) {
-        count++;
-    }
-
-    return count;
-}
-
-int sam_hdr_line_index(sam_hdr_t *bh,
-                       const char *type,
-                       const char *key) {
-    sam_hrecs_t *hrecs;
-    if (!bh || !type || !key)
-        return -2;
-
-    if (!(hrecs = bh->hrecs)) {
-        if (sam_hdr_fill_hrecs(bh) != 0)
-            return -2;
-        hrecs = bh->hrecs;
-    }
-
-    khint_t k;
-    int idx = -1;
-    switch (type[0]) {
-    case 'S':
-        if (type[1] == 'Q') {
-            k = kh_get(m_s2i, hrecs->ref_hash, key);
-            if (k != kh_end(hrecs->ref_hash))
-                idx = kh_val(hrecs->ref_hash, k);
-        } else {
-            hts_log_warning("Type '%s' not supported. Only @SQ, @RG and @PG lines are indexed", type);
-        }
-        break;
-    case 'R':
-        if (type[1] == 'G') {
-            k = kh_get(m_s2i, hrecs->rg_hash, key);
-            if (k != kh_end(hrecs->rg_hash))
-                idx = kh_val(hrecs->rg_hash, k);
-        } else {
-            hts_log_warning("Type '%s' not supported. Only @SQ, @RG and @PG lines are indexed", type);
-        }
-        break;
-    case 'P':
-        if (type[1] == 'G') {
-            k = kh_get(m_s2i, hrecs->pg_hash, key);
-            if (k != kh_end(hrecs->pg_hash))
-                idx = kh_val(hrecs->pg_hash, k);
-        } else {
-            hts_log_warning("Type '%s' not supported. Only @SQ, @RG and @PG lines are indexed", type);
-        }
-        break;
-    default:
-        hts_log_warning("Type '%s' not supported. Only @SQ, @RG and @PG lines are indexed", type);
-    }
-
-    return idx;
-}
-
-const char *sam_hdr_line_name(sam_hdr_t *bh,
-                              const char *type,
-                              int pos) {
-    sam_hrecs_t *hrecs;
-    if (!bh || !type || pos < 0)
-        return NULL;
-
-    if (!(hrecs = bh->hrecs)) {
-        if (sam_hdr_fill_hrecs(bh) != 0)
-            return NULL;
-        hrecs = bh->hrecs;
-    }
-
-    switch (type[0]) {
-    case 'S':
-        if (type[1] == 'Q') {
-            if (pos < hrecs->nref)
-                return hrecs->ref[pos].name;
-        } else {
-            hts_log_warning("Type '%s' not supported. Only @SQ, @RG and @PG lines are indexed", type);
-        }
-        break;
-    case 'R':
-        if (type[1] == 'G') {
-            if (pos < hrecs->nrg)
-                return hrecs->rg[pos].name;
-        } else {
-            hts_log_warning("Type '%s' not supported. Only @SQ, @RG and @PG lines are indexed", type);
-        }
-        break;
-    case 'P':
-        if (type[1] == 'G') {
-            if (pos < hrecs->npg)
-                return hrecs->pg[pos].name;
-        } else {
-            hts_log_warning("Type '%s' not supported. Only @SQ, @RG and @PG lines are indexed", type);
-        }
-        break;
-    default:
-        hts_log_warning("Type '%s' not supported. Only @SQ, @RG and @PG lines are indexed", type);
-    }
-
-    return NULL;
-}
-
-/* ==== Key:val level methods ==== */
-
-int sam_hdr_find_tag_id(sam_hdr_t *bh,
-                     const char *type,
-                     const char *ID_key,
-                     const char *ID_value,
-                     const char *key,
-                     kstring_t *ks) {
-    sam_hrecs_t *hrecs;
-    if (!bh || !type || !key)
-        return -2;
-
-    if (!(hrecs = bh->hrecs)) {
-        if (sam_hdr_fill_hrecs(bh) != 0)
-            return -2;
-        hrecs = bh->hrecs;
-    }
-
-    sam_hrec_type_t *ty = sam_hrecs_find_type_id(hrecs, type, ID_key, ID_value);
-    if (!ty)
-        return -1;
-
-    sam_hrec_tag_t *tag = sam_hrecs_find_key(ty, key, NULL);
-    if (!tag || !tag->str || tag->len < 4)
-        return -1;
-
-    ks->l = 0;
-    if (kputsn(tag->str+3, tag->len-3, ks) == EOF) {
-        return -2;
-    }
-
-    return 0;
-}
-
-int sam_hdr_find_tag_pos(sam_hdr_t *bh,
-                     const char *type,
-                     int pos,
-                     const char *key,
-                     kstring_t *ks) {
-    sam_hrecs_t *hrecs;
-    if (!bh || !type || !key)
-        return -2;
-
-    if (!(hrecs = bh->hrecs)) {
-        if (sam_hdr_fill_hrecs(bh) != 0)
-            return -2;
-        hrecs = bh->hrecs;
-    }
-
-    sam_hrec_type_t *ty = sam_hrecs_find_type_pos(hrecs, type, pos);
-    if (!ty)
-        return -1;
-
-    sam_hrec_tag_t *tag = sam_hrecs_find_key(ty, key, NULL);
-    if (!tag || !tag->str || tag->len < 4)
-        return -1;
-
-    ks->l = 0;
-    if (kputsn(tag->str+3, tag->len-3, ks) == EOF) {
-        return -2;
-    }
-
-    return 0;
-}
-
-int sam_hdr_remove_tag_id(sam_hdr_t *bh,
-        const char *type,
-        const char *ID_key,
-        const char *ID_value,
-        const char *key) {
-    sam_hrecs_t *hrecs;
-    if (!bh || !type || !key)
-        return -1;
-
-    if (!(hrecs = bh->hrecs)) {
-        if (sam_hdr_fill_hrecs(bh) != 0)
-            return -1;
-        hrecs = bh->hrecs;
-    }
-
-    sam_hrec_type_t *ty = sam_hrecs_find_type_id(hrecs, type, ID_key, ID_value);
-    if (!ty)
-        return -1;
-
-    int ret = sam_hrecs_remove_key(hrecs, ty, key);
-    if (!ret && hrecs->dirty)
-        redact_header_text(bh);
-
-    return ret;
-}
-
-/*
- * Reconstructs a kstring from the header hash table.
- * Returns 0 on success
- *        -1 on failure
- */
-int sam_hrecs_rebuild_text(const sam_hrecs_t *hrecs, kstring_t *ks) {
-    ks->l = 0;
-
-    if (!hrecs->h || !hrecs->h->size) {
-        return kputsn("", 0, ks) >= 0 ? 0 : -1;
-    }
-    if (sam_hrecs_rebuild_lines(hrecs, ks) != 0)
-        return -1;
-
-    return 0;
-}
-
-/*
- * Looks up a reference sequence by name and returns the numerical ID.
- * Returns -1 if unknown reference; -2 if header could not be parsed.
- */
-int sam_hdr_name2tid(sam_hdr_t *bh, const char *ref) {
-    sam_hrecs_t *hrecs;
-    khint_t k;
-
-    if (!bh)
-        return -1;
-
-    if (!(hrecs = bh->hrecs)) {
-        if (sam_hdr_fill_hrecs(bh) != 0)
-            return -2;
-        hrecs = bh->hrecs;
-    }
-
-    if (!hrecs->ref_hash)
-        return -1;
-
-    k = kh_get(m_s2i, hrecs->ref_hash, ref);
-    return k == kh_end(hrecs->ref_hash) ? -1 : kh_val(hrecs->ref_hash, k);
-}
-
-const char *sam_hdr_tid2name(const sam_hdr_t *h, int tid) {
-    sam_hrecs_t *hrecs;
-
-    if (!h || tid < 0)
-        return NULL;
-
-    if ((hrecs = h->hrecs) != NULL && tid < hrecs->nref) {
-        return hrecs->ref[tid].name;
-    } else {
-        if (tid < h->n_targets)
-            return h->target_name[tid];
-    }
-
-    return NULL;
-}
-
-hts_pos_t sam_hdr_tid2len(const sam_hdr_t *h, int tid) {
-    sam_hrecs_t *hrecs;
-
-    if (!h || tid < 0)
-        return 0;
-
-    if ((hrecs = h->hrecs) != NULL && tid < hrecs->nref) {
-        return hrecs->ref[tid].len;
-    } else {
-        if (tid < h->n_targets) {
-            if (h->target_len[tid] < UINT32_MAX || !h->sdict) {
-                return h->target_len[tid];
-            } else {
-                khash_t(s2i) *long_refs = (khash_t(s2i) *) h->sdict;
-                khint_t k = kh_get(s2i, long_refs, h->target_name[tid]);
-                if (k < kh_end(long_refs)) {
-                    return kh_val(long_refs, k);
-                } else {
-                    return UINT32_MAX;
-                }
-            }
-        }
-    }
-
-    return 0;
-}
-
-/*
- * Fixes any PP links in @PG headers.
- * If the entries are in order then this doesn't need doing, but in case
- * our header is out of order this goes through the hrecs->pg[] array
- * setting the prev_id field.
- *
- * Note we can have multiple complete chains. This code should identify the
- * tails of these chains as these are the entries we have to link to in
- * subsequent PP records.
- *
- * Returns 0 on success
- *        -1 on failure (indicating broken PG/PP records)
- */
-static int sam_hdr_link_pg(sam_hdr_t *bh) {
-    sam_hrecs_t *hrecs;
-    int i, j, ret = 0, *new_pg_end;
-
-    if (!bh)
-        return -1;
-
-    if (!(hrecs = bh->hrecs)) {
-        if (sam_hdr_fill_hrecs(bh) != 0)
-            return -1;
-        hrecs = bh->hrecs;
-    }
-
-    if (!hrecs->pgs_changed || !hrecs->npg)
-        return 0;
-
-    hrecs->npg_end_alloc = hrecs->npg;
-    new_pg_end = realloc(hrecs->pg_end, hrecs->npg * sizeof(*new_pg_end));
-    if (!new_pg_end)
-        return -1;
-    hrecs->pg_end = new_pg_end;
-    int *chain_size = calloc(hrecs->npg, sizeof(int));
-    if (!chain_size)
-        return -1;
-
-    for (i = 0; i < hrecs->npg; i++)
-        hrecs->pg_end[i] = i;
-
-    for (i = 0; i < hrecs->npg; i++) {
-        khint_t k;
-        sam_hrec_tag_t *tag;
-
-        assert(hrecs->pg[i].ty != NULL);
-        for (tag = hrecs->pg[i].ty->tag; tag; tag = tag->next) {
-            if (tag->str[0] == 'P' && tag->str[1] == 'P')
-                break;
-        }
-        if (!tag) {
-            /* Chain start points */
-            continue;
-        }
-
-        k = kh_get(m_s2i, hrecs->pg_hash, tag->str+3);
-
-        if (k == kh_end(hrecs->pg_hash)) {
-            hts_log_warning("PG line with PN:%s has a PP link to missing program '%s'",
-                    hrecs->pg[i].name, tag->str+3);
-            continue;
-        }
-
-        hrecs->pg[i].prev_id = hrecs->pg[kh_val(hrecs->pg_hash, k)].id;
-        hrecs->pg_end[kh_val(hrecs->pg_hash, k)] = -1;
-        chain_size[i] = chain_size[kh_val(hrecs->pg_hash, k)]+1;
-    }
-
-    for (i = j = 0; i < hrecs->npg; i++) {
-        if (hrecs->pg_end[i] != -1 && chain_size[i] > 0)
-            hrecs->pg_end[j++] = hrecs->pg_end[i];
-    }
-    /* Only leafs? Choose the last one! */
-    if (!j && hrecs->npg_end > 0) {
-        hrecs->pg_end[0] = hrecs->pg_end[hrecs->npg_end-1];
-        j = 1;
-    }
-
-    hrecs->npg_end = j;
-    hrecs->pgs_changed = 0;
-
-    /* mark as dirty or empty for rebuild */
-    hrecs->dirty = 1;
-    redact_header_text(bh);
-    free(chain_size);
-
-    return ret;
-}
-
-/*
- * Returns a unique ID from a base name.
- *
- * The value returned is valid until the next call to
- * this function.
- */
-const char *sam_hdr_pg_id(sam_hdr_t *bh, const char *name) {
-    sam_hrecs_t *hrecs;
-    size_t name_len;
-    const size_t name_extra = 17;
-    if (!bh || !name)
-        return NULL;
-
-    if (!(hrecs = bh->hrecs)) {
-        if (sam_hdr_fill_hrecs(bh) != 0)
-            return NULL;
-        hrecs = bh->hrecs;
-    }
-
-    khint_t k = kh_get(m_s2i, hrecs->pg_hash, name);
-    if (k == kh_end(hrecs->pg_hash))
-        return name;
-
-    name_len = strlen(name);
-    if (name_len > 1000) name_len = 1000;
-    if (hrecs->ID_buf_sz < name_len + name_extra) {
-        char *new_ID_buf = realloc(hrecs->ID_buf, name_len + name_extra);
-        if (new_ID_buf == NULL)
-            return NULL;
-        hrecs->ID_buf = new_ID_buf;
-        hrecs->ID_buf_sz = name_len + name_extra;
-    }
-
-    do {
-        snprintf(hrecs->ID_buf, hrecs->ID_buf_sz, "%.1000s.%d", name, hrecs->ID_cnt++);
-        k = kh_get(m_s2i, hrecs->pg_hash, hrecs->ID_buf);
-    } while (k != kh_end(hrecs->pg_hash));
-
-    return hrecs->ID_buf;
-}
-
-/*
- * Add an @PG line.
- *
- * If we wish complete control over this use sam_hdr_add_line() directly. This
- * function uses that, but attempts to do a lot of tedious house work for
- * you too.
- *
- * - It will generate a suitable ID if the supplied one clashes.
- * - It will generate multiple @PG records if we have multiple PG chains.
- *
- * Call it as per sam_hdr_add_line() with a series of key,value pairs ending
- * in NULL.
- *
- * Returns 0 on success
- *        -1 on failure
- */
-int sam_hdr_add_pg(sam_hdr_t *bh, const char *name, ...) {
-    sam_hrecs_t *hrecs;
-    const char *specified_id = NULL, *specified_pn = NULL, *specified_pp = NULL;
-    const char *key, *val;
-    if (!bh)
-        return -1;
-
-    if (!(hrecs = bh->hrecs)) {
-        if (sam_hdr_fill_hrecs(bh) != 0)
-            return -1;
-        hrecs = bh->hrecs;
-    }
-
-    bh->hrecs->pgs_changed = 1;
-    if (sam_hdr_link_pg(bh) < 0) {
-        hts_log_error("Error linking @PG lines");
-        return -1;
-    }
-
-    va_list args;
-    // Check for ID / PN / PP tags in varargs list
-    va_start(args, name);
-    while ((key = va_arg(args, const char *)) != NULL) {
-        val = va_arg(args, const char *);
-        if (!val) break;
-        if (strcmp(key, "PN") == 0 && *val != '\0')
-            specified_pn = val;
-        else if (strcmp(key, "PP") == 0 && *val != '\0')
-            specified_pp = val;
-        else if (strcmp(key, "ID") == 0 && *val != '\0')
-            specified_id = val;
-    }
-    va_end(args);
-
-    if (specified_id && hrecs->pg_hash) {
-        khint_t k = kh_get(m_s2i, hrecs->pg_hash, specified_id);
-        if (k != kh_end(hrecs->pg_hash)) {
-            hts_log_error("Header @PG ID:%s already present", specified_id);
-            return -1;
-        }
-    }
-
-    if (specified_pp && hrecs->pg_hash) {
-        khint_t k = kh_get(m_s2i, hrecs->pg_hash, specified_pp);
-        if (k == kh_end(hrecs->pg_hash)) {
-            hts_log_error("Header @PG ID:%s referred to by PP tag not present",
-                          specified_pp);
-            return -1;
-        }
-    }
-
-    if (!specified_pp && hrecs->npg_end) {
-        /* Copy ends array to avoid us looping while modifying it */
-        int *end = malloc(hrecs->npg_end * sizeof(int));
-        int i, nends = hrecs->npg_end;
-
-        if (!end)
-            return -1;
-
-        memcpy(end, hrecs->pg_end, nends * sizeof(*end));
-
-        for (i = 0; i < nends; i++) {
-            const char *id = !specified_id ? sam_hdr_pg_id(bh, name) : "";
-            if (!id) {
-                free(end);
-                return -1;
-            }
-            va_start(args, name);
-            if (-1 == sam_hrecs_vadd(hrecs, "PG", args,
-                                     "ID", id,
-                                     "PN", !specified_pn ? name : "",
-                                     "PP", hrecs->pg[end[i]].name,
-                                     NULL)) {
-                free(end);
-                return  -1;
-            }
-            va_end(args);
-        }
-
-        free(end);
-    } else {
-        const char *id = !specified_id ? sam_hdr_pg_id(bh, name) : "";
-        if (!id)
-            return -1;
-        va_start(args, name);
-        if (-1 == sam_hrecs_vadd(hrecs, "PG", args,
-                                 "ID", id,
-                                 "PN", !specified_pn ? name : "",
-                                 NULL))
-            return -1;
-        va_end(args);
-    }
-
-    hrecs->dirty = 1;
-    redact_header_text(bh);
-
-    return 0;
-}
-
-/*! Increments a reference count on bh.
- *
- * This permits multiple files to share the same header, all calling
- * sam_hdr_destroy when done, without causing errors for other open files.
- */
-void sam_hdr_incr_ref(sam_hdr_t *bh) {
-    if (!bh)
-        return;
-    bh->ref_count++;
-}
-
-/* ==== Internal methods ==== */
-
-/*
- * Creates an empty SAM header.  Allocates space for the SAM header
- * structures (hash tables) ready to be populated.
- *
- * Returns a sam_hrecs_t struct on success (free with sam_hrecs_free())
- *         NULL on failure
- */
-sam_hrecs_t *sam_hrecs_new() {
-    sam_hrecs_t *hrecs = calloc(1, sizeof(*hrecs));
-
-    if (!hrecs)
-        return NULL;
-
-    hrecs->h = kh_init(sam_hrecs_t);
-    if (!hrecs->h)
-        goto err;
-
-    hrecs->ID_cnt = 1;
-
-    hrecs->nref = 0;
-    hrecs->ref_sz = 0;
-    hrecs->ref  = NULL;
-    if (!(hrecs->ref_hash = kh_init(m_s2i)))
-        goto err;
-    hrecs->refs_changed = -1;
-
-    hrecs->nrg = 0;
-    hrecs->rg_sz = 0;
-    hrecs->rg  = NULL;
-    if (!(hrecs->rg_hash = kh_init(m_s2i)))
-        goto err;
-
-    hrecs->npg = 0;
-    hrecs->pg_sz = 0;
-    hrecs->pg  = NULL;
-    hrecs->npg_end = hrecs->npg_end_alloc = 0;
-    hrecs->pg_end = NULL;
-    if (!(hrecs->pg_hash = kh_init(m_s2i)))
-        goto err;
-
-    if (!(hrecs->tag_pool = pool_create(sizeof(sam_hrec_tag_t))))
-        goto err;
-
-    if (!(hrecs->type_pool = pool_create(sizeof(sam_hrec_type_t))))
-        goto err;
-
-    if (!(hrecs->str_pool = string_pool_create(65536)))
-        goto err;
-
-    if (sam_hrecs_init_type_order(hrecs, NULL))
-        goto err;
-
-    return hrecs;
-
-err:
-    if (hrecs->h)
-        kh_destroy(sam_hrecs_t, hrecs->h);
-
-    if (hrecs->tag_pool)
-        pool_destroy(hrecs->tag_pool);
-
-    if (hrecs->type_pool)
-        pool_destroy(hrecs->type_pool);
-
-    if (hrecs->str_pool)
-        string_pool_destroy(hrecs->str_pool);
-
-    free(hrecs);
-
-    return NULL;
-}
-#if 0
-/*
- * Produces a duplicate copy of source and returns it.
- * Returns NULL on failure
- */
-sam_hrecs_t *sam_hrecs_dup(sam_hrecs_t *source) {
-        return NULL;
-}
-#endif
-/*! Deallocates all storage used by a sam_hrecs_t struct.
- *
- * This also decrements the header reference count. If after decrementing
- * it is still non-zero then the header is assumed to be in use by another
- * caller and the free is not done.
- *
- */
-void sam_hrecs_free(sam_hrecs_t *hrecs) {
-    if (!hrecs)
-        return;
-
-    if (hrecs->h)
-        kh_destroy(sam_hrecs_t, hrecs->h);
-
-    if (hrecs->ref_hash)
-        kh_destroy(m_s2i, hrecs->ref_hash);
-
-    if (hrecs->ref)
-        free(hrecs->ref);
-
-    if (hrecs->rg_hash)
-        kh_destroy(m_s2i, hrecs->rg_hash);
-
-    if (hrecs->rg)
-        free(hrecs->rg);
-
-    if (hrecs->pg_hash)
-        kh_destroy(m_s2i, hrecs->pg_hash);
-
-    if (hrecs->pg)
-        free(hrecs->pg);
-
-    if (hrecs->pg_end)
-        free(hrecs->pg_end);
-
-    if (hrecs->type_pool)
-        pool_destroy(hrecs->type_pool);
-
-    if (hrecs->tag_pool)
-        pool_destroy(hrecs->tag_pool);
-
-    if (hrecs->str_pool)
-        string_pool_destroy(hrecs->str_pool);
-
-    if (hrecs->type_order)
-        free(hrecs->type_order);
-
-    if (hrecs->ID_buf)
-        free(hrecs->ID_buf);
-
-    free(hrecs);
-}
-
-/*
- * Internal method already used by the CRAM code
- * Returns the first header item matching 'type'. If ID is non-NULL it checks
- * for the tag ID: and compares against the specified ID.
- *
- * Returns NULL if no type/ID is found
- */
-sam_hrec_type_t *sam_hrecs_find_type_id(sam_hrecs_t *hrecs, const char *type,
-                                     const char *ID_key, const char *ID_value) {
-    if (!hrecs || !type)
-        return NULL;
-    sam_hrec_type_t *t1, *t2;
-    khint_t k;
-
-    /* Special case for types we have prebuilt hashes on */
-    if (ID_key) {
-        if (!ID_value)
-            return NULL;
-
-        if (type[0]   == 'S' && type[1]   == 'Q' &&
-            ID_key[0] == 'S' && ID_key[1] == 'N') {
-            k = kh_get(m_s2i, hrecs->ref_hash, ID_value);
-            return k != kh_end(hrecs->ref_hash)
-                ? hrecs->ref[kh_val(hrecs->ref_hash, k)].ty
-                : NULL;
-        }
-
-        if (type[0]   == 'R' && type[1]   == 'G' &&
-            ID_key[0] == 'I' && ID_key[1] == 'D') {
-            k = kh_get(m_s2i, hrecs->rg_hash, ID_value);
-            return k != kh_end(hrecs->rg_hash)
-                ? hrecs->rg[kh_val(hrecs->rg_hash, k)].ty
-                : NULL;
-        }
-
-        if (type[0]   == 'P' && type[1]   == 'G' &&
-            ID_key[0] == 'I' && ID_key[1] == 'D') {
-            k = kh_get(m_s2i, hrecs->pg_hash, ID_value);
-            return k != kh_end(hrecs->pg_hash)
-                ? hrecs->pg[kh_val(hrecs->pg_hash, k)].ty
-                : NULL;
-        }
-    }
-
-    k = kh_get(sam_hrecs_t, hrecs->h, TYPEKEY(type));
-    if (k == kh_end(hrecs->h))
-        return NULL;
-
-    if (!ID_key)
-        return kh_val(hrecs->h, k);
-
-    t1 = t2 = kh_val(hrecs->h, k);
-    do {
-        sam_hrec_tag_t *tag;
-        for (tag = t1->tag; tag; tag = tag->next) {
-            if (tag->str[0] == ID_key[0] && tag->str[1] == ID_key[1]) {
-                const char *cp1 = tag->str+3;
-                const char *cp2 = ID_value;
-                while (*cp1 && *cp1 == *cp2)
-                    cp1++, cp2++;
-                if (*cp2 || *cp1)
-                    continue;
-                return t1;
-            }
-        }
-        t1 = t1->next;
-    } while (t1 != t2);
-
-    return NULL;
-}
-
-/*
- * Adds or updates tag key,value pairs in a header line.
- * Eg for adding M5 tags to @SQ lines or updating sort order for the
- * @HD line.
- *
- * va_list contains multiple key,value pairs ending in NULL.
- *
- * Returns 0 on success
- *        -1 on failure
- */
-int sam_hrecs_vupdate(sam_hrecs_t *hrecs, sam_hrec_type_t *type, va_list ap) {
-    if (!hrecs)
-        return -1;
-
-    for (;;) {
-        char *k, *v, *str;
-        sam_hrec_tag_t *tag, *prev = NULL;
-
-        if (!(k = (char *)va_arg(ap, char *)))
-            break;
-        if (!(v = va_arg(ap, char *)))
-            v = "";
-
-        tag = sam_hrecs_find_key(type, k, &prev);
-        if (!tag) {
-            if (!(tag = pool_alloc(hrecs->tag_pool)))
-                return -1;
-            if (prev)
-                prev->next = tag;
-            else
-                type->tag = tag;
-
-            tag->next = NULL;
-        }
-
-        tag->len = 3 + strlen(v);
-        str = string_alloc(hrecs->str_pool, tag->len+1);
-        if (!str)
-            return -1;
-
-        if (snprintf(str, tag->len+1, "%2.2s:%s", k, v) < 0)
-            return -1;
-
-        tag->str = str;
-    }
-
-    hrecs->dirty = 1; //mark text as dirty and force a rebuild
-
-    return 0;
-}
-
-/*
- * Adds or updates tag key,value pairs in a header line.
- * Eg for adding M5 tags to @SQ lines or updating sort order for the
- * @HD line.
- *
- * Specify multiple key,value pairs ending in NULL.
- *
- * Returns 0 on success
- *        -1 on failure
- */
-static int sam_hrecs_update(sam_hrecs_t *hrecs, sam_hrec_type_t *type, ...) {
-    va_list args;
-    int res;
-    va_start(args, type);
-    res = sam_hrecs_vupdate(hrecs, type, args);
-    va_end(args);
-    return res;
-}
-
-/*
- * Looks for a specific key in a single sam header line identified by *type.
- * If prev is non-NULL it also fills this out with the previous tag, to
- * permit use in key removal. *prev is set to NULL when the tag is the first
- * key in the list. When a tag isn't found, prev (if non NULL) will be the last
- * tag in the existing list.
- *
- * Returns the tag pointer on success
- *         NULL on failure
- */
-sam_hrec_tag_t *sam_hrecs_find_key(sam_hrec_type_t *type,
-                                   const char *key,
-                                   sam_hrec_tag_t **prev) {
-    sam_hrec_tag_t *tag, *p = NULL;
-    if (!type)
-        return NULL;
-
-    for (tag = type->tag; tag; p = tag, tag = tag->next) {
-        if (tag->str[0] == key[0] && tag->str[1] == key[1]) {
-            if (prev)
-                *prev = p;
-            return tag;
-        }
-    }
-
-    if (prev)
-        *prev = p;
-
-    return NULL;
-}
-
-int sam_hrecs_remove_key(sam_hrecs_t *hrecs,
-                         sam_hrec_type_t *type,
-                         const char *key) {
-    sam_hrec_tag_t *tag, *prev;
-    if (!hrecs)
-        return -1;
-    tag = sam_hrecs_find_key(type, key, &prev);
-    if (!tag)
-        return 0; // Not there anyway
-
-    if (type->type == TYPEKEY("SQ") && tag->str[0] == 'A' && tag->str[1] == 'N') {
-        assert(tag->len >= 3);
-        sam_hrec_tag_t *sn_tag = sam_hrecs_find_key(type, "SN", NULL);
-        if (sn_tag) {
-            assert(sn_tag->len >= 3);
-            khint_t k = kh_get(m_s2i, hrecs->ref_hash, sn_tag->str + 3);
-            if (k != kh_end(hrecs->ref_hash))
-                sam_hrecs_remove_ref_altnames(hrecs, kh_val(hrecs->ref_hash, k), tag->str + 3);
-        }
-    }
-
-    if (!prev) { //first tag
-        type->tag = tag->next;
-    } else {
-        prev->next = tag->next;
-    }
-    pool_free(hrecs->tag_pool, tag);
-    hrecs->dirty = 1; //mark text as dirty and force a rebuild
-
-    return 1;
-}
-
-/*
- * Looks up a read-group by name and returns a pointer to the start of the
- * associated tag list.
- *
- * Returns NULL on failure
- */
-sam_hrec_rg_t *sam_hrecs_find_rg(sam_hrecs_t *hrecs, const char *rg) {
-    khint_t k = kh_get(m_s2i, hrecs->rg_hash, rg);
-    return k == kh_end(hrecs->rg_hash)
-        ? NULL
-        : &hrecs->rg[kh_val(hrecs->rg_hash, k)];
-}
-
-#if DEBUG_HEADER
-void sam_hrecs_dump(sam_hrecs_t *hrecs) {
-    khint_t k;
-    int i;
-
-    printf("===DUMP===\n");
-    for (k = kh_begin(hrecs->h); k != kh_end(hrecs->h); k++) {
-        sam_hrec_type_t *t1, *t2;
-        char c[2];
-        int idx = 0;
-
-        if (!kh_exist(hrecs->h, k))
-            continue;
-
-        t1 = t2 = kh_val(hrecs->h, k);
-        c[0] = kh_key(hrecs->h, k)>>8;
-        c[1] = kh_key(hrecs->h, k)&0xff;
-        printf("Type %.2s\n", c);
-
-        do {
-            sam_hrec_tag_t *tag;
-            printf(">>>%d ", idx++);
-            for (tag = t1->tag; tag; tag=tag->next) {
-                if (strncmp(c, "CO", 2))
-                    printf("\"%.2s\":\"%.*s\"\t", tag->str, tag->len-3, tag->str+3);
-                else
-                    printf("%s", tag->str);
-            }
-            putchar('\n');
-            t1 = t1->next;
-        } while (t1 != t2);
-    }
-
-    /* Dump out PG chains */
-    printf("\n@PG chains:\n");
-    for (i = 0; i < hrecs->npg_end; i++) {
-        int j;
-        printf("  %d:", i);
-        for (j = hrecs->pg_end[i]; j != -1; j = hrecs->pg[j].prev_id) {
-            printf("%s%d(%.*s)",
-                   j == hrecs->pg_end[i] ? " " : "->",
-                   j, hrecs->pg[j].name_len, hrecs->pg[j].name);
-        }
-        printf("\n");
-    }
-
-    puts("===END DUMP===");
-}
-#endif
-
-/*
- * Returns the sort order:
- */
-enum sam_sort_order sam_hrecs_sort_order(sam_hrecs_t *hrecs) {
-    khint_t k;
-    enum sam_sort_order so;
-
-    so = ORDER_UNKNOWN;
-    k = kh_get(sam_hrecs_t, hrecs->h, TYPEKEY("HD"));
-    if (k != kh_end(hrecs->h)) {
-        sam_hrec_type_t *ty = kh_val(hrecs->h, k);
-        sam_hrec_tag_t *tag;
-        for (tag = ty->tag; tag; tag = tag->next) {
-            if (tag->str[0] == 'S' && tag->str[1] == 'O') {
-                if (strcmp(tag->str+3, "unsorted") == 0)
-                    so = ORDER_UNSORTED;
-                else if (strcmp(tag->str+3, "queryname") == 0)
-                    so = ORDER_NAME;
-                else if (strcmp(tag->str+3, "coordinate") == 0)
-                    so = ORDER_COORD;
-                else if (strcmp(tag->str+3, "unknown") != 0)
-                    hts_log_error("Unknown sort order field: %s", tag->str+3);
-            }
-        }
-    }
-
-    return so;
-}
-
-enum sam_group_order sam_hrecs_group_order(sam_hrecs_t *hrecs) {
-    khint_t k;
-    enum sam_group_order go;
-
-    go = ORDER_NONE;
-    k = kh_get(sam_hrecs_t, hrecs->h, TYPEKEY("HD"));
-    if (k != kh_end(hrecs->h)) {
-        sam_hrec_type_t *ty = kh_val(hrecs->h, k);
-        sam_hrec_tag_t *tag;
-        for (tag = ty->tag; tag; tag = tag->next) {
-            if (tag->str[0] == 'G' && tag->str[1] == 'O') {
-                if (strcmp(tag->str+3, "query") == 0)
-                    go = ORDER_QUERY;
-                else if (strcmp(tag->str+3, "reference") == 0)
-                    go = ORDER_REFERENCE;
-            }
-        }
-    }
-
-    return go;
-}
diff -ruN stringtie.orig/htslib/header.h stringtie/htslib/header.h
--- stringtie.orig/htslib/header.h	2024-02-28 13:57:39.701246126 +0100
+++ stringtie/htslib/header.h	1970-01-01 01:00:00.000000000 +0100
@@ -1,319 +0,0 @@
-/*
-Copyright (c) 2013-2019 Genome Research Ltd.
-Authors: James Bonfield <jkb@sanger.ac.uk>, Valeriu Ohan <vo2@sanger.ac.uk>
-
-Redistribution and use in source and binary forms, with or without
-modification, are permitted provided that the following conditions are met:
-
-   1. Redistributions of source code must retain the above copyright notice,
-this list of conditions and the following disclaimer.
-
-   2. Redistributions in binary form must reproduce the above copyright notice,
-this list of conditions and the following disclaimer in the documentation
-and/or other materials provided with the distribution.
-
-   3. Neither the names Genome Research Ltd and Wellcome Trust Sanger
-Institute nor the names of its contributors may be used to endorse or promote
-products derived from this software without specific prior written permission.
-
-THIS SOFTWARE IS PROVIDED BY GENOME RESEARCH LTD AND CONTRIBUTORS "AS IS" AND
-ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
-WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
-DISCLAIMED. IN NO EVENT SHALL GENOME RESEARCH LTD OR CONTRIBUTORS BE LIABLE
-FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
-DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
-SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
-CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
-OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
-OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-*/
-
-/*! \file
- * SAM header parsing.
- *
- * These functions can be shared between SAM, BAM and CRAM file
- * formats as all three internally use the same string encoding for
- * header fields.
- */
-
-
-#ifndef HEADER_H_
-#define HEADER_H_
-
-#include <stdarg.h>
-
-#include "cram/string_alloc.h"
-#include "cram/pooled_alloc.h"
-
-#include "htslib/khash.h"
-#include "htslib/kstring.h"
-#include "htslib/sam.h"
-
-#ifdef __cplusplus
-extern "C" {
-#endif
-
-/*! Make a single integer out of a two-letter type code */
-static inline khint32_t TYPEKEY(const char *type) {
-    unsigned int u0 = (unsigned char) type[0];
-    unsigned int u1 = (unsigned char) type[1];
-    return (u0 << 8) | u1;
-}
-
-/*
- * Proposed new SAM header parsing
-
-1 @SQ ID:foo LN:100
-2 @SQ ID:bar LN:200
-3 @SQ ID:ram LN:300 UR:xyz
-4 @RG ID:r ...
-5 @RG ID:s ...
-
-Hash table for 2-char @keys without dup entries.
-If dup lines, we form a circular linked list. Ie hash keys = {RG, SQ}.
-
-HASH("SQ")--\
-            |
-    (3) <-> 1 <-> 2 <-> 3 <-> (1)
-
-HASH("RG")--\
-            |
-    (5) <-> 4 <-> 5 <-> (4)
-
-Items stored in the hash values also form their own linked lists:
-Ie SQ->ID(foo)->LN(100)
-   SQ->ID(bar)->LN(200)
-   SQ->ID(ram)->LN(300)->UR(xyz)
-   RG->ID(r)
- */
-
-/*! A single key:value pair on a header line
- *
- * These form a linked list and hold strings. The strings are
- * allocated from a string_alloc_t pool referenced in the master
- * sam_hrecs_t structure. Do not attempt to free, malloc or manipulate
- * these strings directly.
- */
-typedef struct sam_hrec_tag_s {
-    struct sam_hrec_tag_s *next;
-    const char *str;
-    int   len;
-} sam_hrec_tag_t;
-
-/*! The parsed version of the SAM header string.
- *
- * Each header type (SQ, RG, HD, etc) points to its own sam_hdr_type
- * struct via the main hash table h in the sam_hrecs_t struct.
- *
- * These in turn consist of circular bi-directional linked lists (ie
- * rings) to hold the multiple instances of the same header type
- * code. For example if we have 5 \@SQ lines the primary hash table
- * will key on \@SQ pointing to the first sam_hdr_type and that in turn
- * will be part of a ring of 5 elements.
- *
- * For each sam_hdr_type structure we also point to a sam_hdr_tag
- * structure which holds the tokenised attributes; the tab separated
- * key:value pairs per line.
- */
-typedef struct sam_hrec_type_s {
-    struct sam_hrec_type_s *next; // circular list of this type
-    struct sam_hrec_type_s *prev; // circular list of this type
-    struct sam_hrec_type_s *global_next; // circular list of all lines
-    struct sam_hrec_type_s *global_prev; // circular list of all lines
-    sam_hrec_tag_t *tag;          // first tag
-    khint32_t type;               // Two-letter type code as an int
-} sam_hrec_type_t;
-
-/*! Parsed \@SQ lines */
-typedef struct {
-    const char *name;
-    hts_pos_t len;
-    sam_hrec_type_t *ty;
-} sam_hrec_sq_t;
-
-/*! Parsed \@RG lines */
-typedef struct {
-    const char *name;
-    sam_hrec_type_t *ty;
-    int name_len;
-    int id;           // numerical ID
-} sam_hrec_rg_t;
-
-/*! Parsed \@PG lines */
-typedef struct {
-    const char *name;
-    sam_hrec_type_t *ty;
-    int name_len;
-    int id;           // numerical ID
-    int prev_id;      // -1 if none
-} sam_hrec_pg_t;
-
-
-/*! Sort order parsed from @HD line */
-enum sam_sort_order {
-    ORDER_UNKNOWN  =-1,
-    ORDER_UNSORTED = 0,
-    ORDER_NAME     = 1,
-    ORDER_COORD    = 2
-  //ORDER_COLLATE  = 3 // maybe one day!
-};
-
-enum sam_group_order {
-    ORDER_NONE      =-1,
-    ORDER_QUERY     = 0,
-    ORDER_REFERENCE = 1
-};
-
-KHASH_MAP_INIT_INT(sam_hrecs_t, sam_hrec_type_t*)
-KHASH_MAP_INIT_STR(m_s2i, int)
-
-/*! Primary structure for header manipulation
- *
- * The initial header text is held in the text kstring_t, but is also
- * parsed out into SQ, RG and PG arrays. These have a hash table
- * associated with each to allow lookup by ID or SN fields instead of
- * their numeric array indices. Additionally PG has an array to hold
- * the linked list start points (the last in a PP chain).
- *
- * Use the appropriate sam_hdr_* functions to edit the header, and
- * call sam_hdr_rebuild() any time the textual form needs to be
- * updated again.
- */
-struct sam_hrecs_t {
-    khash_t(sam_hrecs_t) *h;
-    sam_hrec_type_t *first_line; //!< First line (usually @HD)
-    string_alloc_t *str_pool; //!< Pool of sam_hdr_tag->str strings
-    pool_alloc_t   *type_pool;//!< Pool of sam_hdr_type structs
-    pool_alloc_t   *tag_pool; //!< Pool of sam_hdr_tag structs
-
-    // @SQ lines / references
-    int nref;                  //!< Number of \@SQ lines
-    int ref_sz;                //!< Number of entries available in ref[]
-    sam_hrec_sq_t *ref;        //!< Array of parsed \@SQ lines
-    khash_t(m_s2i) *ref_hash;  //!< Maps SQ SN field to ref[] index
-
-    // @RG lines / read-groups
-    int nrg;                   //!< Number of \@RG lines
-    int rg_sz;                 //!< number of entries available in rg[]
-    sam_hrec_rg_t *rg;         //!< Array of parsed \@RG lines
-    khash_t(m_s2i) *rg_hash;   //!< Maps RG ID field to rg[] index
-
-    // @PG lines / programs
-    int npg;                   //!< Number of \@PG lines
-    int pg_sz;                //!< Number of entries available in pg[]
-    int npg_end;               //!< Number of terminating \@PG lines
-    int npg_end_alloc;         //!< Size of pg_end field
-    sam_hrec_pg_t *pg;         //!< Array of parsed \@PG lines
-    khash_t(m_s2i) *pg_hash;   //!< Maps PG ID field to pg[] index
-    int *pg_end;               //!< \@PG chain termination IDs
-
-    // @cond internal
-    char *ID_buf;             // temporary buffer for sam_hdr_pg_id
-    uint32_t ID_buf_sz;
-    int ID_cnt;
-    // @endcond
-
-    int dirty;                // marks the header as modified, so it can be rebuilt
-    int refs_changed;         // Index of first changed ref (-1 if unchanged)
-    int pgs_changed;          // New PG line added
-    int type_count;
-    char (*type_order)[3];
-};
-
-/*!
- * Method for parsing the header text and populating the
- * internal hash tables. After calling this method, the
- * parsed representation becomes the single source of truth.
- *
- * @param bh    Header structure, previously initialised by a
- *              sam_hdr_init call
- * @return      0 on success, -1 on failure
- */
-int sam_hdr_fill_hrecs(sam_hdr_t *bh);
-
-/*!
- * Reconstructs the text representation of the header from
- * the hash table data after a change has been performed on
- * the header.
- *
- * @return  0 on success, -1 on failure
- */
-int sam_hdr_rebuild(sam_hdr_t *bh);
-
-/*! Creates an empty SAM header, ready to be populated.
- *
- * @return
- * Returns a sam_hrecs_t struct on success (free with sam_hrecs_free())
- *         NULL on failure
- */
-sam_hrecs_t *sam_hrecs_new(void);
-
-/*! Produces a duplicate copy of hrecs and returns it.
- * @return
- * Returns NULL on failure
- */
-sam_hrecs_t *sam_hrecs_dup(sam_hrecs_t *hrecs);
-
-/*! Update sam_hdr_t target_name and target_len arrays
- *
- *  sam_hdr_t and sam_hrecs_t are specified separately so that sam_hdr_dup
- *  can use it to construct target arrays from the source header.
- *
- *  @return 0 on success; -1 on failure
- */
-int sam_hdr_update_target_arrays(sam_hdr_t *bh, const sam_hrecs_t *hrecs,
-                                 int refs_changed);
-
-/*! Reconstructs a kstring from the header hash table.
- *
- * @return
- * Returns 0 on success
- *        -1 on failure
- */
-int sam_hrecs_rebuild_text(const sam_hrecs_t *hrecs, kstring_t *ks);
-
-/*! Deallocates all storage used by a sam_hrecs_t struct.
- *
- * This also decrements the header reference count. If after decrementing
- * it is still non-zero then the header is assumed to be in use by another
- * caller and the free is not done.
- */
-void sam_hrecs_free(sam_hrecs_t *hrecs);
-
-/*!
- * @return
- * Returns the first header item matching 'type'. If ID is non-NULL it checks
- * for the tag ID: and compares against the specified ID.
- *
- * Returns NULL if no type/ID is found
- */
-sam_hrec_type_t *sam_hrecs_find_type_id(sam_hrecs_t *hrecs, const char *type,
-                                     const char *ID_key, const char *ID_value);
-
-sam_hrec_tag_t *sam_hrecs_find_key(sam_hrec_type_t *type,
-                                   const char *key,
-                                   sam_hrec_tag_t **prev);
-
-int sam_hrecs_remove_key(sam_hrecs_t *hrecs,
-                         sam_hrec_type_t *type,
-                         const char *key);
-
-/*! Looks up a read-group by name and returns a pointer to the start of the
- * associated tag list.
- *
- * @return
- * Returns NULL on failure
- */
-sam_hrec_rg_t *sam_hrecs_find_rg(sam_hrecs_t *hrecs, const char *rg);
-
-/*! Returns the sort order from the @HD SO: field */
-enum sam_sort_order sam_hrecs_sort_order(sam_hrecs_t *hrecs);
-
-/*! Returns the group order from the @HD SO: field */
-enum sam_group_order sam_hrecs_group_order(sam_hrecs_t *hrecs);
-
-#ifdef __cplusplus
-}
-#endif
-
-#endif /* HEADER_H_ */
diff -ruN stringtie.orig/htslib/hfile.c stringtie/htslib/hfile.c
--- stringtie.orig/htslib/hfile.c	2024-02-28 13:57:39.701246126 +0100
+++ stringtie/htslib/hfile.c	1970-01-01 01:00:00.000000000 +0100
@@ -1,1405 +0,0 @@
-/*  hfile.c -- buffered low-level input/output streams.
-
-    Copyright (C) 2013-2021 Genome Research Ltd.
-
-    Author: John Marshall <jm18@sanger.ac.uk>
-
-Permission is hereby granted, free of charge, to any person obtaining a copy
-of this software and associated documentation files (the "Software"), to deal
-in the Software without restriction, including without limitation the rights
-to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
-copies of the Software, and to permit persons to whom the Software is
-furnished to do so, subject to the following conditions:
-
-The above copyright notice and this permission notice shall be included in
-all copies or substantial portions of the Software.
-
-THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
-IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
-FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
-THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
-LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
-FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
-DEALINGS IN THE SOFTWARE.  */
-
-#define HTS_BUILDING_LIBRARY // Enables HTSLIB_EXPORT, see htslib/hts_defs.h
-#include <config.h>
-
-#include <stdio.h>
-#include <stdlib.h>
-#include <stddef.h>
-#include <string.h>
-#include <errno.h>
-#include <limits.h>
-
-#include <pthread.h>
-
-#ifdef ENABLE_PLUGINS
-#if defined(_WIN32) || defined(__CYGWIN__) || defined(__MSYS__)
-#define USING_WINDOWS_PLUGIN_DLLS
-#include <dlfcn.h>
-#endif
-#endif
-
-#include "htslib/hfile.h"
-#include "hfile_internal.h"
-#include "htslib/kstring.h"
-
-#ifndef ENOTSUP
-#define ENOTSUP EINVAL
-#endif
-#ifndef EOVERFLOW
-#define EOVERFLOW ERANGE
-#endif
-#ifndef EPROTONOSUPPORT
-#define EPROTONOSUPPORT ENOSYS
-#endif
-
-#ifndef SSIZE_MAX /* SSIZE_MAX is POSIX 1 */
-#define SSIZE_MAX LONG_MAX
-#endif
-
-/* hFILE fields are used as follows:
-
-   char *buffer;     // Pointer to the start of the I/O buffer
-   char *begin;      // First not-yet-read character / unused position
-   char *end;        // First unfilled/unfillable position
-   char *limit;      // Pointer to the first position past the buffer
-
-   const hFILE_backend *backend;  // Methods to refill/flush I/O buffer
-
-   off_t offset;     // Offset within the stream of buffer position 0
-   unsigned at_eof:1;// For reading, whether EOF has been seen
-   unsigned mobile:1;// Buffer is a mobile window or fixed full contents
-   unsigned readonly:1;// Whether opened as "r" rather than "r+"/"w"/"a"
-   int has_errno;    // Error number from the last failure on this stream
-
-For reading, begin is the first unread character in the buffer and end is the
-first unfilled position:
-
-   -----------ABCDEFGHIJKLMNO---------------
-   ^buffer    ^begin         ^end           ^limit
-
-For writing, begin is the first unused position and end is unused so remains
-equal to buffer:
-
-   ABCDEFGHIJKLMNOPQRSTUVWXYZ---------------
-   ^buffer                   ^begin         ^limit
-   ^end
-
-Thus if begin > end then there is a non-empty write buffer, if begin < end
-then there is a non-empty read buffer, and if begin == end then both buffers
-are empty.  In all cases, the stream's file position indicator corresponds
-to the position pointed to by begin.
-
-The above is the normal scenario of a mobile window.  For in-memory
-streams (eg via hfile_init_fixed) the buffer can be used as the full
-contents without any separate backend behind it.  These always have at_eof
-set, offset set to 0, need no read() method, and should just return EINVAL
-for seek():
-
-   abcdefghijkLMNOPQRSTUVWXYZ------
-   ^buffer    ^begin         ^end  ^limit
-*/
-HTSLIB_EXPORT
-hFILE *hfile_init(size_t struct_size, const char *mode, size_t capacity)
-{
-    hFILE *fp = (hFILE *) malloc(struct_size);
-    if (fp == NULL) goto error;
-
-    if (capacity == 0) capacity = 32768;
-    // FIXME For now, clamp input buffer sizes so mpileup doesn't eat memory
-    if (strchr(mode, 'r') && capacity > 32768) capacity = 32768;
-
-    fp->buffer = (char *) malloc(capacity);
-    if (fp->buffer == NULL) goto error;
-
-    fp->begin = fp->end = fp->buffer;
-    fp->limit = &fp->buffer[capacity];
-
-    fp->offset = 0;
-    fp->at_eof = 0;
-    fp->mobile = 1;
-    fp->readonly = (strchr(mode, 'r') && ! strchr(mode, '+'));
-    fp->has_errno = 0;
-    return fp;
-
-error:
-    hfile_destroy(fp);
-    return NULL;
-}
-
-hFILE *hfile_init_fixed(size_t struct_size, const char *mode,
-                        char *buffer, size_t buf_filled, size_t buf_size)
-{
-    hFILE *fp = (hFILE *) malloc(struct_size);
-    if (fp == NULL) return NULL;
-
-    fp->buffer = fp->begin = buffer;
-    fp->end = &fp->buffer[buf_filled];
-    fp->limit = &fp->buffer[buf_size];
-
-    fp->offset = 0;
-    fp->at_eof = 1;
-    fp->mobile = 0;
-    fp->readonly = (strchr(mode, 'r') && ! strchr(mode, '+'));
-    fp->has_errno = 0;
-    return fp;
-}
-
-static const struct hFILE_backend mem_backend;
-
-HTSLIB_EXPORT
-void hfile_destroy(hFILE *fp)
-{
-    int save = errno;
-    if (fp) free(fp->buffer);
-    free(fp);
-    errno = save;
-}
-
-static inline int writebuffer_is_nonempty(hFILE *fp)
-{
-    return fp->begin > fp->end;
-}
-
-/* Refills the read buffer from the backend (once, so may only partially
-   fill the buffer), returning the number of additional characters read
-   (which might be 0), or negative when an error occurred.  */
-static ssize_t refill_buffer(hFILE *fp)
-{
-    ssize_t n;
-
-    // Move any unread characters to the start of the buffer
-    if (fp->mobile && fp->begin > fp->buffer) {
-        fp->offset += fp->begin - fp->buffer;
-        memmove(fp->buffer, fp->begin, fp->end - fp->begin);
-        fp->end = &fp->buffer[fp->end - fp->begin];
-        fp->begin = fp->buffer;
-    }
-
-    // Read into the available buffer space at fp->[end,limit)
-    if (fp->at_eof || fp->end == fp->limit) n = 0;
-    else {
-        n = fp->backend->read(fp, fp->end, fp->limit - fp->end);
-        if (n < 0) { fp->has_errno = errno; return n; }
-        else if (n == 0) fp->at_eof = 1;
-    }
-
-    fp->end += n;
-    return n;
-}
-
-/*
- * Changes the buffer size for an hFILE.  Ideally this is done
- * immediately after opening.  If performed later, this function may
- * fail if we are reducing the buffer size and the current offset into
- * the buffer is beyond the new capacity.
- *
- * Returns 0 on success;
- *        -1 on failure.
- */
-HTSLIB_EXPORT
-int hfile_set_blksize(hFILE *fp, size_t bufsiz) {
-    char *buffer;
-    ptrdiff_t curr_used;
-    if (!fp) return -1;
-    curr_used = (fp->begin > fp->end ? fp->begin : fp->end) - fp->buffer;
-    if (bufsiz == 0) bufsiz = 32768;
-
-    // Ensure buffer resize will not erase live data
-    if (bufsiz < curr_used)
-        return -1;
-
-    if (!(buffer = (char *) realloc(fp->buffer, bufsiz))) return -1;
-
-    fp->begin  = buffer + (fp->begin - fp->buffer);
-    fp->end    = buffer + (fp->end   - fp->buffer);
-    fp->buffer = buffer;
-    fp->limit  = &fp->buffer[bufsiz];
-
-    return 0;
-}
-
-/* Called only from hgetc(), when our buffer is empty.  */
-HTSLIB_EXPORT
-int hgetc2(hFILE *fp)
-{
-    return (refill_buffer(fp) > 0)? (unsigned char) *(fp->begin++) : EOF;
-}
-
-ssize_t hgetdelim(char *buffer, size_t size, int delim, hFILE *fp)
-{
-    char *found;
-    size_t n, copied = 0;
-    ssize_t got;
-
-    if (size < 1 || size > SSIZE_MAX) {
-        fp->has_errno = errno = EINVAL;
-        return -1;
-    }
-    if (writebuffer_is_nonempty(fp)) {
-        fp->has_errno = errno = EBADF;
-        return -1;
-    }
-
-    --size; /* to allow space for the NUL terminator */
-
-    do {
-        n = fp->end - fp->begin;
-        if (n > size - copied) n = size - copied;
-
-        /* Look in the hFILE buffer for the delimiter */
-        found = memchr(fp->begin, delim, n);
-        if (found != NULL) {
-            n = found - fp->begin + 1;
-            memcpy(buffer + copied, fp->begin, n);
-            buffer[n + copied] = '\0';
-            fp->begin += n;
-            return n + copied;
-        }
-
-        /* No delimiter yet, copy as much as we can and refill if necessary */
-        memcpy(buffer + copied, fp->begin, n);
-        fp->begin += n;
-        copied += n;
-
-        if (copied == size) { /* Output buffer full */
-            buffer[copied] = '\0';
-            return copied;
-        }
-
-        got = refill_buffer(fp);
-    } while (got > 0);
-
-    if (got < 0) return -1; /* Error on refill. */
-
-    buffer[copied] = '\0';  /* EOF, return anything that was copied. */
-    return copied;
-}
-
-char *hgets(char *buffer, int size, hFILE *fp)
-{
-    if (size < 1) {
-        fp->has_errno = errno = EINVAL;
-        return NULL;
-    }
-    return hgetln(buffer, size, fp) > 0 ? buffer : NULL;
-}
-
-ssize_t hpeek(hFILE *fp, void *buffer, size_t nbytes)
-{
-    size_t n = fp->end - fp->begin;
-    while (n < nbytes) {
-        ssize_t ret = refill_buffer(fp);
-        if (ret < 0) return ret;
-        else if (ret == 0) break;
-        else n += ret;
-    }
-
-    if (n > nbytes) n = nbytes;
-    memcpy(buffer, fp->begin, n);
-    return n;
-}
-
-/* Called only from hread(); when called, our buffer is empty and nread bytes
-   have already been placed in the destination buffer.  */
-HTSLIB_EXPORT
-ssize_t hread2(hFILE *fp, void *destv, size_t nbytes, size_t nread)
-{
-    const size_t capacity = fp->limit - fp->buffer;
-    int buffer_invalidated = 0;
-    char *dest = (char *) destv;
-    dest += nread, nbytes -= nread;
-
-    // Read large requests directly into the destination buffer
-    while (nbytes * 2 >= capacity && !fp->at_eof) {
-        ssize_t n = fp->backend->read(fp, dest, nbytes);
-        if (n < 0) { fp->has_errno = errno; return n; }
-        else if (n == 0) fp->at_eof = 1;
-        else buffer_invalidated = 1;
-        fp->offset += n;
-        dest += n, nbytes -= n;
-        nread += n;
-    }
-
-    if (buffer_invalidated) {
-        // Our unread buffer is empty, so begin == end, but our already-read
-        // buffer [buffer,begin) is likely non-empty and is no longer valid as
-        // its contents are no longer adjacent to the file position indicator.
-        // Discard it so that hseek() can't try to take advantage of it.
-        fp->offset += fp->begin - fp->buffer;
-        fp->begin = fp->end = fp->buffer;
-    }
-
-    while (nbytes > 0 && !fp->at_eof) {
-        size_t n;
-        ssize_t ret = refill_buffer(fp);
-        if (ret < 0) return ret;
-
-        n = fp->end - fp->begin;
-        if (n > nbytes) n = nbytes;
-        memcpy(dest, fp->begin, n);
-        fp->begin += n;
-        dest += n, nbytes -= n;
-        nread += n;
-    }
-
-    return nread;
-}
-
-/* Flushes the write buffer, fp->[buffer,begin), out through the backend
-   returning 0 on success or negative if an error occurred.  */
-static ssize_t flush_buffer(hFILE *fp)
-{
-    const char *buffer = fp->buffer;
-    while (buffer < fp->begin) {
-        ssize_t n = fp->backend->write(fp, buffer, fp->begin - buffer);
-        if (n < 0) { fp->has_errno = errno; return n; }
-        buffer += n;
-        fp->offset += n;
-    }
-
-    fp->begin = fp->buffer;  // Leave the buffer empty
-    return 0;
-}
-
-int hflush(hFILE *fp)
-{
-    if (flush_buffer(fp) < 0) return EOF;
-    if (fp->backend->flush) {
-        if (fp->backend->flush(fp) < 0) { fp->has_errno = errno; return EOF; }
-    }
-    return 0;
-}
-
-/* Called only from hputc(), when our buffer is already full.  */
-HTSLIB_EXPORT
-int hputc2(int c, hFILE *fp)
-{
-    if (flush_buffer(fp) < 0) return EOF;
-    *(fp->begin++) = c;
-    return c;
-}
-
-/* Called only from hwrite() and hputs2(); when called, our buffer is either
-   full and ncopied bytes from the source have already been copied to our
-   buffer; or completely empty, ncopied is zero and totalbytes is greater than
-   the buffer size.  */
-HTSLIB_EXPORT
-ssize_t hwrite2(hFILE *fp, const void *srcv, size_t totalbytes, size_t ncopied)
-{
-    const char *src = (const char *) srcv;
-    ssize_t ret;
-    const size_t capacity = fp->limit - fp->buffer;
-    size_t remaining = totalbytes - ncopied;
-    src += ncopied;
-
-    ret = flush_buffer(fp);
-    if (ret < 0) return ret;
-
-    // Write large blocks out directly from the source buffer
-    while (remaining * 2 >= capacity) {
-        ssize_t n = fp->backend->write(fp, src, remaining);
-        if (n < 0) { fp->has_errno = errno; return n; }
-        fp->offset += n;
-        src += n, remaining -= n;
-    }
-
-    // Just buffer any remaining characters
-    memcpy(fp->begin, src, remaining);
-    fp->begin += remaining;
-
-    return totalbytes;
-}
-
-/* Called only from hputs(), when our buffer is already full.  */
-HTSLIB_EXPORT
-int hputs2(const char *text, size_t totalbytes, size_t ncopied, hFILE *fp)
-{
-    return (hwrite2(fp, text, totalbytes, ncopied) >= 0)? 0 : EOF;
-}
-
-off_t hseek(hFILE *fp, off_t offset, int whence)
-{
-    off_t curpos, pos;
-
-    if (writebuffer_is_nonempty(fp) && fp->mobile) {
-        int ret = flush_buffer(fp);
-        if (ret < 0) return ret;
-    }
-
-    curpos = htell(fp);
-
-    // Relative offsets are given relative to the hFILE's stream position,
-    // which may differ from the backend's physical position due to buffering
-    // read-ahead.  Correct for this by converting to an absolute position.
-    if (whence == SEEK_CUR) {
-        if (curpos + offset < 0) {
-            // Either a negative offset resulted in a position before the
-            // start of the file, or we overflowed when given a positive offset
-            fp->has_errno = errno = (offset < 0)? EINVAL : EOVERFLOW;
-            return -1;
-        }
-
-        whence = SEEK_SET;
-        offset = curpos + offset;
-    }
-    // For fixed immobile buffers, convert everything else to SEEK_SET too
-    // so that seeking can be avoided for all (within range) requests.
-    else if (! fp->mobile && whence == SEEK_END) {
-        size_t length = fp->end - fp->buffer;
-        if (offset > 0 || -offset > length) {
-            fp->has_errno = errno = EINVAL;
-            return -1;
-        }
-
-        whence = SEEK_SET;
-        offset = length + offset;
-    }
-
-    // Avoid seeking if the desired position is within our read buffer.
-    // (But not when the next operation may be a write on a mobile buffer.)
-    if (whence == SEEK_SET && (! fp->mobile || fp->readonly) &&
-        offset >= fp->offset && offset - fp->offset <= fp->end - fp->buffer) {
-        fp->begin = &fp->buffer[offset - fp->offset];
-        return offset;
-    }
-
-    pos = fp->backend->seek(fp, offset, whence);
-    if (pos < 0) { fp->has_errno = errno; return pos; }
-
-    // Seeking succeeded, so discard any non-empty read buffer
-    fp->begin = fp->end = fp->buffer;
-    fp->at_eof = 0;
-
-    fp->offset = pos;
-    return pos;
-}
-
-int hclose(hFILE *fp)
-{
-    int err = fp->has_errno;
-
-    if (writebuffer_is_nonempty(fp) && hflush(fp) < 0) err = fp->has_errno;
-    if (fp->backend->close(fp) < 0) err = errno;
-    hfile_destroy(fp);
-
-    if (err) {
-        errno = err;
-        return EOF;
-    }
-    else return 0;
-}
-
-void hclose_abruptly(hFILE *fp)
-{
-    int save = errno;
-    if (fp->backend->close(fp) < 0) { /* Ignore subsequent errors */ }
-    hfile_destroy(fp);
-    errno = save;
-}
-
-
-/***************************
- * File descriptor backend *
- ***************************/
-
-#ifndef _WIN32
-#include <sys/socket.h>
-#include <sys/stat.h>
-#define HAVE_STRUCT_STAT_ST_BLKSIZE
-#else
-#include <winsock2.h>
-#define HAVE_CLOSESOCKET
-#define HAVE_SETMODE
-#endif
-#include <fcntl.h>
-#include <unistd.h>
-
-/* For Unix, it doesn't matter whether a file descriptor is a socket.
-   However Windows insists on send()/recv() and its own closesocket()
-   being used when fd happens to be a socket.  */
-
-typedef struct {
-    hFILE base;
-    int fd;
-    unsigned is_socket:1;
-} hFILE_fd;
-
-static ssize_t fd_read(hFILE *fpv, void *buffer, size_t nbytes)
-{
-    hFILE_fd *fp = (hFILE_fd *) fpv;
-    ssize_t n;
-    do {
-        n = fp->is_socket? recv(fp->fd, buffer, nbytes, 0)
-                         : read(fp->fd, buffer, nbytes);
-    } while (n < 0 && errno == EINTR);
-    return n;
-}
-
-static ssize_t fd_write(hFILE *fpv, const void *buffer, size_t nbytes)
-{
-    hFILE_fd *fp = (hFILE_fd *) fpv;
-    ssize_t n;
-    do {
-        n = fp->is_socket?  send(fp->fd, buffer, nbytes, 0)
-                         : write(fp->fd, buffer, nbytes);
-    } while (n < 0 && errno == EINTR);
-#ifdef _WIN32
-        // On windows we have no SIGPIPE.  Instead write returns
-        // EINVAL.  We check for this and our fd being a pipe.
-        // If so, we raise SIGTERM instead of SIGPIPE.  It's not
-        // ideal, but I think the only alternative is extra checking
-        // in every single piece of code.
-        if (n < 0 && errno == EINVAL &&
-            GetLastError() == ERROR_NO_DATA &&
-            GetFileType((HANDLE)_get_osfhandle(fp->fd)) == FILE_TYPE_PIPE) {
-            raise(SIGTERM);
-        }
-#endif
-    return n;
-}
-
-static off_t fd_seek(hFILE *fpv, off_t offset, int whence)
-{
-    hFILE_fd *fp = (hFILE_fd *) fpv;
-    return lseek(fp->fd, offset, whence);
-}
-
-static int fd_flush(hFILE *fpv)
-{
-    int ret = 0;
-    do {
-#ifdef HAVE_FDATASYNC
-        hFILE_fd *fp = (hFILE_fd *) fpv;
-        ret = fdatasync(fp->fd);
-#elif defined(HAVE_FSYNC)
-        hFILE_fd *fp = (hFILE_fd *) fpv;
-        ret = fsync(fp->fd);
-#endif
-        // Ignore invalid-for-fsync(2) errors due to being, e.g., a pipe,
-        // and operation-not-supported errors (Mac OS X)
-        if (ret < 0 && (errno == EINVAL || errno == ENOTSUP)) ret = 0;
-    } while (ret < 0 && errno == EINTR);
-    return ret;
-}
-
-static int fd_close(hFILE *fpv)
-{
-    hFILE_fd *fp = (hFILE_fd *) fpv;
-    int ret;
-    do {
-#ifdef HAVE_CLOSESOCKET
-        ret = fp->is_socket? closesocket(fp->fd) : close(fp->fd);
-#else
-        ret = close(fp->fd);
-#endif
-    } while (ret < 0 && errno == EINTR);
-    return ret;
-}
-
-static const struct hFILE_backend fd_backend =
-{
-    fd_read, fd_write, fd_seek, fd_flush, fd_close
-};
-
-static size_t blksize(int fd)
-{
-#ifdef HAVE_STRUCT_STAT_ST_BLKSIZE
-    struct stat sbuf;
-    if (fstat(fd, &sbuf) != 0) return 0;
-    return sbuf.st_blksize;
-#else
-    return 0;
-#endif
-}
-
-static hFILE *hopen_fd(const char *filename, const char *mode)
-{
-    hFILE_fd *fp = NULL;
-    int fd = open(filename, hfile_oflags(mode), 0666);
-    if (fd < 0) goto error;
-
-    fp = (hFILE_fd *) hfile_init(sizeof (hFILE_fd), mode, blksize(fd));
-    if (fp == NULL) goto error;
-
-    fp->fd = fd;
-    fp->is_socket = 0;
-    fp->base.backend = &fd_backend;
-    return &fp->base;
-
-error:
-    if (fd >= 0) { int save = errno; (void) close(fd); errno = save; }
-    hfile_destroy((hFILE *) fp);
-    return NULL;
-}
-
-// Loads the contents of filename to produced a read-only, in memory,
-// immobile hfile.  fp is the already opened file.  We always close this
-// input fp, irrespective of whether we error or whether we return a new
-// immobile hfile.
-static hFILE *hpreload(hFILE *fp) {
-    hFILE *mem_fp;
-    char *buf = NULL;
-    off_t buf_sz = 0, buf_a = 0, buf_inc = 8192, len;
-
-    for (;;) {
-        if (buf_a - buf_sz < 5000) {
-            buf_a += buf_inc;
-            char *t = realloc(buf, buf_a);
-            if (!t) goto err;
-            buf = t;
-            if (buf_inc < 1000000) buf_inc *= 1.3;
-        }
-        len = hread(fp, buf+buf_sz, buf_a-buf_sz);
-        if (len > 0)
-            buf_sz += len;
-        else
-            break;
-    }
-
-    if (len < 0) goto err;
-    mem_fp = hfile_init_fixed(sizeof(hFILE), "r", buf, buf_sz, buf_a);
-    if (!mem_fp) goto err;
-    mem_fp->backend = &mem_backend;
-
-    if (hclose(fp) < 0) {
-        hclose_abruptly(mem_fp);
-        goto err;
-    }
-    return mem_fp;
-
- err:
-    free(buf);
-    hclose_abruptly(fp);
-    return NULL;
-}
-
-static int is_preload_url_remote(const char *url){
-    return hisremote(url + 8); // len("preload:") = 8
-}
-
-static hFILE *hopen_preload(const char *url, const char *mode){
-    hFILE* fp = hopen(url + 8, mode);
-    return hpreload(fp);
-}
-
-hFILE *hdopen(int fd, const char *mode)
-{
-    hFILE_fd *fp = (hFILE_fd*) hfile_init(sizeof (hFILE_fd), mode, blksize(fd));
-    if (fp == NULL) return NULL;
-
-    fp->fd = fd;
-    fp->is_socket = (strchr(mode, 's') != NULL);
-    fp->base.backend = &fd_backend;
-    return &fp->base;
-}
-
-static hFILE *hopen_fd_fileuri(const char *url, const char *mode)
-{
-    if (strncmp(url, "file://localhost/", 17) == 0) url += 16;
-    else if (strncmp(url, "file:///", 8) == 0) url += 7;
-    else { errno = EPROTONOSUPPORT; return NULL; }
-
-#if defined(_WIN32) || defined(__MSYS__)
-    // For cases like C:/foo
-    if (url[0] == '/' && url[1] && url[2] == ':' && url[3] == '/') url++;
-#endif
-
-    return hopen_fd(url, mode);
-}
-
-static hFILE *hopen_fd_stdinout(const char *mode)
-{
-    int fd = (strchr(mode, 'r') != NULL)? STDIN_FILENO : STDOUT_FILENO;
-#if defined HAVE_SETMODE && defined O_BINARY
-    if (setmode(fd, O_BINARY) < 0) return NULL;
-#endif
-    return hdopen(fd, mode);
-}
-
-HTSLIB_EXPORT
-int hfile_oflags(const char *mode)
-{
-    int rdwr = 0, flags = 0;
-    const char *s;
-    for (s = mode; *s; s++)
-        switch (*s) {
-        case 'r': rdwr = O_RDONLY;  break;
-        case 'w': rdwr = O_WRONLY; flags |= O_CREAT | O_TRUNC;  break;
-        case 'a': rdwr = O_WRONLY; flags |= O_CREAT | O_APPEND;  break;
-        case '+': rdwr = O_RDWR;  break;
-#ifdef O_CLOEXEC
-        case 'e': flags |= O_CLOEXEC;  break;
-#endif
-#ifdef O_EXCL
-        case 'x': flags |= O_EXCL;  break;
-#endif
-        default:  break;
-        }
-
-#ifdef O_BINARY
-    flags |= O_BINARY;
-#endif
-
-    return rdwr | flags;
-}
-
-
-/*********************
- * In-memory backend *
- *********************/
-
-#include "hts_internal.h"
-
-typedef struct {
-    hFILE base;
-} hFILE_mem;
-
-static off_t mem_seek(hFILE *fpv, off_t offset, int whence)
-{
-    errno = EINVAL;
-    return -1;
-}
-
-static int mem_close(hFILE *fpv)
-{
-    return 0;
-}
-
-static const struct hFILE_backend mem_backend =
-{
-    NULL, NULL, mem_seek, NULL, mem_close
-};
-
-static int cmp_prefix(const char *key, const char *s)
-{
-    while (*key)
-        if (tolower_c(*s) != *key) return +1;
-        else s++, key++;
-
-    return 0;
-}
-
-static hFILE *create_hfile_mem(char* buffer, const char* mode, size_t buf_filled, size_t buf_size)
-{
-    hFILE_mem *fp = (hFILE_mem *) hfile_init_fixed(sizeof(hFILE_mem), mode, buffer, buf_filled, buf_size);
-    if (fp == NULL)
-        return NULL;
-
-    fp->base.backend = &mem_backend;
-    return &fp->base;
-}
-
-static hFILE *hopen_mem(const char *url, const char *mode)
-{
-    size_t length, size;
-    char *buffer;
-    const char *data, *comma = strchr(url, ',');
-    if (comma == NULL) { errno = EINVAL; return NULL; }
-    data = comma+1;
-
-    // TODO Implement write modes
-    if (strchr(mode, 'r') == NULL) { errno = EROFS; return NULL; }
-
-    if (comma - url >= 7 && cmp_prefix(";base64", &comma[-7]) == 0) {
-        size = hts_base64_decoded_length(strlen(data));
-        buffer = malloc(size);
-        if (buffer == NULL) return NULL;
-        hts_decode_base64(buffer, &length, data);
-    }
-    else {
-        size = strlen(data) + 1;
-        buffer = malloc(size);
-        if (buffer == NULL) return NULL;
-        hts_decode_percent(buffer, &length, data);
-    }
-    hFILE* hf;
-
-    if(!(hf = create_hfile_mem(buffer, mode, length, size))){
-        free(buffer);
-        return NULL;
-    }
-
-    return hf;
-}
-
-static hFILE *hopenv_mem(const char *filename, const char *mode, va_list args)
-{
-    char* buffer = va_arg(args, char*);
-    size_t sz = va_arg(args, size_t);
-    va_end(args);
-
-    hFILE* hf;
-
-    if(!(hf = create_hfile_mem(buffer, mode, sz, sz))){
-        free(buffer);
-        return NULL;
-    }
-
-    return hf;
-}
-
-char *hfile_mem_get_buffer(hFILE *file, size_t *length) {
-    if (file->backend != &mem_backend) {
-        errno = EINVAL;
-        return NULL;
-    }
-
-    if (length)
-        *length = file->buffer - file->limit;
-
-    return file->buffer;
-}
-
-char *hfile_mem_steal_buffer(hFILE *file, size_t *length) {
-    char *buf = hfile_mem_get_buffer(file, length);
-    if (buf)
-        file->buffer = NULL;
-    return buf;
-}
-
-int hfile_plugin_init_mem(struct hFILE_plugin *self)
-{
-    // mem files are declared remote so they work with a tabix index
-    static const struct hFILE_scheme_handler handler =
-            {NULL, hfile_always_remote, "mem", 2000 + 50, hopenv_mem};
-    self->name = "mem";
-    hfile_add_scheme_handler("mem", &handler);
-    return 0;
-}
-
-/**********************************************************************
- * Dummy crypt4gh plug-in.  Does nothing apart from advise how to get *
- * the real one.  It will be overridden by the actual plug-in.        *
- **********************************************************************/
-
-static hFILE *crypt4gh_needed(const char *url, const char *mode)
-{
-    const char *u = strncmp(url, "crypt4gh:", 9) == 0 ? url + 9 : url;
-#if defined(ENABLE_PLUGINS)
-    const char *enable_plugins = "";
-#else
-    const char *enable_plugins = "You also need to rebuild HTSlib with plug-ins enabled.\n";
-#endif
-
-    hts_log_error("Accessing \"%s\" needs the crypt4gh plug-in.\n"
-                  "It can be found at "
-                  "https://github.com/samtools/htslib-crypt4gh\n"
-                  "%s"
-                  "If you have the plug-in, please ensure it can be "
-                  "found on your HTS_PATH.",
-                  u, enable_plugins);
-
-    errno = EPROTONOSUPPORT;
-    return NULL;
-}
-
-int hfile_plugin_init_crypt4gh_needed(struct hFILE_plugin *self)
-{
-    static const struct hFILE_scheme_handler handler =
-        { crypt4gh_needed, NULL, "crypt4gh-needed", 0, NULL };
-    self->name = "crypt4gh-needed";
-    hfile_add_scheme_handler("crypt4gh", &handler);
-    return 0;
-}
-
-
-/*****************************************
- * Plugin and hopen() backend dispatcher *
- *****************************************/
-
-#include "htslib/khash.h"
-
-KHASH_MAP_INIT_STR(scheme_string, const struct hFILE_scheme_handler *)
-static khash_t(scheme_string) *schemes = NULL;
-
-struct hFILE_plugin_list {
-    struct hFILE_plugin plugin;
-    struct hFILE_plugin_list *next;
-};
-
-static struct hFILE_plugin_list *plugins = NULL;
-static pthread_mutex_t plugins_lock = PTHREAD_MUTEX_INITIALIZER;
-
-void hfile_shutdown(int do_close_plugin)
-{
-    pthread_mutex_lock(&plugins_lock);
-
-    if (schemes) {
-        kh_destroy(scheme_string, schemes);
-        schemes = NULL;
-    }
-
-    while (plugins != NULL) {
-        struct hFILE_plugin_list *p = plugins;
-        if (p->plugin.destroy) p->plugin.destroy();
-#ifdef ENABLE_PLUGINS
-        if (p->plugin.obj && do_close_plugin) close_plugin(p->plugin.obj);
-#endif
-        plugins = p->next;
-        free(p);
-    }
-
-    pthread_mutex_unlock(&plugins_lock);
-}
-
-static void hfile_exit()
-{
-    hfile_shutdown(0);
-    pthread_mutex_destroy(&plugins_lock);
-}
-
-static inline int priority(const struct hFILE_scheme_handler *handler)
-{
-    return handler->priority % 1000;
-}
-
-#ifdef USING_WINDOWS_PLUGIN_DLLS
-/*
- * Work-around for Windows plug-in dlls where the plug-in could be
- * using a different HTSlib library to the executable (for example
- * because the latter was build against a static libhts.a).  When this
- * happens, the plug-in can call the wrong copy of hfile_add_scheme_handler().
- * If this is detected, it calls this function which attempts to fix the
- * problem by redirecting to the hfile_add_scheme_handler() in the main
- * executable.
- */
-static int try_exe_add_scheme_handler(const char *scheme,
-                                      const struct hFILE_scheme_handler *handler)
-{
-    static void (*add_scheme_handler)(const char *scheme,
-                                      const struct hFILE_scheme_handler *handler);
-    if (!add_scheme_handler) {
-        // dlopen the main executable and resolve hfile_add_scheme_handler
-        void *exe_handle = dlopen(NULL, RTLD_LAZY);
-        if (!exe_handle) return -1;
-        *(void **) (&add_scheme_handler) = dlsym(exe_handle, "hfile_add_scheme_handler");
-        dlclose(exe_handle);
-    }
-    // Check that the symbol was obtained and isn't the one in this copy
-    // of the library (to avoid infinite recursion)
-    if (!add_scheme_handler || add_scheme_handler == hfile_add_scheme_handler)
-        return -1;
-    add_scheme_handler(scheme, handler);
-    return 0;
-}
-#else
-static int try_exe_add_scheme_handler(const char *scheme,
-                                      const struct hFILE_scheme_handler *handler)
-{
-    return -1;
-}
-#endif
-
-HTSLIB_EXPORT
-void hfile_add_scheme_handler(const char *scheme,
-                              const struct hFILE_scheme_handler *handler)
-{
-    int absent;
-    if (!schemes) {
-        if (try_exe_add_scheme_handler(scheme, handler) != 0) {
-            hts_log_warning("Couldn't register scheme handler for %s", scheme);
-        }
-        return;
-    }
-    khint_t k = kh_put(scheme_string, schemes, scheme, &absent);
-    if (absent < 0) {
-        hts_log_warning("Couldn't register scheme handler for %s : %s",
-                        scheme, strerror(errno));
-        return;
-    }
-    if (absent || priority(handler) > priority(kh_value(schemes, k))) {
-        kh_value(schemes, k) = handler;
-    }
-}
-
-static int init_add_plugin(void *obj, int (*init)(struct hFILE_plugin *),
-                           const char *pluginname)
-{
-    struct hFILE_plugin_list *p = malloc (sizeof (struct hFILE_plugin_list));
-    if (p == NULL) {
-        hts_log_debug("Failed to allocate memory for plugin \"%s\"", pluginname);
-        return -1;
-    }
-
-    p->plugin.api_version = 1;
-    p->plugin.obj = obj;
-    p->plugin.name = NULL;
-    p->plugin.destroy = NULL;
-
-    int ret = (*init)(&p->plugin);
-
-    if (ret != 0) {
-        hts_log_debug("Initialisation failed for plugin \"%s\": %d", pluginname, ret);
-        free(p);
-        return ret;
-    }
-
-    hts_log_debug("Loaded \"%s\"", pluginname);
-
-    p->next = plugins, plugins = p;
-    return 0;
-}
-
-/*
- * Returns 0 on success,
- *        <0 on failure
- */
-static int load_hfile_plugins()
-{
-    static const struct hFILE_scheme_handler
-        data = { hopen_mem, hfile_always_local, "built-in", 80 },
-        file = { hopen_fd_fileuri, hfile_always_local, "built-in", 80 },
-        preload = { hopen_preload, is_preload_url_remote, "built-in", 80 };
-
-    schemes = kh_init(scheme_string);
-    if (schemes == NULL)
-        return -1;
-
-    hfile_add_scheme_handler("data", &data);
-    hfile_add_scheme_handler("file", &file);
-    hfile_add_scheme_handler("preload", &preload);
-    init_add_plugin(NULL, hfile_plugin_init_mem, "mem");
-    init_add_plugin(NULL, hfile_plugin_init_crypt4gh_needed, "crypt4gh-needed");
-
-#ifdef ENABLE_PLUGINS
-    struct hts_path_itr path;
-    const char *pluginname;
-    hts_path_itr_setup(&path, NULL, NULL, "hfile_", 6, NULL, 0);
-    while ((pluginname = hts_path_itr_next(&path)) != NULL) {
-        void *obj;
-        int (*init)(struct hFILE_plugin *) = (int (*)(struct hFILE_plugin *))
-            load_plugin(&obj, pluginname, "hfile_plugin_init");
-
-        if (init) {
-            if (init_add_plugin(obj, init, pluginname) != 0)
-                close_plugin(obj);
-        }
-    }
-#else
-
-#ifdef HAVE_LIBCURL
-    init_add_plugin(NULL, hfile_plugin_init_libcurl, "libcurl");
-#endif
-#ifdef ENABLE_GCS
-    init_add_plugin(NULL, hfile_plugin_init_gcs, "gcs");
-#endif
-#ifdef ENABLE_S3
-    init_add_plugin(NULL, hfile_plugin_init_s3, "s3");
-    init_add_plugin(NULL, hfile_plugin_init_s3_write, "s3w");
-#endif
-
-#endif
-
-    // In the unlikely event atexit() fails, it's better to succeed here and
-    // carry on; then eventually when the program exits, we'll merely close
-    // down the plugins uncleanly, as if we had aborted.
-    (void) atexit(hfile_exit);
-
-    return 0;
-}
-
-/* A filename like "foo:bar" in which we don't recognise the scheme is
-   either an ordinary file or an indication of a missing or broken plugin.
-   Try to open it as an ordinary file; but if there's no such file, set
-   errno distinctively to make the plugin issue apparent.  */
-static hFILE *hopen_unknown_scheme(const char *fname, const char *mode)
-{
-    hFILE *fp = hopen_fd(fname, mode);
-    if (fp == NULL && errno == ENOENT) errno = EPROTONOSUPPORT;
-    return fp;
-}
-
-/* Returns the appropriate handler, or NULL if the string isn't an URL.  */
-static const struct hFILE_scheme_handler *find_scheme_handler(const char *s)
-{
-    static const struct hFILE_scheme_handler unknown_scheme =
-        { hopen_unknown_scheme, hfile_always_local, "built-in", 0 };
-
-    char scheme[12];
-    int i;
-
-    for (i = 0; i < sizeof scheme; i++)
-        if (isalnum_c(s[i]) || s[i] == '+' || s[i] == '-' || s[i] == '.')
-            scheme[i] = tolower_c(s[i]);
-        else if (s[i] == ':') break;
-        else return NULL;
-
-    // 1 byte schemes are likely windows C:/foo pathnames
-    if (i <= 1 || i >= sizeof scheme) return NULL;
-    scheme[i] = '\0';
-
-    pthread_mutex_lock(&plugins_lock);
-    if (!schemes && load_hfile_plugins() < 0) {
-        pthread_mutex_unlock(&plugins_lock);
-        return NULL;
-    }
-    pthread_mutex_unlock(&plugins_lock);
-
-    khint_t k = kh_get(scheme_string, schemes, scheme);
-    return (k != kh_end(schemes))? kh_value(schemes, k) : &unknown_scheme;
-}
-
-
-/***************************
- * Library introspection functions
- ***************************/
-
-/*
- * Fills out sc_list[] with the list of known URL schemes.
- * This can be restricted to just ones from a specific plugin,
- * or all (plugin == NULL).
- *
- * Returns number of schemes found on success;
- *        -1 on failure.
- */
-HTSLIB_EXPORT
-int hfile_list_schemes(const char *plugin, const char *sc_list[], int *nschemes)
-{
-    pthread_mutex_lock(&plugins_lock);
-    if (!schemes && load_hfile_plugins() < 0) {
-        pthread_mutex_unlock(&plugins_lock);
-        return -1;
-    }
-    pthread_mutex_unlock(&plugins_lock);
-
-    khiter_t k;
-    int ns = 0;
-
-    for (k = kh_begin(schemes); k != kh_end(schemes); k++) {
-        if (!kh_exist(schemes, k))
-            continue;
-
-        const struct hFILE_scheme_handler *s = kh_value(schemes, k);
-        if (plugin && strcmp(s->provider, plugin) != 0)
-            continue;
-
-        if (ns < *nschemes)
-            sc_list[ns] = kh_key(schemes, k);
-        ns++;
-    }
-
-    if (*nschemes > ns)
-        *nschemes = ns;
-
-    return ns;
-}
-
-
-/*
- * Fills out plist[] with the list of known hFILE plugins.
- *
- * Returns number of schemes found on success;
- *        -1 on failure
- */
-HTSLIB_EXPORT
-int hfile_list_plugins(const char *plist[], int *nplugins)
-{
-    pthread_mutex_lock(&plugins_lock);
-    if (!schemes && load_hfile_plugins() < 0) {
-        pthread_mutex_unlock(&plugins_lock);
-        return -1;
-    }
-    pthread_mutex_unlock(&plugins_lock);
-
-    int np = 0;
-    if (*nplugins)
-        plist[np++] = "built-in";
-
-    struct hFILE_plugin_list *p = plugins;
-    while (p) {
-        if (np < *nplugins)
-            plist[np] = p->plugin.name;
-
-        p = p->next;
-        np++;
-    }
-
-    if (*nplugins > np)
-        *nplugins = np;
-
-    return np;
-}
-
-
-/*
- * Tests for the presence of a specific hFILE plugin.
- *
- * Returns 1 if true
- *         0 otherwise
- */
-HTSLIB_EXPORT
-int hfile_has_plugin(const char *name)
-{
-    pthread_mutex_lock(&plugins_lock);
-    if (!schemes && load_hfile_plugins() < 0) {
-        pthread_mutex_unlock(&plugins_lock);
-        return -1;
-    }
-    pthread_mutex_unlock(&plugins_lock);
-
-    struct hFILE_plugin_list *p = plugins;
-    while (p) {
-        if (strcmp(p->plugin.name, name) == 0)
-            return 1;
-        p = p->next;
-    }
-
-    return 0;
-}
-
-/***************************
- * hFILE interface proper
- ***************************/
-
-hFILE *hopen(const char *fname, const char *mode, ...)
-{
-    const struct hFILE_scheme_handler *handler = find_scheme_handler(fname);
-    if (handler) {
-        if (strchr(mode, ':') == NULL
-            || handler->priority < 2000
-            || handler->vopen == NULL) {
-            return handler->open(fname, mode);
-        }
-        else {
-            hFILE *fp;
-            va_list arg;
-            va_start(arg, mode);
-            fp = handler->vopen(fname, mode, arg);
-            va_end(arg);
-            return fp;
-        }
-    }
-    else if (strcmp(fname, "-") == 0) return hopen_fd_stdinout(mode);
-    else return hopen_fd(fname, mode);
-}
-
-HTSLIB_EXPORT
-int hfile_always_local (const char *fname) { return 0; }
-
-HTSLIB_EXPORT
-int hfile_always_remote(const char *fname) { return 1; }
-
-int hisremote(const char *fname)
-{
-    const struct hFILE_scheme_handler *handler = find_scheme_handler(fname);
-    return handler? handler->isremote(fname) : 0;
-}
-
-// Remove an extension, if any, from the basename part of [start,limit).
-// Note: Doesn't notice percent-encoded '.' and '/' characters. Don't do that.
-static const char *strip_extension(const char *start, const char *limit)
-{
-    const char *s = limit;
-    while (s > start) {
-        --s;
-        if (*s == '.') return s;
-        else if (*s == '/') break;
-    }
-    return limit;
-}
-
-char *haddextension(struct kstring_t *buffer, const char *filename,
-                    int replace, const char *new_extension)
-{
-    const char *trailing, *end;
-
-    if (find_scheme_handler(filename)) {
-        // URL, so alter extensions before any trailing query or fragment parts
-        // Allow # symbols in s3 URLs
-        trailing = filename + ((strncmp(filename, "s3://", 5) && strncmp(filename, "s3+http://", 10) && strncmp(filename, "s3+https://", 11))  ? strcspn(filename, "?#") : strcspn(filename, "?"));
-    }
-    else {
-        // Local path, so alter extensions at the end of the filename
-        trailing = strchr(filename, '\0');
-    }
-
-    end = replace? strip_extension(filename, trailing) : trailing;
-
-    buffer->l = 0;
-    if (kputsn(filename, end - filename, buffer) >= 0 &&
-        kputs(new_extension, buffer) >= 0 &&
-        kputs(trailing, buffer) >= 0) return buffer->s;
-    else return NULL;
-}
-
-
-/*
- * ----------------------------------------------------------------------
- * Minimal stub functions for knet, added after the removal of
- * hfile_net.c and knetfile.c.
- *
- * They exist purely for ABI compatibility, but are simply wrappers to
- * hFILE.  API should be compatible except knet_fileno (unused?).
- *
- * CULL THESE and knetfile.h at the next .so version bump.
- */
-typedef struct knetFile_s {
-    // As per htslib/knetfile.h.  Duplicated here as we don't wish to
-    // have any dependence on the deprecated knetfile.h interface, plus
-    // it's hopefully only temporary.
-    int type, fd;
-    int64_t offset;
-    char *host, *port;
-    int ctrl_fd, pasv_ip[4], pasv_port, max_response, no_reconnect, is_ready;
-    char *response, *retr, *size_cmd;
-    int64_t seek_offset;
-    int64_t file_size;
-    char *path, *http_host;
-
-    // Our local addition
-    hFILE *hf;
-} knetFile;
-
-HTSLIB_EXPORT
-knetFile *knet_open(const char *fn, const char *mode) {
-    knetFile *fp = calloc(1, sizeof(*fp));
-    if (!fp) return NULL;
-    if (!(fp->hf = hopen(fn, mode))) {
-        free(fp);
-        fp = NULL;
-    }
-
-    // FD backend is the only one implementing knet_fileno
-    fp->fd = fp->hf->backend == &fd_backend
-        ? ((hFILE_fd *)fp->hf)->fd
-        : -1;
-
-    return fp;
-}
-
-HTSLIB_EXPORT
-knetFile *knet_dopen(int fd, const char *mode) {
-    knetFile *fp = calloc(1, sizeof(*fp));
-    if (!fp) return NULL;
-    if (!(fp->hf = hdopen(fd, mode))) {
-        free(fp);
-        fp = NULL;
-    }
-    fp->fd = fd;
-    return fp;
-}
-
-HTSLIB_EXPORT
-ssize_t knet_read(knetFile *fp, void *buf, size_t len) {
-    ssize_t r = hread(fp->hf, buf, len);
-    fp->offset += r>0?r:0;
-    return r;
-}
-
-HTSLIB_EXPORT
-off_t knet_seek(knetFile *fp, off_t off, int whence) {
-    off_t r = hseek(fp->hf, off, whence);
-    if (r >= 0)
-        fp->offset = r;
-    return r;
-}
-
-HTSLIB_EXPORT
-int knet_close(knetFile *fp) {
-    int r = hclose(fp->hf);
-    free(fp);
-    return r;
-}
diff -ruN stringtie.orig/htslib/hfile_gcs.c stringtie/htslib/hfile_gcs.c
--- stringtie.orig/htslib/hfile_gcs.c	2024-02-28 13:57:39.701246126 +0100
+++ stringtie/htslib/hfile_gcs.c	1970-01-01 01:00:00.000000000 +0100
@@ -1,138 +0,0 @@
-/*  hfile_gcs.c -- Google Cloud Storage backend for low-level file streams.
-
-    Copyright (C) 2016 Genome Research Ltd.
-
-    Author: John Marshall <jm18@sanger.ac.uk>
-
-Permission is hereby granted, free of charge, to any person obtaining a copy
-of this software and associated documentation files (the "Software"), to deal
-in the Software without restriction, including without limitation the rights
-to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
-copies of the Software, and to permit persons to whom the Software is
-furnished to do so, subject to the following conditions:
-
-The above copyright notice and this permission notice shall be included in
-all copies or substantial portions of the Software.
-
-THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
-IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
-FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
-THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
-LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
-FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
-DEALINGS IN THE SOFTWARE.  */
-
-#define HTS_BUILDING_LIBRARY // Enables HTSLIB_EXPORT, see htslib/hts_defs.h
-#include <config.h>
-
-#include <stdarg.h>
-#include <stdio.h>
-#include <stdlib.h>
-#include <string.h>
-#include <errno.h>
-
-#include "htslib/hts.h"
-#include "htslib/kstring.h"
-#include "hfile_internal.h"
-#ifdef ENABLE_PLUGINS
-#include "version.h"
-#endif
-
-static hFILE *
-gcs_rewrite(const char *gsurl, const char *mode, int mode_has_colon,
-            va_list *argsp)
-{
-    const char *bucket, *path, *access_token;
-    kstring_t mode_colon = { 0, 0, NULL };
-    kstring_t url = { 0, 0, NULL };
-    kstring_t auth_hdr = { 0, 0, NULL };
-    hFILE *fp = NULL;
-
-    // GCS URL format is gs[+SCHEME]://BUCKET/PATH
-
-    if (gsurl[2] == '+') {
-        bucket = strchr(gsurl, ':') + 1;
-        kputsn(&gsurl[3], bucket - &gsurl[3], &url);
-    }
-    else {
-        kputs("https:", &url);
-        bucket = &gsurl[3];
-    }
-    while (*bucket == '/') kputc(*bucket++, &url);
-
-    path = bucket + strcspn(bucket, "/?#");
-
-    kputsn(bucket, path - bucket, &url);
-    if (strchr(mode, 'r')) kputs(".storage-download", &url);
-    else if (strchr(mode, 'w')) kputs(".storage-upload", &url);
-    else kputs(".storage", &url);
-    kputs(".googleapis.com", &url);
-
-    kputs(path, &url);
-
-    if (hts_verbose >= 8)
-        fprintf(stderr, "[M::gcs_open] rewrote URL as %s\n", url.s);
-
-    // TODO Find the access token in a more standard way
-    access_token = getenv("GCS_OAUTH_TOKEN");
-
-    if (access_token) {
-        kputs("Authorization: Bearer ", &auth_hdr);
-        kputs(access_token, &auth_hdr);
-    }
-
-    if (argsp || auth_hdr.l > 0 || mode_has_colon) {
-        if (! mode_has_colon) {
-            kputs(mode, &mode_colon);
-            kputc(':', &mode_colon);
-            mode = mode_colon.s;
-        }
-
-        fp = hopen(url.s, mode, "va_list", argsp,
-                   "httphdr", (auth_hdr.l > 0)? auth_hdr.s : NULL, NULL);
-    }
-    else
-        fp = hopen(url.s, mode);
-
-    free(mode_colon.s);
-    free(url.s);
-    free(auth_hdr.s);
-    return fp;
-}
-
-static hFILE *gcs_open(const char *url, const char *mode)
-{
-    return gcs_rewrite(url, mode, 0, NULL);
-}
-
-static hFILE *gcs_vopen(const char *url, const char *mode_colon, va_list args0)
-{
-    // Need to use va_copy() as we can only take the address of an actual
-    // va_list object, not that of a parameter as its type may have decayed.
-    va_list args;
-    va_copy(args, args0);
-    hFILE *fp = gcs_rewrite(url, mode_colon, 1, &args);
-    va_end(args);
-    return fp;
-}
-
-int PLUGIN_GLOBAL(hfile_plugin_init,_gcs)(struct hFILE_plugin *self)
-{
-    static const struct hFILE_scheme_handler handler =
-        { gcs_open, hfile_always_remote, "Google Cloud Storage",
-          2000 + 50, gcs_vopen
-        };
-
-#ifdef ENABLE_PLUGINS
-    // Embed version string for examination via strings(1) or what(1)
-    static const char id[] = "@(#)hfile_gcs plugin (htslib)\t" HTS_VERSION_TEXT;
-    if (hts_verbose >= 9)
-        fprintf(stderr, "[M::hfile_gcs.init] version %s\n", strchr(id, '\t')+1);
-#endif
-
-    self->name = "Google Cloud Storage";
-    hfile_add_scheme_handler("gs", &handler);
-    hfile_add_scheme_handler("gs+http", &handler);
-    hfile_add_scheme_handler("gs+https", &handler);
-    return 0;
-}
diff -ruN stringtie.orig/htslib/hfile_internal.h stringtie/htslib/hfile_internal.h
--- stringtie.orig/htslib/hfile_internal.h	2024-02-28 13:57:39.701246126 +0100
+++ stringtie/htslib/hfile_internal.h	1970-01-01 01:00:00.000000000 +0100
@@ -1,203 +0,0 @@
-/*  hfile_internal.h -- internal parts of low-level input/output streams.
-
-    Copyright (C) 2013-2016, 2019 Genome Research Ltd.
-
-    Author: John Marshall <jm18@sanger.ac.uk>
-
-Permission is hereby granted, free of charge, to any person obtaining a copy
-of this software and associated documentation files (the "Software"), to deal
-in the Software without restriction, including without limitation the rights
-to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
-copies of the Software, and to permit persons to whom the Software is
-furnished to do so, subject to the following conditions:
-
-The above copyright notice and this permission notice shall be included in
-all copies or substantial portions of the Software.
-
-THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
-IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
-FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
-THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
-LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
-FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
-DEALINGS IN THE SOFTWARE.  */
-
-#ifndef HFILE_INTERNAL_H
-#define HFILE_INTERNAL_H
-
-#include <stdarg.h>
-
-#include "htslib/hts_defs.h"
-#include "htslib/hfile.h"
-
-#include "textutils_internal.h"
-
-#ifdef __cplusplus
-extern "C" {
-#endif
-
-/*!
-  @abstract  Resizes the buffer within an hFILE.
-
-  @notes  Changes the buffer size for an hFILE.  Ideally this is done
-  immediately after opening.  If performed later, this function may
-  fail if we are reducing the buffer size and the current offset into
-  the buffer is beyond the new capacity.
-
-  @param fp        The file stream
-  @param bufsiz    The size of the new buffer
-
-  @return Returns 0 on success, -1 on failure.
- */
-int hfile_set_blksize(hFILE *fp, size_t bufsiz);
-
-struct BGZF;
-/*!
-  @abstract Return the hFILE connected to a BGZF
- */
-struct hFILE *bgzf_hfile(struct BGZF *fp);
-
-/*!
-  @abstract Closes all hFILE plugins that have been loaded
-*/
-void hfile_shutdown(int do_close_plugin);
-
-struct hFILE_backend {
-    /* As per read(2), returning the number of bytes read (possibly 0) or
-       negative (and setting errno) on errors.  Front-end code will call this
-       repeatedly if necessary to attempt to get the desired byte count.  */
-    ssize_t (*read)(hFILE *fp, void *buffer, size_t nbytes) HTS_RESULT_USED;
-
-    /* As per write(2), returning the number of bytes written or negative (and
-       setting errno) on errors.  Front-end code will call this repeatedly if
-       necessary until the desired block is written or an error occurs.  */
-    ssize_t (*write)(hFILE *fp, const void *buffer, size_t nbytes)
-        HTS_RESULT_USED;
-
-    /* As per lseek(2), returning the resulting offset within the stream or
-       negative (and setting errno) on errors.  */
-    off_t (*seek)(hFILE *fp, off_t offset, int whence) HTS_RESULT_USED;
-
-    /* Performs low-level flushing, if any, e.g., fsync(2); for writing streams
-       only.  Returns 0 for success or negative (and sets errno) on errors. */
-    int (*flush)(hFILE *fp) HTS_RESULT_USED;
-
-    /* Closes the underlying stream (for output streams, the buffer will
-       already have been flushed), returning 0 for success or negative (and
-       setting errno) on errors, as per close(2).  */
-    int (*close)(hFILE *fp) HTS_RESULT_USED;
-};
-
-/* May be called by hopen_*() functions to decode a fopen()-style mode into
-   open(2)-style flags.  */
-int hfile_oflags(const char *mode);
-
-/* Must be called by hopen_*() functions to allocate the hFILE struct and set
-   up its base.  Capacity is a suggested buffer size (e.g., via fstat(2))
-   or 0 for a default-sized buffer.  */
-hFILE *hfile_init(size_t struct_size, const char *mode, size_t capacity);
-
-/* Alternative to hfile_init() for in-memory backends for which the base
-   buffer is the only storage.  Buffer is already allocated via malloc(2)
-   of size buf_size and with buf_filled bytes already filled.  Ownership
-   of the buffer is transferred to the resulting hFILE.  */
-hFILE *hfile_init_fixed(size_t struct_size, const char *mode,
-                        char *buffer, size_t buf_filled, size_t buf_size);
-
-/* May be called by hopen_*() functions to undo the effects of hfile_init()
-   in the event opening the stream subsequently fails.  (This is safe to use
-   even if fp is NULL.  This takes care to preserve errno.)  */
-void hfile_destroy(hFILE *fp);
-
-
-struct hFILE_scheme_handler {
-    /* Opens a stream when dispatched by hopen(); should call hfile_init()
-       to malloc a struct "derived" from hFILE and initialise it appropriately,
-       including setting base.backend to its own backend vector.  */
-    hFILE *(*open)(const char *filename, const char *mode) HTS_RESULT_USED;
-
-    /* Returns whether the URL denotes remote storage when dispatched by
-       hisremote().  For simple cases, use one of hfile_always_*() below.  */
-    int (*isremote)(const char *filename) HTS_RESULT_USED;
-
-    /* The name of the plugin or other code providing this handler.  */
-    const char *provider;
-
-    /* If multiple handlers are registered for the same scheme, the one with
-       the highest priority is used; range is 0 (lowest) to 100 (highest).
-       This field is used modulo 1000 as a priority; thousands indicate
-       later revisions to this structure, as noted below.  */
-    int priority;
-
-    /* Fields below are present when priority >= 2000.  */
-
-    /* Same as the open() method, used when extra arguments have been given
-       to hopen().  */
-    hFILE *(*vopen)(const char *filename, const char *mode, va_list args)
-        HTS_RESULT_USED;
-};
-
-/* May be used as an isremote() function in simple cases.  */
-extern int hfile_always_local (const char *fname);
-extern int hfile_always_remote(const char *fname);
-
-/* Should be called by plugins for each URL scheme they wish to handle.  */
-void hfile_add_scheme_handler(const char *scheme,
-                              const struct hFILE_scheme_handler *handler);
-
-struct hFILE_plugin {
-    /* On entry, HTSlib's plugin API version (currently 1).  */
-    int api_version;
-
-    /* On entry, the plugin's handle as returned by dlopen() etc.  */
-    void *obj;
-
-    /* The plugin should fill this in with its (human-readable) name.  */
-    const char *name;
-
-    /* The plugin may wish to fill in a function to be called on closing.  */
-    void (*destroy)(void);
-};
-
-#ifdef ENABLE_PLUGINS
-#define PLUGIN_GLOBAL(identifier,suffix) identifier
-
-/* Plugins must define an entry point with this signature.  */
-HTSLIB_EXPORT
-extern int hfile_plugin_init(struct hFILE_plugin *self);
-
-#else
-#define PLUGIN_GLOBAL(identifier,suffix) identifier##suffix
-
-/* Only plugins distributed within the HTSlib source that might be built
-   even with --disable-plugins need to use PLUGIN_GLOBAL and be listed here;
-   others can simply define hfile_plugin_init().  */
-
-extern int hfile_plugin_init_gcs(struct hFILE_plugin *self);
-extern int hfile_plugin_init_libcurl(struct hFILE_plugin *self);
-extern int hfile_plugin_init_s3(struct hFILE_plugin *self);
-extern int hfile_plugin_init_s3_write(struct hFILE_plugin *self);
-#endif
-
-// Callback to allow headers to be set in http connections.  Currently used
-// to allow s3 to renew tokens when seeking.  Kept internal for now,
-// although we may consider exposing it in the API later.
-typedef int (* hts_httphdr_callback) (void *cb_data, char ***hdrs);
-
-/** Callback for handling 3xx redirect responses from http connections.
-
-    @param data       is passed to the callback
-    @param response   http response code (e.g. 301)
-    @param headers    http response headers
-    @param new_url    the callback should write the url to switch to in here
-
-    Currently used by s3 to handle switching region endpoints.
-*/
-typedef int (*redirect_callback) (void *data, long response,
-                                  kstring_t *headers, kstring_t *new_url);
-
-#ifdef __cplusplus
-}
-#endif
-
-#endif
diff -ruN stringtie.orig/htslib/hfile_libcurl.c stringtie/htslib/hfile_libcurl.c
--- stringtie.orig/htslib/hfile_libcurl.c	2024-02-28 13:57:39.701246126 +0100
+++ stringtie/htslib/hfile_libcurl.c	1970-01-01 01:00:00.000000000 +0100
@@ -1,1556 +0,0 @@
-/*  hfile_libcurl.c -- libcurl backend for low-level file streams.
-
-    Copyright (C) 2015-2017, 2019-2020 Genome Research Ltd.
-
-    Author: John Marshall <jm18@sanger.ac.uk>
-
-Permission is hereby granted, free of charge, to any person obtaining a copy
-of this software and associated documentation files (the "Software"), to deal
-in the Software without restriction, including without limitation the rights
-to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
-copies of the Software, and to permit persons to whom the Software is
-furnished to do so, subject to the following conditions:
-
-The above copyright notice and this permission notice shall be included in
-all copies or substantial portions of the Software.
-
-THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
-IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
-FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
-THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
-LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
-FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
-DEALINGS IN THE SOFTWARE.  */
-
-#define HTS_BUILDING_LIBRARY // Enables HTSLIB_EXPORT, see htslib/hts_defs.h
-#include <config.h>
-
-#include <stdarg.h>
-#include <stdlib.h>
-#include <string.h>
-#include <strings.h>
-#include <errno.h>
-#include <pthread.h>
-#ifndef _WIN32
-# include <sys/select.h>
-#endif
-#include <assert.h>
-
-#include "hfile_internal.h"
-#ifdef ENABLE_PLUGINS
-#include "version.h"
-#endif
-#include "htslib/hts.h"  // for hts_version() and hts_verbose
-#include "htslib/kstring.h"
-#include "htslib/khash.h"
-
-#include <curl/curl.h>
-
-// Number of seconds to take off auth_token expiry, to allow for clock skew
-// and slow servers
-#define AUTH_REFRESH_EARLY_SECS 60
-
-// Minimum number of bytes to skip when seeking forward.  Seeks less than
-// this will just read the data and throw it away.  The optimal value
-// depends on how long it takes to make a new connection compared
-// to how fast the data arrives.
-#define MIN_SEEK_FORWARD 1000000
-
-typedef struct {
-    char *path;
-    char *token;
-    time_t expiry;
-    int failed;
-    pthread_mutex_t lock;
-} auth_token;
-
-// For the authorization header cache
-KHASH_MAP_INIT_STR(auth_map, auth_token *)
-
-// Curl-compatible header linked list
-typedef struct {
-    struct curl_slist *list;
-    unsigned int num;
-    unsigned int size;
-} hdrlist;
-
-typedef struct {
-    hdrlist fixed;                   // List of headers supplied at hopen()
-    hdrlist extra;                   // List of headers from callback
-    hts_httphdr_callback callback;   // Callback to get more headers
-    void *callback_data;             // Data to pass to httphdr callback
-    auth_token *auth;                // Authentication token
-    int auth_hdr_num;                // Location of auth_token in hdrlist extra
-                                     // If -1, Authorization header is in fixed
-                                     //    -2, it came from the callback
-                                     //    -3, "auth_token_enabled", "false"
-                                     //        passed to hopen()
-    redirect_callback redirect;      // Callback to handle 3xx redirects
-    void *redirect_data;             // Data to pass to redirect_callback
-    long *http_response_ptr;         // Location to store http response code.
-    int fail_on_error;               // Open fails on >400 response code
-                                     //    (default true)
-} http_headers;
-
-typedef struct {
-    hFILE base;
-    CURL *easy;
-    CURLM *multi;
-    off_t file_size;
-    struct {
-        union { char *rd; const char *wr; } ptr;
-        size_t len;
-    } buffer;
-    CURLcode final_result;  // easy result code for finished transfers
-    // Flags for communicating with libcurl callbacks:
-    unsigned paused : 1;    // callback tells us that it has paused transfer
-    unsigned closing : 1;   // informs callback that hclose() has been invoked
-    unsigned finished : 1;  // wait_perform() tells us transfer is complete
-    unsigned perform_again : 1;
-    unsigned is_read : 1;   // Opened in read mode
-    unsigned can_seek : 1;  // Can (attempt to) seek on this handle
-    unsigned is_recursive:1; // Opened by hfile_libcurl itself
-    unsigned tried_seek : 1; // At least one seek has been attempted
-    int nrunning;
-    http_headers headers;
-
-    off_t delayed_seek;      // Location to seek to before reading
-    off_t last_offset;       // Location we're seeking from
-    char *preserved;         // Preserved buffer content on seek
-    size_t preserved_bytes;  // Number of preserved bytes
-    size_t preserved_size;   // Size of preserved buffer
-} hFILE_libcurl;
-
-static off_t libcurl_seek(hFILE *fpv, off_t offset, int whence);
-static int restart_from_position(hFILE_libcurl *fp, off_t pos);
-
-static int http_status_errno(int status)
-{
-    if (status >= 500)
-        switch (status) {
-        case 501: return ENOSYS;
-        case 503: return EBUSY;
-        case 504: return ETIMEDOUT;
-        default:  return EIO;
-        }
-    else if (status >= 400)
-        switch (status) {
-        case 401: return EPERM;
-        case 403: return EACCES;
-        case 404: return ENOENT;
-        case 405: return EROFS;
-        case 407: return EPERM;
-        case 408: return ETIMEDOUT;
-        case 410: return ENOENT;
-        default:  return EINVAL;
-        }
-    else return 0;
-}
-
-static int easy_errno(CURL *easy, CURLcode err)
-{
-    long lval;
-
-    switch (err) {
-    case CURLE_OK:
-        return 0;
-
-    case CURLE_UNSUPPORTED_PROTOCOL:
-    case CURLE_URL_MALFORMAT:
-        return EINVAL;
-
-#if LIBCURL_VERSION_NUM >= 0x071505
-    case CURLE_NOT_BUILT_IN:
-        return ENOSYS;
-#endif
-
-    case CURLE_COULDNT_RESOLVE_PROXY:
-    case CURLE_COULDNT_RESOLVE_HOST:
-    case CURLE_FTP_CANT_GET_HOST:
-        return EDESTADDRREQ; // Lookup failure
-
-    case CURLE_COULDNT_CONNECT:
-    case CURLE_SEND_ERROR:
-    case CURLE_RECV_ERROR:
-        if (curl_easy_getinfo(easy, CURLINFO_OS_ERRNO, &lval) == CURLE_OK)
-            return lval;
-        else
-            return ECONNABORTED;
-
-    case CURLE_REMOTE_ACCESS_DENIED:
-    case CURLE_LOGIN_DENIED:
-    case CURLE_TFTP_PERM:
-        return EACCES;
-
-    case CURLE_PARTIAL_FILE:
-        return EPIPE;
-
-    case CURLE_HTTP_RETURNED_ERROR:
-        if (curl_easy_getinfo(easy, CURLINFO_RESPONSE_CODE, &lval) == CURLE_OK)
-            return http_status_errno(lval);
-        else
-            return EIO;
-
-    case CURLE_OUT_OF_MEMORY:
-        return ENOMEM;
-
-    case CURLE_OPERATION_TIMEDOUT:
-        return ETIMEDOUT;
-
-    case CURLE_RANGE_ERROR:
-        return ESPIPE;
-
-    case CURLE_SSL_CONNECT_ERROR:
-        // TODO return SSL error buffer messages
-        return ECONNABORTED;
-
-    case CURLE_FILE_COULDNT_READ_FILE:
-    case CURLE_TFTP_NOTFOUND:
-        return ENOENT;
-
-    case CURLE_TOO_MANY_REDIRECTS:
-        return ELOOP;
-
-    case CURLE_FILESIZE_EXCEEDED:
-        return EFBIG;
-
-    case CURLE_REMOTE_DISK_FULL:
-        return ENOSPC;
-
-    case CURLE_REMOTE_FILE_EXISTS:
-        return EEXIST;
-
-    default:
-        hts_log_error("Libcurl reported error %d (%s)", (int) err,
-                      curl_easy_strerror(err));
-        return EIO;
-    }
-}
-
-static int multi_errno(CURLMcode errm)
-{
-    switch (errm) {
-    case CURLM_CALL_MULTI_PERFORM:
-    case CURLM_OK:
-        return 0;
-
-    case CURLM_BAD_HANDLE:
-    case CURLM_BAD_EASY_HANDLE:
-    case CURLM_BAD_SOCKET:
-        return EBADF;
-
-    case CURLM_OUT_OF_MEMORY:
-        return ENOMEM;
-
-    default:
-        hts_log_error("Libcurl reported error %d (%s)", (int) errm,
-                      curl_multi_strerror(errm));
-        return EIO;
-    }
-}
-
-static struct {
-    kstring_t useragent;
-    CURLSH *share;
-    char *auth_path;
-    khash_t(auth_map) *auth_map;
-    int allow_unencrypted_auth_header;
-    pthread_mutex_t auth_lock;
-    pthread_mutex_t share_lock;
-} curl = { { 0, 0, NULL }, NULL, NULL, NULL, 0, PTHREAD_MUTEX_INITIALIZER,
-           PTHREAD_MUTEX_INITIALIZER };
-
-static void share_lock(CURL *handle, curl_lock_data data,
-                       curl_lock_access access, void *userptr) {
-    pthread_mutex_lock(&curl.share_lock);
-}
-
-static void share_unlock(CURL *handle, curl_lock_data data, void *userptr) {
-    pthread_mutex_unlock(&curl.share_lock);
-}
-
-static void free_auth(auth_token *tok) {
-    if (!tok) return;
-    if (pthread_mutex_destroy(&tok->lock)) abort();
-    free(tok->path);
-    free(tok->token);
-    free(tok);
-}
-
-static void libcurl_exit()
-{
-    if (curl_share_cleanup(curl.share) == CURLSHE_OK)
-        curl.share = NULL;
-
-    free(curl.useragent.s);
-    curl.useragent.l = curl.useragent.m = 0; curl.useragent.s = NULL;
-
-    free(curl.auth_path);
-    curl.auth_path = NULL;
-
-    if (curl.auth_map) {
-        khiter_t i;
-        for (i = kh_begin(curl.auth_map); i != kh_end(curl.auth_map); ++i) {
-            if (kh_exist(curl.auth_map, i)) {
-                free_auth(kh_value(curl.auth_map, i));
-                kh_key(curl.auth_map, i) = NULL;
-                kh_value(curl.auth_map, i) = NULL;
-            }
-        }
-        kh_destroy(auth_map, curl.auth_map);
-        curl.auth_map = NULL;
-    }
-
-    curl_global_cleanup();
-}
-
-static int append_header(hdrlist *hdrs, const char *data, int dup) {
-    if (hdrs->num == hdrs->size) {
-        unsigned int new_sz = hdrs->size ? hdrs->size * 2 : 4, i;
-        struct curl_slist *new_list = realloc(hdrs->list,
-                                              new_sz * sizeof(*new_list));
-        if (!new_list) return -1;
-        hdrs->size = new_sz;
-        hdrs->list = new_list;
-        for (i = 1; i < hdrs->num; i++) hdrs->list[i-1].next = &hdrs->list[i];
-    }
-    // Annoyingly, libcurl doesn't declare the char * as const...
-    hdrs->list[hdrs->num].data = dup ? strdup(data) : (char *) data;
-    if (!hdrs->list[hdrs->num].data) return -1;
-    if (hdrs->num > 0) hdrs->list[hdrs->num - 1].next = &hdrs->list[hdrs->num];
-    hdrs->list[hdrs->num].next = NULL;
-    hdrs->num++;
-    return 0;
-}
-
-static void free_headers(hdrlist *hdrs, int completely) {
-    unsigned int i;
-    for (i = 0; i < hdrs->num; i++) {
-        free(hdrs->list[i].data);
-        hdrs->list[i].data = NULL;
-        hdrs->list[i].next = NULL;
-    }
-    hdrs->num = 0;
-    if (completely) {
-        free(hdrs->list);
-        hdrs->size = 0;
-        hdrs->list = NULL;
-    }
-}
-
-static struct curl_slist * get_header_list(hFILE_libcurl *fp) {
-    if (fp->headers.fixed.num > 0)
-        return &fp->headers.fixed.list[0];
-    if (fp->headers.extra.num > 0)
-        return &fp->headers.extra.list[0];
-    return 0;
-}
-
-static inline int is_authorization(const char *hdr) {
-    return (strncasecmp("authorization:", hdr, 14) == 0);
-}
-
-static int add_callback_headers(hFILE_libcurl *fp) {
-    char **hdrs = NULL, **hdr;
-
-    if (!fp->headers.callback)
-        return 0;
-
-    // Get the headers from the callback
-    if (fp->headers.callback(fp->headers.callback_data, &hdrs) != 0) {
-        return -1;
-    }
-
-    if (!hdrs) // No change
-        return 0;
-
-    // Remove any old callback headers
-    if (fp->headers.fixed.num > 0) {
-        // Unlink lists
-        fp->headers.fixed.list[fp->headers.fixed.num - 1].next = NULL;
-    }
-    free_headers(&fp->headers.extra, 0);
-
-    if (fp->headers.auth_hdr_num > 0 || fp->headers.auth_hdr_num == -2)
-        fp->headers.auth_hdr_num = 0; // Just removed it...
-
-    // Convert to libcurl-suitable form
-    for (hdr = hdrs; *hdr; hdr++) {
-        if (append_header(&fp->headers.extra, *hdr, 0) < 0) {
-            goto cleanup;
-        }
-        if (is_authorization(*hdr) && !fp->headers.auth_hdr_num)
-            fp->headers.auth_hdr_num = -2;
-    }
-    for (hdr = hdrs; *hdr; hdr++) *hdr = NULL;
-
-    if (fp->headers.fixed.num > 0 && fp->headers.extra.num > 0) {
-        // Relink lists
-        fp->headers.fixed.list[fp->headers.fixed.num - 1].next
-            = &fp->headers.extra.list[0];
-    }
-    return 0;
-
- cleanup:
-    while (hdr && *hdr) {
-        free(*hdr);
-        *hdr = NULL;
-    }
-    return -1;
-}
-
-/*
- * Read an OAUTH2-style Bearer access token (see
- * https://tools.ietf.org/html/rfc6750#section-4).
- * Returns 'v' for valid; 'i' for invalid (token missing or wrong sort);
- * '?' for a JSON parse error; 'm' if it runs out of memory.
- */
-static int read_auth_json(auth_token *tok, hFILE *auth_fp) {
-    hts_json_token *t = hts_json_alloc_token();
-    kstring_t str = {0, 0, NULL};
-    char *token = NULL, *type = NULL, *expiry = NULL;
-    int ret = 'i';
-
-    if (!t) goto error;
-
-    if ((ret = hts_json_fnext(auth_fp, t, &str)) != '{') goto error;
-    while (hts_json_fnext(auth_fp, t, &str) != '}') {
-        char *key;
-        if (hts_json_token_type(t) != 's') {
-            ret = '?';
-            goto error;
-        }
-        key = hts_json_token_str(t);
-        if (!key) goto error;
-        if (strcmp(key, "access_token") == 0) {
-            if ((ret = hts_json_fnext(auth_fp, t, &str)) != 's') goto error;
-            token = ks_release(&str);
-        } else if (strcmp(key, "token_type") == 0) {
-            if ((ret = hts_json_fnext(auth_fp, t, &str)) != 's') goto error;
-            type = ks_release(&str);
-        } else if (strcmp(key, "expires_in") == 0) {
-            if ((ret = hts_json_fnext(auth_fp, t, &str)) != 'n') goto error;
-            expiry = ks_release(&str);
-        } else if (hts_json_fskip_value(auth_fp, '\0') != 'v') {
-            ret = '?';
-            goto error;
-        }
-    }
-
-    if (!token || (type && strcmp(type, "Bearer") != 0)) {
-        ret = 'i';
-        goto error;
-    }
-
-    ret = 'm';
-    str.l = 0;
-    if (kputs("Authorization: Bearer ", &str) < 0) goto error;
-    if (kputs(token, &str) < 0) goto error;
-    free(tok->token);
-    tok->token = ks_release(&str);
-    if (expiry) {
-        long exp = strtol(expiry, NULL, 10);
-        if (exp < 0) exp = 0;
-        tok->expiry = time(NULL) + exp;
-    } else {
-        tok->expiry = 0;
-    }
-    ret = 'v';
-
- error:
-    free(token);
-    free(type);
-    free(expiry);
-    free(str.s);
-    hts_json_free_token(t);
-    return ret;
-}
-
-static int read_auth_plain(auth_token *tok, hFILE *auth_fp) {
-    kstring_t line = {0, 0, NULL};
-    kstring_t token = {0, 0, NULL};
-    const char *start, *end;
-
-    if (kgetline(&line, (char * (*)(char *, int, void *)) hgets, auth_fp) < 0) goto error;
-    if (kputc('\0', &line) < 0) goto error;
-
-    for (start = line.s; *start && isspace_c(*start); start++) {}
-    for (end = start; *end && !isspace_c(*end); end++) {}
-
-    if (end > start) {
-        if (kputs("Authorization: Bearer ", &token) < 0) goto error;
-        if (kputsn(start, end - start, &token) < 0) goto error;
-    }
-
-    free(tok->token);
-    tok->token = ks_release(&token);
-    tok->expiry = 0;
-    free(line.s);
-    return 0;
-
- error:
-    free(line.s);
-    free(token.s);
-    return -1;
-}
-
-static int renew_auth_token(auth_token *tok, int *changed) {
-    hFILE *auth_fp = NULL;
-    char buffer[16];
-    ssize_t len;
-
-    *changed = 0;
-    if (tok->expiry == 0 || time(NULL) + AUTH_REFRESH_EARLY_SECS < tok->expiry)
-        return 0; // Still valid
-
-    if (tok->failed)
-        return -1;
-
-    *changed = 1;
-    auth_fp = hopen(tok->path, "rR");
-    if (!auth_fp) {
-        // Not worried about missing files; other errors are bad.
-        if (errno != ENOENT)
-            goto fail;
-
-        tok->expiry = 0; // Prevent retry
-        free(tok->token); // Just in case it was set
-        return 0;
-    }
-
-    len = hpeek(auth_fp, buffer, sizeof(buffer));
-    if (len < 0)
-        goto fail;
-
-    if (memchr(buffer, '{', len) != NULL) {
-        if (read_auth_json(tok, auth_fp) != 'v')
-            goto fail;
-    } else {
-        if (read_auth_plain(tok, auth_fp) < 0)
-            goto fail;
-    }
-
-    return hclose(auth_fp) < 0 ? -1 : 0;
-
- fail:
-    tok->failed = 1;
-    if (auth_fp) hclose_abruptly(auth_fp);
-    return -1;
-}
-
-static int add_auth_header(hFILE_libcurl *fp) {
-    int changed = 0;
-
-    if (fp->headers.auth_hdr_num < 0)
-        return 0; // Have an Authorization header from open or header callback
-
-    if (!fp->headers.auth)
-        return 0; // Nothing to add
-
-    pthread_mutex_lock(&fp->headers.auth->lock);
-    if (renew_auth_token(fp->headers.auth, &changed) < 0)
-        goto unlock_fail;
-
-    if (!changed && fp->headers.auth_hdr_num > 0) {
-        pthread_mutex_unlock(&fp->headers.auth->lock);
-        return 0;
-    }
-
-    if (fp->headers.auth_hdr_num > 0) {
-        // Had a previous header, so swap in the new one
-        char *header = fp->headers.auth->token;
-        char *header_copy = header ? strdup(header) : NULL;
-        int idx = fp->headers.auth_hdr_num - 1;
-        if (header && !header_copy)
-            goto unlock_fail;
-
-        if (header_copy) {
-            free(fp->headers.extra.list[idx].data);
-            fp->headers.extra.list[idx].data = header_copy;
-        } else {
-            unsigned int j;
-            // More complicated case - need to get rid of the old header
-            // and tidy up linked lists
-            free(fp->headers.extra.list[idx].data);
-            for (j = idx + 1; j < fp->headers.extra.num; j++) {
-                fp->headers.extra.list[j - 1] = fp->headers.extra.list[j];
-                fp->headers.extra.list[j - 1].next = &fp->headers.extra.list[j];
-            }
-            fp->headers.extra.num--;
-            if (fp->headers.extra.num > 0) {
-                fp->headers.extra.list[fp->headers.extra.num-1].next = NULL;
-            } else if (fp->headers.fixed.num > 0) {
-                fp->headers.fixed.list[fp->headers.fixed.num - 1].next = NULL;
-            }
-            fp->headers.auth_hdr_num = 0;
-        }
-    } else if (fp->headers.auth->token) {
-        // Add new header and remember where it is
-        if (append_header(&fp->headers.extra,
-                          fp->headers.auth->token, 1) < 0) {
-            goto unlock_fail;
-        }
-        fp->headers.auth_hdr_num = fp->headers.extra.num;
-    }
-
-    pthread_mutex_unlock(&fp->headers.auth->lock);
-    return 0;
-
- unlock_fail:
-    pthread_mutex_unlock(&fp->headers.auth->lock);
-    return -1;
-}
-
-static int get_auth_token(hFILE_libcurl *fp, const char *url) {
-    const char *host = NULL, *p, *q;
-    kstring_t name = {0, 0, NULL};
-    size_t host_len = 0;
-    khiter_t idx;
-    auth_token *tok = NULL;
-
-    // Nothing to do if:
-    //   curl.auth_path has not been set
-    //   fp was made by hfile_libcurl (e.g. auth_path is a http:// url)
-    //   we already have an Authorization header
-    if (!curl.auth_path || fp->is_recursive || fp->headers.auth_hdr_num != 0)
-        return 0;
-
-    // Insist on having a secure connection unless the user insists harder
-    if (!curl.allow_unencrypted_auth_header && strncmp(url, "https://", 8) != 0)
-        return 0;
-
-    host = strstr(url, "://");
-    if (host) {
-        host += 3;
-        host_len = strcspn(host, "/");
-    }
-
-    p = curl.auth_path;
-    while ((q = strstr(p, "%h")) != NULL) {
-        if (q - p > INT_MAX || host_len > INT_MAX) goto error;
-        if (kputsn_(p, q - p, &name) < 0) goto error;
-        if (kputsn_(host, host_len, &name) < 0) goto error;
-        p = q + 2;
-    }
-    if (kputs(p, &name) < 0) goto error;
-
-    pthread_mutex_lock(&curl.auth_lock);
-    idx = kh_get(auth_map, curl.auth_map, name.s);
-    if (idx < kh_end(curl.auth_map)) {
-        tok = kh_value(curl.auth_map, idx);
-    } else {
-        tok = calloc(1, sizeof(*tok));
-        if (tok && pthread_mutex_init(&tok->lock, NULL) != 0) {
-            free(tok);
-            tok = NULL;
-        }
-        if (tok) {
-            int ret = -1;
-            tok->path = ks_release(&name);
-            tok->token = NULL;
-            tok->expiry = 1; // Force refresh
-            idx = kh_put(auth_map, curl.auth_map, tok->path, &ret);
-            if (ret < 0) {
-                free_auth(tok);
-                tok = NULL;
-            }
-            kh_value(curl.auth_map, idx) = tok;
-        }
-    }
-    pthread_mutex_unlock(&curl.auth_lock);
-
-    fp->headers.auth = tok;
-    free(name.s);
-
-    return add_auth_header(fp);
-
- error:
-    free(name.s);
-    return -1;
-}
-
-static void process_messages(hFILE_libcurl *fp)
-{
-    CURLMsg *msg;
-    int remaining;
-
-    while ((msg = curl_multi_info_read(fp->multi, &remaining)) != NULL) {
-        switch (msg->msg) {
-        case CURLMSG_DONE:
-            fp->finished = 1;
-            fp->final_result = msg->data.result;
-            break;
-
-        default:
-            break;
-        }
-    }
-}
-
-static int wait_perform(hFILE_libcurl *fp)
-{
-    fd_set rd, wr, ex;
-    int maxfd, nrunning;
-    long timeout;
-    CURLMcode errm;
-
-    if (!fp->perform_again) {
-        FD_ZERO(&rd);
-        FD_ZERO(&wr);
-        FD_ZERO(&ex);
-        if (curl_multi_fdset(fp->multi, &rd, &wr, &ex, &maxfd) != CURLM_OK)
-            maxfd = -1, timeout = 1000;
-        else {
-            if (curl_multi_timeout(fp->multi, &timeout) != CURLM_OK)
-                timeout = 1000;
-            else if (timeout < 0) {
-                timeout = 10000;  // as recommended by curl_multi_timeout(3)
-            }
-        }
-        if (maxfd < 0) {
-            if (timeout > 100)
-                timeout = 100; // as recommended by curl_multi_fdset(3)
-#ifdef _WIN32
-            /* Windows ignores the first argument of select, so calling select
-             * with maxfd=-1 does not give the expected result of sleeping for
-             * timeout milliseconds in the conditional block below.
-             * So sleep here and skip the next block.
-             */
-            Sleep(timeout);
-            timeout = 0;
-#endif
-        }
-
-        if (timeout > 0) {
-            struct timeval tval;
-            tval.tv_sec  = (timeout / 1000);
-            tval.tv_usec = (timeout % 1000) * 1000;
-
-            if (select(maxfd + 1, &rd, &wr, &ex, &tval) < 0) return -1;
-        }
-    }
-
-    errm = curl_multi_perform(fp->multi, &nrunning);
-    fp->perform_again = 0;
-    if (errm == CURLM_CALL_MULTI_PERFORM) fp->perform_again = 1;
-    else if (errm != CURLM_OK) { errno = multi_errno(errm); return -1; }
-
-    if (nrunning < fp->nrunning) process_messages(fp);
-    return 0;
-}
-
-
-static size_t recv_callback(char *ptr, size_t size, size_t nmemb, void *fpv)
-{
-    hFILE_libcurl *fp = (hFILE_libcurl *) fpv;
-    size_t n = size * nmemb;
-
-    if (n > fp->buffer.len) {
-        fp->paused = 1;
-        return CURL_WRITEFUNC_PAUSE;
-    }
-    else if (n == 0) return 0;
-
-    memcpy(fp->buffer.ptr.rd, ptr, n);
-    fp->buffer.ptr.rd += n;
-    fp->buffer.len -= n;
-    return n;
-}
-
-
-static size_t header_callback(void *contents, size_t size, size_t nmemb,
-                              void *userp)
-{
-    size_t realsize = size * nmemb;
-    kstring_t *resp = (kstring_t *)userp;
-
-    if (kputsn((const char *)contents, realsize, resp) == EOF) {
-        return 0;
-    }
-
-    return realsize;
-}
-
-
-static ssize_t libcurl_read(hFILE *fpv, void *bufferv, size_t nbytes)
-{
-    hFILE_libcurl *fp = (hFILE_libcurl *) fpv;
-    char *buffer = (char *) bufferv;
-    off_t to_skip = -1;
-    ssize_t got = 0;
-    CURLcode err;
-
-    if (fp->delayed_seek >= 0) {
-        assert(fp->base.offset == fp->delayed_seek);
-
-        if (fp->preserved
-            && fp->last_offset > fp->delayed_seek
-            && fp->last_offset - fp->preserved_bytes <= fp->delayed_seek) {
-            // Can use buffer contents copied when seeking started, to
-            // avoid having to re-read data discarded by hseek().
-            // Note fp->last_offset is the offset of the *end* of the
-            // preserved buffer.
-            size_t n = fp->last_offset - fp->delayed_seek;
-            char *start = fp->preserved + (fp->preserved_bytes - n);
-            size_t bytes = n <= nbytes ? n : nbytes;
-            memcpy(buffer, start, bytes);
-            if (bytes < n) { // Part of the preserved buffer still left
-                fp->delayed_seek += bytes;
-            } else {
-                fp->last_offset = fp->delayed_seek = -1;
-            }
-            return bytes;
-        }
-
-        if (fp->last_offset >= 0
-            && fp->delayed_seek > fp->last_offset
-            && fp->delayed_seek - fp->last_offset < MIN_SEEK_FORWARD) {
-            // If not seeking far, just read the data and throw it away.  This
-            // is likely to be quicker than opening a new stream
-            to_skip = fp->delayed_seek - fp->last_offset;
-        } else {
-            if (restart_from_position(fp, fp->delayed_seek) < 0) {
-                return -1;
-            }
-        }
-        fp->delayed_seek = -1;
-        fp->last_offset = -1;
-        fp->preserved_bytes = 0;
-    }
-
-    do {
-        fp->buffer.ptr.rd = buffer;
-        fp->buffer.len = nbytes;
-        fp->paused = 0;
-        if (!fp->finished) {
-            err = curl_easy_pause(fp->easy, CURLPAUSE_CONT);
-            if (err != CURLE_OK) {
-                errno = easy_errno(fp->easy, err);
-                return -1;
-            }
-        }
-
-        while (! fp->paused && ! fp->finished) {
-            if (wait_perform(fp) < 0) return -1;
-        }
-
-        got = fp->buffer.ptr.rd - buffer;
-
-        if (to_skip >= 0) { // Skipping over a small seek
-            if (got < to_skip) { // Need to skip more data
-                to_skip -= got;
-            } else {
-                got -= to_skip;
-                if (got > 0) {  // If enough was skipped, return the rest
-                    memmove(buffer, buffer + to_skip, got);
-                    to_skip = -1;
-                }
-            }
-        }
-    } while (to_skip >= 0 && ! fp->finished);
-    fp->buffer.ptr.rd = NULL;
-    fp->buffer.len = 0;
-
-    if (fp->finished && fp->final_result != CURLE_OK) {
-        errno = easy_errno(fp->easy, fp->final_result);
-        return -1;
-    }
-
-    return got;
-}
-
-static size_t send_callback(char *ptr, size_t size, size_t nmemb, void *fpv)
-{
-    hFILE_libcurl *fp = (hFILE_libcurl *) fpv;
-    size_t n = size * nmemb;
-
-    if (fp->buffer.len == 0) {
-        // Send buffer is empty; normally pause, or signal EOF if we're closing
-        if (fp->closing) return 0;
-        else { fp->paused = 1; return CURL_READFUNC_PAUSE; }
-    }
-
-    if (n > fp->buffer.len) n = fp->buffer.len;
-    memcpy(ptr, fp->buffer.ptr.wr, n);
-    fp->buffer.ptr.wr += n;
-    fp->buffer.len -= n;
-    return n;
-}
-
-static ssize_t libcurl_write(hFILE *fpv, const void *bufferv, size_t nbytes)
-{
-    hFILE_libcurl *fp = (hFILE_libcurl *) fpv;
-    const char *buffer = (const char *) bufferv;
-    CURLcode err;
-
-    fp->buffer.ptr.wr = buffer;
-    fp->buffer.len = nbytes;
-    fp->paused = 0;
-    err = curl_easy_pause(fp->easy, CURLPAUSE_CONT);
-    if (err != CURLE_OK) { errno = easy_errno(fp->easy, err); return -1; }
-
-    while (! fp->paused && ! fp->finished)
-        if (wait_perform(fp) < 0) return -1;
-
-    nbytes = fp->buffer.ptr.wr - buffer;
-    fp->buffer.ptr.wr = NULL;
-    fp->buffer.len = 0;
-
-    if (fp->finished && fp->final_result != CURLE_OK) {
-        errno = easy_errno(fp->easy, fp->final_result);
-        return -1;
-    }
-
-    return nbytes;
-}
-
-static void preserve_buffer_content(hFILE_libcurl *fp)
-{
-    if (fp->base.begin == fp->base.end) {
-        fp->preserved_bytes = 0;
-        return;
-    }
-    if (!fp->preserved
-        || fp->preserved_size < fp->base.limit - fp->base.buffer) {
-        fp->preserved = malloc(fp->base.limit - fp->base.buffer);
-        if (!fp->preserved) return;
-        fp->preserved_size = fp->base.limit - fp->base.buffer;
-    }
-
-    assert(fp->base.end - fp->base.begin <= fp->preserved_size);
-
-    memcpy(fp->preserved, fp->base.begin, fp->base.end - fp->base.begin);
-    fp->preserved_bytes = fp->base.end - fp->base.begin;
-    return;
-}
-
-static off_t libcurl_seek(hFILE *fpv, off_t offset, int whence)
-{
-    hFILE_libcurl *fp = (hFILE_libcurl *) fpv;
-    off_t origin, pos;
-
-    if (!fp->is_read || !fp->can_seek) {
-        // Cowardly refuse to seek when writing or a previous seek failed.
-        errno = ESPIPE;
-        return -1;
-    }
-
-    switch (whence) {
-    case SEEK_SET:
-        origin = 0;
-        break;
-    case SEEK_CUR:
-        errno = ENOSYS;
-        return -1;
-    case SEEK_END:
-        if (fp->file_size < 0) { errno = ESPIPE; return -1; }
-        origin = fp->file_size;
-        break;
-    default:
-        errno = EINVAL;
-        return -1;
-    }
-
-    // Check 0 <= origin+offset < fp->file_size carefully, avoiding overflow
-    if ((offset < 0)? origin + offset < 0
-                : (fp->file_size >= 0 && offset > fp->file_size - origin)) {
-        errno = EINVAL;
-        return -1;
-    }
-
-    pos = origin + offset;
-
-    if (fp->tried_seek) {
-        /* Seeking has worked at least once, so now we can delay doing
-           the actual work until the next read.  This avoids lots of pointless
-           http or ftp reconnections if the caller does lots of seeks
-           without any intervening reads. */
-        if (fp->delayed_seek < 0) {
-            fp->last_offset = fp->base.offset + (fp->base.end - fp->base.buffer);
-            // Stash the current hFILE buffer content in case it's useful later
-            preserve_buffer_content(fp);
-        }
-        fp->delayed_seek = pos;
-        return pos;
-    }
-
-    if (restart_from_position(fp, pos) < 0) {
-        /* This value for errno may not be entirely true, but the caller may be
-           able to carry on with the existing handle. */
-        errno = ESPIPE;
-        return -1;
-    }
-
-    fp->tried_seek = 1;
-    return pos;
-}
-
-static int restart_from_position(hFILE_libcurl *fp, off_t pos) {
-    hFILE_libcurl temp_fp;
-    CURLcode err;
-    CURLMcode errm;
-    int update_headers = 0;
-    int save_errno = 0;
-
-    // TODO If we seem to be doing random access, use CURLOPT_RANGE to do
-    // limited reads (e.g. about a BAM block!) so seeking can reuse the
-    // existing connection more often.
-
-    // Get new headers from the callback (if defined).  This changes the
-    // headers in fp before it gets duplicated, but they should be have been
-    // sent by now.
-
-    if (fp->headers.callback) {
-        if (add_callback_headers(fp) != 0)
-            return -1;
-        update_headers = 1;
-    }
-    if (fp->headers.auth_hdr_num > 0 && fp->headers.auth) {
-        if (add_auth_header(fp) != 0)
-            return -1;
-        update_headers = 1;
-    }
-    if (update_headers) {
-        struct curl_slist *list = get_header_list(fp);
-        if (list) {
-            err = curl_easy_setopt(fp->easy, CURLOPT_HTTPHEADER, list);
-            if (err != CURLE_OK) {
-                errno = easy_errno(fp->easy,err);
-                return -1;
-            }
-        }
-    }
-
-    /*
-      Duplicate the easy handle, and use CURLOPT_RESUME_FROM_LARGE to open
-      a new request to the server, reading from the location that we want
-      to seek to.  If the new request works and returns the correct data,
-      the original easy handle in *fp is closed and replaced with the new
-      one.  If not, we close the new handle and leave *fp unchanged.
-     */
-
-    memcpy(&temp_fp, fp, sizeof(temp_fp));
-    temp_fp.buffer.len = 0;
-    temp_fp.buffer.ptr.rd = NULL;
-    temp_fp.easy = curl_easy_duphandle(fp->easy);
-    if (!temp_fp.easy)
-        goto early_error;
-
-    err = curl_easy_setopt(temp_fp.easy, CURLOPT_RESUME_FROM_LARGE,(curl_off_t)pos);
-    err |= curl_easy_setopt(temp_fp.easy, CURLOPT_PRIVATE, &temp_fp);
-    err |= curl_easy_setopt(temp_fp.easy, CURLOPT_WRITEDATA, &temp_fp);
-    if (err != CURLE_OK) {
-        save_errno = easy_errno(temp_fp.easy, err);
-        goto error;
-    }
-
-    temp_fp.buffer.len = 0;  // Ensures we only read the response headers
-    temp_fp.paused = temp_fp.finished = 0;
-
-    // fp->multi and temp_fp.multi are the same.
-    errm = curl_multi_add_handle(fp->multi, temp_fp.easy);
-    if (errm != CURLM_OK) {
-        save_errno = multi_errno(errm);
-        goto error;
-    }
-    temp_fp.nrunning = ++fp->nrunning;
-
-    while (! temp_fp.paused && ! temp_fp.finished)
-        if (wait_perform(&temp_fp) < 0) {
-            save_errno = errno;
-            goto error_remove;
-        }
-
-    if (temp_fp.finished && temp_fp.final_result != CURLE_OK) {
-        save_errno = easy_errno(temp_fp.easy, temp_fp.final_result);
-        goto error_remove;
-    }
-
-    // We've got a good response, close the original connection and
-    // replace it with the new one.
-
-    errm = curl_multi_remove_handle(fp->multi, fp->easy);
-    if (errm != CURLM_OK) {
-        // Clean up as much as possible
-        curl_easy_reset(temp_fp.easy);
-        if (curl_multi_remove_handle(fp->multi, temp_fp.easy) == CURLM_OK) {
-            fp->nrunning--;
-            curl_easy_cleanup(temp_fp.easy);
-        }
-        save_errno = multi_errno(errm);
-        goto early_error;
-    }
-    fp->nrunning--;
-
-    curl_easy_cleanup(fp->easy);
-    fp->easy = temp_fp.easy;
-    err = curl_easy_setopt(fp->easy, CURLOPT_WRITEDATA, fp);
-    err |= curl_easy_setopt(fp->easy, CURLOPT_PRIVATE, fp);
-    if (err != CURLE_OK) {
-        save_errno = easy_errno(fp->easy, err);
-        curl_easy_reset(fp->easy);
-        errno = save_errno;
-        return -1;
-    }
-    fp->buffer.len = 0;
-    fp->paused = temp_fp.paused;
-    fp->finished = temp_fp.finished;
-    fp->perform_again = temp_fp.perform_again;
-    fp->final_result = temp_fp.final_result;
-
-    return 0;
-
- error_remove:
-    curl_easy_reset(temp_fp.easy); // Ensure no pointers to on-stack temp_fp
-    errm = curl_multi_remove_handle(fp->multi, temp_fp.easy);
-    if (errm != CURLM_OK) {
-        errno = multi_errno(errm);
-        return -1;
-    }
-    fp->nrunning--;
- error:
-    curl_easy_cleanup(temp_fp.easy);
- early_error:
-    fp->can_seek = 0;  // Don't try to seek again
-    if (save_errno)
-        errno = save_errno;
-    return -1;
-}
-
-static int libcurl_close(hFILE *fpv)
-{
-    hFILE_libcurl *fp = (hFILE_libcurl *) fpv;
-    CURLcode err;
-    CURLMcode errm;
-    int save_errno = 0;
-
-    // Before closing the file, unpause it and perform on it so that uploads
-    // have the opportunity to signal EOF to the server -- see send_callback().
-
-    fp->buffer.len = 0;
-    fp->closing = 1;
-    fp->paused = 0;
-    if (!fp->finished) {
-        err = curl_easy_pause(fp->easy, CURLPAUSE_CONT);
-        if (err != CURLE_OK) save_errno = easy_errno(fp->easy, err);
-    }
-
-    while (save_errno == 0 && ! fp->paused && ! fp->finished)
-        if (wait_perform(fp) < 0) save_errno = errno;
-
-    if (fp->finished && fp->final_result != CURLE_OK)
-        save_errno = easy_errno(fp->easy, fp->final_result);
-
-    errm = curl_multi_remove_handle(fp->multi, fp->easy);
-    if (errm != CURLM_OK && save_errno == 0) save_errno = multi_errno(errm);
-    fp->nrunning--;
-
-    curl_easy_cleanup(fp->easy);
-    curl_multi_cleanup(fp->multi);
-
-    if (fp->headers.callback) // Tell callback to free any data it needs to
-        fp->headers.callback(fp->headers.callback_data, NULL);
-    free_headers(&fp->headers.fixed, 1);
-    free_headers(&fp->headers.extra, 1);
-
-    free(fp->preserved);
-
-    if (save_errno) { errno = save_errno; return -1; }
-    else return 0;
-}
-
-static const struct hFILE_backend libcurl_backend =
-{
-    libcurl_read, libcurl_write, libcurl_seek, NULL, libcurl_close
-};
-
-static hFILE *
-libcurl_open(const char *url, const char *modes, http_headers *headers)
-{
-    hFILE_libcurl *fp;
-    struct curl_slist *list;
-    char mode;
-    const char *s;
-    CURLcode err;
-    CURLMcode errm;
-    int save, is_recursive;
-    kstring_t in_header = {0, 0, NULL};
-    long response;
-
-    is_recursive = strchr(modes, 'R') != NULL;
-
-    if ((s = strpbrk(modes, "rwa+")) != NULL) {
-        mode = *s;
-        if (strpbrk(&s[1], "rwa+")) mode = 'e';
-    }
-    else mode = '\0';
-
-    if (mode != 'r' && mode != 'w') { errno = EINVAL; goto early_error; }
-
-    fp = (hFILE_libcurl *) hfile_init(sizeof (hFILE_libcurl), modes, 0);
-    if (fp == NULL) goto early_error;
-
-    if (headers) {
-        fp->headers = *headers;
-    } else {
-        memset(&fp->headers, 0, sizeof(fp->headers));
-        fp->headers.fail_on_error = 1;
-    }
-
-    fp->file_size = -1;
-    fp->buffer.ptr.rd = NULL;
-    fp->buffer.len = 0;
-    fp->final_result = (CURLcode) -1;
-    fp->paused = fp->closing = fp->finished = fp->perform_again = 0;
-    fp->can_seek = 1;
-    fp->tried_seek = 0;
-    fp->delayed_seek = fp->last_offset = -1;
-    fp->preserved = NULL;
-    fp->preserved_bytes = fp->preserved_size = 0;
-    fp->is_recursive = is_recursive;
-    fp->nrunning = 0;
-    fp->easy = NULL;
-
-    fp->multi = curl_multi_init();
-    if (fp->multi == NULL) { errno = ENOMEM; goto error; }
-
-    fp->easy = curl_easy_init();
-    if (fp->easy == NULL) { errno = ENOMEM; goto error; }
-
-    // Make a route to the hFILE_libcurl* given just a CURL* easy handle
-    err = curl_easy_setopt(fp->easy, CURLOPT_PRIVATE, fp);
-
-    // Avoid many repeated CWD calls with FTP, instead requesting the filename
-    // by full path (but not strictly compliant with RFC1738).
-    err |= curl_easy_setopt(fp->easy, CURLOPT_FTP_FILEMETHOD, CURLFTPMETHOD_NOCWD);
-
-    if (mode == 'r') {
-        err |= curl_easy_setopt(fp->easy, CURLOPT_WRITEFUNCTION, recv_callback);
-        err |= curl_easy_setopt(fp->easy, CURLOPT_WRITEDATA, fp);
-        fp->is_read = 1;
-    }
-    else {
-        err |= curl_easy_setopt(fp->easy, CURLOPT_READFUNCTION, send_callback);
-        err |= curl_easy_setopt(fp->easy, CURLOPT_READDATA, fp);
-        err |= curl_easy_setopt(fp->easy, CURLOPT_UPLOAD, 1L);
-        if (append_header(&fp->headers.fixed,
-                          "Transfer-Encoding: chunked", 1) < 0)
-            goto error;
-        fp->is_read = 0;
-    }
-
-    err |= curl_easy_setopt(fp->easy, CURLOPT_SHARE, curl.share);
-    err |= curl_easy_setopt(fp->easy, CURLOPT_URL, url);
-    {
-        char* env_curl_ca_bundle = getenv("CURL_CA_BUNDLE");
-        if (env_curl_ca_bundle) {
-            err |= curl_easy_setopt(fp->easy, CURLOPT_CAINFO, env_curl_ca_bundle);
-        }
-    }
-    err |= curl_easy_setopt(fp->easy, CURLOPT_USERAGENT, curl.useragent.s);
-    if (fp->headers.callback) {
-        if (add_callback_headers(fp) != 0) goto error;
-    }
-    if (get_auth_token(fp, url) < 0)
-        goto error;
-    if ((list = get_header_list(fp)) != NULL)
-        err |= curl_easy_setopt(fp->easy, CURLOPT_HTTPHEADER, list);
-
-    if (hts_verbose <= 8 && fp->headers.fail_on_error)
-        err |= curl_easy_setopt(fp->easy, CURLOPT_FAILONERROR, 1L);
-    if (hts_verbose >= 8)
-        err |= curl_easy_setopt(fp->easy, CURLOPT_VERBOSE, 1L);
-
-    if (fp->headers.redirect) {
-        err |= curl_easy_setopt(fp->easy, CURLOPT_HEADERFUNCTION, header_callback);
-        err |= curl_easy_setopt(fp->easy, CURLOPT_HEADERDATA, (void *)&in_header);
-    } else {
-        err |= curl_easy_setopt(fp->easy, CURLOPT_FOLLOWLOCATION, 1L);
-    }
-
-    if (err != 0) { errno = ENOSYS; goto error; }
-
-    errm = curl_multi_add_handle(fp->multi, fp->easy);
-    if (errm != CURLM_OK) { errno = multi_errno(errm); goto error; }
-    fp->nrunning++;
-
-    while (! fp->paused && ! fp->finished) {
-        if (wait_perform(fp) < 0) goto error_remove;
-    }
-
-    curl_easy_getinfo(fp->easy, CURLINFO_RESPONSE_CODE, &response);
-    if (fp->headers.http_response_ptr) {
-        *fp->headers.http_response_ptr = response;
-    }
-
-    if (fp->finished && fp->final_result != CURLE_OK) {
-        errno = easy_errno(fp->easy, fp->final_result);
-        goto error_remove;
-    }
-
-    if (fp->headers.redirect) {
-        if (response >= 300 && response < 400) { // redirection
-            kstring_t new_url = {0, 0, NULL};
-
-            if (fp->headers.redirect(fp->headers.redirect_data, response,
-                                     &in_header, &new_url)) {
-                errno = ENOSYS;
-                goto error;
-            }
-
-            err |= curl_easy_setopt(fp->easy, CURLOPT_URL, new_url.s);
-            err |= curl_easy_setopt(fp->easy, CURLOPT_HEADERFUNCTION, NULL);
-            err |= curl_easy_setopt(fp->easy, CURLOPT_HEADERDATA, NULL);
-            free(ks_release(&in_header));
-
-            if (err != 0) { errno = ENOSYS; goto error; }
-            free(ks_release(&new_url));
-
-            if (restart_from_position(fp, 0) < 0) {
-                goto error_remove;
-            }
-
-            if (fp->headers.http_response_ptr) {
-                curl_easy_getinfo(fp->easy, CURLINFO_RESPONSE_CODE,
-                                  fp->headers.http_response_ptr);
-            }
-
-            if (fp->finished && fp->final_result != CURLE_OK) {
-                errno = easy_errno(fp->easy, fp->final_result);
-                goto error_remove;
-            }
-        } else {
-            // we no longer need to look at the headers
-            err |= curl_easy_setopt(fp->easy, CURLOPT_HEADERFUNCTION, NULL);
-            err |= curl_easy_setopt(fp->easy, CURLOPT_HEADERDATA, NULL);
-            free(ks_release(&in_header));
-
-            if (err != 0) { errno = ENOSYS; goto error; }
-        }
-    }
-
-    if (mode == 'r') {
-        double dval;
-
-        if (curl_easy_getinfo(fp->easy, CURLINFO_CONTENT_LENGTH_DOWNLOAD,
-                              &dval) == CURLE_OK && dval >= 0.0)
-            fp->file_size = (off_t) (dval + 0.1);
-    }
-
-    fp->base.backend = &libcurl_backend;
-    return &fp->base;
-
-error_remove:
-    save = errno;
-    (void) curl_multi_remove_handle(fp->multi, fp->easy);
-    fp->nrunning--;
-    errno = save;
-
-error:
-    if (fp->headers.redirect) free(in_header.s);
-    save = errno;
-    if (fp->easy) curl_easy_cleanup(fp->easy);
-    if (fp->multi) curl_multi_cleanup(fp->multi);
-    free_headers(&fp->headers.extra, 1);
-    hfile_destroy((hFILE *) fp);
-    errno = save;
-    return NULL;
-
-early_error:
-    return NULL;
-}
-
-static hFILE *hopen_libcurl(const char *url, const char *modes)
-{
-    return libcurl_open(url, modes, NULL);
-}
-
-static int parse_va_list(http_headers *headers, va_list args)
-{
-    const char *argtype;
-
-    while ((argtype = va_arg(args, const char *)) != NULL)
-        if (strcmp(argtype, "httphdr:v") == 0) {
-            const char **hdr;
-            for (hdr = va_arg(args, const char **); *hdr; hdr++) {
-                if (append_header(&headers->fixed, *hdr, 1) < 0)
-                    return -1;
-                if (is_authorization(*hdr))
-                    headers->auth_hdr_num = -1;
-            }
-        }
-        else if (strcmp(argtype, "httphdr:l") == 0) {
-            const char *hdr;
-            while ((hdr = va_arg(args, const char *)) != NULL) {
-                if (append_header(&headers->fixed, hdr, 1) < 0)
-                    return -1;
-                if (is_authorization(hdr))
-                    headers->auth_hdr_num = -1;
-            }
-        }
-        else if (strcmp(argtype, "httphdr") == 0) {
-            const char *hdr = va_arg(args, const char *);
-            if (hdr) {
-                if (append_header(&headers->fixed, hdr, 1) < 0)
-                    return -1;
-                if (is_authorization(hdr))
-                    headers->auth_hdr_num = -1;
-            }
-        }
-        else if (strcmp(argtype, "httphdr_callback") == 0) {
-            headers->callback = va_arg(args, const hts_httphdr_callback);
-        }
-        else if (strcmp(argtype, "httphdr_callback_data") == 0) {
-            headers->callback_data = va_arg(args, void *);
-        }
-        else if (strcmp(argtype, "va_list") == 0) {
-            va_list *args2 = va_arg(args, va_list *);
-            if (args2) {
-                if (parse_va_list(headers, *args2) < 0) return -1;
-            }
-        }
-        else if (strcmp(argtype, "auth_token_enabled") == 0) {
-            const char *flag = va_arg(args, const char *);
-            if (strcmp(flag, "false") == 0)
-                headers->auth_hdr_num = -3;
-        }
-        else if (strcmp(argtype, "redirect_callback") == 0) {
-            headers->redirect = va_arg(args, const redirect_callback);
-        }
-        else if (strcmp(argtype, "redirect_callback_data") == 0) {
-            headers->redirect_data = va_arg(args, void *);
-        }
-        else if (strcmp(argtype, "http_response_ptr") == 0) {
-            headers->http_response_ptr = va_arg(args, long *);
-        }
-        else if (strcmp(argtype, "fail_on_error") == 0) {
-            headers->fail_on_error = va_arg(args, int);
-        }
-        else { errno = EINVAL; return -1; }
-
-    return 0;
-}
-
-/*
-  HTTP headers to be added to the request can be passed in as extra
-  arguments to hopen().  The headers can be specified as follows:
-
-  * Single header:
-    hopen(url, mode, "httphdr", "X-Hdr-1: text", NULL);
-
-  * Multiple headers in the argument list:
-    hopen(url, mode, "httphdr:l", "X-Hdr-1: text", "X-Hdr-2: text", NULL, NULL);
-
-  * Multiple headers in a char* array:
-    hopen(url, mode, "httphdr:v", hdrs, NULL);
-    where `hdrs` is a char **.  The list ends with a NULL pointer.
-
-  * A callback function
-    hopen(url, mode, "httphdr_callback", func,
-                     "httphdr_callback_data", arg, NULL);
-    `func` has type
-         int (* hts_httphdr_callback) (void *cb_data, char ***hdrs);
-    `arg` is passed to the callback as a void *.
-
-    The function is called at file open, and when attempting to seek (which
-    opens a new HTTP request).  This allows, for example, access tokens
-    that may have gone stale to be regenerated.  The function is also
-    called (with `hdrs` == NULL) on file close so that the callback can
-    free any memory that it needs to.
-
-    The callback should return 0 on success, non-zero on failure.  It should
-    return in *hdrs a list of strings containing the new headers (terminated
-    with a NULL pointer).  These will replace any headers previously supplied
-    by the callback.  If no changes are necessary, it can return NULL
-    in *hdrs, in which case the previous headers will be left unchanged.
-
-    Ownership of the strings in the header list passes to hfile_libcurl,
-    so the callback should not attempt to use or free them itself.  The memory
-    containing the array belongs to the callback and will not be freed by
-    hfile_libcurl.
-
-    Headers supplied by the callback are appended after any specified
-    using the "httphdr", "httphdr:l" or "httphdr:v" methods.  No attempt
-    is made to replace these headers (even if a key is repeated) so anything
-    that is expected to vary needs to come from the callback.
- */
-
-static hFILE *vhopen_libcurl(const char *url, const char *modes, va_list args)
-{
-    hFILE *fp = NULL;
-    http_headers headers = { .fail_on_error = 1 };
-
-    if (parse_va_list(&headers, args) == 0) {
-        fp = libcurl_open(url, modes, &headers);
-    }
-
-    if (!fp) {
-        free_headers(&headers.fixed, 1);
-    }
-    return fp;
-}
-
-int PLUGIN_GLOBAL(hfile_plugin_init,_libcurl)(struct hFILE_plugin *self)
-{
-    static const struct hFILE_scheme_handler handler =
-        { hopen_libcurl, hfile_always_remote, "libcurl",
-          2000 + 50,
-          vhopen_libcurl };
-
-#ifdef ENABLE_PLUGINS
-    // Embed version string for examination via strings(1) or what(1)
-    static const char id[] =
-        "@(#)hfile_libcurl plugin (htslib)\t" HTS_VERSION_TEXT;
-    const char *version = strchr(id, '\t')+1;
-#else
-    const char *version = hts_version();
-#endif
-    const curl_version_info_data *info;
-    const char * const *protocol;
-    const char *auth;
-    CURLcode err;
-    CURLSHcode errsh;
-
-    err = curl_global_init(CURL_GLOBAL_ALL);
-    if (err != CURLE_OK) { errno = easy_errno(NULL, err); return -1; }
-
-    curl.share = curl_share_init();
-    if (curl.share == NULL) { curl_global_cleanup(); errno = EIO; return -1; }
-    errsh = curl_share_setopt(curl.share, CURLSHOPT_LOCKFUNC, share_lock);
-    errsh |= curl_share_setopt(curl.share, CURLSHOPT_UNLOCKFUNC, share_unlock);
-    errsh |= curl_share_setopt(curl.share, CURLSHOPT_SHARE, CURL_LOCK_DATA_DNS);
-    if (errsh != 0) {
-        curl_share_cleanup(curl.share);
-        curl_global_cleanup();
-        errno = EIO;
-        return -1;
-    }
-
-    if ((auth = getenv("HTS_AUTH_LOCATION")) != NULL) {
-        curl.auth_path = strdup(auth);
-        curl.auth_map = kh_init(auth_map);
-        if (!curl.auth_path || !curl.auth_map) {
-            int save_errno = errno;
-            free(curl.auth_path);
-            kh_destroy(auth_map, curl.auth_map);
-            curl_share_cleanup(curl.share);
-            curl_global_cleanup();
-            errno = save_errno;
-            return -1;
-        }
-    }
-    if ((auth = getenv("HTS_ALLOW_UNENCRYPTED_AUTHORIZATION_HEADER")) != NULL
-        && strcmp(auth, "I understand the risks") == 0) {
-        curl.allow_unencrypted_auth_header = 1;
-    }
-
-    info = curl_version_info(CURLVERSION_NOW);
-    ksprintf(&curl.useragent, "htslib/%s libcurl/%s", version, info->version);
-
-    self->name = "libcurl";
-    self->destroy = libcurl_exit;
-
-    for (protocol = info->protocols; *protocol; protocol++)
-        hfile_add_scheme_handler(*protocol, &handler);
-    return 0;
-}
diff -ruN stringtie.orig/htslib/hfile_s3.c stringtie/htslib/hfile_s3.c
--- stringtie.orig/htslib/hfile_s3.c	2024-02-28 13:57:39.701246126 +0100
+++ stringtie/htslib/hfile_s3.c	1970-01-01 01:00:00.000000000 +0100
@@ -1,1306 +0,0 @@
-/*  hfile_s3.c -- Amazon S3 backend for low-level file streams.
-
-    Copyright (C) 2015-2017, 2019-2020 Genome Research Ltd.
-
-    Author: John Marshall <jm18@sanger.ac.uk>
-
-Permission is hereby granted, free of charge, to any person obtaining a copy
-of this software and associated documentation files (the "Software"), to deal
-in the Software without restriction, including without limitation the rights
-to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
-copies of the Software, and to permit persons to whom the Software is
-furnished to do so, subject to the following conditions:
-
-The above copyright notice and this permission notice shall be included in
-all copies or substantial portions of the Software.
-
-THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
-IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
-FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
-THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
-LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
-FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
-DEALINGS IN THE SOFTWARE.  */
-
-#define HTS_BUILDING_LIBRARY // Enables HTSLIB_EXPORT, see htslib/hts_defs.h
-#include <config.h>
-
-#include <stdarg.h>
-#include <stdio.h>
-#include <stdlib.h>
-#include <string.h>
-#include <strings.h>
-#include <time.h>
-
-#include <errno.h>
-
-#include "hfile_internal.h"
-#ifdef ENABLE_PLUGINS
-#include "version.h"
-#endif
-#include "htslib/hts.h"  // for hts_version() and hts_verbose
-#include "htslib/kstring.h"
-
-typedef struct s3_auth_data {
-    kstring_t id;
-    kstring_t token;
-    kstring_t secret;
-    kstring_t region;
-    kstring_t canonical_query_string;
-    kstring_t user_query_string;
-    kstring_t host;
-    char *bucket;
-    kstring_t auth_hdr;
-    time_t auth_time;
-    char date[40];
-    char date_long[17];
-    char date_short[9];
-    kstring_t date_html;
-    char mode;
-    char *headers[4];
-    int refcount;
-} s3_auth_data;
-
-#define AUTH_LIFETIME 60
-
-#if defined HAVE_COMMONCRYPTO
-
-#include <CommonCrypto/CommonHMAC.h>
-
-#define DIGEST_BUFSIZ CC_SHA1_DIGEST_LENGTH
-#define SHA256_DIGEST_BUFSIZE CC_SHA256_DIGEST_LENGTH
-#define HASH_LENGTH_SHA256 (SHA256_DIGEST_BUFSIZE * 2) + 1
-
-static size_t
-s3_sign(unsigned char *digest, kstring_t *key, kstring_t *message)
-{
-    CCHmac(kCCHmacAlgSHA1, key->s, key->l, message->s, message->l, digest);
-    return CC_SHA1_DIGEST_LENGTH;
-}
-
-
-static void s3_sha256(const unsigned char *in, size_t length, unsigned char *out) {
-    CC_SHA256(in, length, out);
-}
-
-
-static void s3_sign_sha256(const void *key, int key_len, const unsigned char *d, int n, unsigned char *md, unsigned int *md_len) {
-    CCHmac(kCCHmacAlgSHA256, key, key_len, d, n, md);
-    *md_len = CC_SHA256_DIGEST_LENGTH;
-}
-
-
-#elif defined HAVE_HMAC
-
-#include <openssl/hmac.h>
-#include <openssl/sha.h>
-
-#define DIGEST_BUFSIZ EVP_MAX_MD_SIZE
-#define SHA256_DIGEST_BUFSIZE SHA256_DIGEST_LENGTH
-#define HASH_LENGTH_SHA256 (SHA256_DIGEST_BUFSIZE * 2) + 1
-
-static size_t
-s3_sign(unsigned char *digest, kstring_t *key, kstring_t *message)
-{
-    unsigned int len;
-    HMAC(EVP_sha1(), key->s, key->l,
-         (unsigned char *) message->s, message->l, digest, &len);
-    return len;
-}
-
-
-static void s3_sha256(const unsigned char *in, size_t length, unsigned char *out) {
-    SHA256(in, length, out);
-}
-
-
-static void s3_sign_sha256(const void *key, int key_len, const unsigned char *d, int n, unsigned char *md, unsigned int *md_len) {
-    HMAC(EVP_sha256(), key, key_len, d, n, md, md_len);
-}
-
-#else
-#error No HMAC() routine found by configure
-#endif
-
-static void
-urldecode_kput(const char *s, int len, kstring_t *str)
-{
-    char buf[3];
-    int i = 0;
-
-    while (i < len)
-        if (s[i] == '%' && i+2 < len) {
-            buf[0] = s[i+1], buf[1] = s[i+2], buf[2] = '\0';
-            kputc(strtol(buf, NULL, 16), str);
-            i += 3;
-        }
-        else kputc(s[i++], str);
-}
-
-static void base64_kput(const unsigned char *data, size_t len, kstring_t *str)
-{
-    static const char base64[] =
-        "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
-
-    size_t i = 0;
-    unsigned x = 0;
-    int bits = 0, pad = 0;
-
-    while (bits || i < len) {
-        if (bits < 6) {
-            x <<= 8, bits += 8;
-            if (i < len) x |= data[i++];
-            else pad++;
-        }
-
-        bits -= 6;
-        kputc(base64[(x >> bits) & 63], str);
-    }
-
-    str->l -= pad;
-    kputsn("==", pad, str);
-}
-
-static int is_dns_compliant(const char *s0, const char *slim, int is_https)
-{
-    int has_nondigit = 0, len = 0;
-    const char *s;
-
-    for (s = s0; s < slim; len++, s++)
-        if (islower_c(*s))
-            has_nondigit = 1;
-        else if (*s == '-') {
-            has_nondigit = 1;
-            if (s == s0 || s+1 == slim) return 0;
-        }
-        else if (isdigit_c(*s))
-            ;
-        else if (*s == '.') {
-            if (is_https) return 0;
-            if (s == s0 || ! isalnum_c(s[-1])) return 0;
-            if (s+1 == slim || ! isalnum_c(s[1])) return 0;
-        }
-        else return 0;
-
-    return has_nondigit && len >= 3 && len <= 63;
-}
-
-static FILE *expand_tilde_open(const char *fname, const char *mode)
-{
-    FILE *fp;
-
-    if (strncmp(fname, "~/", 2) == 0) {
-        kstring_t full_fname = { 0, 0, NULL };
-        const char *home = getenv("HOME");
-        if (! home) return NULL;
-
-        kputs(home, &full_fname);
-        kputs(&fname[1], &full_fname);
-
-        fp = fopen(full_fname.s, mode);
-        free(full_fname.s);
-    }
-    else
-        fp = fopen(fname, mode);
-
-    return fp;
-}
-
-static void parse_ini(const char *fname, const char *section, ...)
-{
-    kstring_t line = { 0, 0, NULL };
-    int active = 1;  // Start active, so global properties are accepted
-    char *s;
-
-    FILE *fp = expand_tilde_open(fname, "r");
-    if (fp == NULL) return;
-
-    while (line.l = 0, kgetline(&line, (kgets_func *) fgets, fp) >= 0)
-        if (line.s[0] == '[' && (s = strchr(line.s, ']')) != NULL) {
-            *s = '\0';
-            active = (strcmp(&line.s[1], section) == 0);
-        }
-        else if (active && (s = strpbrk(line.s, ":=")) != NULL) {
-            const char *key = line.s, *value = &s[1], *akey;
-            va_list args;
-
-            while (isspace_c(*key)) key++;
-            while (s > key && isspace_c(s[-1])) s--;
-            *s = '\0';
-
-            while (isspace_c(*value)) value++;
-            while (line.l > 0 && isspace_c(line.s[line.l-1]))
-                line.s[--line.l] = '\0';
-
-            va_start(args, section);
-            while ((akey = va_arg(args, const char *)) != NULL) {
-                kstring_t *avar = va_arg(args, kstring_t *);
-                if (strcmp(key, akey) == 0) { kputs(value, avar); break; }
-            }
-            va_end(args);
-        }
-
-    fclose(fp);
-    free(line.s);
-}
-
-static void parse_simple(const char *fname, kstring_t *id, kstring_t *secret)
-{
-    kstring_t text = { 0, 0, NULL };
-    char *s;
-    size_t len;
-
-    FILE *fp = expand_tilde_open(fname, "r");
-    if (fp == NULL) return;
-
-    while (kgetline(&text, (kgets_func *) fgets, fp) >= 0)
-        kputc(' ', &text);
-    fclose(fp);
-
-    s = text.s;
-    while (isspace_c(*s)) s++;
-    kputsn(s, len = strcspn(s, " \t"), id);
-
-    s += len;
-    while (isspace_c(*s)) s++;
-    kputsn(s, strcspn(s, " \t"), secret);
-
-    free(text.s);
-}
-
-static int copy_auth_headers(s3_auth_data *ad, char ***hdrs) {
-    char **hdr = &ad->headers[0];
-    *hdrs = hdr;
-    *hdr = strdup(ad->date);
-    if (!*hdr) return -1;
-    hdr++;
-    if (ad->auth_hdr.l) {
-        *hdr = strdup(ad->auth_hdr.s);
-        if (!*hdr) { free(ad->headers[0]); return -1; }
-        hdr++;
-    }
-    *hdr = NULL;
-    return 0;
-}
-
-static void free_auth_data(s3_auth_data *ad) {
-    if (ad->refcount > 0) {
-        --ad->refcount;
-        return;
-    }
-    free(ad->id.s);
-    free(ad->token.s);
-    free(ad->secret.s);
-    free(ad->region.s);
-    free(ad->canonical_query_string.s);
-    free(ad->user_query_string.s);
-    free(ad->host.s);
-    free(ad->bucket);
-    free(ad->auth_hdr.s);
-    free(ad->date_html.s);
-    free(ad);
-}
-
-static int auth_header_callback(void *ctx, char ***hdrs) {
-    s3_auth_data *ad = (s3_auth_data *) ctx;
-
-    time_t now = time(NULL);
-#ifdef HAVE_GMTIME_R
-    struct tm tm_buffer;
-    struct tm *tm = gmtime_r(&now, &tm_buffer);
-#else
-    struct tm *tm = gmtime(&now);
-#endif
-    kstring_t message = { 0, 0, NULL };
-    unsigned char digest[DIGEST_BUFSIZ];
-    size_t digest_len;
-
-    if (!hdrs) { // Closing connection
-        free_auth_data(ad);
-        return 0;
-    }
-
-    if (now - ad->auth_time < AUTH_LIFETIME) {
-        // Last auth string should still be valid
-        *hdrs = NULL;
-        return 0;
-    }
-
-    strftime(ad->date, sizeof(ad->date), "Date: %a, %d %b %Y %H:%M:%S GMT", tm);
-    if (!ad->id.l || !ad->secret.l) {
-        ad->auth_time = now;
-        return copy_auth_headers(ad, hdrs);
-    }
-
-    if (ksprintf(&message, "%s\n\n\n%s\n%s%s%s%s",
-                 ad->mode == 'r' ? "GET" : "PUT", ad->date + 6,
-                 ad->token.l ? "x-amz-security-token:" : "",
-                 ad->token.l ? ad->token.s : "",
-                 ad->token.l ? "\n" : "",
-                 ad->bucket) < 0) {
-        return -1;
-    }
-
-    digest_len = s3_sign(digest, &ad->secret, &message);
-    ad->auth_hdr.l = 0;
-    if (ksprintf(&ad->auth_hdr, "Authorization: AWS %s:", ad->id.s) < 0)
-        goto fail;
-    base64_kput(digest, digest_len, &ad->auth_hdr);
-
-    free(message.s);
-    ad->auth_time = now;
-    return copy_auth_headers(ad, hdrs);
-
- fail:
-    free(message.s);
-    return -1;
-}
-
-
-/* like a escape path but for query strings '=' and '&' are untouched */
-static char *escape_query(const char *qs) {
-    size_t i, j = 0, length;
-    char *escaped;
-
-    length = strlen(qs);
-
-    if ((escaped = malloc(length * 3 + 1)) == NULL) {
-        return NULL;
-    }
-
-    for (i = 0; i < length; i++) {
-        int c = qs[i];
-
-        if ((c >= '0' && c <= '9') || (c >= 'A' && c <= 'Z') || (c >= 'a' && c <= 'z') ||
-             c == '_' || c == '-' || c == '~' || c == '.' || c == '/' || c == '=' || c == '&') {
-            escaped[j++] = c;
-        } else {
-            sprintf(escaped + j, "%%%02X", c);
-            j += 3;
-        }
-    }
-
-    if (i != length) {
-        // in the case of a '?' copy the rest of the qs across unchanged
-        strcpy(escaped + j, qs + i);
-    } else {
-        escaped[j] = '\0';
-    }
-
-    return escaped;
-}
-
-
-static char *escape_path(const char *path) {
-    size_t i, j = 0, length;
-    char *escaped;
-
-    length = strlen(path);
-
-    if ((escaped = malloc(length * 3 + 1)) == NULL) {
-        return NULL;
-    }
-
-    for (i = 0; i < length; i++) {
-        int c = path[i];
-
-        if (c == '?') break; // don't escape ? or beyond
-
-        if ((c >= '0' && c <= '9') || (c >= 'A' && c <= 'Z') || (c >= 'a' && c <= 'z') ||
-             c == '_' || c == '-' || c == '~' || c == '.' || c == '/') {
-            escaped[j++] = c;
-        } else {
-            sprintf(escaped + j, "%%%02X", c);
-            j += 3;
-        }
-    }
-
-    if (i != length) {
-        // in the case of a '?' copy the rest of the path across unchanged
-        strcpy(escaped + j, path + i);
-    } else {
-        escaped[j] = '\0';
-    }
-
-    return escaped;
-}
-
-
-static int is_escaped(const char *str) {
-    const char *c = str;
-    int escaped = 0;
-    int needs_escape = 0;
-
-    while (*c != '\0') {
-        if (*c == '%' && c[1] != '\0' && c[2] != '\0') {
-            if (isxdigit_c(c[1]) && isxdigit_c(c[2])) {
-                escaped = 1;
-                c += 3;
-                continue;
-            } else {
-                // only escaped if all % signs are escaped
-                escaped = 0;
-            }
-        }
-        if (!((*c >= '0' && *c <= '9') || (*c >= 'A' && *c <= 'Z')
-              || (*c >= 'a' && *c <= 'z') ||
-              *c == '_' || *c == '-' || *c == '~' || *c == '.' || *c == '/')) {
-            needs_escape = 1;
-        }
-        c++;
-    }
-
-    return escaped || !needs_escape;
-}
-
-static int redirect_endpoint_callback(void *auth, long response,
-                                      kstring_t *header, kstring_t *url) {
-    s3_auth_data *ad = (s3_auth_data *)auth;
-    char *new_region;
-    char *end;
-    int ret = -1;
-
-    // get the new region from the reply header
-    if ((new_region = strstr(header->s, "x-amz-bucket-region: "))) {
-
-        new_region += strlen("x-amz-bucket-region: ");
-        end = new_region;
-
-        while (isalnum_c(*end) || ispunct_c(*end)) end++;
-
-        *end = 0;
-
-        if (strstr(ad->host.s, "amazonaws.com")) {
-            ad->region.l = 0;
-            kputs(new_region, &ad->region);
-
-            ad->host.l = 0;
-            ksprintf(&ad->host, "s3.%s.amazonaws.com", new_region);
-
-            if (ad->region.l && ad->host.l) {
-               url->l = 0;
-               kputs(ad->host.s, url);
-               kputsn(ad->bucket, strlen(ad->bucket), url);
-               if (ad->user_query_string.l) {
-                   kputc('?', url);
-                   kputsn(ad->user_query_string.s, ad->user_query_string.l, url);
-               }
-               ret = 0;
-            }
-        }
-    }
-
-    return ret;
-}
-
-static s3_auth_data * setup_auth_data(const char *s3url, const char *mode,
-                                      int sigver, kstring_t *url)
-{
-    s3_auth_data *ad = calloc(1, sizeof(*ad));
-    const char *bucket, *path;
-    char *escaped = NULL;
-    kstring_t profile = { 0, 0, NULL };
-    size_t url_path_pos;
-    ptrdiff_t bucket_len;
-    int is_https = 1, dns_compliant;
-    char *query_start;
-    enum {s3_auto, s3_virtual, s3_path} address_style = s3_auto;
-
-    if (!ad)
-        return NULL;
-    ad->mode = strchr(mode, 'r') ? 'r' : 'w';
-
-    // Our S3 URL format is s3[+SCHEME]://[ID[:SECRET[:TOKEN]]@]BUCKET/PATH
-
-    if (s3url[2] == '+') {
-        bucket = strchr(s3url, ':') + 1;
-        if (bucket == NULL) {
-            free(ad);
-            return NULL;
-        }
-        kputsn(&s3url[3], bucket - &s3url[3], url);
-        is_https = strncmp(url->s, "https:", 6) == 0;
-    }
-    else {
-        kputs("https:", url);
-        bucket = &s3url[3];
-    }
-    while (*bucket == '/') kputc(*bucket++, url);
-
-    path = bucket + strcspn(bucket, "/?#@");
-
-    if (*path == '@') {
-        const char *colon = strpbrk(bucket, ":@");
-        if (*colon != ':') {
-            urldecode_kput(bucket, colon - bucket, &profile);
-        }
-        else {
-            const char *colon2 = strpbrk(&colon[1], ":@");
-            urldecode_kput(bucket, colon - bucket, &ad->id);
-            urldecode_kput(&colon[1], colon2 - &colon[1], &ad->secret);
-            if (*colon2 == ':')
-                urldecode_kput(&colon2[1], path - &colon2[1], &ad->token);
-        }
-
-        bucket = &path[1];
-        path = bucket + strcspn(bucket, "/?#");
-    }
-    else {
-        // If the URL has no ID[:SECRET]@, consider environment variables.
-        const char *v;
-        if ((v = getenv("AWS_ACCESS_KEY_ID")) != NULL) kputs(v, &ad->id);
-        if ((v = getenv("AWS_SECRET_ACCESS_KEY")) != NULL) kputs(v, &ad->secret);
-        if ((v = getenv("AWS_SESSION_TOKEN")) != NULL) kputs(v, &ad->token);
-        if ((v = getenv("AWS_DEFAULT_REGION")) != NULL) kputs(v, &ad->region);
-        if ((v = getenv("HTS_S3_HOST")) != NULL) kputs(v, &ad->host);
-
-        if ((v = getenv("AWS_DEFAULT_PROFILE")) != NULL) kputs(v, &profile);
-        else if ((v = getenv("AWS_PROFILE")) != NULL) kputs(v, &profile);
-        else kputs("default", &profile);
-
-        if ((v = getenv("HTS_S3_ADDRESS_STYLE")) != NULL) {
-            if (strcasecmp(v, "virtual") == 0) {
-                address_style = s3_virtual;
-            } else if (strcasecmp(v, "path") == 0) {
-                address_style = s3_path;
-            }
-        }
-    }
-
-    if (ad->id.l == 0) {
-        kstring_t url_style = KS_INITIALIZE;
-        const char *v = getenv("AWS_SHARED_CREDENTIALS_FILE");
-        parse_ini(v? v : "~/.aws/credentials", profile.s,
-                  "aws_access_key_id", &ad->id,
-                  "aws_secret_access_key", &ad->secret,
-                  "aws_session_token", &ad->token,
-                  "region", &ad->region,
-                  "addressing_style", &url_style,
-                  NULL);
-
-        if (url_style.l) {
-            if (strcmp(url_style.s, "virtual") == 0) {
-                address_style = s3_virtual;
-            } else if (strcmp(url_style.s, "path") == 0) {
-                address_style = s3_path;
-            } else {
-                address_style = s3_auto;
-            }
-        }
-
-        ks_free(&url_style);
-    }
-
-    if (ad->id.l == 0) {
-        kstring_t url_style = KS_INITIALIZE;
-        const char *v = getenv("HTS_S3_S3CFG");
-        parse_ini(v? v : "~/.s3cfg", profile.s, "access_key", &ad->id,
-                  "secret_key", &ad->secret, "access_token", &ad->token,
-                  "host_base", &ad->host,
-                  "bucket_location", &ad->region,
-                  "host_bucket", &url_style,
-                  NULL);
-
-        if (url_style.l) {
-            // Conforming to s3cmd's GitHub PR#416, host_bucket without the "%(bucket)s" string
-            // indicates use of path style adressing.
-            if (strstr(url_style.s, "%(bucket)s") == NULL) {
-                address_style = s3_path;
-            } else {
-                address_style = s3_auto;
-            }
-        }
-
-        ks_free(&url_style);
-    }
-
-    if (ad->id.l == 0)
-        parse_simple("~/.awssecret", &ad->id, &ad->secret);
-
-
-    // if address_style is set, force the dns_compliant setting
-    if (address_style == s3_virtual) {
-        dns_compliant = 1;
-    } else if (address_style == s3_path) {
-        dns_compliant = 0;
-    } else {
-        dns_compliant = is_dns_compliant(bucket, path, is_https);
-    }
-
-    if (ad->host.l == 0)
-        kputs("s3.amazonaws.com", &ad->host);
-
-    if (!dns_compliant && ad->region.l > 0
-        && strcmp(ad->host.s, "s3.amazonaws.com") == 0) {
-        // Can avoid a redirection by including the region in the host name
-        // (assuming the right one has been specified)
-        ad->host.l = 0;
-        ksprintf(&ad->host, "s3.%s.amazonaws.com", ad->region.s);
-    }
-
-    if (ad->region.l == 0)
-        kputs("us-east-1", &ad->region);
-
-    if (!is_escaped(path)) {
-        escaped = escape_path(path);
-        if (escaped == NULL) {
-            goto error;
-        }
-    }
-
-    bucket_len = path - bucket;
-
-    // Use virtual hosted-style access if possible, otherwise path-style.
-    if (dns_compliant) {
-        size_t url_host_pos = url->l;
-        // Append "bucket.host" to url
-        kputsn_(bucket, bucket_len, url);
-        kputc('.', url);
-        kputsn(ad->host.s, ad->host.l, url);
-        url_path_pos = url->l;
-
-        if (sigver == 4) {
-            // Copy back to ad->host to use when making the signature
-            ad->host.l = 0;
-            kputsn(url->s + url_host_pos, url->l - url_host_pos, &ad->host);
-        }
-    }
-    else {
-        // Append "host/bucket" to url
-        kputsn(ad->host.s, ad->host.l, url);
-        url_path_pos = url->l;
-        kputc('/', url);
-        kputsn(bucket, bucket_len, url);
-    }
-
-    kputs(escaped == NULL ? path : escaped, url);
-
-    if (sigver == 4 || !dns_compliant) {
-        ad->bucket = malloc(url->l - url_path_pos + 1);
-        if (ad->bucket == NULL) {
-            goto error;
-        }
-        memcpy(ad->bucket, url->s + url_path_pos, url->l - url_path_pos + 1);
-    }
-    else {
-        ad->bucket = malloc(url->l - url_path_pos + bucket_len + 2);
-        if (ad->bucket == NULL) {
-            goto error;
-        }
-        ad->bucket[0] = '/';
-        memcpy(ad->bucket + 1, bucket, bucket_len);
-        memcpy(ad->bucket + bucket_len + 1,
-               url->s + url_path_pos, url->l - url_path_pos + 1);
-    }
-
-    // write any query strings to its own place to use later
-    if ((query_start = strchr(ad->bucket, '?'))) {
-        kputs(query_start + 1, &ad->user_query_string);
-        *query_start = 0;
-    }
-
-    free(profile.s);
-    free(escaped);
-
-    return ad;
-
- error:
-    free(profile.s);
-    free(escaped);
-    free_auth_data(ad);
-    return NULL;
-}
-
-static hFILE * s3_rewrite(const char *s3url, const char *mode, va_list *argsp)
-{
-    char *header_list[4], **header = header_list;
-
-    kstring_t url = { 0, 0, NULL };
-    kstring_t token_hdr = { 0, 0, NULL };
-    s3_auth_data *ad = setup_auth_data(s3url, mode, 2, &url);
-
-    if (!ad)
-        return NULL;
-
-    if (ad->token.l > 0) {
-        kputs("X-Amz-Security-Token: ", &token_hdr);
-        kputs(ad->token.s, &token_hdr);
-        *header++ = token_hdr.s;
-    }
-
-    *header = NULL;
-    hFILE *fp = hopen(url.s, mode, "va_list", argsp, "httphdr:v", header_list,
-                      "httphdr_callback", auth_header_callback,
-                      "httphdr_callback_data", ad,
-                      "redirect_callback", redirect_endpoint_callback,
-                      "redirect_callback_data", ad,
-                      NULL);
-    if (!fp) goto fail;
-
-    free(url.s);
-    free(token_hdr.s);
-    return fp;
-
- fail:
-    free(url.s);
-    free(token_hdr.s);
-    free_auth_data(ad);
-    return NULL;
-}
-
-/***************************************************************
-
-AWS S3 sig version 4 writing code
-
-****************************************************************/
-
-static void hash_string(char *in, size_t length, char *out) {
-    unsigned char hashed[SHA256_DIGEST_BUFSIZE];
-    int i, j;
-
-    s3_sha256((const unsigned char *)in, length, hashed);
-
-    for (i = 0, j = 0; i < SHA256_DIGEST_BUFSIZE; i++, j+= 2) {
-        sprintf(out + j, "%02x", hashed[i]);
-    }
-}
-
-static void ksinit(kstring_t *s) {
-    s->l = 0;
-    s->m = 0;
-    s->s = NULL;
-}
-
-
-static void ksfree(kstring_t *s) {
-    free(s->s);
-    ksinit(s);
-}
-
-
-static int make_signature(s3_auth_data *ad, kstring_t *string_to_sign, char *signature_string) {
-    unsigned char date_key[SHA256_DIGEST_BUFSIZE];
-    unsigned char date_region_key[SHA256_DIGEST_BUFSIZE];
-    unsigned char date_region_service_key[SHA256_DIGEST_BUFSIZE];
-    unsigned char signing_key[SHA256_DIGEST_BUFSIZE];
-    unsigned char signature[SHA256_DIGEST_BUFSIZE];
-
-    const unsigned char service[] = "s3";
-    const unsigned char request[] = "aws4_request";
-
-    kstring_t secret_access_key = {0, 0, NULL};
-    unsigned int len;
-    unsigned int i, j;
-
-    ksprintf(&secret_access_key, "AWS4%s", ad->secret.s);
-
-    if (secret_access_key.l == 0) {
-        return -1;
-    }
-
-    s3_sign_sha256(secret_access_key.s, secret_access_key.l, (const unsigned char *)ad->date_short, strlen(ad->date_short), date_key, &len);
-    s3_sign_sha256(date_key, len, (const unsigned char *)ad->region.s, ad->region.l, date_region_key, &len);
-    s3_sign_sha256(date_region_key, len, service, 2, date_region_service_key, &len);
-    s3_sign_sha256(date_region_service_key, len, request, 12, signing_key, &len);
-    s3_sign_sha256(signing_key, len, (const unsigned char *)string_to_sign->s, string_to_sign->l, signature, &len);
-
-    for (i = 0, j = 0; i < len; i++, j+= 2) {
-        sprintf(signature_string + j, "%02x", signature[i]);
-    }
-
-    ksfree(&secret_access_key);
-
-    return 0;
-}
-
-
-static int make_authorisation(s3_auth_data *ad, char *http_request, char *content, kstring_t *auth) {
-    kstring_t signed_headers = {0, 0, NULL};
-    kstring_t canonical_headers = {0, 0, NULL};
-    kstring_t canonical_request = {0, 0, NULL};
-    kstring_t scope = {0, 0, NULL};
-    kstring_t string_to_sign = {0, 0, NULL};
-    char cr_hash[HASH_LENGTH_SHA256];
-    char signature_string[HASH_LENGTH_SHA256];
-    int ret = -1;
-
-
-    if (!ad->token.l) {
-        kputs("host;x-amz-content-sha256;x-amz-date", &signed_headers);
-    } else {
-        kputs("host;x-amz-content-sha256;x-amz-date;x-amz-security-token", &signed_headers);
-    }
-
-    if (signed_headers.l == 0) {
-        return -1;
-    }
-
-
-    if (!ad->token.l) {
-        ksprintf(&canonical_headers, "host:%s\nx-amz-content-sha256:%s\nx-amz-date:%s\n",
-        ad->host.s, content, ad->date_long);
-    } else {
-        ksprintf(&canonical_headers, "host:%s\nx-amz-content-sha256:%s\nx-amz-date:%s\nx-amz-security-token:%s\n",
-        ad->host.s, content, ad->date_long, ad->token.s);
-    }
-
-    if (canonical_headers.l == 0) {
-        goto cleanup;
-    }
-
-    // bucket == canonical_uri
-    ksprintf(&canonical_request, "%s\n%s\n%s\n%s\n%s\n%s",
-        http_request, ad->bucket, ad->canonical_query_string.s,
-        canonical_headers.s, signed_headers.s, content);
-
-    if (canonical_request.l == 0) {
-        goto cleanup;
-    }
-
-    hash_string(canonical_request.s, canonical_request.l, cr_hash);
-
-    ksprintf(&scope, "%s/%s/s3/aws4_request", ad->date_short, ad->region.s);
-
-    if (scope.l == 0) {
-        goto cleanup;
-    }
-
-    ksprintf(&string_to_sign, "AWS4-HMAC-SHA256\n%s\n%s\n%s", ad->date_long, scope.s, cr_hash);
-
-    if (string_to_sign.l == 0) {
-        goto cleanup;
-    }
-
-    if (make_signature(ad, &string_to_sign, signature_string)) {
-        goto cleanup;
-    }
-
-    ksprintf(auth, "Authorization: AWS4-HMAC-SHA256 Credential=%s/%s/%s/s3/aws4_request,SignedHeaders=%s,Signature=%s",
-                ad->id.s, ad->date_short, ad->region.s, signed_headers.s, signature_string);
-
-    if (auth->l == 0) {
-        goto cleanup;
-    }
-
-    ret = 0;
-
- cleanup:
-    ksfree(&signed_headers);
-    ksfree(&canonical_headers);
-    ksfree(&canonical_request);
-    ksfree(&scope);
-    ksfree(&string_to_sign);
-
-    return ret;
-}
-
-
-static int update_time(s3_auth_data *ad) {
-    int ret = -1;
-    time_t now = time(NULL);
-#ifdef HAVE_GMTIME_R
-    struct tm tm_buffer;
-    struct tm *tm = gmtime_r(&now, &tm_buffer);
-#else
-    struct tm *tm = gmtime(&now);
-#endif
-
-    if (now - ad->auth_time > AUTH_LIFETIME) {
-        // update timestamp
-        ad->auth_time = now;
-
-        if (strftime(ad->date_long, 17, "%Y%m%dT%H%M%SZ", tm) != 16) {
-            return -1;
-        }
-
-        if (strftime(ad->date_short, 9, "%Y%m%d", tm) != 8) {
-            return -1;;
-        }
-
-        ad->date_html.l = 0;
-        ksprintf(&ad->date_html, "x-amz-date: %s", ad->date_long);
-    }
-
-    if (ad->date_html.l) ret = 0;
-
-    return ret;
-}
-
-
-static int query_cmp(const void *p1, const void *p2) {
-    char **q1 = (char **)p1;
-    char **q2 = (char **)p2;
-
-    return strcmp(*q1, *q2);
-}
-
-
-/* Query strings must be in alphabetical order for authorisation */
-
-static int order_query_string(kstring_t *qs) {
-    int *query_offset = NULL;
-    int num_queries, i;
-    char **queries = NULL;
-    kstring_t ordered = {0, 0, NULL};
-    char *escaped = NULL;
-    int ret = -1;
-
-    if ((query_offset = ksplit(qs, '&', &num_queries)) == NULL) {
-        return -1;
-    }
-
-    if ((queries = malloc(num_queries * sizeof(char*))) == NULL)
-        goto err;
-
-    for (i = 0; i < num_queries; i++) {
-        queries[i] = qs->s + query_offset[i];
-    }
-
-    qsort(queries, num_queries, sizeof(char *), query_cmp);
-
-    for (i = 0; i < num_queries; i++) {
-        if (i) {
-            kputs("&", &ordered);
-        }
-
-        kputs(queries[i], &ordered);
-    }
-
-    if ((escaped = escape_query(ordered.s)) == NULL)
-        goto err;
-
-    qs->l = 0;
-    kputs(escaped, qs);
-
-    ret = 0;
- err:
-    free(ordered.s);
-    free(queries);
-    free(query_offset);
-    free(escaped);
-
-    return ret;
-}
-
-
-static int write_authorisation_callback(void *auth, char *request, kstring_t *content, char *cqs,
-                                        kstring_t *hash, kstring_t *auth_str, kstring_t *date,
-                                        kstring_t *token, int uqs) {
-    s3_auth_data *ad = (s3_auth_data *)auth;
-    char content_hash[HASH_LENGTH_SHA256];
-
-    if (request == NULL) {
-        // signal to free auth data
-        free_auth_data(ad);
-        return 0;
-    }
-
-    if (update_time(ad)) {
-        return -1;
-    }
-
-    if (content) {
-        hash_string(content->s, content->l, content_hash);
-    } else {
-        // empty hash
-        hash_string("", 0, content_hash);
-    }
-
-    ad->canonical_query_string.l = 0;
-    kputs(cqs, &ad->canonical_query_string);
-
-    if (ad->canonical_query_string.l == 0) {
-        return -1;
-    }
-
-    /* add a user provided query string, normally only useful on upload initiation */
-    if (uqs) {
-        kputs("&", &ad->canonical_query_string);
-        kputs(ad->user_query_string.s, &ad->canonical_query_string);
-
-        if (order_query_string(&ad->canonical_query_string)) {
-            return -1;
-        }
-    }
-
-    if (make_authorisation(ad, request, content_hash, auth_str)) {
-        return -1;
-    }
-
-    kputs(ad->date_html.s, date);
-    kputsn(content_hash, HASH_LENGTH_SHA256, hash);
-
-    if (date->l == 0 || hash->l == 0) {
-        return -1;
-    }
-
-    if (ad->token.l) {
-        ksprintf(token, "x-amz-security-token: %s", ad->token.s);
-    }
-
-    return 0;
-}
-
-
-static int v4_auth_header_callback(void *ctx, char ***hdrs) {
-    s3_auth_data *ad = (s3_auth_data *) ctx;
-    char content_hash[HASH_LENGTH_SHA256];
-    kstring_t content = {0, 0, NULL};
-    kstring_t authorisation = {0, 0, NULL};
-    char *date_html = NULL;
-
-    if (!hdrs) { // Closing connection
-        free_auth_data(ad);
-        return 0;
-    }
-
-    if (update_time(ad)) {
-        return -1;
-    }
-
-    hash_string("", 0, content_hash); // empty hash
-
-    ad->canonical_query_string.l = 0;
-
-    if (ad->user_query_string.l > 0) {
-        kputs(ad->user_query_string.s, &ad->canonical_query_string);
-
-        if (order_query_string(&ad->canonical_query_string)) {
-            return -1;
-        }
-    } else {
-        kputs("", &ad->canonical_query_string);
-    }
-
-    if (make_authorisation(ad, "GET", content_hash, &authorisation)) {
-        return -1;
-    }
-
-    ksprintf(&content, "x-amz-content-sha256: %s", content_hash);
-    date_html = strdup(ad->date_html.s);
-
-    if (content.l == 0 || date_html == NULL) {
-        ksfree(&authorisation);
-        ksfree(&content);
-        free(date_html);
-        return -1;
-    }
-
-    *hdrs = &ad->headers[0];
-    ad->headers[0] = ks_release(&authorisation);
-    ad->headers[1] = date_html;
-    ad->headers[2] = ks_release(&content);
-    ad->headers[3] = NULL;
-
-    return 0;
-}
-
-static int handle_400_response(hFILE *fp, s3_auth_data *ad) {
-    // v4 signatures in virtual hosted mode return 400 Bad Request if the
-    // wrong region is used to make the signature.  The response is an xml
-    // document which includes the name of the correct region.  This can
-    // be extracted and used to generate a corrected signature.
-    // As the xml is fairly simple, go with something "good enough" instead
-    // of trying to parse it properly.
-
-    char buffer[1024], *region, *reg_end;
-    ssize_t bytes;
-
-    bytes = hread(fp, buffer, sizeof(buffer) - 1);
-    if (bytes < 0) {
-        return -1;
-    }
-    buffer[bytes] = '\0';
-    region = strstr(buffer, "<Region>");
-    if (region == NULL) {
-        return -1;
-    }
-    region += 8;
-    while (isspace((unsigned char) *region)) ++region;
-    reg_end = strchr(region, '<');
-    if (reg_end == NULL || strncmp(reg_end + 1, "/Region>", 8) != 0) {
-        return -1;
-    }
-    while (reg_end > region && isspace((unsigned char) reg_end[-1])) --reg_end;
-    ad->region.l = 0;
-    kputsn(region, reg_end - region, &ad->region);
-    if (ad->region.l == 0) {
-        return -1;
-    }
-
-    return 0;
-}
-
-static int set_region(void *adv, kstring_t *region) {
-    s3_auth_data *ad = (s3_auth_data *) adv;
-
-    ad->region.l = 0;
-    return kputsn(region->s, region->l, &ad->region) < 0;
-}
-
-static int http_status_errno(int status)
-{
-    if (status >= 500)
-        switch (status) {
-        case 501: return ENOSYS;
-        case 503: return EBUSY;
-        case 504: return ETIMEDOUT;
-        default:  return EIO;
-        }
-    else if (status >= 400)
-        switch (status) {
-        case 401: return EPERM;
-        case 403: return EACCES;
-        case 404: return ENOENT;
-        case 405: return EROFS;
-        case 407: return EPERM;
-        case 408: return ETIMEDOUT;
-        case 410: return ENOENT;
-        default:  return EINVAL;
-        }
-    else return 0;
-}
-
-static hFILE *s3_open_v4(const char *s3url, const char *mode, va_list *argsp) {
-    kstring_t url = { 0, 0, NULL };
-    kstring_t token_hdr = { 0, 0, NULL };
-
-    char *header_list[4], **header = header_list;
-    s3_auth_data *ad = setup_auth_data(s3url, mode, 4, &url);
-    hFILE *fp = NULL;
-
-    if (ad == NULL) {
-        return NULL;
-    }
-
-    if (ad->mode == 'r') {
-        long http_response = 0;
-
-        if (ad->token.l > 0) {
-            kputs("x-amz-security-token: ", &token_hdr);
-            kputs(ad->token.s, &token_hdr);
-            *header++ = token_hdr.s;
-        }
-
-        *header = NULL;
-        fp = hopen(url.s, mode, "va_list", argsp, "httphdr:v", header_list,
-                   "httphdr_callback", v4_auth_header_callback,
-                   "httphdr_callback_data", ad,
-                   "redirect_callback", redirect_endpoint_callback,
-                   "redirect_callback_data", ad,
-                   "http_response_ptr", &http_response,
-                   "fail_on_error", 0,
-                   NULL);
-
-        if (fp == NULL) goto error;
-
-        if (http_response == 400) {
-            ad->refcount = 1;
-            if (handle_400_response(fp, ad) != 0) {
-                goto error;
-            }
-            hclose_abruptly(fp);
-            fp = hopen(url.s, mode, "va_list", argsp, "httphdr:v", header_list,
-                       "httphdr_callback", v4_auth_header_callback,
-                       "httphdr_callback_data", ad,
-                       "redirect_callback", redirect_endpoint_callback,
-                       "redirect_callback_data", ad,
-                       NULL);
-        } else if (http_response > 400) {
-            ad->refcount = 1;
-            errno = http_status_errno(http_response);
-            goto error;
-        }
-
-        if (fp == NULL) goto error;
-    } else {
-        kstring_t final_url = {0, 0, NULL};
-
-         // add the scheme marker
-        ksprintf(&final_url, "s3w+%s", url.s);
-
-        if(final_url.l == 0) goto error;
-
-        fp = hopen(final_url.s, mode, "va_list", argsp,
-                   "s3_auth_callback",  write_authorisation_callback,
-                   "s3_auth_callback_data", ad,
-                   "redirect_callback", redirect_endpoint_callback,
-                   "set_region_callback", set_region,
-                   NULL);
-        free(final_url.s);
-
-        if (fp == NULL) goto error;
-    }
-
-    free(url.s);
-    free(token_hdr.s);
-
-    return fp;
-
-  error:
-
-    if (fp) hclose_abruptly(fp);
-    free(url.s);
-    free(token_hdr.s);
-    free_auth_data(ad);
-
-    return NULL;
-}
-
-
-static hFILE *s3_open(const char *url, const char *mode)
-{
-    hFILE *fp;
-
-    kstring_t mode_colon = { 0, 0, NULL };
-    kputs(mode, &mode_colon);
-    kputc(':', &mode_colon);
-
-    if (getenv("HTS_S3_V2") == NULL) { // Force the v2 signature code
-        fp = s3_open_v4(url, mode_colon.s, NULL);
-    } else {
-        fp = s3_rewrite(url, mode_colon.s, NULL);
-    }
-
-    free(mode_colon.s);
-
-    return fp;
-}
-
-static hFILE *s3_vopen(const char *url, const char *mode_colon, va_list args0)
-{
-    hFILE *fp;
-    // Need to use va_copy() as we can only take the address of an actual
-    // va_list object, not that of a parameter whose type may have decayed.
-    va_list args;
-    va_copy(args, args0);
-
-    if (getenv("HTS_S3_V2") == NULL) { // Force the v2 signature code
-        fp = s3_open_v4(url, mode_colon, &args);
-    } else {
-        fp = s3_rewrite(url, mode_colon, &args);
-    }
-
-    va_end(args);
-    return fp;
-}
-
-int PLUGIN_GLOBAL(hfile_plugin_init,_s3)(struct hFILE_plugin *self)
-{
-    static const struct hFILE_scheme_handler handler =
-        { s3_open, hfile_always_remote, "Amazon S3", 2000 + 50, s3_vopen
-        };
-
-#ifdef ENABLE_PLUGINS
-    // Embed version string for examination via strings(1) or what(1)
-    static const char id[] = "@(#)hfile_s3 plugin (htslib)\t" HTS_VERSION_TEXT;
-    if (hts_verbose >= 9)
-        fprintf(stderr, "[M::hfile_s3.init] version %s\n", strchr(id, '\t')+1);
-#endif
-
-    self->name = "Amazon S3";
-    hfile_add_scheme_handler("s3", &handler);
-    hfile_add_scheme_handler("s3+http", &handler);
-    hfile_add_scheme_handler("s3+https", &handler);
-    return 0;
-}
diff -ruN stringtie.orig/htslib/hfile_s3_write.c stringtie/htslib/hfile_s3_write.c
--- stringtie.orig/htslib/hfile_s3_write.c	2024-02-28 13:57:39.701246126 +0100
+++ stringtie/htslib/hfile_s3_write.c	1970-01-01 01:00:00.000000000 +0100
@@ -1,896 +0,0 @@
-/*
-    hfile_s3_write.c - Code to handle multipart uploading to S3.
-
-    Copyright (C) 2019 Genome Research Ltd.
-
-    Author: Andrew Whitwham <aw7@sanger.ac.uk>
-
-Permission is hereby granted, free of charge, to any person obtaining a copy
-of this software and associated documentation files (the "Software"), to deal
-in the Software without restriction, including without limitation the rights
-to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
-copies of the Software, and to permit persons to whom the Software is
-furnished to do so, subject to the following conditions:
-
-The above copyright notice and this permission notice shall be included in
-all copies or substantial portions of the Software.
-
-THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
-IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
-FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
-THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
-LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
-FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
-DEALINGS IN THE SOFTWARE
-
-
-S3 Multipart Upload
--------------------
-
-There are several steps in the Mulitipart upload.
-
-
-1) Initiate Upload
-------------------
-
-Initiate the upload and get an upload ID.  This ID is used in all other steps.
-
-
-2) Upload Part
---------------
-
-Upload a part of the data.  5Mb minimum part size (except for the last part).
-Each part is numbered and a successful upload returns an Etag header value that
-needs to used for the completion step.
-
-Step repeated till all data is uploaded.
-
-
-3) Completion
--------------
-
-Complete the upload by sending all the part numbers along with their associated
-Etag values.
-
-
-Optional - Abort
-----------------
-
-If something goes wrong this instructs the server to delete all the partial
-uploads and abandon the upload process.
-
-
-Andrew Whitwham, January 2019
-*/
-
-#define HTS_BUILDING_LIBRARY // Enables HTSLIB_EXPORT, see htslib/hts_defs.h
-#include <config.h>
-
-#include <stdarg.h>
-#include <stdlib.h>
-#include <string.h>
-#ifdef __MSYS__
-#include <strings.h>
-#endif
-#include <errno.h>
-#include <pthread.h>
-
-#include "hfile_internal.h"
-#ifdef ENABLE_PLUGINS
-#include "version.h"
-#endif
-#include "htslib/hts.h"
-#include "htslib/kstring.h"
-#include "htslib/khash.h"
-
-#include <curl/curl.h>
-
-#define MINIMUM_S3_WRITE_SIZE 5242880
-#define S3_MOVED_PERMANENTLY 301
-#define S3_BAD_REQUEST 400
-
-// Lets the part memory size grow to about 1Gb giving a 2.5Tb max file size.
-// Max. parts allowed by AWS is 10000, so use ceil(10000.0/9.0)
-#define EXPAND_ON 1112
-
-static struct {
-    kstring_t useragent;
-    CURLSH *share;
-    pthread_mutex_t share_lock;
-} curl = { { 0, 0, NULL }, NULL, PTHREAD_MUTEX_INITIALIZER };
-
-static void share_lock(CURL *handle, curl_lock_data data,
-                       curl_lock_access access, void *userptr) {
-    pthread_mutex_lock(&curl.share_lock);
-}
-
-static void share_unlock(CURL *handle, curl_lock_data data, void *userptr) {
-    pthread_mutex_unlock(&curl.share_lock);
-}
-
-typedef int (*s3_auth_callback) (void *auth_data, char *, kstring_t*, char*, kstring_t*, kstring_t*, kstring_t*, kstring_t*, int);
-
-typedef int (*set_region_callback) (void *auth_data, kstring_t *region);
-
-typedef struct {
-    s3_auth_callback callback;
-    redirect_callback redirect_callback;
-    set_region_callback set_region_callback;
-    void *callback_data;
-} s3_authorisation;
-
-typedef struct {
-    hFILE base;
-    CURL *curl;
-    CURLcode ret;
-    s3_authorisation *au;
-    kstring_t buffer;
-    kstring_t url;
-    kstring_t upload_id;
-    kstring_t completion_message;
-    int part_no;
-    int aborted;
-    size_t index;
-    long verbose;
-    int part_size;
-    int expand;
-} hFILE_s3_write;
-
-
-static void ksinit(kstring_t *s) {
-    s->l = 0;
-    s->m = 0;
-    s->s = NULL;
-}
-
-
-static void ksfree(kstring_t *s) {
-    free(s->s);
-    ksinit(s);
-}
-
-
-static size_t response_callback(void *contents, size_t size, size_t nmemb, void *userp) {
-    size_t realsize = size * nmemb;
-    kstring_t *resp = (kstring_t *)userp;
-
-    if (kputsn((const char *)contents, realsize, resp) == EOF) {
-        return 0;
-    }
-
-    return realsize;
-}
-
-
-static int get_entry(char *in, char *start_tag, char *end_tag, kstring_t *out) {
-    char *start;
-    char *end;
-
-    if (!in) {
-        return EOF;
-    }
-
-    start = strstr(in, start_tag);
-    if (!start) return EOF;
-
-    start += strlen(start_tag);
-    end = strstr(start, end_tag);
-
-    if (!end) return EOF;
-
-    return kputsn(start, end - start, out);
-}
-
-
-static void cleanup_local(hFILE_s3_write *fp) {
-    ksfree(&fp->buffer);
-    ksfree(&fp->url);
-    ksfree(&fp->upload_id);
-    ksfree(&fp->completion_message);
-    curl_easy_cleanup(fp->curl);
-    free(fp->au);
-
-}
-
-
-static void cleanup(hFILE_s3_write *fp) {
-    // free up authorisation data
-    fp->au->callback(fp->au->callback_data,  NULL, NULL, NULL, NULL, NULL, NULL, NULL, 0);
-    cleanup_local(fp);
-}
-
-
-static struct curl_slist *set_html_headers(hFILE_s3_write *fp, kstring_t *auth, kstring_t *date, kstring_t *content, kstring_t *token) {
-    struct curl_slist *headers = NULL;
-
-    headers = curl_slist_append(headers, "Content-Type:"); // get rid of this
-    headers = curl_slist_append(headers, "Expect:");       // and this
-    headers = curl_slist_append(headers, auth->s);
-    headers = curl_slist_append(headers, date->s);
-    headers = curl_slist_append(headers, content->s);
-
-    if (token->l) {
-        headers = curl_slist_append(headers, token->s);
-    }
-
-    curl_easy_setopt(fp->curl, CURLOPT_HTTPHEADER, headers);
-
-    return headers;
-}
-
-
-/*
-    The partially uploaded file will hang around unless the delete command is sent.
-*/
-static int abort_upload(hFILE_s3_write *fp) {
-    kstring_t content_hash = {0, 0, NULL};
-    kstring_t authorisation = {0, 0, NULL};
-    kstring_t url = {0, 0, NULL};
-    kstring_t content = {0, 0, NULL};
-    kstring_t canonical_query_string = {0, 0, NULL};
-    kstring_t date = {0, 0, NULL};
-    kstring_t token = {0, 0, NULL};
-    int ret = -1;
-    struct curl_slist *headers = NULL;
-    char http_request[] = "DELETE";
-
-    if (ksprintf(&canonical_query_string, "uploadId=%s", fp->upload_id.s) < 0) {
-        goto out;
-    }
-
-    if (fp->au->callback(fp->au->callback_data,  http_request, NULL,
-                         canonical_query_string.s, &content_hash,
-                         &authorisation, &date, &token, 0) != 0) {
-        goto out;
-    }
-
-    if (ksprintf(&url, "%s?%s", fp->url.s, canonical_query_string.s) < 0) {
-        goto out;
-    }
-
-    if (ksprintf(&content, "x-amz-content-sha256: %s", content_hash.s) < 0) {
-        goto out;
-    }
-
-    curl_easy_reset(fp->curl);
-    curl_easy_setopt(fp->curl, CURLOPT_CUSTOMREQUEST, http_request);
-    curl_easy_setopt(fp->curl, CURLOPT_USERAGENT, curl.useragent.s);
-    curl_easy_setopt(fp->curl, CURLOPT_URL, url.s);
-
-    curl_easy_setopt(fp->curl, CURLOPT_VERBOSE, fp->verbose);
-
-    headers = set_html_headers(fp, &authorisation, &date, &content, &token);
-    fp->ret = curl_easy_perform(fp->curl);
-
-    if (fp->ret == CURLE_OK) {
-        ret = 0;
-    }
-
- out:
-    ksfree(&authorisation);
-    ksfree(&content);
-    ksfree(&content_hash);
-    ksfree(&url);
-    ksfree(&date);
-    ksfree(&canonical_query_string);
-    ksfree(&token);
-    curl_slist_free_all(headers);
-
-    fp->aborted = 1;
-    cleanup(fp);
-
-    return ret;
-}
-
-
-static int complete_upload(hFILE_s3_write *fp, kstring_t *resp) {
-    kstring_t content_hash = {0, 0, NULL};
-    kstring_t authorisation = {0, 0, NULL};
-    kstring_t url = {0, 0, NULL};
-    kstring_t content = {0, 0, NULL};
-    kstring_t canonical_query_string = {0, 0, NULL};
-    kstring_t date = {0, 0, NULL};
-    kstring_t token = {0, 0, NULL};
-    int ret = -1;
-    struct curl_slist *headers = NULL;
-    char http_request[] = "POST";
-
-    if (ksprintf(&canonical_query_string, "uploadId=%s", fp->upload_id.s) < 0) {
-        return -1;
-    }
-
-    // finish off the completion reply
-    if (kputs("</CompleteMultipartUpload>\n", &fp->completion_message) < 0) {
-        goto out;
-    }
-
-    if (fp->au->callback(fp->au->callback_data,  http_request,
-                         &fp->completion_message, canonical_query_string.s,
-                         &content_hash, &authorisation, &date, &token, 0) != 0) {
-        goto out;
-    }
-
-    if (ksprintf(&url, "%s?%s", fp->url.s, canonical_query_string.s) < 0) {
-        goto out;
-    }
-
-    if (ksprintf(&content, "x-amz-content-sha256: %s", content_hash.s) < 0) {
-        goto out;
-    }
-
-    curl_easy_reset(fp->curl);
-    curl_easy_setopt(fp->curl, CURLOPT_POST, 1L);
-    curl_easy_setopt(fp->curl, CURLOPT_POSTFIELDS, fp->completion_message.s);
-    curl_easy_setopt(fp->curl, CURLOPT_POSTFIELDSIZE, fp->completion_message.l);
-    curl_easy_setopt(fp->curl, CURLOPT_WRITEFUNCTION, response_callback);
-    curl_easy_setopt(fp->curl, CURLOPT_WRITEDATA, (void *)resp);
-    curl_easy_setopt(fp->curl, CURLOPT_URL, url.s);
-    curl_easy_setopt(fp->curl, CURLOPT_USERAGENT, curl.useragent.s);
-
-    curl_easy_setopt(fp->curl, CURLOPT_VERBOSE, fp->verbose);
-
-    headers = set_html_headers(fp, &authorisation, &date, &content, &token);
-    fp->ret = curl_easy_perform(fp->curl);
-
-    if (fp->ret == CURLE_OK) {
-        ret = 0;
-    }
-
- out:
-    ksfree(&authorisation);
-    ksfree(&content);
-    ksfree(&content_hash);
-    ksfree(&url);
-    ksfree(&date);
-    ksfree(&token);
-    ksfree(&canonical_query_string);
-    curl_slist_free_all(headers);
-
-    return ret;
-}
-
-
-static size_t upload_callback(void *ptr, size_t size, size_t nmemb, void *stream) {
-    size_t realsize = size * nmemb;
-    hFILE_s3_write *fp = (hFILE_s3_write *)stream;
-    size_t read_length;
-
-    if (realsize > (fp->buffer.l - fp->index)) {
-        read_length = fp->buffer.l - fp->index;
-    } else {
-        read_length = realsize;
-    }
-
-    memcpy(ptr, fp->buffer.s + fp->index, read_length);
-    fp->index += read_length;
-
-    return read_length;
-}
-
-
-static int upload_part(hFILE_s3_write *fp, kstring_t *resp) {
-    kstring_t content_hash = {0, 0, NULL};
-    kstring_t authorisation = {0, 0, NULL};
-    kstring_t url = {0, 0, NULL};
-    kstring_t content = {0, 0, NULL};
-    kstring_t canonical_query_string = {0, 0, NULL};
-    kstring_t date = {0, 0, NULL};
-    kstring_t token = {0, 0, NULL};
-    int ret = -1;
-    struct curl_slist *headers = NULL;
-    char http_request[] = "PUT";
-
-    if (ksprintf(&canonical_query_string, "partNumber=%d&uploadId=%s", fp->part_no, fp->upload_id.s) < 0) {
-        return -1;
-    }
-
-    if (fp->au->callback(fp->au->callback_data, http_request, &fp->buffer,
-                         canonical_query_string.s, &content_hash,
-                         &authorisation, &date, &token, 0) != 0) {
-        goto out;
-    }
-
-    if (ksprintf(&url, "%s?%s", fp->url.s, canonical_query_string.s) < 0) {
-        goto out;
-    }
-
-    fp->index = 0;
-    if (ksprintf(&content, "x-amz-content-sha256: %s", content_hash.s) < 0) {
-        goto out;
-    }
-
-    curl_easy_reset(fp->curl);
-
-    curl_easy_setopt(fp->curl, CURLOPT_UPLOAD, 1L);
-    curl_easy_setopt(fp->curl, CURLOPT_READFUNCTION, upload_callback);
-    curl_easy_setopt(fp->curl, CURLOPT_READDATA, fp);
-    curl_easy_setopt(fp->curl, CURLOPT_INFILESIZE_LARGE, (curl_off_t)fp->buffer.l);
-    curl_easy_setopt(fp->curl, CURLOPT_HEADERFUNCTION, response_callback);
-    curl_easy_setopt(fp->curl, CURLOPT_HEADERDATA, (void *)resp);
-    curl_easy_setopt(fp->curl, CURLOPT_URL, url.s);
-    curl_easy_setopt(fp->curl, CURLOPT_USERAGENT, curl.useragent.s);
-
-    curl_easy_setopt(fp->curl, CURLOPT_VERBOSE, fp->verbose);
-
-    headers = set_html_headers(fp, &authorisation, &date, &content, &token);
-    fp->ret = curl_easy_perform(fp->curl);
-
-    if (fp->ret == CURLE_OK) {
-        ret = 0;
-    }
-
- out:
-    ksfree(&authorisation);
-    ksfree(&content);
-    ksfree(&content_hash);
-    ksfree(&url);
-    ksfree(&date);
-    ksfree(&token);
-    ksfree(&canonical_query_string);
-    curl_slist_free_all(headers);
-
-    return ret;
-}
-
-
-static ssize_t s3_write(hFILE *fpv, const void *bufferv, size_t nbytes) {
-    hFILE_s3_write *fp = (hFILE_s3_write *)fpv;
-    const char *buffer  = (const char *)bufferv;
-
-    if (kputsn(buffer, nbytes, &fp->buffer) == EOF) {
-        return -1;
-    }
-
-    if (fp->buffer.l > fp->part_size) {
-        // time to write out our data
-        kstring_t response = {0, 0, NULL};
-        int ret;
-
-        ret = upload_part(fp, &response);
-
-        if (!ret) {
-            long response_code;
-            kstring_t etag = {0, 0, NULL};
-
-            curl_easy_getinfo(fp->curl, CURLINFO_RESPONSE_CODE, &response_code);
-
-            if (response_code > 200) {
-                ret = -1;
-            } else {
-                if (get_entry(response.s, "ETag: \"", "\"", &etag) == EOF) {
-                    ret = -1;
-                } else {
-                    ksprintf(&fp->completion_message, "\t<Part>\n\t\t<PartNumber>%d</PartNumber>\n\t\t<ETag>%s</ETag>\n\t</Part>\n",
-                        fp->part_no, etag.s);
-
-                    ksfree(&etag);
-                }
-            }
-        }
-
-        ksfree(&response);
-
-        if (ret) {
-            abort_upload(fp);
-            return -1;
-        }
-
-        fp->part_no++;
-        fp->buffer.l = 0;
-
-        if (fp->expand && (fp->part_no % EXPAND_ON == 0)) {
-            fp->part_size *= 2;
-        }
-    }
-
-    return nbytes;
-}
-
-
-static int s3_close(hFILE *fpv) {
-    hFILE_s3_write *fp = (hFILE_s3_write *)fpv;
-    kstring_t response = {0, 0, NULL};
-    int ret = 0;
-
-    if (!fp->aborted) {
-
-        if (fp->buffer.l) {
-            // write the last part
-
-            ret = upload_part(fp, &response);
-
-            if (!ret) {
-                long response_code;
-                kstring_t etag = {0, 0, NULL};
-
-                curl_easy_getinfo(fp->curl, CURLINFO_RESPONSE_CODE, &response_code);
-
-                if (response_code > 200) {
-                    ret = -1;
-                } else {
-                    if (get_entry(response.s, "ETag: \"", "\"", &etag) == EOF) {
-                        ret = -1;
-                    } else {
-                        ksprintf(&fp->completion_message, "\t<Part>\n\t\t<PartNumber>%d</PartNumber>\n\t\t<ETag>%s</ETag>\n\t</Part>\n",
-                            fp->part_no, etag.s);
-
-                        ksfree(&etag);
-                    }
-                }
-            }
-
-            ksfree(&response);
-
-            if (ret) {
-                abort_upload(fp);
-                return -1;
-            }
-
-            fp->part_no++;
-        }
-
-        if (fp->part_no > 1) {
-            ret = complete_upload(fp, &response);
-
-            if (!ret) {
-                if (strstr(response.s, "CompleteMultipartUploadResult") == NULL) {
-                    ret = -1;
-                }
-            }
-        } else {
-            ret = -1;
-        }
-
-        if (ret) {
-            abort_upload(fp);
-        } else {
-            cleanup(fp);
-        }
-    }
-
-    ksfree(&response);
-
-    return ret;
-}
-
-
-static int redirect_endpoint(hFILE_s3_write *fp, kstring_t *head) {
-    int ret = -1;
-
-    if (fp->au->redirect_callback) {
-        ret = fp->au->redirect_callback(fp->au->callback_data, 301, head, &fp->url);
-    }
-
-    return ret;
-}
-
-static int handle_bad_request(hFILE_s3_write *fp, kstring_t *resp) {
-    kstring_t region = {0, 0, NULL};
-    int ret = -1;
-
-    if (fp->au->set_region_callback) {
-        if (get_entry(resp->s, "<Region>", "</Region>", &region) == EOF) {
-            return -1;
-        }
-
-        ret = fp->au->set_region_callback(fp->au->callback_data, &region);
-
-        ksfree(&region);
-    }
-
-    return ret;
-}
-
-static int initialise_upload(hFILE_s3_write *fp, kstring_t *head, kstring_t *resp, int user_query) {
-    kstring_t content_hash = {0, 0, NULL};
-    kstring_t authorisation = {0, 0, NULL};
-    kstring_t url = {0, 0, NULL};
-    kstring_t content = {0, 0, NULL};
-    kstring_t date = {0, 0, NULL};
-    kstring_t token = {0, 0, NULL};
-    int ret = -1;
-    struct curl_slist *headers = NULL;
-    char http_request[] = "POST";
-    char delimiter = '?';
-
-    if (user_query) {
-        delimiter = '&';
-    }
-
-    if (fp->au->callback(fp->au->callback_data,  http_request, NULL, "uploads=",
-                         &content_hash, &authorisation, &date, &token, user_query) != 0) {
-        goto out;
-    }
-
-    if (ksprintf(&url, "%s%cuploads", fp->url.s, delimiter) < 0) {
-        goto out;
-    }
-
-    if (ksprintf(&content, "x-amz-content-sha256: %s", content_hash.s) < 0) {
-        goto out;
-    }
-
-    curl_easy_setopt(fp->curl, CURLOPT_URL, url.s);
-    curl_easy_setopt(fp->curl, CURLOPT_POST, 1L);
-    curl_easy_setopt(fp->curl, CURLOPT_POSTFIELDS, "");  // send no data
-    curl_easy_setopt(fp->curl, CURLOPT_WRITEFUNCTION, response_callback);
-    curl_easy_setopt(fp->curl, CURLOPT_WRITEDATA, (void *)resp);
-    curl_easy_setopt(fp->curl, CURLOPT_HEADERFUNCTION, response_callback);
-    curl_easy_setopt(fp->curl, CURLOPT_HEADERDATA, (void *)head);
-    curl_easy_setopt(fp->curl, CURLOPT_USERAGENT, curl.useragent.s);
-
-    curl_easy_setopt(fp->curl, CURLOPT_VERBOSE, fp->verbose);
-
-    headers = set_html_headers(fp, &authorisation, &date, &content, &token);
-    fp->ret = curl_easy_perform(fp->curl);
-
-    if (fp->ret == CURLE_OK) {
-        ret = 0;
-    }
-
- out:
-    ksfree(&authorisation);
-    ksfree(&content);
-    ksfree(&content_hash);
-    ksfree(&url);
-    ksfree(&date);
-    ksfree(&token);
-    curl_slist_free_all(headers);
-
-    return ret;
-}
-
-
-static int get_upload_id(hFILE_s3_write *fp, kstring_t *resp) {
-    int ret = 0;
-
-    ksinit(&fp->upload_id);
-
-    if (get_entry(resp->s, "<UploadId>", "</UploadId>", &fp->upload_id) == EOF) {
-        ret = -1;
-    }
-
-    return ret;
-}
-
-
-static const struct hFILE_backend s3_write_backend = {
-    NULL, s3_write, NULL, NULL, s3_close
-};
-
-
-static hFILE *s3_write_open(const char *url, s3_authorisation *auth) {
-    hFILE_s3_write *fp;
-    kstring_t response = {0, 0, NULL};
-    kstring_t header   = {0, 0, NULL};
-    int ret, has_user_query = 0;
-    char *query_start;
-    const char *env;
-
-
-    if (!auth || !auth->callback || !auth->callback_data) {
-        return NULL;
-    }
-
-    fp = (hFILE_s3_write *)hfile_init(sizeof(hFILE_s3_write), "w", 0);
-
-    if (fp == NULL) {
-        return NULL;
-    }
-
-    if ((fp->curl = curl_easy_init()) == NULL) {
-        errno = ENOMEM;
-        goto error;
-    }
-
-    if ((fp->au = calloc(1, sizeof(s3_authorisation))) == NULL) {
-        goto error;
-    }
-
-    memcpy(fp->au, auth, sizeof(s3_authorisation));
-
-    ksinit(&fp->buffer);
-    ksinit(&fp->url);
-    ksinit(&fp->completion_message);
-    fp->aborted = 0;
-
-    fp->part_size = MINIMUM_S3_WRITE_SIZE;
-    fp->expand = 1;
-
-    if ((env = getenv("HTS_S3_PART_SIZE")) != NULL) {
-        int part_size = atoi(env) * 1024 * 1024;
-
-        if (part_size > fp->part_size)
-            fp->part_size = part_size;
-
-        fp->expand = 0;
-    }
-
-    if (hts_verbose >= 8) {
-        fp->verbose = 1L;
-    } else {
-        fp->verbose = 0L;
-    }
-
-    kputs(url + 4, &fp->url);
-
-    if ((query_start = strchr(fp->url.s, '?'))) {
-        has_user_query = 1;;
-    }
-
-    ret = initialise_upload(fp, &header, &response, has_user_query);
-
-    if (ret == 0) {
-        long response_code;
-
-        curl_easy_getinfo(fp->curl, CURLINFO_RESPONSE_CODE, &response_code);
-
-        if (response_code == S3_MOVED_PERMANENTLY) {
-            if (redirect_endpoint(fp, &header) == 0) {
-                ksfree(&response);
-                ksfree(&header);
-
-                ret = initialise_upload(fp, &header, &response, has_user_query);
-            }
-        } else if (response_code == S3_BAD_REQUEST) {
-            if (handle_bad_request(fp, &response) == 0) {
-                ksfree(&response);
-                ksfree(&header);
-
-                ret = initialise_upload(fp, &header, &response, has_user_query);
-            }
-        }
-
-        ksfree(&header); // no longer needed
-    }
-
-    if (ret) goto error;
-
-    if (get_upload_id(fp, &response)) goto error;
-
-    // start the completion message (a formatted list of parts)
-    ksinit(&fp->completion_message);
-
-    if (kputs("<CompleteMultipartUpload>\n", &fp->completion_message) == EOF) {
-        goto error;
-    }
-
-    fp->part_no = 1;
-
-    // user query string no longer a useful part of the URL
-    if (query_start)
-         *query_start = '\0';
-
-    fp->base.backend = &s3_write_backend;
-    ksfree(&response);
-
-    return &fp->base;
-
-error:
-    ksfree(&response);
-    cleanup_local(fp);
-    hfile_destroy((hFILE *)fp);
-    return NULL;
-}
-
-
-static hFILE *hopen_s3_write(const char *url, const char *mode) {
-    if (hts_verbose >= 1) {
-        fprintf(stderr, "[E::%s] s3w:// URLs should not be used directly; use s3:// instead.\n", __func__);
-    }
-    return NULL;
-}
-
-
-static int parse_va_list(s3_authorisation *auth, va_list args) {
-    const char *argtype;
-
-    while  ((argtype = va_arg(args, const char *)) != NULL) {
-        if (strcmp(argtype, "s3_auth_callback") == 0) {
-            auth->callback = va_arg(args, s3_auth_callback);
-        } else if (strcmp(argtype, "s3_auth_callback_data") == 0) {
-            auth->callback_data = va_arg(args, void *);
-        } else if (strcmp(argtype, "redirect_callback") == 0) {
-            auth->redirect_callback = va_arg(args, redirect_callback);
-        } else if (strcmp(argtype, "set_region_callback") == 0) {
-            auth->set_region_callback = va_arg(args, set_region_callback);
-        } else if (strcmp(argtype, "va_list") == 0) {
-            va_list *args2 = va_arg(args, va_list *);
-
-            if (args2) {
-                if (parse_va_list(auth, *args2) < 0) return -1;
-            }
-        } else {
-            errno = EINVAL;
-            return -1;
-        }
-    }
-
-    return 0;
-}
-
-
-static hFILE *vhopen_s3_write(const char *url, const char *mode, va_list args) {
-    hFILE *fp = NULL;
-    s3_authorisation auth = {NULL, NULL, NULL};
-
-    if (parse_va_list(&auth, args) == 0) {
-        fp =  s3_write_open(url, &auth);
-    }
-
-    return fp;
-}
-
-
-static void s3_write_exit() {
-    if (curl_share_cleanup(curl.share) == CURLSHE_OK)
-        curl.share = NULL;
-
-    free(curl.useragent.s);
-    curl.useragent.l = curl.useragent.m = 0; curl.useragent.s = NULL;
-    curl_global_cleanup();
-}
-
-
-int PLUGIN_GLOBAL(hfile_plugin_init,_s3_write)(struct hFILE_plugin *self) {
-
-    static const struct hFILE_scheme_handler handler =
-        { hopen_s3_write, hfile_always_remote, "S3 Multipart Upload",
-          2000 + 50, vhopen_s3_write
-        };
-
-#ifdef ENABLE_PLUGINS
-    // Embed version string for examination via strings(1) or what(1)
-    static const char id[] =
-        "@(#)hfile_s3_write plugin (htslib)\t" HTS_VERSION_TEXT;
-    const char *version = strchr(id, '\t') + 1;
-
-    if (hts_verbose >= 9)
-        fprintf(stderr, "[M::hfile_s3_write.init] version %s\n",
-                version);
-#else
-    const char *version = hts_version();
-#endif
-
-    const curl_version_info_data *info;
-    CURLcode err;
-    CURLSHcode errsh;
-
-    err = curl_global_init(CURL_GLOBAL_ALL);
-
-    if (err != CURLE_OK) {
-        // look at putting in an errno here
-        return -1;
-    }
-
-    curl.share = curl_share_init();
-
-    if (curl.share == NULL) {
-        curl_global_cleanup();
-        errno = EIO;
-        return -1;
-    }
-
-    errsh  = curl_share_setopt(curl.share, CURLSHOPT_LOCKFUNC, share_lock);
-    errsh |= curl_share_setopt(curl.share, CURLSHOPT_UNLOCKFUNC, share_unlock);
-    errsh |= curl_share_setopt(curl.share, CURLSHOPT_SHARE, CURL_LOCK_DATA_DNS);
-
-    if (errsh != 0) {
-        curl_share_cleanup(curl.share);
-        curl_global_cleanup();
-        errno = EIO;
-        return -1;
-    }
-
-    info = curl_version_info(CURLVERSION_NOW);
-    ksprintf(&curl.useragent, "htslib/%s libcurl/%s", version, info->version);
-
-    self->name = "S3 Multipart Upload";
-    self->destroy = s3_write_exit;
-
-    hfile_add_scheme_handler("s3w",       &handler);
-    hfile_add_scheme_handler("s3w+http",  &handler);
-    hfile_add_scheme_handler("s3w+https", &handler);
-
-    return 0;
-}
diff -ruN stringtie.orig/htslib/hts.c stringtie/htslib/hts.c
--- stringtie.orig/htslib/hts.c	2024-02-28 13:57:39.701246126 +0100
+++ stringtie/htslib/hts.c	1970-01-01 01:00:00.000000000 +0100
@@ -1,4510 +0,0 @@
-/*  hts.c -- format-neutral I/O, indexing, and iterator API functions.
-
-    Copyright (C) 2008, 2009, 2012-2020 Genome Research Ltd.
-    Copyright (C) 2012, 2013 Broad Institute.
-
-    Author: Heng Li <lh3@sanger.ac.uk>
-
-Permission is hereby granted, free of charge, to any person obtaining a copy
-of this software and associated documentation files (the "Software"), to deal
-in the Software without restriction, including without limitation the rights
-to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
-copies of the Software, and to permit persons to whom the Software is
-furnished to do so, subject to the following conditions:
-
-The above copyright notice and this permission notice shall be included in
-all copies or substantial portions of the Software.
-
-THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
-IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
-FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
-THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
-LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
-FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
-DEALINGS IN THE SOFTWARE.  */
-
-#define HTS_BUILDING_LIBRARY // Enables HTSLIB_EXPORT, see htslib/hts_defs.h
-#include <config.h>
-
-#include <zlib.h>
-#include <stdio.h>
-#include <string.h>
-#include <strings.h>
-#include <stdlib.h>
-#include <unistd.h>
-#include <inttypes.h>
-#include <limits.h>
-#include <stdint.h>
-#include <fcntl.h>
-#include <errno.h>
-#include <time.h>
-#include <sys/stat.h>
-#include <assert.h>
-
-#include "htslib/hts.h"
-#include "htslib/bgzf.h"
-#include "cram/cram.h"
-#include "htslib/hfile.h"
-#include "htslib/hts_endian.h"
-#include "version.h"
-#include "config_vars.h"
-#include "hts_internal.h"
-#include "hfile_internal.h"
-#include "sam_internal.h"
-#include "htslib/hts_expr.h"
-#include "htslib/hts_os.h" // drand48
-
-#include "htslib/khash.h"
-#include "htslib/kseq.h"
-#include "htslib/ksort.h"
-#include "htslib/tbx.h"
-#if defined(HAVE_EXTERNAL_LIBHTSCODECS)
-#include <htscodecs/htscodecs.h>
-#else
-#include "htscodecs/htscodecs/htscodecs.h"
-#endif
-
-#ifndef EFTYPE
-#define EFTYPE ENOEXEC
-#endif
-
-KHASH_INIT2(s2i,, kh_cstr_t, int64_t, 1, kh_str_hash_func, kh_str_hash_equal)
-
-HTSLIB_EXPORT
-int hts_verbose = HTS_LOG_WARNING;
-
-const char *hts_version()
-{
-    return HTS_VERSION_TEXT;
-}
-
-unsigned int hts_features(void) {
-    unsigned int feat = HTS_FEATURE_HTSCODECS; // Always present
-
-#ifdef PACKAGE_URL
-    feat |= HTS_FEATURE_CONFIGURE;
-#endif
-
-#ifdef ENABLE_PLUGINS
-    feat |= HTS_FEATURE_PLUGINS;
-#endif
-
-#ifdef HAVE_LIBCURL
-    feat |= HTS_FEATURE_LIBCURL;
-#endif
-
-#ifdef ENABLE_S3
-    feat |= HTS_FEATURE_S3;
-#endif
-
-#ifdef ENABLE_GCS
-    feat |= HTS_FEATURE_GCS;
-#endif
-
-#ifdef HAVE_LIBDEFLATE
-    feat |= HTS_FEATURE_LIBDEFLATE;
-#endif
-
-#ifdef HAVE_LIBLZMA
-    feat |= HTS_FEATURE_LZMA;
-#endif
-
-#ifdef HAVE_LIBBZ2
-    feat |= HTS_FEATURE_BZIP2;
-#endif
-
-    return feat;
-}
-
-const char *hts_test_feature(unsigned int id) {
-    unsigned int feat = hts_features();
-
-    switch (id) {
-    case HTS_FEATURE_CONFIGURE:
-        return feat & HTS_FEATURE_CONFIGURE ? "yes" : NULL;
-    case HTS_FEATURE_PLUGINS:
-        return feat & HTS_FEATURE_PLUGINS ? "yes" : NULL;
-    case HTS_FEATURE_LIBCURL:
-        return feat & HTS_FEATURE_LIBCURL ? "yes" : NULL;
-    case HTS_FEATURE_S3:
-        return feat & HTS_FEATURE_S3 ? "yes" : NULL;
-    case HTS_FEATURE_GCS:
-        return feat & HTS_FEATURE_GCS ? "yes" : NULL;
-    case HTS_FEATURE_LIBDEFLATE:
-        return feat & HTS_FEATURE_LIBDEFLATE ? "yes" : NULL;
-    case HTS_FEATURE_BZIP2:
-        return feat & HTS_FEATURE_BZIP2 ? "yes" : NULL;
-    case HTS_FEATURE_LZMA:
-        return feat & HTS_FEATURE_LZMA ? "yes" : NULL;
-
-    case HTS_FEATURE_HTSCODECS:
-        return htscodecs_version();
-
-    case HTS_FEATURE_CC:
-        return HTS_CC;
-    case HTS_FEATURE_CFLAGS:
-        return HTS_CFLAGS;
-    case HTS_FEATURE_LDFLAGS:
-        return HTS_LDFLAGS;
-    case HTS_FEATURE_CPPFLAGS:
-        return HTS_CPPFLAGS;
-
-    default:
-        fprintf(stderr, "Unknown feature code: %u\n", id);
-    }
-
-    return NULL;
-}
-
-// Note this implementation also means we can just "strings" the library
-// to find the configuration parameters.
-const char *hts_feature_string(void) {
-    static char config[1200];
-    const char *fmt=
-
-#ifdef PACKAGE_URL
-    "build=configure "
-#else
-    "build=Makefile "
-#endif
-
-#ifdef ENABLE_PLUGINS
-    "plugins=yes, plugin-path=%.1000s "
-#else
-    "plugins=no "
-#endif
-
-#ifdef HAVE_LIBCURL
-    "libcurl=yes "
-#else
-    "libcurl=no "
-#endif
-
-#ifdef ENABLE_S3
-    "S3=yes "
-#else
-    "S3=no "
-#endif
-
-#ifdef ENABLE_GCS
-    "GCS=yes "
-#else
-    "GCS=no "
-#endif
-
-#ifdef HAVE_LIBDEFLATE
-    "libdeflate=yes "
-#else
-    "libdeflate=no "
-#endif
-
-#ifdef HAVE_LIBLZMA
-    "lzma=yes "
-#else
-    "lzma=no "
-#endif
-
-#ifdef HAVE_LIBBZ2
-    "bzip2=yes "
-#else
-    "bzip2=no "
-#endif
-
-    "htscodecs=%.40s";
-
-#ifdef ENABLE_PLUGINS
-    snprintf(config, sizeof(config), fmt,
-             hts_plugin_path(), htscodecs_version());
-#else
-    snprintf(config, sizeof(config), fmt, htscodecs_version());
-#endif
-    return config;
-}
-
-
-HTSLIB_EXPORT
-const unsigned char seq_nt16_table[256] = {
-    15,15,15,15, 15,15,15,15, 15,15,15,15, 15,15,15,15,
-    15,15,15,15, 15,15,15,15, 15,15,15,15, 15,15,15,15,
-    15,15,15,15, 15,15,15,15, 15,15,15,15, 15,15,15,15,
-     1, 2, 4, 8, 15,15,15,15, 15,15,15,15, 15, 0 /*=*/,15,15,
-    15, 1,14, 2, 13,15,15, 4, 11,15,15,12, 15, 3,15,15,
-    15,15, 5, 6,  8,15, 7, 9, 15,10,15,15, 15,15,15,15,
-    15, 1,14, 2, 13,15,15, 4, 11,15,15,12, 15, 3,15,15,
-    15,15, 5, 6,  8,15, 7, 9, 15,10,15,15, 15,15,15,15,
-
-    15,15,15,15, 15,15,15,15, 15,15,15,15, 15,15,15,15,
-    15,15,15,15, 15,15,15,15, 15,15,15,15, 15,15,15,15,
-    15,15,15,15, 15,15,15,15, 15,15,15,15, 15,15,15,15,
-    15,15,15,15, 15,15,15,15, 15,15,15,15, 15,15,15,15,
-    15,15,15,15, 15,15,15,15, 15,15,15,15, 15,15,15,15,
-    15,15,15,15, 15,15,15,15, 15,15,15,15, 15,15,15,15,
-    15,15,15,15, 15,15,15,15, 15,15,15,15, 15,15,15,15,
-    15,15,15,15, 15,15,15,15, 15,15,15,15, 15,15,15,15
-};
-
-HTSLIB_EXPORT
-const char seq_nt16_str[] = "=ACMGRSVTWYHKDBN";
-
-HTSLIB_EXPORT
-const int seq_nt16_int[] = { 4, 0, 1, 4, 2, 4, 4, 4, 3, 4, 4, 4, 4, 4, 4, 4 };
-
-/**********************
- *** Basic file I/O ***
- **********************/
-
-static enum htsFormatCategory format_category(enum htsExactFormat fmt)
-{
-    switch (fmt) {
-    case bam:
-    case sam:
-    case cram:
-    case fastq_format:
-        return sequence_data;
-
-    case vcf:
-    case bcf:
-        return variant_data;
-
-    case bai:
-    case crai:
-    case csi:
-    case fai_format:
-    case fqi_format:
-    case gzi:
-    case tbi:
-        return index_file;
-
-    case bed:
-        return region_list;
-
-    case fasta_format:
-    case htsget:
-    case hts_crypt4gh_format:
-        return unknown_category;
-
-    case unknown_format:
-    case binary_format:
-    case text_format:
-    case empty_format:
-    case format_maximum:
-        break;
-    }
-
-    return unknown_category;
-}
-
-// Decompress several hundred bytes by peeking at the file, which must be
-// positioned at the start of a GZIP block.
-static size_t decompress_peek(hFILE *fp, unsigned char *dest, size_t destsize)
-{
-    unsigned char buffer[2048];
-    z_stream zs;
-    ssize_t npeek = hpeek(fp, buffer, sizeof buffer);
-
-    if (npeek < 0) return 0;
-
-    zs.zalloc = NULL;
-    zs.zfree = NULL;
-    zs.next_in = buffer;
-    zs.avail_in = npeek;
-    zs.next_out = dest;
-    zs.avail_out = destsize;
-    if (inflateInit2(&zs, 31) != Z_OK) return 0;
-
-    while (zs.total_out < destsize)
-        if (inflate(&zs, Z_SYNC_FLUSH) != Z_OK) break;
-
-    destsize = zs.total_out;
-    inflateEnd(&zs);
-
-    return destsize;
-}
-
-// Parse "x.y" text, taking care because the string is not NUL-terminated
-// and filling in major/minor only when the digits are followed by a delimiter,
-// so we don't misread "1.10" as "1.1" due to reaching the end of the buffer.
-static void
-parse_version(htsFormat *fmt, const unsigned char *u, const unsigned char *ulim)
-{
-    const char *s    = (const char *) u;
-    const char *slim = (const char *) ulim;
-    short v;
-
-    fmt->version.major = fmt->version.minor = -1;
-
-    for (v = 0; s < slim && isdigit_c(*s); s++)
-        v = 10 * v + *s - '0';
-
-    if (s < slim) {
-        fmt->version.major = v;
-        if (*s == '.') {
-            s++;
-            for (v = 0; s < slim && isdigit_c(*s); s++)
-                v = 10 * v + *s - '0';
-            if (s < slim)
-                fmt->version.minor = v;
-        }
-        else
-            fmt->version.minor = 0;
-    }
-}
-
-static int
-cmp_nonblank(const char *key, const unsigned char *u, const unsigned char *ulim)
-{
-    const unsigned char *ukey = (const unsigned char *) key;
-
-    while (*ukey)
-        if (u >= ulim) return +1;
-        else if (isspace_c(*u)) u++;
-        else if (*u != *ukey) return (*ukey < *u)? -1 : +1;
-        else u++, ukey++;
-
-    return 0;
-}
-
-static int is_text_only(const unsigned char *u, const unsigned char *ulim)
-{
-    for (; u < ulim; u++)
-        if (! (*u >= ' ' || *u == '\t' || *u == '\r' || *u == '\n'))
-            return 0;
-
-    return 1;
-}
-
-static int
-secondline_is_bases(const unsigned char *u, const unsigned char *ulim)
-{
-    // Skip to second line, returning false if there isn't one
-    u = memchr(u, '\n', ulim - u);
-    if (u == NULL || ++u == ulim) return 0;
-
-    // Scan over all base-encoding letters (including 'N' but not SEQ's '=')
-    while (u < ulim && (seq_nt16_table[*u] != 15 || toupper(*u) == 'N')) {
-        if (*u == '=') return 0;
-        u++;
-    }
-
-    return (u == ulim || *u == '\r' || *u == '\n')? 1 : 0;
-}
-
-// Parse tab-delimited text, filling in a string of column types and returning
-// the number of columns spotted (within [u,ulim), and up to column_len) or -1
-// if non-printable characters were seen.  Column types:
-//     i: integer, s: strand sign, C: CIGAR, O: SAM optional field, Z: anything
-static int
-parse_tabbed_text(char *columns, int column_len,
-                  const unsigned char *u, const unsigned char *ulim,
-                  int *complete)
-{
-    const char *str  = (const char *) u;
-    const char *slim = (const char *) ulim;
-    const char *s;
-    int ncolumns = 0;
-
-    enum { digit = 1, leading_sign = 2, cigar_operator = 4, other = 8 };
-    unsigned seen = 0;
-    *complete = 0;
-
-    for (s = str; s < slim; s++)
-        if (*s >= ' ') {
-            if (isdigit_c(*s))
-                seen |= digit;
-            else if ((*s == '+' || *s == '-') && s == str)
-                seen |= leading_sign;
-            else if (strchr(BAM_CIGAR_STR, *s) && s > str && isdigit_c(s[-1]))
-                seen |= cigar_operator;
-            else
-                seen |= other;
-        }
-        else if (*s == '\t' || *s == '\r' || *s == '\n') {
-            size_t len = s - str;
-            char type;
-
-            if (seen == digit || seen == (leading_sign|digit)) type = 'i';
-            else if (seen == (digit|cigar_operator)) type = 'C';
-            else if (len == 1)
-                switch (str[0]) {
-                case '*': type = 'C'; break;
-                case '+': case '-': case '.': type = 's'; break;
-                default: type = 'Z'; break;
-                }
-            else if (len >= 5 && str[2] == ':' && str[4] == ':') type = 'O';
-            else type = 'Z';
-
-            columns[ncolumns++] = type;
-            if (*s != '\t' || ncolumns >= column_len - 1) {
-                *complete = 1; // finished the line or more columns than needed
-                break;
-            }
-
-            str = s + 1;
-            seen = 0;
-        }
-        else return -1;
-
-    columns[ncolumns] = '\0';
-    return ncolumns;
-}
-
-// Match COLUMNS as a prefix against PATTERN (so COLUMNS may run out first).
-// Returns len(COLUMNS) (modulo '+'), or 0 if there is a mismatched entry.
-static int colmatch(const char *columns, const char *pattern)
-{
-    int i;
-    for (i = 0; columns[i] != '\0'; i++) {
-        if (pattern[i] == '+') return i;
-        if (! (columns[i] == pattern[i] || pattern[i] == 'Z')) return 0;
-    }
-
-    return i;
-}
-
-int hts_detect_format(hFILE *hfile, htsFormat *fmt)
-{
-    char columns[24];
-    unsigned char s[1024];
-    int complete = 0;
-    ssize_t len = hpeek(hfile, s, 18);
-    if (len < 0) return -1;
-
-    fmt->category = unknown_category;
-    fmt->format = unknown_format;
-    fmt->version.major = fmt->version.minor = -1;
-    fmt->compression = no_compression;
-    fmt->compression_level = -1;
-    fmt->specific = NULL;
-
-    if (len >= 2 && s[0] == 0x1f && s[1] == 0x8b) {
-        // The stream is either gzip-compressed or BGZF-compressed.
-        // Determine which, and decompress the first few records or lines.
-        fmt->compression = gzip;
-        if (len >= 18 && (s[3] & 4)) {
-            if (memcmp(&s[12], "BC\2\0", 4) == 0)
-                fmt->compression = bgzf;
-            else if (memcmp(&s[12], "RAZF", 4) == 0)
-                fmt->compression = razf_compression;
-        }
-        if (len >= 9 && s[2] == 8)
-            fmt->compression_level = (s[8] == 2)? 9 : (s[8] == 4)? 1 : -1;
-
-        len = decompress_peek(hfile, s, sizeof s);
-    }
-    else if (len >= 10 && memcmp(s, "BZh", 3) == 0 &&
-             (memcmp(&s[4], "\x31\x41\x59\x26\x53\x59", 6) == 0 ||
-              memcmp(&s[4], "\x17\x72\x45\x38\x50\x90", 6) == 0)) {
-        fmt->compression = bzip2_compression;
-        fmt->compression_level = s[3] - '0';
-        // Decompressing via libbz2 produces no output until it has a whole
-        // block (of size 100Kb x level), which is too large for peeking.
-        // So unfortunately we can recognise bzip2 but not the contents,
-        // except that \x1772... magic indicates the stream is empty.
-        if (s[4] == '\x31') return 0;
-        else len = 0;
-    }
-    else {
-        len = hpeek(hfile, s, sizeof s);
-    }
-    if (len < 0) return -1;
-
-    if (len == 0) {
-        fmt->format = empty_format;
-        return 0;
-    }
-
-    if (len >= 6 && memcmp(s,"CRAM",4) == 0 && s[4]>=1 && s[4]<=7 && s[5]<=7) {
-        fmt->category = sequence_data;
-        fmt->format = cram;
-        fmt->version.major = s[4], fmt->version.minor = s[5];
-        fmt->compression = custom;
-        return 0;
-    }
-    else if (len >= 4 && s[3] <= '\4') {
-        if (memcmp(s, "BAM\1", 4) == 0) {
-            fmt->category = sequence_data;
-            fmt->format = bam;
-            // TODO Decompress enough to pick version from @HD-VN header
-            fmt->version.major = 1, fmt->version.minor = -1;
-            return 0;
-        }
-        else if (memcmp(s, "BAI\1", 4) == 0) {
-            fmt->category = index_file;
-            fmt->format = bai;
-            fmt->version.major = -1, fmt->version.minor = -1;
-            return 0;
-        }
-        else if (memcmp(s, "BCF\4", 4) == 0) {
-            fmt->category = variant_data;
-            fmt->format = bcf;
-            fmt->version.major = 1, fmt->version.minor = -1;
-            return 0;
-        }
-        else if (memcmp(s, "BCF\2", 4) == 0) {
-            fmt->category = variant_data;
-            fmt->format = bcf;
-            fmt->version.major = s[3];
-            fmt->version.minor = (len >= 5 && s[4] <= 2)? s[4] : 0;
-            return 0;
-        }
-        else if (memcmp(s, "CSI\1", 4) == 0) {
-            fmt->category = index_file;
-            fmt->format = csi;
-            fmt->version.major = 1, fmt->version.minor = -1;
-            return 0;
-        }
-        else if (memcmp(s, "TBI\1", 4) == 0) {
-            fmt->category = index_file;
-            fmt->format = tbi;
-            return 0;
-        }
-    }
-    else if (len >= 16 && memcmp(s, "##fileformat=VCF", 16) == 0) {
-        fmt->category = variant_data;
-        fmt->format = vcf;
-        if (len >= 21 && s[16] == 'v')
-            parse_version(fmt, &s[17], &s[len]);
-        return 0;
-    }
-    else if (len >= 4 && s[0] == '@' &&
-             (memcmp(s, "@HD\t", 4) == 0 || memcmp(s, "@SQ\t", 4) == 0 ||
-              memcmp(s, "@RG\t", 4) == 0 || memcmp(s, "@PG\t", 4) == 0 ||
-              memcmp(s, "@CO\t", 4) == 0)) {
-        fmt->category = sequence_data;
-        fmt->format = sam;
-        // @HD-VN is not guaranteed to be the first tag, but then @HD is
-        // not guaranteed to be present at all...
-        if (len >= 9 && memcmp(s, "@HD\tVN:", 7) == 0)
-            parse_version(fmt, &s[7], &s[len]);
-        else
-            fmt->version.major = 1, fmt->version.minor = -1;
-        return 0;
-    }
-    else if (cmp_nonblank("{\"htsget\":", s, &s[len]) == 0) {
-        fmt->category = unknown_category;
-        fmt->format = htsget;
-        return 0;
-    }
-    else if (len > 8 && memcmp(s, "crypt4gh", 8) == 0) {
-        fmt->category = unknown_category;
-        fmt->format = hts_crypt4gh_format;
-        return 0;
-    }
-    else if (len >= 1 && s[0] == '>' && secondline_is_bases(s, &s[len])) {
-        fmt->format = fasta_format;
-        return 0;
-    }
-    else if (len >= 1 && s[0] == '@' && secondline_is_bases(s, &s[len])) {
-        fmt->category = sequence_data;
-        fmt->format = fastq_format;
-        return 0;
-    }
-    else if (parse_tabbed_text(columns, sizeof columns, s,
-                               &s[len], &complete) > 0) {
-        // A complete SAM line is at least 11 columns.  On unmapped long reads may
-        // be missing two.  (On mapped long reads we must have an @ header so long
-        // CIGAR is irrelevant.)
-        if (colmatch(columns, "ZiZiiCZiiZZOOOOOOOOOOOOOOOOOOOO+")
-            >= 9 + 2*complete) {
-            fmt->category = sequence_data;
-            fmt->format = sam;
-            fmt->version.major = 1, fmt->version.minor = -1;
-            return 0;
-        }
-        else if (fmt->compression == gzip && colmatch(columns, "iiiiii") == 6) {
-            fmt->category = index_file;
-            fmt->format = crai;
-            return 0;
-        }
-        else if (colmatch(columns, "Ziiiii") == 6) {
-            fmt->category = index_file;
-            fmt->format = fqi_format;
-            return 0;
-        }
-        else if (colmatch(columns, "Ziiii") == 5) {
-            fmt->category = index_file;
-            fmt->format = fai_format;
-            return 0;
-        }
-        else if (colmatch(columns, "Zii+") >= 3) {
-            fmt->category = region_list;
-            fmt->format = bed;
-            return 0;
-        }
-    }
-
-    // Arbitrary text files can be read using hts_getline().
-    if (is_text_only(s, &s[len])) fmt->format = text_format;
-
-    // Nothing recognised: leave unset fmt-> fields as unknown.
-    return 0;
-}
-
-char *hts_format_description(const htsFormat *format)
-{
-    kstring_t str = { 0, 0, NULL };
-
-    switch (format->format) {
-    case sam:   kputs("SAM", &str); break;
-    case bam:   kputs("BAM", &str); break;
-    case cram:  kputs("CRAM", &str); break;
-    case fasta_format:  kputs("FASTA", &str); break;
-    case fastq_format:  kputs("FASTQ", &str); break;
-    case vcf:   kputs("VCF", &str); break;
-    case bcf:
-        if (format->version.major == 1) kputs("Legacy BCF", &str);
-        else kputs("BCF", &str);
-        break;
-    case bai:   kputs("BAI", &str); break;
-    case crai:  kputs("CRAI", &str); break;
-    case csi:   kputs("CSI", &str); break;
-    case fai_format:    kputs("FASTA-IDX", &str); break;
-    case fqi_format:    kputs("FASTQ-IDX", &str); break;
-    case gzi:   kputs("GZI", &str); break;
-    case tbi:   kputs("Tabix", &str); break;
-    case bed:   kputs("BED", &str); break;
-    case htsget: kputs("htsget", &str); break;
-    case hts_crypt4gh_format: kputs("crypt4gh", &str); break;
-    case empty_format:  kputs("empty", &str); break;
-    default:    kputs("unknown", &str); break;
-    }
-
-    if (format->version.major >= 0) {
-        kputs(" version ", &str);
-        kputw(format->version.major, &str);
-        if (format->version.minor >= 0) {
-            kputc('.', &str);
-            kputw(format->version.minor, &str);
-        }
-    }
-
-    switch (format->compression) {
-    case bzip2_compression:  kputs(" bzip2-compressed", &str); break;
-    case razf_compression:   kputs(" legacy-RAZF-compressed", &str); break;
-    case custom: kputs(" compressed", &str); break;
-    case gzip:   kputs(" gzip-compressed", &str); break;
-    case bgzf:
-        switch (format->format) {
-        case bam:
-        case bcf:
-        case csi:
-        case tbi:
-            // These are by definition BGZF, so just use the generic term
-            kputs(" compressed", &str);
-            break;
-        default:
-            kputs(" BGZF-compressed", &str);
-            break;
-        }
-        break;
-    default: break;
-    }
-
-    switch (format->category) {
-    case sequence_data: kputs(" sequence", &str); break;
-    case variant_data:  kputs(" variant calling", &str); break;
-    case index_file:    kputs(" index", &str); break;
-    case region_list:   kputs(" genomic region", &str); break;
-    default: break;
-    }
-
-    if (format->compression == no_compression)
-        switch (format->format) {
-        case text_format:
-        case sam:
-        case crai:
-        case vcf:
-        case bed:
-        case fai_format:
-        case fqi_format:
-        case fasta_format:
-        case fastq_format:
-        case htsget:
-            kputs(" text", &str);
-            break;
-
-        case empty_format:
-            break;
-
-        default:
-            kputs(" data", &str);
-            break;
-        }
-    else
-        kputs(" data", &str);
-
-    return ks_release(&str);
-}
-
-htsFile *hts_open_format(const char *fn, const char *mode, const htsFormat *fmt)
-{
-    char smode[101], *cp, *cp2, *mode_c;
-    htsFile *fp = NULL;
-    hFILE *hfile = NULL;
-    char fmt_code = '\0';
-    const char format_to_mode[] = "\0g\0\0b\0c\0\0b\0g\0\0";
-
-    strncpy(smode, mode, 99);
-    smode[99]=0;
-    if ((cp = strchr(smode, ',')))
-        *cp = '\0';
-
-    // Migrate format code (b or c) to the end of the smode buffer.
-    for (cp2 = cp = smode; *cp; cp++) {
-        if (*cp == 'b')
-            fmt_code = 'b';
-        else if (*cp == 'c')
-            fmt_code = 'c';
-        else
-            *cp2++ = *cp;
-    }
-    mode_c = cp2;
-    *cp2++ = fmt_code;
-    *cp2++ = 0;
-
-    // Set or reset the format code if opts->format is used
-    if (fmt && fmt->format > unknown_format
-        && fmt->format < sizeof(format_to_mode)) {
-        *mode_c = format_to_mode[fmt->format];
-    }
-
-    // If we really asked for a compressed text format then mode_c above will
-    // point to nul.  We set to 'z' to enable bgzf.
-    if (strchr(mode, 'w') && fmt && fmt->compression == bgzf) {
-        if (fmt->format == sam || fmt->format == vcf || fmt->format == text_format)
-            *mode_c = 'z';
-    }
-
-    char *rmme = NULL, *fnidx = strstr(fn, HTS_IDX_DELIM);
-    if ( fnidx ) {
-        rmme = strdup(fn);
-        if ( !rmme ) goto error;
-        rmme[fnidx-fn] = 0;
-        fn = rmme;
-    }
-
-    hfile = hopen(fn, smode);
-    if (hfile == NULL) goto error;
-
-    fp = hts_hopen(hfile, fn, smode);
-    if (fp == NULL) goto error;
-
-    // Compensate for the loss of exactness in htsExactFormat.
-    // hts_hopen returns generics such as binary or text, but we
-    // have been given something explicit here so use that instead.
-    if (fp->is_write && fmt &&
-        (fmt->format == bam || fmt->format == sam ||
-         fmt->format == vcf || fmt->format == bcf ||
-         fmt->format == bed || fmt->format == fasta_format ||
-         fmt->format == fastq_format))
-        fp->format.format = fmt->format;
-
-    if (fmt && fmt->specific)
-        if (hts_opt_apply(fp, fmt->specific) != 0)
-            goto error;
-
-    if ( rmme ) free(rmme);
-    return fp;
-
-error:
-    hts_log_error("Failed to open file \"%s\"%s%s", fn,
-                  errno ? " : " : "", errno ? strerror(errno) : "");
-    if ( rmme ) free(rmme);
-
-    if (hfile)
-        hclose_abruptly(hfile);
-
-    return NULL;
-}
-
-htsFile *hts_open(const char *fn, const char *mode) {
-    return hts_open_format(fn, mode, NULL);
-}
-
-/*
- * Splits str into a prefix, delimiter ('\0' or delim), and suffix, writing
- * the prefix in lowercase into buf and returning a pointer to the suffix.
- * On return, buf is always NUL-terminated; thus assumes that the "keyword"
- * prefix should be one of several known values of maximum length buflen-2.
- * (If delim is not found, returns a pointer to the '\0'.)
- */
-static const char *
-scan_keyword(const char *str, char delim, char *buf, size_t buflen)
-{
-    size_t i = 0;
-    while (*str && *str != delim) {
-        if (i < buflen-1) buf[i++] = tolower_c(*str);
-        str++;
-    }
-
-    buf[i] = '\0';
-    return *str? str+1 : str;
-}
-
-/*
- * Parses arg and appends it to the option list.
- *
- * Returns 0 on success;
- *        -1 on failure.
- */
-int hts_opt_add(hts_opt **opts, const char *c_arg) {
-    hts_opt *o, *t;
-    char *val;
-
-    /*
-     * IMPORTANT!!!
-     * If you add another string option here, don't forget to also add
-     * it to the case statement in hts_opt_apply.
-     */
-
-    if (!c_arg)
-        return -1;
-
-    if (!(o =  malloc(sizeof(*o))))
-        return -1;
-
-    if (!(o->arg = strdup(c_arg))) {
-        free(o);
-        return -1;
-    }
-
-    if (!(val = strchr(o->arg, '=')))
-        val = "1"; // assume boolean
-    else
-        *val++ = '\0';
-
-    if (strcmp(o->arg, "decode_md") == 0 ||
-        strcmp(o->arg, "DECODE_MD") == 0)
-        o->opt = CRAM_OPT_DECODE_MD, o->val.i = atoi(val);
-
-    else if (strcmp(o->arg, "verbosity") == 0 ||
-             strcmp(o->arg, "VERBOSITY") == 0)
-        o->opt = CRAM_OPT_VERBOSITY, o->val.i = atoi(val);
-
-    else if (strcmp(o->arg, "seqs_per_slice") == 0 ||
-             strcmp(o->arg, "SEQS_PER_SLICE") == 0)
-        o->opt = CRAM_OPT_SEQS_PER_SLICE, o->val.i = atoi(val);
-
-    else if (strcmp(o->arg, "bases_per_slice") == 0 ||
-             strcmp(o->arg, "BASES_PER_SLICE") == 0)
-        o->opt = CRAM_OPT_BASES_PER_SLICE, o->val.i = atoi(val);
-
-    else if (strcmp(o->arg, "slices_per_container") == 0 ||
-             strcmp(o->arg, "SLICES_PER_CONTAINER") == 0)
-        o->opt = CRAM_OPT_SLICES_PER_CONTAINER, o->val.i = atoi(val);
-
-    else if (strcmp(o->arg, "embed_ref") == 0 ||
-             strcmp(o->arg, "EMBED_REF") == 0)
-        o->opt = CRAM_OPT_EMBED_REF, o->val.i = atoi(val);
-
-    else if (strcmp(o->arg, "no_ref") == 0 ||
-             strcmp(o->arg, "NO_REF") == 0)
-        o->opt = CRAM_OPT_NO_REF, o->val.i = atoi(val);
-
-    else if (strcmp(o->arg, "pos_delta") == 0 ||
-             strcmp(o->arg, "POS_DELTA") == 0)
-        o->opt = CRAM_OPT_POS_DELTA, o->val.i = atoi(val);
-
-    else if (strcmp(o->arg, "ignore_md5") == 0 ||
-             strcmp(o->arg, "IGNORE_MD5") == 0)
-        o->opt = CRAM_OPT_IGNORE_MD5, o->val.i = atoi(val);
-
-    else if (strcmp(o->arg, "use_bzip2") == 0 ||
-             strcmp(o->arg, "USE_BZIP2") == 0)
-        o->opt = CRAM_OPT_USE_BZIP2, o->val.i = atoi(val);
-
-    else if (strcmp(o->arg, "use_rans") == 0 ||
-             strcmp(o->arg, "USE_RANS") == 0)
-        o->opt = CRAM_OPT_USE_RANS, o->val.i = atoi(val);
-
-    else if (strcmp(o->arg, "use_lzma") == 0 ||
-             strcmp(o->arg, "USE_LZMA") == 0)
-        o->opt = CRAM_OPT_USE_LZMA, o->val.i = atoi(val);
-
-    else if (strcmp(o->arg, "use_tok") == 0 ||
-             strcmp(o->arg, "USE_TOK") == 0)
-        o->opt = CRAM_OPT_USE_TOK, o->val.i = atoi(val);
-
-    else if (strcmp(o->arg, "use_fqz") == 0 ||
-             strcmp(o->arg, "USE_FQZ") == 0)
-        o->opt = CRAM_OPT_USE_FQZ, o->val.i = atoi(val);
-
-    else if (strcmp(o->arg, "use_arith") == 0 ||
-             strcmp(o->arg, "USE_ARITH") == 0)
-        o->opt = CRAM_OPT_USE_ARITH, o->val.i = atoi(val);
-
-    else if (strcmp(o->arg, "fast") == 0 ||
-             strcmp(o->arg, "FAST") == 0)
-        o->opt = HTS_OPT_PROFILE, o->val.i = HTS_PROFILE_FAST;
-
-    else if (strcmp(o->arg, "normal") == 0 ||
-             strcmp(o->arg, "NORMAL") == 0)
-        o->opt = HTS_OPT_PROFILE, o->val.i = HTS_PROFILE_NORMAL;
-
-    else if (strcmp(o->arg, "small") == 0 ||
-             strcmp(o->arg, "SMALL") == 0)
-        o->opt = HTS_OPT_PROFILE, o->val.i = HTS_PROFILE_SMALL;
-
-    else if (strcmp(o->arg, "archive") == 0 ||
-             strcmp(o->arg, "ARCHIVE") == 0)
-        o->opt = HTS_OPT_PROFILE, o->val.i = HTS_PROFILE_ARCHIVE;
-
-    else if (strcmp(o->arg, "reference") == 0 ||
-             strcmp(o->arg, "REFERENCE") == 0)
-        o->opt = CRAM_OPT_REFERENCE, o->val.s = val;
-
-    else if (strcmp(o->arg, "version") == 0 ||
-             strcmp(o->arg, "VERSION") == 0)
-        o->opt = CRAM_OPT_VERSION, o->val.s =val;
-
-    else if (strcmp(o->arg, "multi_seq_per_slice") == 0 ||
-             strcmp(o->arg, "MULTI_SEQ_PER_SLICE") == 0)
-        o->opt = CRAM_OPT_MULTI_SEQ_PER_SLICE, o->val.i = atoi(val);
-
-    else if (strcmp(o->arg, "nthreads") == 0 ||
-             strcmp(o->arg, "NTHREADS") == 0)
-        o->opt = HTS_OPT_NTHREADS, o->val.i = atoi(val);
-
-    else if (strcmp(o->arg, "cache_size") == 0 ||
-             strcmp(o->arg, "CACHE_SIZE") == 0) {
-        char *endp;
-        o->opt = HTS_OPT_CACHE_SIZE;
-        o->val.i = strtol(val, &endp, 0);
-        // NB: Doesn't support floats, eg 1.5g
-        // TODO: extend hts_parse_decimal? See also samtools sort.
-        switch (*endp) {
-        case 'g': case 'G': o->val.i *= 1024; // fall through
-        case 'm': case 'M': o->val.i *= 1024; // fall through
-        case 'k': case 'K': o->val.i *= 1024; break;
-        case '\0': break;
-        default:
-            hts_log_error("Unrecognised cache size suffix '%c'", *endp);
-            free(o->arg);
-            free(o);
-            return -1;
-        }
-    }
-
-    else if (strcmp(o->arg, "required_fields") == 0 ||
-             strcmp(o->arg, "REQUIRED_FIELDS") == 0)
-        o->opt = CRAM_OPT_REQUIRED_FIELDS, o->val.i = strtol(val, NULL, 0);
-
-    else if (strcmp(o->arg, "lossy_names") == 0 ||
-             strcmp(o->arg, "LOSSY_NAMES") == 0)
-        o->opt = CRAM_OPT_LOSSY_NAMES, o->val.i = strtol(val, NULL, 0);
-
-    else if (strcmp(o->arg, "name_prefix") == 0 ||
-             strcmp(o->arg, "NAME_PREFIX") == 0)
-        o->opt = CRAM_OPT_PREFIX, o->val.s = val;
-
-    else if (strcmp(o->arg, "store_md") == 0 ||
-             strcmp(o->arg, "store_md") == 0)
-        o->opt = CRAM_OPT_STORE_MD, o->val.i = atoi(val);
-
-    else if (strcmp(o->arg, "store_nm") == 0 ||
-             strcmp(o->arg, "store_nm") == 0)
-        o->opt = CRAM_OPT_STORE_NM, o->val.i = atoi(val);
-
-    else if (strcmp(o->arg, "block_size") == 0 ||
-             strcmp(o->arg, "BLOCK_SIZE") == 0)
-        o->opt = HTS_OPT_BLOCK_SIZE, o->val.i = strtol(val, NULL, 0);
-
-    else if (strcmp(o->arg, "level") == 0 ||
-             strcmp(o->arg, "LEVEL") == 0)
-        o->opt = HTS_OPT_COMPRESSION_LEVEL, o->val.i = strtol(val, NULL, 0);
-
-    else if (strcmp(o->arg, "filter") == 0 ||
-             strcmp(o->arg, "FILTER") == 0)
-        o->opt = HTS_OPT_FILTER, o->val.s = val;
-
-    else {
-        hts_log_error("Unknown option '%s'", o->arg);
-        free(o->arg);
-        free(o);
-        return -1;
-    }
-
-    o->next = NULL;
-
-    // Append; assumes small list.
-    if (*opts) {
-        t = *opts;
-        while (t->next)
-            t = t->next;
-        t->next = o;
-    } else {
-        *opts = o;
-    }
-
-    return 0;
-}
-
-/*
- * Applies an hts_opt option list to a given htsFile.
- *
- * Returns 0 on success
- *        -1 on failure
- */
-int hts_opt_apply(htsFile *fp, hts_opt *opts) {
-    hts_opt *last = NULL;
-
-    for (; opts;  opts = (last=opts)->next) {
-        switch (opts->opt) {
-            case CRAM_OPT_REFERENCE:
-                if (!(fp->fn_aux = strdup(opts->val.s)))
-                    return -1;
-                // fall through
-            case CRAM_OPT_VERSION:
-            case CRAM_OPT_PREFIX:
-            case HTS_OPT_FILTER:
-                if (hts_set_opt(fp,  opts->opt,  opts->val.s) != 0)
-                    return -1;
-                break;
-            default:
-                if (hts_set_opt(fp,  opts->opt,  opts->val.i) != 0)
-                    return -1;
-                break;
-        }
-    }
-
-    return 0;
-}
-
-/*
- * Frees an hts_opt list.
- */
-void hts_opt_free(hts_opt *opts) {
-    hts_opt *last = NULL;
-    while (opts) {
-        opts = (last=opts)->next;
-        free(last->arg);
-        free(last);
-    }
-}
-
-
-/*
- * Tokenise options as (key(=value)?,)*(key(=value)?)?
- * NB: No provision for ',' appearing in the value!
- * Add backslashing rules?
- *
- * This could be used as part of a general command line option parser or
- * as a string concatenated onto the file open mode.
- *
- * Returns 0 on success
- *        -1 on failure.
- */
-int hts_parse_opt_list(htsFormat *fmt, const char *str) {
-    while (str && *str) {
-        const char *str_start;
-        int len;
-        char arg[8001];
-
-        while (*str && *str == ',')
-            str++;
-
-        for (str_start = str; *str && *str != ','; str++);
-        len = str - str_start;
-
-        // Produce a nul terminated copy of the option
-        strncpy(arg, str_start, len < 8000 ? len : 8000);
-        arg[len < 8000 ? len : 8000] = '\0';
-
-        if (hts_opt_add((hts_opt **)&fmt->specific, arg) != 0)
-            return -1;
-
-        if (*str)
-            str++;
-    }
-
-    return 0;
-}
-
-/*
- * Accepts a string file format (sam, bam, cram, vcf, bam) optionally
- * followed by a comma separated list of key=value options and splits
- * these up into the fields of htsFormat struct.
- *
- * format is assumed to be already initialised, either to blank
- * "unknown" values or via previous hts_opt_add calls.
- *
- * Returns 0 on success
- *        -1 on failure.
- */
-int hts_parse_format(htsFormat *format, const char *str) {
-    char fmt[8];
-    const char *cp = scan_keyword(str, ',', fmt, sizeof fmt);
-
-    format->version.minor = 0; // unknown
-    format->version.major = 0; // unknown
-
-    if (strcmp(fmt, "sam") == 0) {
-        format->category          = sequence_data;
-        format->format            = sam;
-        format->compression       = no_compression;;
-        format->compression_level = 0;
-    } else if (strcmp(fmt, "sam.gz") == 0) {
-        format->category          = sequence_data;
-        format->format            = sam;
-        format->compression       = bgzf;
-        format->compression_level = -1;
-    } else if (strcmp(fmt, "bam") == 0) {
-        format->category          = sequence_data;
-        format->format            = bam;
-        format->compression       = bgzf;
-        format->compression_level = -1;
-    } else if (strcmp(fmt, "cram") == 0) {
-        format->category          = sequence_data;
-        format->format            = cram;
-        format->compression       = custom;
-        format->compression_level = -1;
-    } else if (strcmp(fmt, "vcf") == 0) {
-        format->category          = variant_data;
-        format->format            = vcf;
-        format->compression       = no_compression;;
-        format->compression_level = 0;
-    } else if (strcmp(fmt, "bcf") == 0) {
-        format->category          = variant_data;
-        format->format            = bcf;
-        format->compression       = bgzf;
-        format->compression_level = -1;
-    } else {
-        return -1;
-    }
-
-    return hts_parse_opt_list(format, cp);
-}
-
-
-/*
- * Tokenise options as (key(=value)?,)*(key(=value)?)?
- * NB: No provision for ',' appearing in the value!
- * Add backslashing rules?
- *
- * This could be used as part of a general command line option parser or
- * as a string concatenated onto the file open mode.
- *
- * Returns 0 on success
- *        -1 on failure.
- */
-static int hts_process_opts(htsFile *fp, const char *opts) {
-    htsFormat fmt;
-
-    fmt.specific = NULL;
-    if (hts_parse_opt_list(&fmt, opts) != 0)
-        return -1;
-
-    if (hts_opt_apply(fp, fmt.specific) != 0) {
-        hts_opt_free(fmt.specific);
-        return -1;
-    }
-
-    hts_opt_free(fmt.specific);
-
-    return 0;
-}
-
-static int hts_crypt4gh_redirect(const char *fn, const char *mode,
-                                 hFILE **hfile_ptr, htsFile *fp) {
-    hFILE *hfile1 = *hfile_ptr;
-    hFILE *hfile2 = NULL;
-    char fn_buf[512], *fn2 = fn_buf;
-    const char *prefix = "crypt4gh:";
-    size_t fn2_len = strlen(prefix) + strlen(fn) + 1;
-    int ret = -1;
-
-    if (fn2_len > sizeof(fn_buf)) {
-        fn2 = malloc(fn2_len);
-        if (!fn2) return -1;
-    }
-
-    // Reopen fn using the crypt4gh plug-in (if available)
-    snprintf(fn2, fn2_len, "%s%s", prefix, fn);
-    hfile2 = hopen(fn2, mode, "parent", hfile1, NULL);
-    if (hfile2) {
-        // Replace original hfile with the new one.  The original is now
-        // enclosed within hfile2
-        *hfile_ptr = hfile2;
-        ret = 0;
-    }
-
-    if (fn2 != fn_buf)
-        free(fn2);
-    return ret;
-}
-
-htsFile *hts_hopen(hFILE *hfile, const char *fn, const char *mode)
-{
-    hFILE *hfile_orig = hfile;
-    htsFile *fp = (htsFile*)calloc(1, sizeof(htsFile));
-    char simple_mode[101], *cp, *opts;
-    simple_mode[100] = '\0';
-
-    if (fp == NULL) goto error;
-
-    fp->fn = strdup(fn);
-    fp->is_be = ed_is_big();
-
-    // Split mode into simple_mode,opts strings
-    if ((cp = strchr(mode, ','))) {
-        strncpy(simple_mode, mode, cp-mode <= 100 ? cp-mode : 100);
-        simple_mode[cp-mode] = '\0';
-        opts = cp+1;
-    } else {
-        strncpy(simple_mode, mode, 100);
-        opts = NULL;
-    }
-
-    if (strchr(simple_mode, 'r')) {
-        const int max_loops = 5; // Should be plenty
-        int loops = 0;
-        if (hts_detect_format(hfile, &fp->format) < 0) goto error;
-
-        // Deal with formats that re-direct an underlying file via a plug-in.
-        // Loops as we may have crypt4gh served via htsget, or
-        // crypt4gh-in-crypt4gh.
-        while (fp->format.format == htsget ||
-               fp->format.format == hts_crypt4gh_format) {
-            // Ensure we don't get stuck in an endless redirect loop
-            if (++loops > max_loops) {
-                errno = ELOOP;
-                goto error;
-            }
-
-            if (fp->format.format == htsget) {
-                hFILE *hfile2 = hopen_htsget_redirect(hfile, simple_mode);
-                if (hfile2 == NULL) goto error;
-
-                hfile = hfile2;
-            }
-            else if (fp->format.format == hts_crypt4gh_format) {
-                if (hts_crypt4gh_redirect(fn, simple_mode, &hfile, fp) < 0)
-                    goto error;
-            }
-
-            // Re-detect format against the result of the redirection
-            if (hts_detect_format(hfile, &fp->format) < 0) goto error;
-        }
-    }
-    else if (strchr(simple_mode, 'w') || strchr(simple_mode, 'a')) {
-        htsFormat *fmt = &fp->format;
-        fp->is_write = 1;
-
-        if (strchr(simple_mode, 'b')) fmt->format = binary_format;
-        else if (strchr(simple_mode, 'c')) fmt->format = cram;
-        else fmt->format = text_format;
-
-        if (strchr(simple_mode, 'z')) fmt->compression = bgzf;
-        else if (strchr(simple_mode, 'g')) fmt->compression = gzip;
-        else if (strchr(simple_mode, 'u')) fmt->compression = no_compression;
-        else {
-            // No compression mode specified, set to the default for the format
-            switch (fmt->format) {
-            case binary_format: fmt->compression = bgzf; break;
-            case cram: fmt->compression = custom; break;
-            case text_format: fmt->compression = no_compression; break;
-            default: abort();
-            }
-        }
-
-        // Fill in category (if determinable; e.g. 'b' could be BAM or BCF)
-        fmt->category = format_category(fmt->format);
-
-        fmt->version.major = fmt->version.minor = -1;
-        fmt->compression_level = -1;
-        fmt->specific = NULL;
-    }
-    else { errno = EINVAL; goto error; }
-
-    switch (fp->format.format) {
-    case binary_format:
-    case bam:
-    case bcf:
-        fp->fp.bgzf = bgzf_hopen(hfile, simple_mode);
-        if (fp->fp.bgzf == NULL) goto error;
-        fp->is_bin = fp->is_bgzf = 1;
-        break;
-
-    case cram:
-        fp->fp.cram = cram_dopen(hfile, fn, simple_mode);
-        if (fp->fp.cram == NULL) goto error;
-        if (!fp->is_write)
-            cram_set_option(fp->fp.cram, CRAM_OPT_DECODE_MD, -1); // auto
-        fp->is_cram = 1;
-        break;
-
-    case empty_format:
-    case text_format:
-    case bed:
-    case fasta_format:
-    case fastq_format:
-    case sam:
-    case vcf:
-        if (fp->format.compression != no_compression) {
-            fp->fp.bgzf = bgzf_hopen(hfile, simple_mode);
-            if (fp->fp.bgzf == NULL) goto error;
-            fp->is_bgzf = 1;
-        }
-        else
-            fp->fp.hfile = hfile;
-        break;
-
-    default:
-        errno = EFTYPE;
-        goto error;
-    }
-
-    if (opts)
-        hts_process_opts(fp, opts);
-
-    // If redirecting, close the original hFILE now (pedantically we would
-    // instead close it in hts_close(), but this a simplifying optimisation)
-    if (hfile != hfile_orig) hclose_abruptly(hfile_orig);
-
-    return fp;
-
-error:
-    hts_log_error("Failed to open file %s", fn);
-
-    // If redirecting, close the failed redirection hFILE that we have opened
-    if (hfile != hfile_orig) hclose_abruptly(hfile);
-
-    if (fp) {
-        free(fp->fn);
-        free(fp->fn_aux);
-        free(fp);
-    }
-    return NULL;
-}
-
-int hts_close(htsFile *fp)
-{
-    int ret, save;
-
-    switch (fp->format.format) {
-    case binary_format:
-    case bam:
-    case bcf:
-        ret = bgzf_close(fp->fp.bgzf);
-        break;
-
-    case cram:
-        if (!fp->is_write) {
-            switch (cram_eof(fp->fp.cram)) {
-            case 2:
-                hts_log_warning("EOF marker is absent. The input is probably truncated");
-                break;
-            case 0:  /* not at EOF, but may not have wanted all seqs */
-            default: /* case 1, expected EOF */
-                break;
-            }
-        }
-        ret = cram_close(fp->fp.cram);
-        break;
-
-    case empty_format:
-    case text_format:
-    case bed:
-    case fasta_format:
-    case fastq_format:
-    case sam:
-    case vcf:
-        ret = sam_state_destroy(fp);
-
-        if (fp->format.compression != no_compression)
-            ret |= bgzf_close(fp->fp.bgzf);
-        else
-            ret |= hclose(fp->fp.hfile);
-        break;
-
-    default:
-        ret = -1;
-        break;
-    }
-
-    save = errno;
-    sam_hdr_destroy(fp->bam_header);
-    hts_idx_destroy(fp->idx);
-    hts_filter_free(fp->filter);
-    free(fp->fn);
-    free(fp->fn_aux);
-    free(fp->line.s);
-    free(fp);
-    errno = save;
-    return ret;
-}
-
-const htsFormat *hts_get_format(htsFile *fp)
-{
-    return fp? &fp->format : NULL;
-}
-
-const char *hts_format_file_extension(const htsFormat *format) {
-    if (!format)
-        return "?";
-
-    switch (format->format) {
-    case sam:  return "sam";
-    case bam:  return "bam";
-    case bai:  return "bai";
-    case cram: return "cram";
-    case crai: return "crai";
-    case vcf:  return "vcf";
-    case bcf:  return "bcf";
-    case csi:  return "csi";
-    case fai_format:   return "fai";
-    case fqi_format:   return "fqi";
-    case gzi:  return "gzi";
-    case tbi:  return "tbi";
-    case bed:  return "bed";
-    case fasta_format: return "fa";
-    case fastq_format: return "fq";
-    default:   return "?";
-    }
-}
-
-static hFILE *hts_hfile(htsFile *fp) {
-    switch (fp->format.format) {
-    case binary_format:// fall through
-    case bcf:          // fall through
-    case bam:          return bgzf_hfile(fp->fp.bgzf);
-    case cram:         return cram_hfile(fp->fp.cram);
-    case text_format:  return fp->fp.hfile;
-    case vcf:          // fall through
-    case sam:          return fp->format.compression != no_compression
-                              ? bgzf_hfile(fp->fp.bgzf)
-                              : fp->fp.hfile;
-    default:           return NULL;
-    }
-}
-
-int hts_set_opt(htsFile *fp, enum hts_fmt_option opt, ...) {
-    int r;
-    va_list args;
-
-    switch (opt) {
-    case HTS_OPT_NTHREADS: {
-        va_start(args, opt);
-        int nthreads = va_arg(args, int);
-        va_end(args);
-        return hts_set_threads(fp, nthreads);
-    }
-
-    case HTS_OPT_BLOCK_SIZE: {
-        hFILE *hf = hts_hfile(fp);
-
-        if (hf) {
-            va_start(args, opt);
-            if (hfile_set_blksize(hf, va_arg(args, int)) != 0)
-                hts_log_warning("Failed to change block size");
-            va_end(args);
-        }
-        else {
-            // To do - implement for vcf/bcf.
-            hts_log_warning("Cannot change block size for this format");
-        }
-
-        return 0;
-    }
-
-    case HTS_OPT_THREAD_POOL: {
-        va_start(args, opt);
-        htsThreadPool *p = va_arg(args, htsThreadPool *);
-        va_end(args);
-        return hts_set_thread_pool(fp, p);
-    }
-
-    case HTS_OPT_CACHE_SIZE: {
-        va_start(args, opt);
-        int cache_size = va_arg(args, int);
-        va_end(args);
-        hts_set_cache_size(fp, cache_size);
-        return 0;
-    }
-
-    case HTS_OPT_COMPRESSION_LEVEL: {
-        va_start(args, opt);
-        int level = va_arg(args, int);
-        va_end(args);
-        if (fp->is_bgzf)
-            fp->fp.bgzf->compress_level = level;
-        else if (fp->format.format == cram)
-            return cram_set_option(fp->fp.cram, opt, level);
-        return 0;
-    }
-
-    case HTS_OPT_FILTER: {
-        va_start(args, opt);
-        char *expr = va_arg(args, char *);
-        va_end(args);
-        return hts_set_filter_expression(fp, expr);
-    }
-
-    case HTS_OPT_PROFILE: {
-        va_start(args, opt);
-        enum hts_profile_option prof = va_arg(args, int);
-        va_end(args);
-        if (fp->is_bgzf) {
-            switch (prof) {
-#ifdef HAVE_LIBDEFLATE
-            case HTS_PROFILE_FAST:    fp->fp.bgzf->compress_level =  2; break;
-            case HTS_PROFILE_NORMAL:  fp->fp.bgzf->compress_level = -1; break;
-            case HTS_PROFILE_SMALL:   fp->fp.bgzf->compress_level = 10; break;
-            case HTS_PROFILE_ARCHIVE: fp->fp.bgzf->compress_level = 12; break;
-#else
-            case HTS_PROFILE_FAST:    fp->fp.bgzf->compress_level =  1; break;
-            case HTS_PROFILE_NORMAL:  fp->fp.bgzf->compress_level = -1; break;
-            case HTS_PROFILE_SMALL:   fp->fp.bgzf->compress_level =  8; break;
-            case HTS_PROFILE_ARCHIVE: fp->fp.bgzf->compress_level =  9; break;
-#endif
-            }
-        } // else CRAM manages this in its own way
-        break;
-    }
-
-    default:
-        break;
-    }
-
-    if (fp->format.format != cram)
-        return 0;
-
-    va_start(args, opt);
-    r = cram_set_voption(fp->fp.cram, opt, args);
-    va_end(args);
-
-    return r;
-}
-
-BGZF *hts_get_bgzfp(htsFile *fp);
-
-int hts_set_threads(htsFile *fp, int n)
-{
-    if (fp->format.format == sam) {
-        return sam_set_threads(fp, n);
-    } else if (fp->format.compression == bgzf) {
-        return bgzf_mt(hts_get_bgzfp(fp), n, 256/*unused*/);
-    } else if (fp->format.format == cram) {
-        return hts_set_opt(fp, CRAM_OPT_NTHREADS, n);
-    }
-    else return 0;
-}
-
-int hts_set_thread_pool(htsFile *fp, htsThreadPool *p) {
-    if (fp->format.format == sam || fp->format.format == text_format) {
-        return sam_set_thread_pool(fp, p);
-    } else if (fp->format.compression == bgzf) {
-        return bgzf_thread_pool(hts_get_bgzfp(fp), p->pool, p->qsize);
-    } else if (fp->format.format == cram) {
-        return hts_set_opt(fp, CRAM_OPT_THREAD_POOL, p);
-    }
-    else return 0;
-}
-
-void hts_set_cache_size(htsFile *fp, int n)
-{
-    if (fp->format.compression == bgzf)
-        bgzf_set_cache_size(hts_get_bgzfp(fp), n);
-}
-
-int hts_set_fai_filename(htsFile *fp, const char *fn_aux)
-{
-    free(fp->fn_aux);
-    if (fn_aux) {
-        fp->fn_aux = strdup(fn_aux);
-        if (fp->fn_aux == NULL) return -1;
-    }
-    else fp->fn_aux = NULL;
-
-    if (fp->format.format == cram)
-        if (cram_set_option(fp->fp.cram, CRAM_OPT_REFERENCE, fp->fn_aux))
-            return -1;
-
-    return 0;
-}
-
-int hts_set_filter_expression(htsFile *fp, const char *expr)
-{
-    if (fp->filter)
-        hts_filter_free(fp->filter);
-
-    if (!expr)
-        return 0;
-
-    return (fp->filter = hts_filter_init(expr))
-        ? 0 : -1;
-}
-
-hFILE *hts_open_tmpfile(const char *fname, const char *mode, kstring_t *tmpname)
-{
-    int pid = (int) getpid();
-    unsigned ptr = (uintptr_t) tmpname;
-    int n = 0;
-    hFILE *fp = NULL;
-
-    do {
-        // Attempt to further uniquify the temporary filename
-        unsigned t = ((unsigned) time(NULL)) ^ ((unsigned) clock()) ^ ptr;
-        n++;
-
-        ks_clear(tmpname);
-        if (ksprintf(tmpname, "%s.tmp_%d_%d_%u", fname, pid, n, t) < 0) break;
-
-        fp = hopen(tmpname->s, mode);
-    } while (fp == NULL && errno == EEXIST && n < 100);
-
-    return fp;
-}
-
-// For VCF/BCF backward sweeper. Not exposing these functions because their
-// future is uncertain. Things will probably have to change with hFILE...
-BGZF *hts_get_bgzfp(htsFile *fp)
-{
-    if (fp->is_bgzf)
-        return fp->fp.bgzf;
-    else
-        return NULL;
-}
-int hts_useek(htsFile *fp, off_t uoffset, int where)
-{
-    if (fp->is_bgzf)
-        return bgzf_useek(fp->fp.bgzf, uoffset, where);
-    else
-        return (hseek(fp->fp.hfile, uoffset, SEEK_SET) >= 0)? 0 : -1;
-}
-off_t hts_utell(htsFile *fp)
-{
-    if (fp->is_bgzf)
-        return bgzf_utell(fp->fp.bgzf);
-    else
-        return htell(fp->fp.hfile);
-}
-
-int hts_getline(htsFile *fp, int delimiter, kstring_t *str)
-{
-    int ret;
-    if (! (delimiter == KS_SEP_LINE || delimiter == '\n')) {
-        hts_log_error("Unexpected delimiter %d", delimiter);
-        abort();
-    }
-
-    switch (fp->format.compression) {
-    case no_compression:
-        str->l = 0;
-        ret = kgetline2(str, (kgets_func2 *) hgetln, fp->fp.hfile);
-        if (ret >= 0) ret = str->l;
-        else if (herrno(fp->fp.hfile)) ret = -2, errno = herrno(fp->fp.hfile);
-        else ret = -1;
-        break;
-
-    case gzip:
-    case bgzf:
-        ret = bgzf_getline(fp->fp.bgzf, '\n', str);
-        break;
-
-    default:
-        abort();
-    }
-
-    ++fp->lineno;
-    return ret;
-}
-
-char **hts_readlist(const char *string, int is_file, int *_n)
-{
-    unsigned int m = 0, n = 0;
-    char **s = 0, **s_new;
-    if ( is_file )
-    {
-        BGZF *fp = bgzf_open(string, "r");
-        if ( !fp ) return NULL;
-
-        kstring_t str;
-        str.s = 0; str.l = str.m = 0;
-        while (bgzf_getline(fp, '\n', &str) >= 0)
-        {
-            if (str.l == 0) continue;
-            if (hts_resize(char*, n + 1, &m, &s, 0) < 0)
-                goto err;
-            s[n] = strdup(str.s);
-            if (!s[n])
-                goto err;
-            n++;
-        }
-        bgzf_close(fp);
-        free(str.s);
-    }
-    else
-    {
-        const char *q = string, *p = string;
-        while ( 1 )
-        {
-            if (*p == ',' || *p == 0)
-            {
-                if (hts_resize(char*, n + 1, &m, &s, 0) < 0)
-                    goto err;
-                s[n] = (char*)calloc(p - q + 1, 1);
-                if (!s[n])
-                    goto err;
-                strncpy(s[n++], q, p - q);
-                q = p + 1;
-            }
-            if ( !*p ) break;
-            p++;
-        }
-    }
-    // Try to shrink s to the minimum size needed
-    s_new = (char**)realloc(s, n * sizeof(char*));
-    if (!s_new)
-        goto err;
-
-    s = s_new;
-    assert(n < INT_MAX); // hts_resize() should ensure this
-    *_n = n;
-    return s;
-
- err:
-    for (m = 0; m < n; m++)
-        free(s[m]);
-    free(s);
-    return NULL;
-}
-
-char **hts_readlines(const char *fn, int *_n)
-{
-    unsigned int m = 0, n = 0;
-    char **s = 0, **s_new;
-    BGZF *fp = bgzf_open(fn, "r");
-    if ( fp ) { // read from file
-        kstring_t str;
-        str.s = 0; str.l = str.m = 0;
-        while (bgzf_getline(fp, '\n', &str) >= 0) {
-            if (str.l == 0) continue;
-            if (hts_resize(char *, n + 1, &m, &s, 0) < 0)
-                goto err;
-            s[n] = strdup(str.s);
-            if (!s[n])
-                goto err;
-            n++;
-        }
-        bgzf_close(fp);
-        free(str.s);
-    } else if (*fn == ':') { // read from string
-        const char *q, *p;
-        for (q = p = fn + 1;; ++p)
-            if (*p == ',' || *p == 0) {
-                if (hts_resize(char *, n + 1, &m, &s, 0) < 0)
-                    goto err;
-                s[n] = (char*)calloc(p - q + 1, 1);
-                if (!s[n])
-                    goto err;
-                strncpy(s[n++], q, p - q);
-                q = p + 1;
-                if (*p == 0) break;
-            }
-    } else return 0;
-    // Try to shrink s to the minimum size needed
-    s_new = (char**)realloc(s, n * sizeof(char*));
-    if (!s_new)
-        goto err;
-
-    s = s_new;
-    assert(n < INT_MAX); // hts_resize() should ensure this
-    *_n = n;
-    return s;
-
- err:
-    for (m = 0; m < n; m++)
-        free(s[m]);
-    free(s);
-    return NULL;
-}
-
-// DEPRECATED: To be removed in a future HTSlib release
-int hts_file_type(const char *fname)
-{
-    int len = strlen(fname);
-    if ( !strcasecmp(".vcf.gz",fname+len-7) ) return FT_VCF_GZ;
-    if ( !strcasecmp(".vcf",fname+len-4) ) return FT_VCF;
-    if ( !strcasecmp(".bcf",fname+len-4) ) return FT_BCF_GZ;
-    if ( !strcmp("-",fname) ) return FT_STDIN;
-
-    hFILE *f = hopen(fname, "r");
-    if (f == NULL) return 0;
-
-    htsFormat fmt;
-    if (hts_detect_format(f, &fmt) < 0) { hclose_abruptly(f); return 0; }
-    if (hclose(f) < 0) return 0;
-
-    switch (fmt.format) {
-    case vcf: return (fmt.compression == no_compression)? FT_VCF : FT_VCF_GZ;
-    case bcf: return (fmt.compression == no_compression)? FT_BCF : FT_BCF_GZ;
-    default:  return 0;
-    }
-}
-
-int hts_check_EOF(htsFile *fp)
-{
-    if (fp->format.compression == bgzf)
-        return bgzf_check_EOF(hts_get_bgzfp(fp));
-    else if (fp->format.format == cram)
-        return cram_check_EOF(fp->fp.cram);
-    else
-        return 3;
-}
-
-
-/****************
- *** Indexing ***
- ****************/
-
-#define HTS_MIN_MARKER_DIST 0x10000
-
-// Finds the special meta bin
-//  ((1<<(3 * n_lvls + 3)) - 1) / 7 + 1
-#define META_BIN(idx) ((idx)->n_bins + 1)
-
-#define pair64_lt(a,b) ((a).u < (b).u)
-#define pair64max_lt(a,b) ((a).u < (b).u || \
-                           ((a).u == (b).u && (a).max < (b).max))
-
-KSORT_INIT_STATIC(_off, hts_pair64_t, pair64_lt)
-KSORT_INIT_STATIC(_off_max, hts_pair64_max_t, pair64max_lt)
-
-typedef struct {
-    int32_t m, n;
-    uint64_t loff;
-    hts_pair64_t *list;
-} bins_t;
-
-KHASH_MAP_INIT_INT(bin, bins_t)
-typedef khash_t(bin) bidx_t;
-
-typedef struct {
-    hts_pos_t n, m;
-    uint64_t *offset;
-} lidx_t;
-
-struct hts_idx_t {
-    int fmt, min_shift, n_lvls, n_bins;
-    uint32_t l_meta;
-    int32_t n, m;
-    uint64_t n_no_coor;
-    bidx_t **bidx;
-    lidx_t *lidx;
-    uint8_t *meta; // MUST have a terminating NUL on the end
-    int tbi_n, last_tbi_tid;
-    struct {
-        uint32_t last_bin, save_bin;
-        hts_pos_t last_coor;
-        int last_tid, save_tid, finished;
-        uint64_t last_off, save_off;
-        uint64_t off_beg, off_end;
-        uint64_t n_mapped, n_unmapped;
-    } z; // keep internal states
-};
-
-static char * idx_format_name(int fmt) {
-    switch (fmt) {
-        case HTS_FMT_CSI: return "csi";
-        case HTS_FMT_BAI: return "bai";
-        case HTS_FMT_TBI: return "tbi";
-        case HTS_FMT_CRAI: return "crai";
-        default: return "unknown";
-    }
-}
-
-static inline int insert_to_b(bidx_t *b, int bin, uint64_t beg, uint64_t end)
-{
-    khint_t k;
-    bins_t *l;
-    int absent;
-    k = kh_put(bin, b, bin, &absent);
-    if (absent < 0) return -1; // Out of memory
-    l = &kh_value(b, k);
-    if (absent) {
-        l->m = 1; l->n = 0;
-        l->list = (hts_pair64_t*)calloc(l->m, sizeof(hts_pair64_t));
-        if (!l->list) {
-            kh_del(bin, b, k);
-            return -1;
-        }
-    } else if (l->n == l->m) {
-        uint32_t new_m = l->m ? l->m << 1 : 1;
-        hts_pair64_t *new_list = realloc(l->list, new_m * sizeof(hts_pair64_t));
-        if (!new_list) return -1;
-        l->list = new_list;
-        l->m = new_m;
-    }
-    l->list[l->n].u = beg;
-    l->list[l->n++].v = end;
-    return 0;
-}
-
-static inline int insert_to_l(lidx_t *l, int64_t _beg, int64_t _end, uint64_t offset, int min_shift)
-{
-    int i;
-    hts_pos_t beg, end;
-    beg = _beg >> min_shift;
-    end = (_end - 1) >> min_shift;
-    if (l->m < end + 1) {
-        size_t new_m = l->m * 2 > end + 1 ? l->m * 2 : end + 1;
-        uint64_t *new_offset;
-
-        new_offset = (uint64_t*)realloc(l->offset, new_m * sizeof(uint64_t));
-        if (!new_offset) return -1;
-
-        // fill unused memory with (uint64_t)-1
-        memset(new_offset + l->m, 0xff, sizeof(uint64_t) * (new_m - l->m));
-        l->m = new_m;
-        l->offset = new_offset;
-    }
-    for (i = beg; i <= end; ++i) {
-        if (l->offset[i] == (uint64_t)-1) l->offset[i] = offset;
-    }
-    if (l->n < end + 1) l->n = end + 1;
-    return 0;
-}
-
-hts_idx_t *hts_idx_init(int n, int fmt, uint64_t offset0, int min_shift, int n_lvls)
-{
-    hts_idx_t *idx;
-    idx = (hts_idx_t*)calloc(1, sizeof(hts_idx_t));
-    if (idx == NULL) return NULL;
-    idx->fmt = fmt;
-    idx->min_shift = min_shift;
-    idx->n_lvls = n_lvls;
-    idx->n_bins = ((1<<(3 * n_lvls + 3)) - 1) / 7;
-    idx->z.save_tid = idx->z.last_tid = -1;
-    idx->z.save_bin = idx->z.last_bin = 0xffffffffu;
-    idx->z.save_off = idx->z.last_off = idx->z.off_beg = idx->z.off_end = offset0;
-    idx->z.last_coor = 0xffffffffu;
-    if (n) {
-        idx->n = idx->m = n;
-        idx->bidx = (bidx_t**)calloc(n, sizeof(bidx_t*));
-        if (idx->bidx == NULL) { free(idx); return NULL; }
-        idx->lidx = (lidx_t*) calloc(n, sizeof(lidx_t));
-        if (idx->lidx == NULL) { free(idx->bidx); free(idx); return NULL; }
-    }
-    idx->tbi_n = -1;
-    idx->last_tbi_tid = -1;
-    return idx;
-}
-
-static void update_loff(hts_idx_t *idx, int i, int free_lidx)
-{
-    bidx_t *bidx = idx->bidx[i];
-    lidx_t *lidx = &idx->lidx[i];
-    khint_t k;
-    int l;
-    uint64_t offset0 = 0;
-    if (bidx) {
-        k = kh_get(bin, bidx, META_BIN(idx));
-        if (k != kh_end(bidx))
-            offset0 = kh_val(bidx, k).list[0].u;
-        for (l = 0; l < lidx->n && lidx->offset[l] == (uint64_t)-1; ++l)
-            lidx->offset[l] = offset0;
-    } else l = 1;
-    for (; l < lidx->n; ++l) // fill missing values
-        if (lidx->offset[l] == (uint64_t)-1)
-            lidx->offset[l] = lidx->offset[l-1];
-    if (bidx == 0) return;
-    for (k = kh_begin(bidx); k != kh_end(bidx); ++k) // set loff
-        if (kh_exist(bidx, k))
-        {
-            if ( kh_key(bidx, k) < idx->n_bins )
-            {
-                int bot_bin = hts_bin_bot(kh_key(bidx, k), idx->n_lvls);
-                // disable linear index if bot_bin out of bounds
-                kh_val(bidx, k).loff = bot_bin < lidx->n ? lidx->offset[bot_bin] : 0;
-            }
-            else
-                kh_val(bidx, k).loff = 0;
-        }
-    if (free_lidx) {
-        free(lidx->offset);
-        lidx->m = lidx->n = 0;
-        lidx->offset = 0;
-    }
-}
-
-static int compress_binning(hts_idx_t *idx, int i)
-{
-    bidx_t *bidx = idx->bidx[i];
-    khint_t k;
-    int l, m;
-    if (bidx == 0) return 0;
-    // merge a bin to its parent if the bin is too small
-    for (l = idx->n_lvls; l > 0; --l) {
-        unsigned start = hts_bin_first(l);
-        for (k = kh_begin(bidx); k != kh_end(bidx); ++k) {
-            bins_t *p, *q;
-            if (!kh_exist(bidx, k) || kh_key(bidx, k) >= idx->n_bins || kh_key(bidx, k) < start) continue;
-            p = &kh_value(bidx, k);
-            if (l < idx->n_lvls && p->n > 1) ks_introsort(_off, p->n, p->list);
-            if ((p->list[p->n - 1].v>>16) - (p->list[0].u>>16) < HTS_MIN_MARKER_DIST) {
-                khint_t kp;
-                kp = kh_get(bin, bidx, hts_bin_parent(kh_key(bidx, k)));
-                if (kp == kh_end(bidx)) continue;
-                q = &kh_val(bidx, kp);
-                if (q->n + p->n > q->m) {
-                    uint32_t new_m = q->n + p->n;
-                    hts_pair64_t *new_list;
-                    kroundup32(new_m);
-                    if (new_m > INT32_MAX) return -1; // Limited by index format
-                    new_list = realloc(q->list, new_m * sizeof(*new_list));
-                    if (!new_list) return -1;
-                    q->m = new_m;
-                    q->list = new_list;
-                }
-                memcpy(q->list + q->n, p->list, p->n * sizeof(hts_pair64_t));
-                q->n += p->n;
-                free(p->list);
-                kh_del(bin, bidx, k);
-            }
-        }
-    }
-    k = kh_get(bin, bidx, 0);
-    if (k != kh_end(bidx)) ks_introsort(_off, kh_val(bidx, k).n, kh_val(bidx, k).list);
-    // merge adjacent chunks that start from the same BGZF block
-    for (k = kh_begin(bidx); k != kh_end(bidx); ++k) {
-        bins_t *p;
-        if (!kh_exist(bidx, k) || kh_key(bidx, k) >= idx->n_bins) continue;
-        p = &kh_value(bidx, k);
-        for (l = 1, m = 0; l < p->n; ++l) {
-            if (p->list[m].v>>16 >= p->list[l].u>>16) {
-                if (p->list[m].v < p->list[l].v) p->list[m].v = p->list[l].v;
-            } else p->list[++m] = p->list[l];
-        }
-        p->n = m + 1;
-    }
-    return 0;
-}
-
-int hts_idx_finish(hts_idx_t *idx, uint64_t final_offset)
-{
-    int i, ret = 0;
-    if (idx == NULL || idx->z.finished) return 0; // do not run this function on an empty index or multiple times
-    if (idx->z.save_tid >= 0) {
-        ret |= insert_to_b(idx->bidx[idx->z.save_tid], idx->z.save_bin, idx->z.save_off, final_offset);
-        ret |= insert_to_b(idx->bidx[idx->z.save_tid], META_BIN(idx), idx->z.off_beg, final_offset);
-        ret |= insert_to_b(idx->bidx[idx->z.save_tid], META_BIN(idx), idx->z.n_mapped, idx->z.n_unmapped);
-    }
-    for (i = 0; i < idx->n; ++i) {
-        update_loff(idx, i, (idx->fmt == HTS_FMT_CSI));
-        ret |= compress_binning(idx, i);
-    }
-    idx->z.finished = 1;
-
-    return ret;
-}
-
-int hts_idx_check_range(hts_idx_t *idx, int tid, hts_pos_t beg, hts_pos_t end)
-{
-    int64_t maxpos = (int64_t) 1 << (idx->min_shift + idx->n_lvls * 3);
-    if (tid < 0 || (beg <= maxpos && end <= maxpos))
-        return 0;
-
-    if (idx->fmt == HTS_FMT_CSI) {
-        hts_log_error("Region %"PRIhts_pos"..%"PRIhts_pos
-                      " cannot be stored in a csi index. "
-                      "Please check headers match the data",
-                      beg, end);
-    } else {
-        hts_log_error("Region %"PRIhts_pos"..%"PRIhts_pos
-                      " cannot be stored in a %s index. Try using a csi index",
-                      beg, end, idx_format_name(idx->fmt));
-    }
-    errno = ERANGE;
-    return -1;
-}
-
-int hts_idx_push(hts_idx_t *idx, int tid, hts_pos_t beg, hts_pos_t end, uint64_t offset, int is_mapped)
-{
-    int bin;
-    if (tid<0) beg = -1, end = 0;
-    if (hts_idx_check_range(idx, tid, beg, end) < 0)
-        return -1;
-    if (tid >= idx->m) { // enlarge the index
-        uint32_t new_m = idx->m * 2 > tid + 1 ? idx->m * 2 : tid + 1;
-        bidx_t **new_bidx;
-        lidx_t *new_lidx;
-
-        new_bidx = (bidx_t**)realloc(idx->bidx, new_m * sizeof(bidx_t*));
-        if (!new_bidx) return -1;
-        idx->bidx = new_bidx;
-
-        new_lidx = (lidx_t*) realloc(idx->lidx, new_m * sizeof(lidx_t));
-        if (!new_lidx) return -1;
-        idx->lidx = new_lidx;
-
-        memset(&idx->bidx[idx->m], 0, (new_m - idx->m) * sizeof(bidx_t*));
-        memset(&idx->lidx[idx->m], 0, (new_m - idx->m) * sizeof(lidx_t));
-        idx->m = new_m;
-    }
-    if (idx->n < tid + 1) idx->n = tid + 1;
-    if (idx->z.finished) return 0;
-    if (idx->z.last_tid != tid || (idx->z.last_tid >= 0 && tid < 0)) { // change of chromosome
-        if ( tid>=0 && idx->n_no_coor )
-        {
-            hts_log_error("NO_COOR reads not in a single block at the end %d %d", tid, idx->z.last_tid);
-            return -1;
-        }
-        if (tid>=0 && idx->bidx[tid] != 0)
-        {
-            hts_log_error("Chromosome blocks not continuous");
-            return -1;
-        }
-        idx->z.last_tid = tid;
-        idx->z.last_bin = 0xffffffffu;
-    } else if (tid >= 0 && idx->z.last_coor > beg) { // test if positions are out of order
-        hts_log_error("Unsorted positions on sequence #%d: %"PRIhts_pos" followed by %"PRIhts_pos, tid+1, idx->z.last_coor+1, beg+1);
-        return -1;
-    }
-    if (end < beg) {
-        // Malformed ranges are errors. (Empty ranges (beg==end) are unusual but acceptable.)
-        hts_log_error("Invalid record on sequence #%d: end %"PRId64" < begin %"PRId64, tid+1, end, beg+1);
-        return -1;
-    }
-    if ( tid>=0 )
-    {
-        if (idx->bidx[tid] == 0) idx->bidx[tid] = kh_init(bin);
-        if (is_mapped) {
-            // shoehorn [-1,0) (VCF POS=0) into the leftmost bottom-level bin
-            if (beg < 0)  beg = 0;
-            if (end <= 0) end = 1;
-            // idx->z.last_off points to the start of the current record
-            if (insert_to_l(&idx->lidx[tid], beg, end,
-                            idx->z.last_off, idx->min_shift) < 0) return -1;
-        }
-    }
-    else idx->n_no_coor++;
-    bin = hts_reg2bin(beg, end, idx->min_shift, idx->n_lvls);
-    if ((int)idx->z.last_bin != bin) { // then possibly write the binning index
-        if (idx->z.save_bin != 0xffffffffu) { // save_bin==0xffffffffu only happens to the first record
-            if (insert_to_b(idx->bidx[idx->z.save_tid], idx->z.save_bin,
-                            idx->z.save_off, idx->z.last_off) < 0) return -1;
-        }
-        if (idx->z.last_bin == 0xffffffffu && idx->z.save_bin != 0xffffffffu) { // change of chr; keep meta information
-            idx->z.off_end = idx->z.last_off;
-            if (insert_to_b(idx->bidx[idx->z.save_tid], META_BIN(idx),
-                            idx->z.off_beg, idx->z.off_end) < 0) return -1;
-            if (insert_to_b(idx->bidx[idx->z.save_tid], META_BIN(idx),
-                            idx->z.n_mapped, idx->z.n_unmapped) < 0) return -1;
-            idx->z.n_mapped = idx->z.n_unmapped = 0;
-            idx->z.off_beg = idx->z.off_end;
-        }
-        idx->z.save_off = idx->z.last_off;
-        idx->z.save_bin = idx->z.last_bin = bin;
-        idx->z.save_tid = tid;
-    }
-    if (is_mapped) ++idx->z.n_mapped;
-    else ++idx->z.n_unmapped;
-    idx->z.last_off = offset;
-    idx->z.last_coor = beg;
-    return 0;
-}
-
-// Needed for TBI only.  Ensure 'tid' with 'name' is in the index meta data.
-// idx->meta needs to have been initialised first with an appropriate Tabix
-// configuration via hts_idx_set_meta.
-//
-// NB number of references (first 4 bytes of tabix header) aren't in
-// idx->meta, but held in idx->n instead.
-int hts_idx_tbi_name(hts_idx_t *idx, int tid, const char *name) {
-    // Horrid - we have to map incoming tid to a tbi alternative tid.
-    // This is because TBI counts tids by "covered" refs while everything
-    // else counts by Nth SQ/contig record in header.
-    if (tid == idx->last_tbi_tid || tid < 0 || !name)
-        return idx->tbi_n;
-
-    uint32_t len = strlen(name)+1;
-    uint8_t *tmp = (uint8_t *)realloc(idx->meta, idx->l_meta + len);
-    if (!tmp)
-        return -1;
-
-    // Append name
-    idx->meta = tmp;
-    strcpy((char *)idx->meta + idx->l_meta, name);
-    idx->l_meta += len;
-
-    // Update seq length
-    u32_to_le(le_to_u32(idx->meta+24)+len, idx->meta+24);
-
-    idx->last_tbi_tid = tid;
-    return ++idx->tbi_n;
-}
-
-// When doing samtools index we have a read_bam / hts_idx_push(bgzf_tell())
-// loop.  idx->z.last_off is the previous bzgf_tell location, so we know
-// the location the current bam record started at as well as where it ends.
-//
-// When building an index on the fly via a write_bam / hts_idx_push loop,
-// this isn't quite identical as we may amend the virtual coord returned
-// by bgzf_tell to the start of a new block if the next bam struct doesn't
-// fit.  It's essentially the same thing, but for bit-identical indices
-// we need to amend the idx->z.last_off when we know we're starting a new
-// block.
-void hts_idx_amend_last(hts_idx_t *idx, uint64_t offset)
-{
-    idx->z.last_off = offset;
-}
-
-void hts_idx_destroy(hts_idx_t *idx)
-{
-    khint_t k;
-    int i;
-    if (idx == 0) return;
-
-    // For HTS_FMT_CRAI, idx actually points to a different type -- see sam.c
-    if (idx->fmt == HTS_FMT_CRAI) {
-        hts_cram_idx_t *cidx = (hts_cram_idx_t *) idx;
-        cram_index_free(cidx->cram);
-        free(cidx);
-        return;
-    }
-
-    for (i = 0; i < idx->m; ++i) {
-        bidx_t *bidx = idx->bidx[i];
-        free(idx->lidx[i].offset);
-        if (bidx == 0) continue;
-        for (k = kh_begin(bidx); k != kh_end(bidx); ++k)
-            if (kh_exist(bidx, k))
-                free(kh_value(bidx, k).list);
-        kh_destroy(bin, bidx);
-    }
-    free(idx->bidx); free(idx->lidx); free(idx->meta);
-    free(idx);
-}
-
-int hts_idx_fmt(hts_idx_t *idx) {
-    return idx->fmt;
-}
-
-// The optimizer eliminates these ed_is_big() calls; still it would be good to
-// TODO Determine endianness at configure- or compile-time
-
-static inline ssize_t HTS_RESULT_USED idx_write_int32(BGZF *fp, int32_t x)
-{
-    if (ed_is_big()) x = ed_swap_4(x);
-    return bgzf_write(fp, &x, sizeof x);
-}
-
-static inline ssize_t HTS_RESULT_USED idx_write_uint32(BGZF *fp, uint32_t x)
-{
-    if (ed_is_big()) x = ed_swap_4(x);
-    return bgzf_write(fp, &x, sizeof x);
-}
-
-static inline ssize_t HTS_RESULT_USED idx_write_uint64(BGZF *fp, uint64_t x)
-{
-    if (ed_is_big()) x = ed_swap_8(x);
-    return bgzf_write(fp, &x, sizeof x);
-}
-
-static inline void swap_bins(bins_t *p)
-{
-    int i;
-    for (i = 0; i < p->n; ++i) {
-        ed_swap_8p(&p->list[i].u);
-        ed_swap_8p(&p->list[i].v);
-    }
-}
-
-static int hts_idx_save_core(const hts_idx_t *idx, BGZF *fp, int fmt)
-{
-    int32_t i, j;
-
-    #define check(ret) if ((ret) < 0) return -1
-
-    // VCF TBI/CSI only writes IDs for non-empty bins (ie covered references)
-    //
-    // NOTE: CSI meta is undefined in spec, so this code has an assumption
-    // that we're only using it for Tabix data.
-    int nids = idx->n;
-    if (idx->meta && idx->l_meta >= 4 && le_to_u32(idx->meta) == TBX_VCF) {
-        for (i = nids = 0; i < idx->n; ++i) {
-            if (idx->bidx[i])
-                nids++;
-        }
-    }
-    check(idx_write_int32(fp, nids));
-    if (fmt == HTS_FMT_TBI && idx->l_meta)
-        check(bgzf_write(fp, idx->meta, idx->l_meta));
-
-    for (i = 0; i < idx->n; ++i) {
-        khint_t k;
-        bidx_t *bidx = idx->bidx[i];
-        lidx_t *lidx = &idx->lidx[i];
-
-        // write binning index
-        if (nids == idx->n || bidx)
-            check(idx_write_int32(fp, bidx? kh_size(bidx) : 0));
-        if (bidx)
-            for (k = kh_begin(bidx); k != kh_end(bidx); ++k)
-                if (kh_exist(bidx, k)) {
-                    bins_t *p = &kh_value(bidx, k);
-                    check(idx_write_uint32(fp, kh_key(bidx, k)));
-                    if (fmt == HTS_FMT_CSI) check(idx_write_uint64(fp, p->loff));
-                    //int j;for(j=0;j<p->n;++j)fprintf(stderr,"%d,%llx,%d,%llx:%llx\n",kh_key(bidx,k),kh_val(bidx, k).loff,j,p->list[j].u,p->list[j].v);
-                    check(idx_write_int32(fp, p->n));
-                    for (j = 0; j < p->n; ++j) {
-                        //fprintf(stderr, "\t%ld\t%ld\n", p->list[j].u, p->list[j].v);
-                        check(idx_write_uint64(fp, p->list[j].u));
-                        check(idx_write_uint64(fp, p->list[j].v));
-                    }
-                }
-
-        // write linear index
-        if (fmt != HTS_FMT_CSI) {
-            check(idx_write_int32(fp, lidx->n));
-            for (j = 0; j < lidx->n; ++j)
-                check(idx_write_uint64(fp, lidx->offset[j]));
-        }
-    }
-
-    check(idx_write_uint64(fp, idx->n_no_coor));
-    return 0;
-    #undef check
-}
-
-int hts_idx_save(const hts_idx_t *idx, const char *fn, int fmt)
-{
-    int ret, save;
-    if (idx == NULL || fn == NULL) { errno = EINVAL; return -1; }
-    char *fnidx = (char*)calloc(1, strlen(fn) + 5);
-    if (fnidx == NULL) return -1;
-
-    strcpy(fnidx, fn);
-    switch (fmt) {
-    case HTS_FMT_BAI: strcat(fnidx, ".bai"); break;
-    case HTS_FMT_CSI: strcat(fnidx, ".csi"); break;
-    case HTS_FMT_TBI: strcat(fnidx, ".tbi"); break;
-    default: abort();
-    }
-
-    ret = hts_idx_save_as(idx, fn, fnidx, fmt);
-    save = errno;
-    free(fnidx);
-    errno = save;
-    return ret;
-}
-
-int hts_idx_save_as(const hts_idx_t *idx, const char *fn, const char *fnidx, int fmt)
-{
-    BGZF *fp;
-
-    #define check(ret) if ((ret) < 0) goto fail
-
-    if (fnidx == NULL) return hts_idx_save(idx, fn, fmt);
-
-    fp = bgzf_open(fnidx, (fmt == HTS_FMT_BAI)? "wu" : "w");
-    if (fp == NULL) return -1;
-
-    if (fmt == HTS_FMT_CSI) {
-        check(bgzf_write(fp, "CSI\1", 4));
-        check(idx_write_int32(fp, idx->min_shift));
-        check(idx_write_int32(fp, idx->n_lvls));
-        check(idx_write_uint32(fp, idx->l_meta));
-        if (idx->l_meta) check(bgzf_write(fp, idx->meta, idx->l_meta));
-    } else if (fmt == HTS_FMT_TBI) {
-        check(bgzf_write(fp, "TBI\1", 4));
-    } else if (fmt == HTS_FMT_BAI) {
-        check(bgzf_write(fp, "BAI\1", 4));
-    } else abort();
-
-    check(hts_idx_save_core(idx, fp, fmt));
-
-    return bgzf_close(fp);
-    #undef check
-
-fail:
-    bgzf_close(fp);
-    return -1;
-}
-
-static int idx_read_core(hts_idx_t *idx, BGZF *fp, int fmt)
-{
-    int32_t i, n, is_be;
-    is_be = ed_is_big();
-    if (idx == NULL) return -4;
-    for (i = 0; i < idx->n; ++i) {
-        bidx_t *h;
-        lidx_t *l = &idx->lidx[i];
-        uint32_t key;
-        int j, absent;
-        bins_t *p;
-        h = idx->bidx[i] = kh_init(bin);
-        if (bgzf_read(fp, &n, 4) != 4) return -1;
-        if (is_be) ed_swap_4p(&n);
-        if (n < 0) return -3;
-        for (j = 0; j < n; ++j) {
-            khint_t k;
-            if (bgzf_read(fp, &key, 4) != 4) return -1;
-            if (is_be) ed_swap_4p(&key);
-            k = kh_put(bin, h, key, &absent);
-            if (absent <  0) return -2; // No memory
-            if (absent == 0) return -3; // Duplicate bin number
-            p = &kh_val(h, k);
-            if (fmt == HTS_FMT_CSI) {
-                if (bgzf_read(fp, &p->loff, 8) != 8) return -1;
-                if (is_be) ed_swap_8p(&p->loff);
-            } else p->loff = 0;
-            if (bgzf_read(fp, &p->n, 4) != 4) return -1;
-            if (is_be) ed_swap_4p(&p->n);
-            if (p->n < 0) return -3;
-            if ((size_t) p->n > SIZE_MAX / sizeof(hts_pair64_t)) return -2;
-            p->m = p->n;
-            p->list = (hts_pair64_t*)malloc(p->m * sizeof(hts_pair64_t));
-            if (p->list == NULL) return -2;
-            if (bgzf_read(fp, p->list, ((size_t) p->n)<<4) != ((size_t) p->n)<<4) return -1;
-            if (is_be) swap_bins(p);
-        }
-        if (fmt != HTS_FMT_CSI) { // load linear index
-            int j;
-            uint32_t x;
-            if (bgzf_read(fp, &x, 4) != 4) return -1;
-            if (is_be) ed_swap_4p(&x);
-            l->n = x;
-            if (l->n < 0) return -3;
-            if ((size_t) l->n > SIZE_MAX / sizeof(uint64_t)) return -2;
-            l->m = l->n;
-            l->offset = (uint64_t*)malloc(l->n * sizeof(uint64_t));
-            if (l->offset == NULL) return -2;
-            if (bgzf_read(fp, l->offset, l->n << 3) != l->n << 3) return -1;
-            if (is_be) for (j = 0; j < l->n; ++j) ed_swap_8p(&l->offset[j]);
-            for (j = 1; j < l->n; ++j) // fill missing values; may happen given older samtools and tabix
-                if (l->offset[j] == 0) l->offset[j] = l->offset[j-1];
-            update_loff(idx, i, 0);
-        }
-    }
-    if (bgzf_read(fp, &idx->n_no_coor, 8) != 8) idx->n_no_coor = 0;
-    if (is_be) ed_swap_8p(&idx->n_no_coor);
-    return 0;
-}
-
-static hts_idx_t *idx_read(const char *fn)
-{
-    uint8_t magic[4];
-    int i, is_be;
-    hts_idx_t *idx = NULL;
-    uint8_t *meta = NULL;
-    BGZF *fp = bgzf_open(fn, "r");
-    if (fp == NULL) return NULL;
-    is_be = ed_is_big();
-    if (bgzf_read(fp, magic, 4) != 4) goto fail;
-
-    if (memcmp(magic, "CSI\1", 4) == 0) {
-        uint32_t x[3], n;
-        if (bgzf_read(fp, x, 12) != 12) goto fail;
-        if (is_be) for (i = 0; i < 3; ++i) ed_swap_4p(&x[i]);
-        if (x[2]) {
-            if (SIZE_MAX - x[2] < 1) goto fail; // Prevent possible overflow
-            if ((meta = (uint8_t*)malloc((size_t) x[2] + 1)) == NULL) goto fail;
-            if (bgzf_read(fp, meta, x[2]) != x[2]) goto fail;
-            // Prevent possible strlen past the end in tbx_index_load2
-            meta[x[2]] = '\0';
-        }
-        if (bgzf_read(fp, &n, 4) != 4) goto fail;
-        if (is_be) ed_swap_4p(&n);
-        if (n > INT32_MAX) goto fail;
-        if ((idx = hts_idx_init(n, HTS_FMT_CSI, 0, x[0], x[1])) == NULL) goto fail;
-        idx->l_meta = x[2];
-        idx->meta = meta;
-        meta = NULL;
-        if (idx_read_core(idx, fp, HTS_FMT_CSI) < 0) goto fail;
-    }
-    else if (memcmp(magic, "TBI\1", 4) == 0) {
-        uint8_t x[8 * 4];
-        uint32_t n;
-        // Read file header
-        if (bgzf_read(fp, x, sizeof(x)) != sizeof(x)) goto fail;
-        n = le_to_u32(&x[0]); // location of n_ref
-        if (n > INT32_MAX) goto fail;
-        if ((idx = hts_idx_init(n, HTS_FMT_TBI, 0, 14, 5)) == NULL) goto fail;
-        n = le_to_u32(&x[7*4]); // location of l_nm
-        if (n > UINT32_MAX - 29) goto fail; // Prevent possible overflow
-        idx->l_meta = 28 + n;
-        if ((idx->meta = (uint8_t*)malloc(idx->l_meta + 1)) == NULL) goto fail;
-        // copy format, col_seq, col_beg, col_end, meta, skip, l_nm
-        // N.B. left in little-endian byte order.
-        memcpy(idx->meta, &x[1*4], 28);
-        // Read in sequence names.
-        if (bgzf_read(fp, idx->meta + 28, n) != n) goto fail;
-        // Prevent possible strlen past the end in tbx_index_load2
-        idx->meta[idx->l_meta] = '\0';
-        if (idx_read_core(idx, fp, HTS_FMT_TBI) < 0) goto fail;
-    }
-    else if (memcmp(magic, "BAI\1", 4) == 0) {
-        uint32_t n;
-        if (bgzf_read(fp, &n, 4) != 4) goto fail;
-        if (is_be) ed_swap_4p(&n);
-        if (n > INT32_MAX) goto fail;
-        if ((idx = hts_idx_init(n, HTS_FMT_BAI, 0, 14, 5)) == NULL) goto fail;
-        if (idx_read_core(idx, fp, HTS_FMT_BAI) < 0) goto fail;
-    }
-    else { errno = EINVAL; goto fail; }
-
-    bgzf_close(fp);
-    return idx;
-
-fail:
-    bgzf_close(fp);
-    hts_idx_destroy(idx);
-    free(meta);
-    return NULL;
-}
-
-int hts_idx_set_meta(hts_idx_t *idx, uint32_t l_meta, uint8_t *meta,
-                      int is_copy)
-{
-    uint8_t *new_meta = meta;
-    if (is_copy) {
-        size_t l = l_meta;
-        if (l > SIZE_MAX - 1) {
-            errno = ENOMEM;
-            return -1;
-        }
-        new_meta = malloc(l + 1);
-        if (!new_meta) return -1;
-        memcpy(new_meta, meta, l);
-        // Prevent possible strlen past the end in tbx_index_load2
-        new_meta[l] = '\0';
-    }
-    if (idx->meta) free(idx->meta);
-    idx->l_meta = l_meta;
-    idx->meta = new_meta;
-    return 0;
-}
-
-uint8_t *hts_idx_get_meta(hts_idx_t *idx, uint32_t *l_meta)
-{
-    *l_meta = idx->l_meta;
-    return idx->meta;
-}
-
-const char **hts_idx_seqnames(const hts_idx_t *idx, int *n, hts_id2name_f getid, void *hdr)
-{
-    if ( !idx->n )
-    {
-        *n = 0;
-        return NULL;
-    }
-
-    int tid = 0, i;
-    const char **names = (const char**) calloc(idx->n,sizeof(const char*));
-    for (i=0; i<idx->n; i++)
-    {
-        bidx_t *bidx = idx->bidx[i];
-        if ( !bidx ) continue;
-        names[tid++] = getid(hdr,i);
-    }
-    *n = tid;
-    return names;
-}
-
-int hts_idx_get_stat(const hts_idx_t* idx, int tid, uint64_t* mapped, uint64_t* unmapped)
-{
-    if ( idx->fmt == HTS_FMT_CRAI ) {
-        *mapped = 0; *unmapped = 0;
-        return -1;
-    }
-
-    bidx_t *h = idx->bidx[tid];
-    khint_t k = kh_get(bin, h, META_BIN(idx));
-    if (k != kh_end(h)) {
-        *mapped = kh_val(h, k).list[1].u;
-        *unmapped = kh_val(h, k).list[1].v;
-        return 0;
-    } else {
-        *mapped = 0; *unmapped = 0;
-        return -1;
-    }
-}
-
-uint64_t hts_idx_get_n_no_coor(const hts_idx_t* idx)
-{
-    return idx->n_no_coor;
-}
-
-/****************
- *** Iterator ***
- ****************/
-
-// Note: even with 32-bit hts_pos_t, end needs to be 64-bit here due to 1LL<<s.
-static inline int reg2bins(int64_t beg, int64_t end, hts_itr_t *itr, int min_shift, int n_lvls)
-{
-    int l, t, s = min_shift + (n_lvls<<1) + n_lvls;
-    if (beg >= end) return 0;
-    if (end >= 1LL<<s) end = 1LL<<s;
-    for (--end, l = 0, t = 0; l <= n_lvls; s -= 3, t += 1<<((l<<1)+l), ++l) {
-        hts_pos_t b, e;
-        int n, i;
-        b = t + (beg>>s); e = t + (end>>s); n = e - b + 1;
-        if (itr->bins.n + n > itr->bins.m) {
-            itr->bins.m = itr->bins.n + n;
-            kroundup32(itr->bins.m);
-            itr->bins.a = (int*)realloc(itr->bins.a, sizeof(int) * itr->bins.m);
-        }
-        for (i = b; i <= e; ++i) itr->bins.a[itr->bins.n++] = i;
-    }
-    return itr->bins.n;
-}
-
-static inline int reg2intervals(hts_itr_t *iter, const hts_idx_t *idx, int tid, int64_t beg, int64_t end, uint32_t interval, uint64_t min_off, uint64_t max_off, int min_shift, int n_lvls)
-{
-    int l, t, s;
-    int i, j;
-    hts_pos_t b, e;
-    hts_pair64_max_t *off;
-    bidx_t *bidx;
-    khint_t k;
-    int start_n_off = iter->n_off;
-
-    if (!iter || !idx || (bidx = idx->bidx[tid]) == NULL || beg >= end)
-        return -1;
-
-    s = min_shift + (n_lvls<<1) + n_lvls;
-    if (end >= 1LL<<s)
-        end = 1LL<<s;
-
-    for (--end, l = 0, t = 0; l <= n_lvls; s -= 3, t += 1<<((l<<1)+l), ++l) {
-        b = t + (beg>>s); e = t + (end>>s);
-
-        for (i = b; i <= e; ++i) {
-            if ((k = kh_get(bin, bidx, i)) != kh_end(bidx)) {
-                bins_t *p = &kh_value(bidx, k);
-
-                if (p->n) {
-                    off = realloc(iter->off, (iter->n_off + p->n) * sizeof(*off));
-                    if (!off)
-                        return -2;
-
-                    iter->off = off;
-                    for (j = 0; j < p->n; ++j) {
-                        if (p->list[j].v > min_off && p->list[j].u < max_off) {
-                            iter->off[iter->n_off].u = min_off > p->list[j].u
-                                ? min_off : p->list[j].u;
-                            iter->off[iter->n_off].v = max_off < p->list[j].v
-                                ? max_off : p->list[j].v;
-                            // hts_pair64_max_t::max is now used to link
-                            // file offsets to region list entries.
-                            // The iterator can use this to decide if it
-                            // can skip some file regions.
-                            iter->off[iter->n_off].max = ((uint64_t) tid << 32) | interval;
-                            iter->n_off++;
-                        }
-                    }
-                }
-            }
-        }
-    }
-
-    if (iter->n_off - start_n_off > 1) {
-        ks_introsort(_off_max, iter->n_off - start_n_off, iter->off + start_n_off);
-        for (i = start_n_off, j = start_n_off + 1; j < iter->n_off; j++) {
-            if (iter->off[i].v >= iter->off[j].u) {
-                if (iter->off[i].v < iter->off[j].v)
-                    iter->off[i].v = iter->off[j].v;
-            } else {
-                i++;
-                if (i < j)
-                    iter->off[i] = iter->off[j];
-            }
-        }
-        iter->n_off = i + 1;
-    }
-
-    return iter->n_off;
-}
-
-static int compare_regions(const void *r1, const void *r2) {
-    hts_reglist_t *reg1 = (hts_reglist_t *)r1;
-    hts_reglist_t *reg2 = (hts_reglist_t *)r2;
-
-    if (reg1->tid < 0 && reg2->tid >= 0)
-        return 1;
-    else if (reg1->tid >= 0 && reg2->tid < 0)
-        return -1;
-    else
-        return reg1->tid - reg2->tid;
-}
-
-uint64_t hts_itr_off(const hts_idx_t* idx, int tid) {
-
-    int i;
-    bidx_t* bidx;
-    uint64_t off0 = (uint64_t) -1;
-    khint_t k;
-    switch (tid) {
-    case HTS_IDX_START:
-        // Find the smallest offset, note that sequence ids may not be ordered sequentially
-        for (i = 0; i < idx->n; i++) {
-            bidx = idx->bidx[i];
-            k = kh_get(bin, bidx, META_BIN(idx));
-            if (k == kh_end(bidx))
-                continue;
-
-            if (off0 > kh_val(bidx, k).list[0].u)
-                off0 = kh_val(bidx, k).list[0].u;
-        }
-        if (off0 == (uint64_t) -1 && idx->n_no_coor)
-            off0 = 0;
-        // only no-coor reads in this bam
-        break;
-    case HTS_IDX_NOCOOR:
-        /* No-coor reads sort after all of the mapped reads.  The position
-           is not stored in the index itself, so need to find the end
-           offset for the last mapped read.  A loop is needed here in
-           case references at the end of the file have no mapped reads,
-           or sequence ids are not ordered sequentially.
-           See issue samtools#568 and commits b2aab8, 60c22d and cc207d. */
-        for (i = 0; i < idx->n; i++) {
-            bidx = idx->bidx[i];
-            k = kh_get(bin, bidx, META_BIN(idx));
-            if (k != kh_end(bidx)) {
-                if (off0 == (uint64_t) -1 || off0 < kh_val(bidx, k).list[0].v) {
-                    off0 = kh_val(bidx, k).list[0].v;
-                }
-            }
-        }
-        if (off0 == (uint64_t) -1 && idx->n_no_coor)
-            off0 = 0;
-        // only no-coor reads in this bam
-        break;
-    case HTS_IDX_REST:
-        off0 = 0;
-        break;
-    case HTS_IDX_NONE:
-        off0 = 0;
-        break;
-    }
-
-    return off0;
-}
-
-hts_itr_t *hts_itr_query(const hts_idx_t *idx, int tid, hts_pos_t beg, hts_pos_t end, hts_readrec_func *readrec)
-{
-    int i, n_off, l, bin;
-    hts_pair64_max_t *off;
-    khint_t k;
-    bidx_t *bidx;
-    uint64_t min_off, max_off;
-    hts_itr_t *iter;
-    uint32_t unmapped = 0, rel_off;
-
-    // It's possible to call this function with NULL idx iff
-    // tid is one of the special values HTS_IDX_REST or HTS_IDX_NONE
-    if (!idx && !(tid == HTS_IDX_REST || tid == HTS_IDX_NONE)) {
-        errno = EINVAL;
-        return NULL;
-    }
-
-    iter = (hts_itr_t*)calloc(1, sizeof(hts_itr_t));
-    if (iter) {
-        if (tid < 0) {
-            uint64_t off = hts_itr_off(idx, tid);
-            if (off != (uint64_t) -1) {
-                iter->read_rest = 1;
-                iter->curr_off = off;
-                iter->readrec = readrec;
-                if (tid == HTS_IDX_NONE)
-                    iter->finished = 1;
-            } else {
-                free(iter);
-                iter = NULL;
-            }
-        } else {
-            if (beg < 0) beg = 0;
-            if (end < beg) {
-              free(iter);
-              return NULL;
-            }
-            if (tid >= idx->n || (bidx = idx->bidx[tid]) == NULL) {
-              free(iter);
-              return NULL;
-            }
-
-            k = kh_get(bin, bidx, META_BIN(idx));
-            if (k != kh_end(bidx))
-                unmapped = kh_val(bidx, k).list[1].v;
-            else
-                unmapped = 1;
-
-            iter->tid = tid, iter->beg = beg, iter->end = end; iter->i = -1;
-            iter->readrec = readrec;
-
-            if ( !kh_size(bidx) ) { iter->finished = 1; return iter; }
-
-            rel_off = beg>>idx->min_shift;
-            // compute min_off
-            bin = hts_bin_first(idx->n_lvls) + rel_off;
-            do {
-                int first;
-                k = kh_get(bin, bidx, bin);
-                if (k != kh_end(bidx)) break;
-                first = (hts_bin_parent(bin)<<3) + 1;
-                if (bin > first) --bin;
-                else bin = hts_bin_parent(bin);
-            } while (bin);
-            if (bin == 0) k = kh_get(bin, bidx, bin);
-            min_off = k != kh_end(bidx)? kh_val(bidx, k).loff : 0;
-            // min_off can be calculated more accurately if the
-            // linear index is available
-            if (idx->lidx[tid].offset
-                && rel_off < idx->lidx[tid].n) {
-                if (min_off < idx->lidx[tid].offset[rel_off])
-                    min_off = idx->lidx[tid].offset[rel_off];
-                if (unmapped) {
-                    int tmp_off;
-                    for (tmp_off = rel_off-1; tmp_off >= 0; tmp_off--) {
-                        if (idx->lidx[tid].offset[tmp_off] < min_off) {
-                            min_off = idx->lidx[tid].offset[tmp_off];
-                            break;
-                        }
-                    }
-
-                    if (k != kh_end(bidx) && (min_off < kh_val(bidx, k).list[0].u || tmp_off < 0))
-                        min_off = kh_val(bidx, k).list[0].u;
-                }
-            } else if (unmapped) { //CSI index
-                if (k != kh_end(bidx))
-                    min_off = kh_val(bidx, k).list[0].u;
-            }
-
-            // compute max_off: a virtual offset from a bin to the right of end
-            bin = hts_bin_first(idx->n_lvls) + ((end-1) >> idx->min_shift) + 1;
-            if (bin >= idx->n_bins) bin = 0;
-            while (1) {
-                // search for an extant bin by moving right, but moving up to the
-                // parent whenever we get to a first child (which also covers falling
-                // off the RHS, which wraps around and immediately goes up to bin 0)
-                while (bin % 8 == 1) bin = hts_bin_parent(bin);
-                if (bin == 0) { max_off = (uint64_t)-1; break; }
-                k = kh_get(bin, bidx, bin);
-                if (k != kh_end(bidx) && kh_val(bidx, k).n > 0) { max_off = kh_val(bidx, k).list[0].u; break; }
-                bin++;
-            }
-
-            // retrieve bins
-            reg2bins(beg, end, iter, idx->min_shift, idx->n_lvls);
-
-            for (i = n_off = 0; i < iter->bins.n; ++i)
-                if ((k = kh_get(bin, bidx, iter->bins.a[i])) != kh_end(bidx))
-                    n_off += kh_value(bidx, k).n;
-            if (n_off == 0) {
-                // No overlapping bins means the iterator has already finished.
-                iter->finished = 1;
-                return iter;
-            }
-            off = calloc(n_off, sizeof(*off));
-            for (i = n_off = 0; i < iter->bins.n; ++i) {
-                if ((k = kh_get(bin, bidx, iter->bins.a[i])) != kh_end(bidx)) {
-                    int j;
-                    bins_t *p = &kh_value(bidx, k);
-                    for (j = 0; j < p->n; ++j)
-                        if (p->list[j].v > min_off && p->list[j].u < max_off) {
-                            off[n_off].u = min_off > p->list[j].u
-                                ? min_off : p->list[j].u;
-                            off[n_off].v = max_off < p->list[j].v
-                                ? max_off : p->list[j].v;
-                            // hts_pair64_max_t::max is now used to link
-                            // file offsets to region list entries.
-                            // The iterator can use this to decide if it
-                            // can skip some file regions.
-                            off[n_off].max = ((uint64_t) tid << 32) | j;
-                            n_off++;
-                        }
-                }
-            }
-
-            if (n_off == 0) {
-                free(off);
-                iter->finished = 1;
-                return iter;
-            }
-            ks_introsort(_off_max, n_off, off);
-            // resolve completely contained adjacent blocks
-            for (i = 1, l = 0; i < n_off; ++i)
-                if (off[l].v < off[i].v) off[++l] = off[i];
-            n_off = l + 1;
-            // resolve overlaps between adjacent blocks; this may happen due to the merge in indexing
-            for (i = 1; i < n_off; ++i)
-                if (off[i-1].v >= off[i].u) off[i-1].v = off[i].u;
-            // merge adjacent blocks
-            for (i = 1, l = 0; i < n_off; ++i) {
-                if (off[l].v>>16 == off[i].u>>16) off[l].v = off[i].v;
-                else off[++l] = off[i];
-            }
-            n_off = l + 1;
-            iter->n_off = n_off; iter->off = off;
-        }
-    }
-
-    return iter;
-}
-
-int hts_itr_multi_bam(const hts_idx_t *idx, hts_itr_t *iter)
-{
-    int i, j, bin;
-    khint_t k;
-    bidx_t *bidx;
-    uint64_t min_off, max_off, t_off = (uint64_t)-1;
-    int tid;
-    hts_pos_t beg, end;
-    hts_reglist_t *curr_reg;
-    uint32_t unmapped = 0, rel_off;
-
-    if (!idx || !iter || !iter->multi)
-        return -1;
-
-    iter->i = -1;
-    for (i=0; i<iter->n_reg; i++) {
-
-        curr_reg = &iter->reg_list[i];
-        tid = curr_reg->tid;
-
-        if (tid < 0) {
-            t_off = hts_itr_off(idx, tid);
-            if (t_off != (uint64_t)-1) {
-                switch (tid) {
-                case HTS_IDX_NONE:
-                    iter->finished = 1;
-                    // fall through
-                case HTS_IDX_START:
-                case HTS_IDX_REST:
-                    iter->curr_off = t_off;
-                    iter->n_reg = 0;
-                    iter->reg_list = NULL;
-                    iter->read_rest = 1;
-                    return 0;
-                case HTS_IDX_NOCOOR:
-                    iter->nocoor = 1;
-                    iter->nocoor_off = t_off;
-                }
-            }
-        } else {
-            if (tid >= idx->n || (bidx = idx->bidx[tid]) == NULL || !kh_size(bidx))
-                continue;
-
-            k = kh_get(bin, bidx, META_BIN(idx));
-            if (k != kh_end(bidx))
-                unmapped = kh_val(bidx, k).list[1].v;
-            else
-                unmapped = 1;
-
-            for(j=0; j<curr_reg->count; j++) {
-                hts_pair32_t *curr_intv = &curr_reg->intervals[j];
-                if (curr_intv->end < curr_intv->beg)
-                    continue;
-
-                beg = curr_intv->beg;
-                end = curr_intv->end;
-                rel_off = beg>>idx->min_shift;
-
-                /* Compute 'min_off' by searching the lowest level bin containing 'beg'.
-                       If the computed bin is not in the index, try the next bin to the
-                       left, belonging to the same parent. If it is the first sibling bin,
-                       try the parent bin. */
-                bin = hts_bin_first(idx->n_lvls) + rel_off;
-                do {
-                    int first;
-                    k = kh_get(bin, bidx, bin);
-                    if (k != kh_end(bidx)) break;
-                    first = (hts_bin_parent(bin)<<3) + 1;
-                    if (bin > first) --bin;
-                    else bin = hts_bin_parent(bin);
-                } while (bin);
-                if (bin == 0)
-                    k = kh_get(bin, bidx, bin);
-                min_off = k != kh_end(bidx)? kh_val(bidx, k).loff : 0;
-                // min_off can be calculated more accurately if the
-                // linear index is available
-                if (idx->lidx[tid].offset
-                    && rel_off < idx->lidx[tid].n) {
-                    if (min_off < idx->lidx[tid].offset[rel_off])
-                        min_off = idx->lidx[tid].offset[rel_off];
-                    if (unmapped) {
-                        int tmp_off;
-                        for (tmp_off = rel_off-1; tmp_off >= 0; tmp_off--) {
-                            if (idx->lidx[tid].offset[tmp_off] < min_off) {
-                                min_off = idx->lidx[tid].offset[tmp_off];
-                                break;
-                            }
-                        }
-
-                        if (k != kh_end(bidx) && (min_off < kh_val(bidx, k).list[0].u || tmp_off < 0))
-                            min_off = kh_val(bidx, k).list[0].u;
-                    }
-                } else if (unmapped) { //CSI index
-                    if (k != kh_end(bidx))
-                        min_off = kh_val(bidx, k).list[0].u;
-                }
-
-                // compute max_off: a virtual offset from a bin to the right of end
-                bin = hts_bin_first(idx->n_lvls) + ((end-1) >> idx->min_shift) + 1;
-                if (bin >= idx->n_bins) bin = 0;
-                while (1) {
-                    // search for an extant bin by moving right, but moving up to the
-                    // parent whenever we get to a first child (which also covers falling
-                    // off the RHS, which wraps around and immediately goes up to bin 0)
-                    while (bin % 8 == 1) bin = hts_bin_parent(bin);
-                    if (bin == 0) { max_off = (uint64_t)-1; break; }
-                    k = kh_get(bin, bidx, bin);
-                    if (k != kh_end(bidx) && kh_val(bidx, k).n > 0) {
-                        max_off = kh_val(bidx, k).list[0].u;
-                        break;
-                    }
-                    bin++;
-                }
-
-                //convert coordinates to file offsets
-                if (reg2intervals(iter, idx, tid, beg, end, j,
-                                  min_off, max_off,
-                                  idx->min_shift, idx->n_lvls) < 0) {
-                    return -1;
-                }
-            }
-        }
-    }
-
-    if (iter->n_off > 1)
-        ks_introsort(_off_max, iter->n_off, iter->off);
-
-    if(!iter->n_off && !iter->nocoor)
-        iter->finished = 1;
-
-    return 0;
-}
-
-int hts_itr_multi_cram(const hts_idx_t *idx, hts_itr_t *iter)
-{
-    const hts_cram_idx_t *cidx = (const hts_cram_idx_t *) idx;
-    int tid, i, n_off = 0;
-    uint32_t j;
-    hts_pos_t beg, end;
-    hts_reglist_t *curr_reg;
-    hts_pair32_t *curr_intv;
-    hts_pair64_max_t *off = NULL, *tmp;
-    cram_index *e = NULL;
-
-    if (!cidx || !iter || !iter->multi)
-        return -1;
-
-    iter->is_cram = 1;
-    iter->read_rest = 0;
-    iter->off = NULL;
-    iter->n_off = 0;
-    iter->curr_off = 0;
-    iter->i = -1;
-
-    for (i=0; i<iter->n_reg; i++) {
-
-        curr_reg = &iter->reg_list[i];
-        tid = curr_reg->tid;
-
-        if (tid >= 0) {
-            tmp = realloc(off, (n_off + curr_reg->count) * sizeof(*off));
-            if (!tmp)
-                goto err;
-            off = tmp;
-
-            for (j=0; j < curr_reg->count; j++) {
-                curr_intv = &curr_reg->intervals[j];
-                if (curr_intv->end < curr_intv->beg)
-                    continue;
-
-                beg = curr_intv->beg;
-                end = curr_intv->end;
-
-/* First, fetch the container overlapping 'beg' and assign its file offset to u, then
- * find the container overlapping 'end' and assign the relative end of the slice to v.
- * The cram_ptell function will adjust with the container offset, which is not stored
- * in the index.
- */
-                e = cram_index_query(cidx->cram, tid, beg+1, NULL);
-                if (e) {
-                    off[n_off].u = e->offset;
-                    // hts_pair64_max_t::max is now used to link
-                    // file offsets to region list entries.
-                    // The iterator can use this to decide if it
-                    // can skip some file regions.
-                    off[n_off].max = ((uint64_t) tid << 32) | j;
-
-                    if (end >= HTS_POS_MAX) {
-                       e = cram_index_last(cidx->cram, tid, NULL);
-                    } else {
-                       e = cram_index_query_last(cidx->cram, tid, end+1);
-                    }
-
-                    if (e) {
-                        off[n_off++].v = e->next
-                            ? e->next
-                            : e->offset + e->slice + e->len;
-                    } else {
-                        hts_log_warning("Could not set offset end for region %d:%"PRIhts_pos"-%"PRIhts_pos". Skipping", tid, beg, end);
-                    }
-                } else {
-                    hts_log_warning("No index entry for region %d:%"PRIhts_pos"-%"PRIhts_pos"", tid, beg, end);
-                }
-            }
-        } else {
-            switch (tid) {
-                case HTS_IDX_NOCOOR:
-                    e = cram_index_query(cidx->cram, tid, 1, NULL);
-                    if (e) {
-                        iter->nocoor = 1;
-                        iter->nocoor_off = e->offset;
-                    } else {
-                        hts_log_warning("No index entry for NOCOOR region");
-                    }
-                    break;
-                case HTS_IDX_START:
-                    e = cram_index_query(cidx->cram, tid, 1, NULL);
-                    if (e) {
-                        iter->read_rest = 1;
-                        tmp = realloc(off, sizeof(*off));
-                        if (!tmp)
-                            goto err;
-                        off = tmp;
-                        off[0].u = e->offset;
-                        off[0].v = 0;
-                        n_off=1;
-                    } else {
-                        hts_log_warning("No index entries");
-                    }
-                    break;
-                case HTS_IDX_REST:
-                    break;
-                case HTS_IDX_NONE:
-                    iter->finished = 1;
-                    break;
-                default:
-                    hts_log_error("Query with tid=%d not implemented for CRAM files", tid);
-            }
-        }
-    }
-
-    if (n_off) {
-        ks_introsort(_off_max, n_off, off);
-        iter->n_off = n_off; iter->off = off;
-    }
-
-    if(!n_off && !iter->nocoor)
-        iter->finished = 1;
-
-    return 0;
-
- err:
-    free(off);
-    return -1;
-}
-
-void hts_itr_destroy(hts_itr_t *iter)
-{
-    if (iter) {
-        if (iter->multi) {
-            hts_reglist_free(iter->reg_list, iter->n_reg);
-        } else {
-            free(iter->bins.a);
-        }
-
-        if (iter->off)
-            free(iter->off);
-        free(iter);
-    }
-}
-
-static inline long long push_digit(long long i, char c)
-{
-    // ensure subtraction occurs first, avoiding overflow for >= MAX-48 or so
-    int digit = c - '0';
-    return 10 * i + digit;
-}
-
-long long hts_parse_decimal(const char *str, char **strend, int flags)
-{
-    long long n = 0;
-    int decimals = 0, e = 0, lost = 0;
-    char sign = '+', esign = '+';
-    const char *s;
-
-    while (isspace_c(*str)) str++;
-    s = str;
-
-    if (*s == '+' || *s == '-') sign = *s++;
-    while (*s)
-        if (isdigit_c(*s)) n = push_digit(n, *s++);
-        else if (*s == ',' && (flags & HTS_PARSE_THOUSANDS_SEP)) s++;
-        else break;
-
-    if (*s == '.') {
-        s++;
-        while (isdigit_c(*s)) decimals++, n = push_digit(n, *s++);
-    }
-
-    if (*s == 'E' || *s == 'e') {
-        s++;
-        if (*s == '+' || *s == '-') esign = *s++;
-        while (isdigit_c(*s)) e = push_digit(e, *s++);
-        if (esign == '-') e = -e;
-    }
-
-    switch (*s) {
-    case 'k': case 'K': e += 3; s++; break;
-    case 'm': case 'M': e += 6; s++; break;
-    case 'g': case 'G': e += 9; s++; break;
-    }
-
-    e -= decimals;
-    while (e > 0) n *= 10, e--;
-    while (e < 0) lost += n % 10, n /= 10, e++;
-
-    if (lost > 0) {
-        hts_log_warning("Discarding fractional part of %.*s", (int)(s - str), str);
-    }
-
-    if (strend) {
-        *strend = (char *)s;
-    } else if (*s) {
-        if ((flags & HTS_PARSE_THOUSANDS_SEP) || (!(flags & HTS_PARSE_THOUSANDS_SEP) && *s != ','))
-            hts_log_warning("Ignoring unknown characters after %.*s[%s]", (int)(s - str), str, s);
-    }
-
-    return (sign == '+')? n : -n;
-}
-
-static void *hts_memrchr(const void *s, int c, size_t n) {
-    size_t i;
-    unsigned char *u = (unsigned char *)s;
-    for (i = n; i > 0; i--) {
-        if (u[i-1] == c)
-            return u+i-1;
-    }
-
-    return NULL;
-}
-
-/*
- * A variant of hts_parse_reg which is reference-id aware.  It uses
- * the iterator name2id callbacks to validate the region tokenisation works.
- *
- * This is necessary due to GRCh38 HLA additions which have reference names
- * like "HLA-DRB1*12:17".
- *
- * All parameters are mandatory.
- *
- * To work around ambiguous parsing issues, eg both "chr1" and "chr1:100-200"
- * are reference names, we may quote using curly braces.
- * Thus "{chr1}:100-200" and "{chr1:100-200}" disambiguate the above example.
- *
- * Flags are used to control how parsing works, and can be one of the below.
- *
- * HTS_PARSE_LIST:
- *     If present, the region is assmed to be a comma separated list and
- *     position parsing will not contain commas (this implicitly
- *     clears HTS_PARSE_THOUSANDS_SEP in the call to hts_parse_decimal).
- *     On success the return pointer will be the start of the next region, ie
- *     the character after the comma.  (If *ret != '\0' then the caller can
- *     assume another region is present in the list.)
- *
- *     If not set then positions may contain commas.  In this case the return
- *     value should point to the end of the string, or NULL on failure.
- *
- * HTS_PARSE_ONE_COORD:
- *     If present, X:100 is treated as the single base pair region X:100-100.
- *     In this case X:-100 is shorthand for X:1-100 and X:100- is X:100-<end>.
- *     (This is the standard bcftools region convention.)
- *
- *     When not set X:100 is considered to be X:100-<end> where <end> is
- *     the end of chromosome X (set to HTS_POS_MAX here).  X:100- and X:-100
- *     are invalid.
- *     (This is the standard samtools region convention.)
- *
- * Note the supplied string expects 1 based inclusive coordinates, but the
- * returned coordinates start from 0 and are half open, so pos0 is valid
- * for use in e.g. "for (pos0 = beg; pos0 < end; pos0++) {...}"
- *
- * On success a pointer to the byte after the end of the entire region
- *            specifier is returned (plus any trailing comma), and tid,
- *            beg & end will be set.
- * On failure NULL is returned.
- */
-const char *hts_parse_region(const char *s, int *tid, hts_pos_t *beg,
-                             hts_pos_t *end, hts_name2id_f getid, void *hdr,
-                             int flags)
-{
-    if (!s || !tid || !beg || !end || !getid)
-        return NULL;
-
-    size_t s_len = strlen(s);
-    kstring_t ks = { 0, 0, NULL };
-
-    const char *colon = NULL, *comma = NULL;
-    int quoted = 0;
-
-    if (flags & HTS_PARSE_LIST)
-        flags &= ~HTS_PARSE_THOUSANDS_SEP;
-    else
-        flags |= HTS_PARSE_THOUSANDS_SEP;
-
-    const char *s_end = s + s_len;
-
-    // Braced quoting of references is permitted to resolve ambiguities.
-    if (*s == '{') {
-        const char *close = memchr(s, '}', s_len);
-        if (!close) {
-            hts_log_error("Mismatching braces in \"%s\"", s);
-            *tid = -1;
-            return NULL;
-        }
-        s++;
-        s_len--;
-        if (close[1] == ':')
-            colon = close+1;
-        quoted = 1; // number of trailing characters to trim
-
-        // Truncate to this item only, if appropriate.
-        if (flags & HTS_PARSE_LIST) {
-            comma = strchr(close, ',');
-            if (comma) {
-                s_len = comma-s;
-                s_end = comma+1;
-            }
-        }
-    } else {
-        // Truncate to this item only, if appropriate.
-        if (flags & HTS_PARSE_LIST) {
-            comma = strchr(s, ',');
-            if (comma) {
-                s_len = comma-s;
-                s_end = comma+1;
-            }
-        }
-
-        colon = hts_memrchr(s, ':', s_len);
-    }
-
-    // No colon is simplest case; just check and return.
-    if (colon == NULL) {
-        *beg = 0; *end = HTS_POS_MAX;
-        kputsn(s, s_len-quoted, &ks); // convert to nul terminated string
-        if (!ks.s) {
-            *tid = -2;
-            return NULL;
-        }
-
-        *tid = getid(hdr, ks.s);
-        free(ks.s);
-
-        return *tid >= 0 ? s_end : NULL;
-    }
-
-    // Has a colon, but check whole name first.
-    if (!quoted) {
-        *beg = 0; *end = HTS_POS_MAX;
-        kputsn(s, s_len, &ks); // convert to nul terminated string
-        if (!ks.s) {
-            *tid = -2;
-            return NULL;
-        }
-        if ((*tid = getid(hdr, ks.s)) >= 0) {
-            // Entire name matches, but also check this isn't
-            // ambiguous.  eg we have ref chr1 and ref chr1:100-200
-            // both present.
-            ks.l = 0;
-            kputsn(s, colon-s, &ks); // convert to nul terminated string
-            if (!ks.s) {
-                *tid = -2;
-                return NULL;
-            }
-            if (getid(hdr, ks.s) >= 0) {
-                free(ks.s);
-                *tid = -1;
-                hts_log_error("Range is ambiguous. "
-                              "Use {%s} or {%.*s}%s instead",
-                              s, (int)(colon-s), s, colon);
-                return NULL;
-            }
-            free(ks.s);
-
-            return s_end;
-        }
-        if (*tid < -1) // Failed to parse header
-            return NULL;
-    }
-
-    // Quoted, or unquoted and whole string isn't a name.
-    // Check the pre-colon part is valid.
-    ks.l = 0;
-    kputsn(s, colon-s-quoted, &ks); // convert to nul terminated string
-    if (!ks.s) {
-        *tid = -2;
-        return NULL;
-    }
-    *tid = getid(hdr, ks.s);
-    free(ks.s);
-    if (*tid < 0)
-        return NULL;
-
-    // Finally parse the post-colon coordinates
-    char *hyphen;
-    *beg = hts_parse_decimal(colon+1, &hyphen, flags) - 1;
-    if (*beg < 0) {
-        if (isdigit_c(*hyphen) || *hyphen == '\0' || *hyphen == ',') {
-            // interpret chr:-100 as chr:1-100
-            *end = *beg==-1 ? HTS_POS_MAX : -(*beg+1);
-            *beg = 0;
-            return s_end;
-        } else if (*hyphen == '-') {
-            *beg = 0;
-        } else {
-            hts_log_error("Unexpected string \"%s\" after region", hyphen);
-            return NULL;
-        }
-    }
-
-    if (*hyphen == '\0' || ((flags & HTS_PARSE_LIST) && *hyphen == ',')) {
-        *end = flags & HTS_PARSE_ONE_COORD ? *beg+1 : HTS_POS_MAX;
-    } else if (*hyphen == '-') {
-        *end = hts_parse_decimal(hyphen+1, &hyphen, flags);
-        if (*hyphen != '\0' && *hyphen != ',') {
-            hts_log_error("Unexpected string \"%s\" after region", hyphen);
-            return NULL;
-        }
-    } else {
-        hts_log_error("Unexpected string \"%s\" after region", hyphen);
-        return NULL;
-    }
-
-    if (*end == 0)
-        *end = HTS_POS_MAX; // interpret chr:100- as chr:100-<end>
-
-    if (*beg >= *end) return NULL;
-
-    return s_end;
-}
-
-// Next release we should mark this as deprecated?
-// Use hts_parse_region above instead.
-const char *hts_parse_reg64(const char *s, hts_pos_t *beg, hts_pos_t *end)
-{
-    char *hyphen;
-    const char *colon = strrchr(s, ':');
-    if (colon == NULL) {
-        *beg = 0; *end = HTS_POS_MAX;
-        return s + strlen(s);
-    }
-
-    *beg = hts_parse_decimal(colon+1, &hyphen, HTS_PARSE_THOUSANDS_SEP) - 1;
-    if (*beg < 0) *beg = 0;
-
-    if (*hyphen == '\0') *end = HTS_POS_MAX;
-    else if (*hyphen == '-') *end = hts_parse_decimal(hyphen+1, NULL, HTS_PARSE_THOUSANDS_SEP);
-    else return NULL;
-
-    if (*beg >= *end) return NULL;
-    return colon;
-}
-
-const char *hts_parse_reg(const char *s, int *beg, int *end)
-{
-    hts_pos_t beg64 = 0, end64 = 0;
-    const char *colon = hts_parse_reg64(s, &beg64, &end64);
-    if (beg64 > INT_MAX) {
-        hts_log_error("Position %"PRId64" too large", beg64);
-        return NULL;
-    }
-    if (end64 > INT_MAX) {
-        if (end64 == HTS_POS_MAX) {
-            end64 = INT_MAX;
-        } else {
-            hts_log_error("Position %"PRId64" too large", end64);
-            return NULL;
-        }
-    }
-    *beg = beg64;
-    *end = end64;
-    return colon;
-}
-
-hts_itr_t *hts_itr_querys(const hts_idx_t *idx, const char *reg, hts_name2id_f getid, void *hdr, hts_itr_query_func *itr_query, hts_readrec_func *readrec)
-{
-    int tid;
-    hts_pos_t beg, end;
-
-    if (strcmp(reg, ".") == 0)
-        return itr_query(idx, HTS_IDX_START, 0, 0, readrec);
-    else if (strcmp(reg, "*") == 0)
-        return itr_query(idx, HTS_IDX_NOCOOR, 0, 0, readrec);
-
-    if (!hts_parse_region(reg, &tid, &beg, &end, getid, hdr, HTS_PARSE_THOUSANDS_SEP))
-        return NULL;
-
-    return itr_query(idx, tid, beg, end, readrec);
-}
-
-hts_itr_t *hts_itr_regions(const hts_idx_t *idx, hts_reglist_t *reglist, int count, hts_name2id_f getid, void *hdr, hts_itr_multi_query_func *itr_specific, hts_readrec_func *readrec, hts_seek_func *seek, hts_tell_func *tell) {
-
-    int i;
-
-    if (!reglist)
-        return NULL;
-
-    hts_itr_t *itr = (hts_itr_t*)calloc(1, sizeof(hts_itr_t));
-    if (itr) {
-        itr->n_reg = count;
-        itr->readrec = readrec;
-        itr->seek = seek;
-        itr->tell = tell;
-        itr->reg_list = reglist;
-        itr->finished = 0;
-        itr->nocoor = 0;
-        itr->multi = 1;
-
-        for (i = 0; i < itr->n_reg; i++) {
-            if (itr->reg_list[i].reg) {
-                if (!strcmp(itr->reg_list[i].reg, ".")) {
-                    itr->reg_list[i].tid = HTS_IDX_START;
-                    continue;
-                }
-
-                if (!strcmp(itr->reg_list[i].reg, "*")) {
-                    itr->reg_list[i].tid = HTS_IDX_NOCOOR;
-                    continue;
-                }
-
-                itr->reg_list[i].tid = getid(hdr, reglist[i].reg);
-                if (itr->reg_list[i].tid < 0) {
-                    if (itr->reg_list[i].tid < -1) {
-                        hts_log_error("Failed to parse header");
-                        hts_itr_destroy(itr);
-                        return NULL;
-                    } else {
-                        hts_log_warning("Region '%s' specifies an unknown reference name. Continue anyway", reglist[i].reg);
-                    }
-                }
-            }
-        }
-
-        qsort(itr->reg_list, itr->n_reg, sizeof(hts_reglist_t), compare_regions);
-        if (itr_specific(idx, itr) != 0) {
-            hts_log_error("Failed to create the multi-region iterator!");
-            hts_itr_destroy(itr);
-            itr = NULL;
-        }
-    }
-
-    return itr;
-}
-
-int hts_itr_next(BGZF *fp, hts_itr_t *iter, void *r, void *data)
-{
-    int ret, tid;
-    hts_pos_t beg, end;
-    if (iter == NULL || iter->finished) return -1;
-    if (iter->read_rest) {
-        if (iter->curr_off) { // seek to the start
-            if (bgzf_seek(fp, iter->curr_off, SEEK_SET) < 0) {
-                hts_log_error("Failed to seek to offset %"PRIu64"%s%s",
-                              iter->curr_off,
-                              errno ? ": " : "", strerror(errno));
-                return -2;
-            }
-            iter->curr_off = 0; // only seek once
-        }
-        ret = iter->readrec(fp, data, r, &tid, &beg, &end);
-        if (ret < 0) iter->finished = 1;
-        iter->curr_tid = tid;
-        iter->curr_beg = beg;
-        iter->curr_end = end;
-        return ret;
-    }
-    // A NULL iter->off should always be accompanied by iter->finished.
-    assert(iter->off != NULL);
-    for (;;) {
-        if (iter->curr_off == 0 || iter->curr_off >= iter->off[iter->i].v) { // then jump to the next chunk
-            if (iter->i == iter->n_off - 1) { ret = -1; break; } // no more chunks
-            if (iter->i < 0 || iter->off[iter->i].v != iter->off[iter->i+1].u) { // not adjacent chunks; then seek
-                if (bgzf_seek(fp, iter->off[iter->i+1].u, SEEK_SET) < 0) {
-                    hts_log_error("Failed to seek to offset %"PRIu64"%s%s",
-                                  iter->off[iter->i+1].u,
-                                  errno ? ": " : "", strerror(errno));
-                    return -2;
-                }
-                iter->curr_off = bgzf_tell(fp);
-            }
-            ++iter->i;
-        }
-        if ((ret = iter->readrec(fp, data, r, &tid, &beg, &end)) >= 0) {
-            iter->curr_off = bgzf_tell(fp);
-            if (tid != iter->tid || beg >= iter->end) { // no need to proceed
-                ret = -1; break;
-            } else if (end > iter->beg && iter->end > beg) {
-                iter->curr_tid = tid;
-                iter->curr_beg = beg;
-                iter->curr_end = end;
-                return ret;
-            }
-        } else break; // end of file or error
-    }
-    iter->finished = 1;
-    return ret;
-}
-
-int hts_itr_multi_next(htsFile *fd, hts_itr_t *iter, void *r)
-{
-    void *fp;
-    int ret, tid, i, cr, ci;
-    hts_pos_t beg, end;
-    hts_reglist_t *found_reg;
-
-    if (iter == NULL || iter->finished) return -1;
-
-    if (iter->is_cram) {
-        fp = fd->fp.cram;
-    } else {
-        fp = fd->fp.bgzf;
-    }
-
-    if (iter->read_rest) {
-        if (iter->curr_off) { // seek to the start
-            if (iter->seek(fp, iter->curr_off, SEEK_SET) < 0) {
-                hts_log_error("Seek at offset %" PRIu64 " failed.", iter->curr_off);
-                return -1;
-            }
-            iter->curr_off = 0; // only seek once
-        }
-
-        ret = iter->readrec(fp, fd, r, &tid, &beg, &end);
-        if (ret < 0)
-            iter->finished = 1;
-
-        iter->curr_tid = tid;
-        iter->curr_beg = beg;
-        iter->curr_end = end;
-
-        return ret;
-    }
-    // A NULL iter->off should always be accompanied by iter->finished.
-    assert(iter->off != NULL || iter->nocoor != 0);
-
-    int next_range = 0;
-    for (;;) {
-        // Note that due to the way bam indexing works, iter->off may contain
-        // file chunks that are not actually needed as they contain data
-        // beyond the end of the requested region.  These are filtered out
-        // by comparing the tid and index into hts_reglist_t::intervals
-        // (packed for reasons of convenience into iter->off[iter->i].max)
-        // associated with the file region with iter->curr_tid and
-        // iter->curr_intv.
-
-        if (next_range
-            || iter->curr_off == 0
-            || iter->i >= iter->n_off
-            || iter->curr_off >= iter->off[iter->i].v
-            || (iter->off[iter->i].max >> 32 == iter->curr_tid
-                && (iter->off[iter->i].max & 0xffffffff) < iter->curr_intv)) {
-
-            // Jump to the next chunk.  It may be necessary to skip more
-            // than one as the iter->off list can include overlapping entries.
-            do {
-                iter->i++;
-            } while (iter->i < iter->n_off
-                     && (iter->curr_off >= iter->off[iter->i].v
-                         || (iter->off[iter->i].max >> 32 == iter->curr_tid
-                             && (iter->off[iter->i].max & 0xffffffff) < iter->curr_intv)));
-
-            if (iter->is_cram && iter->i < iter->n_off) {
-                // Ensure iter->curr_reg is correct.
-                //
-                // We need this for CRAM as we shortcut some of the later
-                // logic by getting an end-of-range and continuing to the
-                // next offset.
-                //
-                // We cannot do this for BAM (and fortunately do not need to
-                // either) because in BAM world a query to genomic positions
-                // GX and GY leading to a seek offsets PX and PY may have
-                // GX > GY and PX < PY.  (This is due to the R-tree and falling
-                // between intervals, bumping up to a higher bin.)
-                // CRAM strictly follows PX >= PY if GX >= GY, so this logic
-                // works.
-                int want_tid = iter->off[iter->i].max >> 32;
-                if (!(iter->curr_reg < iter->n_reg &&
-                      iter->reg_list[iter->curr_reg].tid == want_tid)) {
-                    int j;
-                    for (j = 0; j < iter->n_reg; j++)
-                        if (iter->reg_list[j].tid == want_tid)
-                            break;
-                    if (j == iter->n_reg)
-                        return -1;
-                    iter->curr_reg = j;
-                    iter->curr_tid = iter->reg_list[iter->curr_reg].tid;
-                };
-                iter->curr_intv = iter->off[iter->i].max & 0xffffffff;
-            }
-
-            if (iter->i >= iter->n_off) { // no more chunks, except NOCOORs
-                if (iter->nocoor) {
-                    next_range = 0;
-                    if (iter->seek(fp, iter->nocoor_off, SEEK_SET) < 0) {
-                        hts_log_error("Seek at offset %" PRIu64 " failed.", iter->nocoor_off);
-                        return -1;
-                    }
-                    if (iter->is_cram) {
-                        cram_range r = { HTS_IDX_NOCOOR };
-                        cram_set_option(fp, CRAM_OPT_RANGE_NOSEEK, &r);
-                    }
-
-                    // The first slice covering the unmapped reads might
-                    // contain a few mapped reads, so scroll
-                    // forward until finding the first unmapped read.
-                    do {
-                        ret = iter->readrec(fp, fd, r, &tid, &beg, &end);
-                    } while (tid >= 0 && ret >=0);
-
-                    if (ret < 0)
-                        iter->finished = 1;
-                    else
-                        iter->read_rest = 1;
-
-                    iter->curr_off = 0; // don't seek any more
-                    iter->curr_tid = tid;
-                    iter->curr_beg = beg;
-                    iter->curr_end = end;
-
-                    return ret;
-                } else {
-                    ret = -1; break;
-                }
-            } else if (iter->i < iter->n_off) {
-                // New chunk may overlap the last one, so ensure we
-                // only seek forwards.
-                if (iter->curr_off < iter->off[iter->i].u || next_range) {
-                    iter->curr_off = iter->off[iter->i].u;
-
-                    // CRAM has the capability of setting an end location.
-                    // This means multi-threaded decodes can stop once they
-                    // reach that point, rather than pointlessly decoding
-                    // more slices than we'll be using.
-                    //
-                    // We have to be careful here.  Whenever we set the cram
-                    // range we need a corresponding seek in order to ensure
-                    // we can safely decode at that offset.  We use next_range
-                    // var to ensure this is always true; this is set on
-                    // end-of-range condition. It's never modified for BAM.
-                    if (iter->is_cram) {
-                        // Next offset.[uv] tuple, but it's already been
-                        // included in our cram range, so don't seek and don't
-                        // reset range so we can efficiently multi-thread.
-                        if (next_range || iter->curr_off >= iter->end) {
-                            if (iter->seek(fp, iter->curr_off, SEEK_SET) < 0) {
-                                hts_log_error("Seek at offset %" PRIu64
-                                        " failed.", iter->curr_off);
-                                return -1;
-                            }
-
-                            // Find the genomic range matching this interval.
-                            int j;
-                            hts_reglist_t *rl = &iter->reg_list[iter->curr_reg];
-                            cram_range r = {
-                                    rl->tid,
-                                    rl->intervals[iter->curr_intv].beg,
-                                    rl->intervals[iter->curr_intv].end
-                            };
-
-                            // Expand it up to cover neighbouring intervals.
-                            // Note we can only have a single chromosome in a
-                            // range, so if we detect our blocks span chromosomes
-                            // or we have a multi-ref mode slice, we just use
-                            // HTS_IDX_START refid instead.  This doesn't actually
-                            // seek (due to CRAM_OPT_RANGE_NOSEEK) and is simply
-                            // and indicator of decoding with no end limit.
-                            //
-                            // That isn't as efficient as it could be, but it's
-                            // no poorer than before and it works.
-                            int tid = r.refid;
-                            int64_t end = r.end;
-                            int64_t v = iter->off[iter->i].v;
-                            j = iter->i+1;
-                            while (j < iter->n_off) {
-                                if (iter->off[j].u > v)
-                                    break;
-
-                                uint64_t max = iter->off[j].max;
-                                if ((max>>32) != tid)
-                                    tid = HTS_IDX_START; // => no range limit
-
-                                if (end < rl->intervals[max & 0xffffffff].end)
-                                    end = rl->intervals[max & 0xffffffff].end;
-                                if (v < iter->off[j].v)
-                                    v = iter->off[j].v;
-                                j++;
-                            }
-                            r.refid = tid;
-                            r.end = end;
-
-                            // Remember maximum 'v' here so we don't do
-                            // unnecessary subsequent seeks for the next
-                            // regions.  We can't change curr_off, but
-                            // beg/end are used only by single region iterator so
-                            // we cache it there to avoid changing the struct.
-                            iter->end = v;
-
-                            cram_set_option(fp, CRAM_OPT_RANGE_NOSEEK, &r);
-                            next_range = 0;
-                        }
-                    } else { // Not CRAM
-                        if (iter->seek(fp, iter->curr_off, SEEK_SET) < 0) {
-                            hts_log_error("Seek at offset %" PRIu64 " failed.",
-                                          iter->curr_off);
-                            return -1;
-                        }
-                    }
-                }
-            }
-        }
-
-        ret = iter->readrec(fp, fd, r, &tid, &beg, &end);
-        if (ret < 0) {
-            if (iter->is_cram && cram_eof(fp)) {
-                // Skip to end of range
-                //
-                // We should never be adjusting curr_off manually unless
-                // we also can guarantee we'll be doing a seek after to
-                // a new location.  Otherwise we'll be reading wrong offset
-                // for the next container.
-                //
-                // We ensure this by adjusting our CRAM_OPT_RANGE
-                // accordingly above, but to double check we also
-                // set the skipped_block flag to enforce a seek also.
-                iter->curr_off = iter->off[iter->i].v;
-                next_range = 1;
-
-                // Next region
-                if (++iter->curr_intv >= iter->reg_list[iter->curr_reg].count){
-                    if (++iter->curr_reg >= iter->n_reg)
-                        break;
-                    iter->curr_intv = 0;
-                    iter->curr_tid = iter->reg_list[iter->curr_reg].tid;
-                }
-                continue;
-            } else {
-                break;
-            }
-        }
-
-        iter->curr_off = iter->tell(fp);
-
-        if (tid != iter->curr_tid) {
-            hts_reglist_t key;
-            key.tid = tid;
-
-            found_reg = (hts_reglist_t *)bsearch(&key, iter->reg_list,
-                                                 iter->n_reg,
-                                                 sizeof(hts_reglist_t),
-                                                 compare_regions);
-            if (!found_reg)
-                continue;
-
-            iter->curr_reg = (found_reg - iter->reg_list);
-            iter->curr_tid = tid;
-            iter->curr_intv = 0;
-        }
-
-        cr = iter->curr_reg;
-        ci = iter->curr_intv;
-
-        for (i = ci; i < iter->reg_list[cr].count; i++) {
-            if (end > iter->reg_list[cr].intervals[i].beg &&
-                iter->reg_list[cr].intervals[i].end > beg) {
-                iter->curr_beg = beg;
-                iter->curr_end = end;
-                iter->curr_intv = i;
-
-                return ret;
-            }
-
-            // Check if the read starts beyond intervals[i].end
-            // If so, the interval is finished so move on to the next.
-            if (beg > iter->reg_list[cr].intervals[i].end)
-                iter->curr_intv = i + 1;
-
-            // No need to keep searching if the read ends before intervals[i].beg
-            if (end < iter->reg_list[cr].intervals[i].beg)
-                break;
-        }
-    }
-    iter->finished = 1;
-
-    return ret;
-}
-
-/**********************
- *** Retrieve index ***
- **********************/
-// Local_fn and local_len will return a sub-region of 'fn'.
-// Eg http://elsewhere/dir/foo.bam.bai?a=b may return
-// foo.bam.bai via local_fn and local_len.
-//
-// Returns -1 if index couldn't be opened.
-//         -2 on other errors
-static int idx_test_and_fetch(const char *fn, const char **local_fn, int *local_len, int download)
-{
-    hFILE *remote_hfp = NULL;
-    hFILE *local_fp = NULL;
-    int save_errno;
-    htsFormat fmt;
-    kstring_t s = KS_INITIALIZE;
-    kstring_t tmps = KS_INITIALIZE;
-
-    if (hisremote(fn)) {
-        const int buf_size = 1 * 1024 * 1024;
-        int l;
-        const char *p, *e;
-        // Ignore ?# params: eg any file.fmt?param=val, except for S3 URLs
-        e = fn + ((strncmp(fn, "s3://", 5) && strncmp(fn, "s3+http://", 10) && strncmp(fn, "s3+https://", 11)) ? strcspn(fn, "?#") : strcspn(fn, "?"));
-        // Find the previous slash from there.
-        p = e;
-        while (p > fn && *p != '/') p--;
-        if (*p == '/') p++;
-
-        // Attempt to open local file first
-        kputsn(p, e-p, &s);
-        if (access(s.s, R_OK) == 0)
-        {
-            free(s.s);
-            *local_fn = p;
-            *local_len = e-p;
-            return 0;
-        }
-
-        // Attempt to open remote file. Stay quiet on failure, it is OK to fail when trying first .csi then .bai or .tbi index.
-        if ((remote_hfp = hopen(fn, "r")) == 0) {
-            hts_log_info("Failed to open index file '%s'", fn);
-            free(s.s);
-            return -1;
-        }
-        if (hts_detect_format(remote_hfp, &fmt)) {
-            hts_log_error("Failed to detect format of index file '%s'", fn);
-            goto fail;
-        }
-        if (fmt.category != index_file || (fmt.format != bai &&  fmt.format != csi && fmt.format != tbi
-                && fmt.format != crai && fmt.format != fai_format)) {
-            hts_log_error("Format of index file '%s' is not supported", fn);
-            goto fail;
-        }
-
-        if (download) {
-            if ((local_fp = hts_open_tmpfile(s.s, "wx", &tmps)) == NULL) {
-                hts_log_error("Failed to create file %s in the working directory", p);
-                goto fail;
-            }
-            hts_log_info("Downloading file %s to local directory", fn);
-            uint8_t *buf = (uint8_t*)calloc(buf_size, 1);
-            if (!buf) {
-                hts_log_error("%s", strerror(errno));
-                goto fail;
-            }
-            while ((l = hread(remote_hfp, buf, buf_size)) > 0) {
-                if (hwrite(local_fp, buf, l) != l) {
-                    hts_log_error("Failed to write data to %s : %s",
-                            fn, strerror(errno));
-                    free(buf);
-                    goto fail;
-                }
-            }
-            free(buf);
-            if (l < 0) {
-                hts_log_error("Error reading \"%s\"", fn);
-                goto fail;
-            }
-            if (hclose(local_fp) < 0) {
-                hts_log_error("Error closing %s : %s", fn, strerror(errno));
-                local_fp = NULL;
-                goto fail;
-            }
-            local_fp = NULL;
-            if (rename(tmps.s, s.s) < 0) {
-                hts_log_error("Error renaming %s : %s", tmps.s, strerror(errno));
-                goto fail;
-            }
-            ks_clear(&tmps);
-
-            *local_fn = p;
-            *local_len = e-p;
-        } else {
-            *local_fn = fn;
-            *local_len = e-fn;
-        }
-
-        if (hclose(remote_hfp) != 0) {
-            hts_log_error("Failed to close remote file %s", fn);
-        }
-
-        free(tmps.s);
-        free(s.s);
-        return 0;
-    } else {
-        hFILE *local_hfp;
-        if ((local_hfp = hopen(fn, "r")) == 0) return -1;
-        hclose_abruptly(local_hfp);
-        *local_fn = fn;
-        *local_len = strlen(fn);
-        return 0;
-    }
-
- fail:
-    save_errno = errno;
-    if (remote_hfp) hclose_abruptly(remote_hfp);
-    if (local_fp) hclose_abruptly(local_fp);
-    if (tmps.l > 0) unlink(tmps.s);
-    free(tmps.s);
-    free(s.s);
-    errno = save_errno;
-    return -2;
-}
-
-/*
- * Check the existence of a local index file using part of the alignment file name.
- * The order is alignment.bam.csi, alignment.csi, alignment.bam.bai, alignment.bai
- * @param fn    - pointer to the file name
- * @param fnidx - pointer to the index file name placeholder
- * @return        1 for success, 0 for failure
- */
-int hts_idx_check_local(const char *fn, int fmt, char **fnidx) {
-    int i, l_fn, l_ext;
-    const char *fn_tmp = NULL;
-    char *fnidx_tmp;
-    char *csi_ext = ".csi";
-    char *bai_ext = ".bai";
-    char *tbi_ext = ".tbi";
-    char *crai_ext = ".crai";
-    char *fai_ext = ".fai";
-
-    if (!fn)
-        return 0;
-
-    if (hisremote(fn)) {
-        for (i = strlen(fn) - 1; i >= 0; --i)
-            if (fn[i] == '/') {
-                fn_tmp = (char *)&fn[i+1];
-                break;
-            }
-    } else {
-        // Borrowed from hopen_fd_fileuri()
-        if (strncmp(fn, "file://localhost/", 17) == 0) fn_tmp = fn + 16;
-        else if (strncmp(fn, "file:///", 8) == 0) fn_tmp = fn + 7;
-        else fn_tmp = fn;
-#if defined(_WIN32) || defined(__MSYS__)
-        // For cases like C:/foo
-        if (fn_tmp[0] == '/' && fn_tmp[1] && fn_tmp[2] == ':' && fn_tmp[3] == '/')
-            fn_tmp++;
-#endif
-    }
-
-    if (!fn_tmp) return 0;
-    hts_log_info("Using alignment file '%s'", fn_tmp);
-    l_fn = strlen(fn_tmp); l_ext = 5;
-    fnidx_tmp = (char*)calloc(l_fn + l_ext + 1, 1);
-    if (!fnidx_tmp) return 0;
-
-    struct stat sbuf;
-
-    // Try alignment.bam.csi first
-    strcpy(fnidx_tmp, fn_tmp); strcpy(fnidx_tmp + l_fn, csi_ext);
-    if(stat(fnidx_tmp, &sbuf) == 0) {
-        *fnidx = fnidx_tmp;
-        return 1;
-    } else { // Then try alignment.csi
-        for (i = l_fn - 1; i > 0; --i)
-            if (fnidx_tmp[i] == '.') {
-                strcpy(fnidx_tmp + i, csi_ext);
-                if(stat(fnidx_tmp, &sbuf) == 0) {
-                    *fnidx = fnidx_tmp;
-                    return 1;
-                }
-                break;
-            }
-    }
-    if (fmt == HTS_FMT_BAI) {
-        // Next, try alignment.bam.bai
-        strcpy(fnidx_tmp, fn_tmp); strcpy(fnidx_tmp + l_fn, bai_ext);
-        if(stat(fnidx_tmp, &sbuf) == 0) {
-            *fnidx = fnidx_tmp;
-            return 1;
-        } else { // And finally, try alignment.bai
-            for (i = l_fn - 1; i > 0; --i)
-                if (fnidx_tmp[i] == '.') {
-                    strcpy(fnidx_tmp + i, bai_ext);
-                    if(stat(fnidx_tmp, &sbuf) == 0) {
-                        *fnidx = fnidx_tmp;
-                        return 1;
-                    }
-                    break;
-                }
-        }
-    } else if (fmt == HTS_FMT_TBI) { // Or .tbi
-        strcpy(fnidx_tmp, fn_tmp); strcpy(fnidx_tmp + l_fn, tbi_ext);
-        if(stat(fnidx_tmp, &sbuf) == 0) {
-            *fnidx = fnidx_tmp;
-            return 1;
-        } else {
-            for (i = l_fn - 1; i > 0; --i)
-                if (fnidx_tmp[i] == '.') {
-                    strcpy(fnidx_tmp + i, tbi_ext);
-                    if(stat(fnidx_tmp, &sbuf) == 0) {
-                        *fnidx = fnidx_tmp;
-                        return 1;
-                    }
-                    break;
-                }
-        }
-    } else if (fmt == HTS_FMT_CRAI) { // Or .crai
-        strcpy(fnidx_tmp, fn_tmp); strcpy(fnidx_tmp + l_fn, crai_ext);
-        if(stat(fnidx_tmp, &sbuf) == 0) {
-            *fnidx = fnidx_tmp;
-            return 1;
-        } else {
-            for (i = l_fn - 1; i > 0; --i)
-                if (fnidx_tmp[i] == '.') {
-                    strcpy(fnidx_tmp + i, crai_ext);
-                    if(stat(fnidx_tmp, &sbuf) == 0) {
-                        *fnidx = fnidx_tmp;
-                        return 1;
-                    }
-                    break;
-                }
-        }
-    } else if (fmt == HTS_FMT_FAI) { // Or .fai
-        strcpy(fnidx_tmp, fn_tmp); strcpy(fnidx_tmp + l_fn, fai_ext);
-        *fnidx = fnidx_tmp;
-        if(stat(fnidx_tmp, &sbuf) == 0)
-            return 1;
-        else
-            return 0;
-    }
-
-    free(fnidx_tmp);
-    return 0;
-}
-
-static char *idx_filename(const char *fn, const char *ext, int download) {
-    int ret, local_len;
-    char *fnidx;
-    const char *local_fn = NULL;
-    kstring_t buffer = KS_INITIALIZE;
-
-    // First try : append `ext` to `fn`
-    if (!(fnidx = haddextension(&buffer, fn, 0, ext))) {
-        free(buffer.s);
-        return NULL;
-    }
-    if ((ret = idx_test_and_fetch(fnidx, &local_fn, &local_len, download)) == -1) {
-        // Second try : replace suffix of `fn` with `ext`
-        if (!(fnidx = haddextension(&buffer, fn, 1, ext))) {
-            free(buffer.s);
-            return NULL;
-        }
-        ret = idx_test_and_fetch(fnidx, &local_fn, &local_len, download);
-    }
-
-    if (ret < 0) {
-        free(buffer.s);
-        return NULL;
-    }
-
-    memmove(fnidx, local_fn, local_len);
-    fnidx[local_len] = 0;
-    return fnidx;
-}
-
-char *hts_idx_getfn(const char *fn, const char *ext)
-{
-    return idx_filename(fn, ext, HTS_IDX_SAVE_REMOTE);
-}
-
-char *hts_idx_locatefn(const char *fn, const char *ext)
-{
-    return idx_filename(fn, ext, 0);
-}
-
-static hts_idx_t *idx_find_and_load(const char *fn, int fmt, int flags)
-{
-    char *fnidx = strstr(fn, HTS_IDX_DELIM);
-    hts_idx_t *idx;
-
-    if ( fnidx ) {
-        char *fn2 = strdup(fn);
-        if (!fn2) {
-            hts_log_error("%s", strerror(errno));
-            return NULL;
-        }
-        fn2[fnidx - fn] = '\0';
-        fnidx += strlen(HTS_IDX_DELIM);
-        idx = hts_idx_load3(fn2, fnidx, fmt, flags);
-        free(fn2);
-        return idx;
-    }
-
-    if (hts_idx_check_local(fn, fmt, &fnidx) == 0 && hisremote(fn)) {
-        if (flags & HTS_IDX_SAVE_REMOTE) {
-            fnidx = hts_idx_getfn(fn, ".csi");
-            if (!fnidx) {
-                switch (fmt) {
-                case HTS_FMT_BAI: fnidx = hts_idx_getfn(fn, ".bai"); break;
-                case HTS_FMT_TBI: fnidx = hts_idx_getfn(fn, ".tbi"); break;
-                default: break;
-                }
-            }
-        } else {
-            fnidx = idx_filename(fn, ".csi", 0);
-            if (!fnidx) {
-                switch (fmt) {
-                case HTS_FMT_BAI: fnidx = idx_filename(fn, ".bai", 0); break;
-                case HTS_FMT_TBI: fnidx = idx_filename(fn, ".tbi", 0); break;
-                default: break;
-                }
-            }
-        }
-    }
-    if (!fnidx) {
-        if (!(flags & HTS_IDX_SILENT_FAIL))
-            hts_log_error("Could not retrieve index file for '%s'", fn);
-        return 0;
-    }
-
-    if (flags & HTS_IDX_SAVE_REMOTE)
-        idx = hts_idx_load3(fn, fnidx, fmt, flags);
-    else
-        idx = idx_read(fnidx);
-    free(fnidx);
-    return idx;
-}
-
-hts_idx_t *hts_idx_load(const char *fn, int fmt) {
-    return idx_find_and_load(fn, fmt, 1);
-}
-
-hts_idx_t *hts_idx_load2(const char *fn, const char *fnidx)
-{
-    return hts_idx_load3(fn, fnidx, 0, 0);
-}
-
-hts_idx_t *hts_idx_load3(const char *fn, const char *fnidx, int fmt, int flags)
-{
-    const char *local_fn = NULL;
-    char *local_fnidx = NULL;
-    int local_len;
-    if (!fnidx)
-        return idx_find_and_load(fn, fmt, flags);
-
-    // Check that the index file is up to date, the main file might have changed
-    struct stat stat_idx,stat_main;
-    int remote_fn = hisremote(fn), remote_fnidx = hisremote(fnidx);
-    if ( !remote_fn && !remote_fnidx
-         && !stat(fn, &stat_main) && !stat(fnidx, &stat_idx) )
-    {
-        if ( stat_idx.st_mtime < stat_main.st_mtime )
-            hts_log_warning("The index file is older than the data file: %s", fnidx);
-    }
-
-    if (remote_fnidx && (flags & HTS_IDX_SAVE_REMOTE))
-    {
-        int ret = idx_test_and_fetch(fnidx, &local_fn, &local_len, 1);
-        if (ret == 0) {
-            local_fnidx = strdup(local_fn);
-            if (local_fnidx) {
-                local_fnidx[local_len] = '\0';
-                fnidx = local_fnidx;
-            }
-        }
-    }
-
-    hts_idx_t *idx = idx_read(fnidx);
-    if (!idx && !(flags & HTS_IDX_SILENT_FAIL))
-        hts_log_error("Could not load local index file '%s'", fnidx);
-
-    free(local_fnidx);
-
-    return idx;
-}
-
-
-
-/**********************
- ***     Memory     ***
- **********************/
-
-/* For use with hts_expand macros *only* */
-HTSLIB_EXPORT
-size_t hts_realloc_or_die(size_t n, size_t m, size_t m_sz, size_t size,
-                          int clear, void **ptr, const char *func) {
-    /* If new_m and size are both below this limit, multiplying them
-       together can't overflow */
-    const size_t safe = (size_t) 1 << (sizeof(size_t) * 4);
-    void *new_ptr;
-    size_t bytes, new_m;
-
-    new_m = n;
-    kroundup_size_t(new_m);
-
-    bytes = size * new_m;
-
-    /* Check for overflow.  Both ensure that new_m will fit in m (we make the
-       pessimistic assumption that m is signed), and that bytes has not
-       wrapped around. */
-    if (new_m > (((size_t) 1 << (m_sz * 8 - 1)) - 1)
-        || ((size > safe || new_m > safe)
-            && bytes / new_m != size)) {
-        errno = ENOMEM;
-        goto die;
-    }
-
-    new_ptr = realloc(*ptr, bytes);
-    if (new_ptr == NULL) goto die;
-
-    if (clear) {
-        if (new_m > m) {
-            memset((char *) new_ptr + m * size, 0, (new_m - m) * size);
-        }
-    }
-
-    *ptr = new_ptr;
-
-    return new_m;
-
- die:
-    hts_log_error("%s", strerror(errno));
-    exit(1);
-}
-
-/*
- * Companion to hts_resize() macro that does the actual allocation.
- *
- * Somewhat complicated as hts_resize() needs to write the new allocated
- * size back into *size_in_out, and the value pointed to may either be
- * int32_t, uint32_t or size_t depending on which array is being resized.
- * This is solved by making `size_in_out` a void pointer, getting the macro
- * to pass in the size of the item pointed to (in `size_sz`) and then using
- * an appropriate cast (based on the value of size_sz).  The function
- * ensures that the maximum size will be storable in a signed type of
- * the given size so storing to an int32_t should work correctly.
- *
- * Assumes that sizeof(uint32_t) and sizeof(int32_t) is 4,
- * sizeof(uint64_t) and sizeof(int64_t) is 8 and sizeof(size_t) is
- * either 4 or 8.  It also assumes casting from unsigned to signed will
- * work as long as the top bit isn't set.
- */
-
-int hts_resize_array_(size_t item_size, size_t num, size_t size_sz,
-                      void *size_in_out, void **ptr_in_out, int flags,
-                      const char *func) {
-    /* If new_size and item_size are both below this limit, multiplying them
-       together can't overflow */
-    const size_t safe = (size_t) 1 << (sizeof(size_t) * 4);
-    void *new_ptr;
-    size_t bytes, new_size;
-
-    new_size = num;
-    kroundup_size_t(new_size);
-    bytes = item_size * new_size;
-
-    /* Check for overflow.  Both ensure that alloc will fit in alloc_in_out (we
-       make the pessimistic assumption that *alloc_in_out is signed), and that
-       bytes has not wrapped around. */
-
-    if ((new_size > (((size_t) 1 << (size_sz * 8 - 1)) - 1))
-        || (((item_size > safe) || (new_size > safe))
-            && bytes / new_size != item_size)) {
-        hts_log(HTS_LOG_ERROR, func, "Memory allocation too large");
-        errno = ENOMEM;
-        return -1;
-    }
-
-    new_ptr = realloc(*ptr_in_out, bytes);
-    if (new_ptr == NULL) {
-        int save_errno = errno;
-        hts_log(HTS_LOG_ERROR, func, "%s", strerror(errno));
-        errno = save_errno;
-        return -1;
-    }
-
-    if (flags & HTS_RESIZE_CLEAR) {
-        size_t old_size;
-        switch (size_sz) {
-        case 4: old_size = *((uint32_t *) size_in_out); break;
-        case 8: old_size = *((uint64_t *) size_in_out); break;
-        default: abort();
-        }
-        if (new_size > old_size) {
-            memset((char *) new_ptr + old_size * item_size, 0,
-                   (new_size - old_size) * item_size);
-        }
-    }
-
-    switch (size_sz) {
-    case 4: *((uint32_t *) size_in_out) = new_size; break;
-    case 8: *((uint64_t *) size_in_out) = new_size; break;
-    default: abort();
-    }
-
-    *ptr_in_out = new_ptr;
-    return 0;
-}
-
-void hts_lib_shutdown()
-{
-    hfile_shutdown(1);
-}
-
-void hts_free(void *ptr) {
-    free(ptr);
-}
-
-void hts_set_log_level(enum htsLogLevel level)
-{
-    hts_verbose = level;
-}
-
-enum htsLogLevel hts_get_log_level()
-{
-    return hts_verbose;
-}
-
-static char get_severity_tag(enum htsLogLevel severity)
-{
-    switch (severity) {
-    case HTS_LOG_ERROR:
-        return 'E';
-    case HTS_LOG_WARNING:
-        return 'W';
-    case HTS_LOG_INFO:
-        return 'I';
-    case HTS_LOG_DEBUG:
-        return 'D';
-    case HTS_LOG_TRACE:
-        return 'T';
-    default:
-        break;
-    }
-
-    return '*';
-}
-
-void hts_log(enum htsLogLevel severity, const char *context, const char *format, ...)
-{
-    int save_errno = errno;
-    if (severity <= hts_verbose) {
-        va_list argptr;
-
-        fprintf(stderr, "[%c::%s] ", get_severity_tag(severity), context);
-
-        va_start(argptr, format);
-        vfprintf(stderr, format, argptr);
-        va_end(argptr);
-
-        fprintf(stderr, "\n");
-    }
-    errno = save_errno;
-}
diff -ruN stringtie.orig/htslib/htscodecs/configure.ac stringtie/htslib/htscodecs/configure.ac
--- stringtie.orig/htslib/htscodecs/configure.ac	2024-02-28 13:57:39.701246126 +0100
+++ stringtie/htslib/htscodecs/configure.ac	1970-01-01 01:00:00.000000000 +0100
@@ -1,118 +0,0 @@
-dnl Process this file with autoconf to produce a configure script.
-AC_INIT(htscodecs, 1.0)
-
-# Some functions benefit from -O3 optimisation, so if the user didn't
-# explicitly set any compiler flags, we'll plump for O3.
-_=${CFLAGS="-g -O3"}
-
-AC_CONFIG_HEADERS([config.h])
-AC_CONFIG_MACRO_DIR([m4])
-AM_INIT_AUTOMAKE([foreign])
-AM_MAINTAINER_MODE
-
-# For my own benefit, here's a summary of how versioning should work.
-#
-# Library versioning, not to be confused with the release number:
-# Update VERS_CURRENT when an interface changes in an incompatible manner.
-#     eg. change of struct, removing a function, changing a prototype.
-#     Also increment this when we add new functions in a backwards compatible
-#     manner, but update VERS_AGE too (see below).
-#
-# Update VERS_REVISION whenever VERS_CURRENT hasn't changed, but the source
-#     code has. (Otherwise reset revision to 0).
-#
-# Update VERS_AGE if new interfaces have been added, causing VERS_CURRENT to
-#        be incremented too. The idea is that if the previous values are
-#        VERS_CURRENT=2, VERS_AGE=0 then after adding a new function we
-#        get VERS_CURRENT=3, VERS_AGE=1 (ie ABI compat with vers 2 or 3).
-#
-# Also see:
-# http://www.gnu.org/software/libtool/manual/libtool.html#Updating-version-info
-
-# Example: We have htscodecs 1.11.6 implementing ABI vers 0, rev 6, age 0.
-# Our library has an soname of libhtscodecs.so.0 and files as follows:
-#       (SONAME      libhtscodecs.so.0)
-# 	libhtscodecs.so -> libhtscodecs.so.0.0.6
-#       libhtscodecs.so.0 -> libhtscodecs.so.0.0.6
-#       libhtscodecs.so.0.0.6
-#
-# We then release htscodecs 1.12.0 with modified structs, so it's incompatible.
-# We bump to ABI vers 1, rev 0, age 0 - giving:
-#       (SONAME      libhtscodecs.so.1)
-# 	libhtscodecs.so -> libhtscodecs.so.1.0.0
-#       libhtscodecs.so.1 -> libhtscodecs.so.1.0.0
-#       libhtscodecs.so.1.0.0
-#
-# If in 1.12.1 to 1.12.5 we then perform several successive minor tweaks (bug
-# fix, optimisation, etc) that do not change the ABI at all, we may
-# end up with ABI vers 1, rev 5, age 0:
-#       (SONAME      libhtscodecs.so.1)
-# 	libhtscodecs.so -> libhtscodecs.so.1.0.5
-#       libhtscodecs.so.1 -> libhtscodecs.so.1.0.5
-#       libhtscodecs.so.1.0.5
-#
-# And assume in 1.13.0 we add an extra public function. Code linked
-# against 1.12.x still works (aka library version 1) meaning our
-# soname doesn't change, but we do update ABI version: vers 2, rev 0, age 1.
-#       (SONAME      libhtscodecs.so.1)
-# 	libhtscodecs.so -> libhtscodecs.so.1.1.0
-#       libhtscodecs.so.1 -> libhtscodecs.so.1.1.0
-#       libhtscodecs.so.1.1.0
-
-VERS_CURRENT=2
-VERS_REVISION=1
-VERS_AGE=0
-AC_SUBST(VERS_CURRENT)
-AC_SUBST(VERS_REVISION)
-AC_SUBST(VERS_AGE)
-
-dnl Checks for programs.
-AC_PROG_CC
-AC_PROG_INSTALL
-LT_INIT
-
-# # by Marcelo Magallon <mmagallo@efis.ucr.ac.cr>
-# # Turn around -rpath problem with libtool 1.0c
-# # This define should be improbable enough to not conflict with anything.
-# echo host=$host
-# case ${host} in
-#   *-linux-gnu | *-apple-darwin*)
-#     AC_MSG_RESULT([Fixing libtool for -rpath problems.])
-#     sed < libtool > libtool-2 \
-#     's/^hardcode_libdir_flag_spec.*$'/'hardcode_libdir_flag_spec=""/'
-#     mv libtool-2 libtool
-#     chmod 755 libtool
-#   ;;
-# esac
-
-dnl Turn on C compiler warnings.
-VL_PROG_CC_WARNINGS
-
-dnl Check for libraries
-ZLIB_CHECK_CONFIG(,,[have_zlib=yes], [have_zlib=no])
-
-AC_CHECK_LIB([bz2], [BZ2_bzBuffToBuffCompress], [
-	LIBS="-lbz2 $LIBS"
-	AC_DEFINE([HAVE_LIBBZ2],1,[Define to 1 if you have the libbz2 library.])])
-
-dnl AC_CHECK_LIB([lzma], [lzma_easy_buffer_encode], [
-dnl 	LIBS="-llzma $LIBS"
-dnl 	AC_DEFINE([HAVE_LIBLZMA],1,[Define to 1 if you have the liblzma library.])])
-dnl 
-dnl # Experimental
-dnl AC_CHECK_LIB([bsc], [bsc_compress], [
-dnl 	LIBS="-lbsc $LIBS"
-dnl 	AC_DEFINE([HAVE_LIBBSC],1,[Define to 1 if you have the libbsc library.])])
-
-AX_LIBDEFLATE
-
-dnl Checks for header files.
-AC_HEADER_SYS_WAIT
-AC_CHECK_HEADERS(fcntl.h limits.h unistd.h malloc.h)
-AC_CHECK_HEADER(zlib.h)
-
-dnl Checks for library functions.
-AC_SEARCH_LIBS([pthread_join], [pthread])
-
-AC_CONFIG_FILES([Makefile htscodecs/Makefile tests/Makefile])
-AC_OUTPUT
diff -ruN stringtie.orig/htslib/htscodecs/htscodecs/arith_dynamic.c stringtie/htslib/htscodecs/htscodecs/arith_dynamic.c
--- stringtie.orig/htslib/htscodecs/htscodecs/arith_dynamic.c	2024-02-28 13:57:39.701246126 +0100
+++ stringtie/htslib/htscodecs/htscodecs/arith_dynamic.c	1970-01-01 01:00:00.000000000 +0100
@@ -1,1119 +0,0 @@
-/*
- * Copyright (c) 2019,2020 Genome Research Ltd.
- * Author(s): James Bonfield
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions are met:
- *
- *    1. Redistributions of source code must retain the above copyright notice,
- *       this list of conditions and the following disclaimer.
- *
- *    2. Redistributions in binary form must reproduce the above
- *       copyright notice, this list of conditions and the following
- *       disclaimer in the documentation and/or other materials provided
- *       with the distribution.
- *
- *    3. Neither the names Genome Research Ltd and Wellcome Trust Sanger
- *       Institute nor the names of its contributors may be used to endorse
- *       or promote products derived from this software without specific
- *       prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY GENOME RESEARCH LTD AND CONTRIBUTORS "AS
- * IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
- * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
- * PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL GENOME RESEARCH
- * LTD OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
- * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
- * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
- * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
- * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
- * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
- * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- */
-
-// As per standard rANS_static but using optional RLE or bit-packing
-// techniques prior to entropy encoding.  This is a significant
-// reduction in some data sets.
-
-// top bits in order byte
-#define X_PACK   0x80    // Pack 2,4,8 or infinite symbols into a byte.
-#define X_RLE    0x40    // Run length encoding with runs & lits encoded separately
-#define X_CAT    0x20    // Nop; for tiny segments where rANS overhead is too big
-#define X_NOSZ   0x10    // Don't store the original size; used by STRIPE mode
-#define X_STRIPE 0x08    // For 4-byte integer data; rotate & encode 4 streams.
-#define X_EXT    0x04    // External compression codec via magic num (gz, xz, bz2)
-#define X_ORDER  0x03    // Mask to obtain order
-
-#include "config.h"
-
-#ifdef HAVE_LIBBZ2
-#include <bzlib.h>
-#endif
-
-#include <stdint.h>
-#include <stdlib.h>
-#include <stdio.h>
-#include <unistd.h>
-#include <assert.h>
-#include <string.h>
-#include <sys/time.h>
-#include <limits.h>
-#ifndef NO_THREADS
-#include <pthread.h>
-#endif
-
-#include "arith_dynamic.h"
-#include "varint.h"
-#include "pack.h"
-#include "utils.h"
-
-#define MIN(a,b) ((a)<(b)?(a):(b))
-
-/*-----------------------------------------------------------------------------
- * Memory to memory compression functions.
- *
- * These are original versions without any manual loop unrolling. They
- * are easier to understand, but can be up to 2x slower.
- */
-#define MAGIC 8
-
-unsigned int arith_compress_bound(unsigned int size, int order) {
-    return (order == 0
-	? 1.05*size + 257*3 + 4
-	: 1.05*size + 257*257*3 + 4 + 257*3+4) +
-	((order & X_PACK) ? 1 : 0) +
-	((order & X_RLE) ? 1 + 257*3+4: 0) + 5;
-}
-
-#ifndef MODEL_256 // see fqzcomp_qual_fuzz.c
-#define NSYM 256
-#include "c_simple_model.h"
-#endif
-
-// Compresses in_size bytes from 'in' to *out_size bytes in 'out'.
-//
-// NB: The output buffer does not hold the original size, so it is up to
-// the caller to store this.
-static
-unsigned char *arith_compress_O0(unsigned char *in, unsigned int in_size,
-				 unsigned char *out, unsigned int *out_size) {
-    int i, bound = arith_compress_bound(in_size,0)-5; // -5 for order/size
-
-    if (!out) {
-	*out_size = bound;
-	out = malloc(*out_size);
-    }
-    if (!out || bound > *out_size)
-	return NULL;
-
-    unsigned int m = 0;
-    for (i = 0; i < in_size; i++)
-	if (m < in[i])
-	    m = in[i];
-    m++;
-    *out = m;
-
-    SIMPLE_MODEL(256,_) byte_model;
-    SIMPLE_MODEL(256,_init)(&byte_model, m);
-
-    RangeCoder rc;
-    RC_SetOutput(&rc, (char *)out+1);
-    RC_StartEncode(&rc);
-
-    for (i = 0; i < in_size; i++)
-	SIMPLE_MODEL(256, _encodeSymbol)(&byte_model, &rc, in[i]);
-
-    RC_FinishEncode(&rc);
-
-    // Finalise block size and return it
-    *out_size = RC_OutSize(&rc)+1;
-
-    return out;
-}
-
-static
-unsigned char *arith_uncompress_O0(unsigned char *in, unsigned int in_size,
-				   unsigned char *out, unsigned int out_sz) {
-    RangeCoder rc;
-    int i;
-    unsigned int m = in[0] ? in[0] : 256;
-
-    SIMPLE_MODEL(256,_) byte_model;
-    SIMPLE_MODEL(256,_init)(&byte_model, m);
-
-    if (!out)
-	out = malloc(out_sz);
-    if (!out)
-	return NULL;
-
-    RC_SetInput(&rc, (char *)in+1, (char *)in+in_size);
-    RC_StartDecode(&rc);
-
-    for (i = 0; i < out_sz; i++)
-	out[i] = SIMPLE_MODEL(256, _decodeSymbol)(&byte_model, &rc);
-
-    RC_FinishDecode(&rc);
-    
-    return out;
-}
-
-
-//-----------------------------------------------------------------------------
-static
-unsigned char *arith_compress_O1(unsigned char *in, unsigned int in_size,
-				 unsigned char *out, unsigned int *out_size) {
-    int i, bound = arith_compress_bound(in_size,0)-5; // -5 for order/size
-
-    if (!out) {
-	*out_size = bound;
-	out = malloc(*out_size);
-    }
-    if (!out || bound > *out_size)
-	return NULL;
-
-    SIMPLE_MODEL(256,_) byte_model[256];
-    unsigned int m = 0;
-    if (1 || in_size > 1000) {
-	for (i = 0; i < in_size; i++)
-	    if (m < in[i])
-		m = in[i];
-	//fprintf(stderr, "%d max %d\n", in_size, m);
-	m++;
-    }
-    *out = m;
-    for (i = 0; i < 256; i++)
-	SIMPLE_MODEL(256,_init)(&byte_model[i], m);
-
-    RangeCoder rc;
-    RC_SetOutput(&rc, (char *)out+1);
-    RC_StartEncode(&rc);
-
-    uint8_t last = 0;
-    for (i = 0; i < in_size; i++) {
-	SIMPLE_MODEL(256, _encodeSymbol)(&byte_model[last], &rc, in[i]);
-	last = in[i];
-    }
-
-    RC_FinishEncode(&rc);
-
-    // Finalise block size and return it
-    *out_size = RC_OutSize(&rc)+1;
-
-    return out;
-}
-
-static
-unsigned char *arith_uncompress_O1(unsigned char *in, unsigned int in_size,
-				   unsigned char *out, unsigned int out_sz) {
-    RangeCoder rc;
-
-    SIMPLE_MODEL(256,_) byte_model[256];
-    unsigned int m = in[0] ? in[0] : 256, i;
-    for (i = 0; i < 256; i++)
-	SIMPLE_MODEL(256,_init)(&byte_model[i], m);
-    
-    if (!out)
-	out = malloc(out_sz);
-    if (!out)
-	return NULL;
-
-    RC_SetInput(&rc, (char *)in+1, (char *)in+in_size);
-    RC_StartDecode(&rc);
-
-    unsigned char last = 0;
-    for (i = 0; i < out_sz; i++) {
-	out[i] = SIMPLE_MODEL(256, _decodeSymbol)(&byte_model[last], &rc);
-	last = out[i];
-    }
-
-    RC_FinishDecode(&rc);
-    
-    return out;
-}
-
-//-----------------------------------------------------------------------------
-
-// Disable O2 for now
-#if 0
-
-#if 0
-unsigned char *arith_compress_O2(unsigned char *in, unsigned int in_size,
-				 unsigned char *out, unsigned int *out_size) {
-    fprintf(stderr, "WARNING: using undocumented O2 arith\n");
-
-    int i, j;
-    int bound = arith_compress_bound(in_size,0)-5; // -5 for order/size
-
-    if (!out) {
-	*out_size = bound;
-	out = malloc(*out_size);
-    }
-    if (!out || bound > *out_size)
-	return NULL;
-
-    unsigned int m = 0;
-    if (1 || in_size > 1000) {
-	for (i = 0; i < in_size; i++)
-	    if (m < in[i])
-		m = in[i];
-	//fprintf(stderr, "%d max %d\n", in_size, m);
-	m++;
-    }
-    *out = m;
-
-    SIMPLE_MODEL(256,_) *byte_model;
-    byte_model = malloc(256*256*sizeof(*byte_model));
-    for (i = 0; i < 256; i++)
-	for (j = 0; j < 256; j++)
-	    SIMPLE_MODEL(256,_init)(&byte_model[i*256+j], m);
-
-    RangeCoder rc;
-    RC_SetOutput(&rc, (char *)out+1);
-    RC_StartEncode(&rc);
-
-    unsigned char last1 = 0, last2 = 0;
-    for (i = 0; i < in_size; i++) {
-	SIMPLE_MODEL(256, _encodeSymbol)(&byte_model[last1*256 + last2], &rc, in[i]);
-	last2 = last1;
-	last1 = in[i];
-    }
-
-    free(byte_model);
-    RC_FinishEncode(&rc);
-
-    // Finalise block size and return it
-    *out_size = RC_OutSize(&rc)+1;
-
-    return out;
-}
-#else
-unsigned char *arith_compress_O2(unsigned char *in, unsigned int in_size,
-				 unsigned char *out, unsigned int *out_size) {
-    fprintf(stderr, "WARNING: using undocumented O2 arith\n");
-
-    int i, j;
-    int bound = arith_compress_bound(in_size,0)-5; // -5 for order/size
-
-    if (!out) {
-	*out_size = bound;
-	out = malloc(*out_size);
-    }
-    if (!out || bound > *out_size)
-	return NULL;
-
-    unsigned int m = 0;
-    if (1 || in_size > 1000) {
-	for (i = 0; i < in_size; i++)
-	    if (m < in[i])
-		m = in[i];
-	//fprintf(stderr, "%d max %d\n", in_size, m);
-	m++;
-    }
-    *out = m;
-
-    SIMPLE_MODEL(256,_) *byte_model;
-    byte_model = malloc(256*256*sizeof(*byte_model));
-    for (i = 0; i < 256; i++)
-	for (j = 0; j < 256; j++)
-	    SIMPLE_MODEL(256,_init)(&byte_model[i*256+j], m);
-    SIMPLE_MODEL(256,_) byte_model1[256];
-    for (i = 0; i < 256; i++)
-	SIMPLE_MODEL(256,_init)(&byte_model1[i], m);
-
-    RangeCoder rc;
-    RC_SetOutput(&rc, (char *)out+1);
-    RC_StartEncode(&rc);
-
-    unsigned char last1 = 0, last2 = 0;
-    for (i = 0; i < in_size; i++) {
-	// Use Order-1 is order-2 isn't sufficiently advanced yet (75+ symbols)
-	if (byte_model[last1*256+last2].TotFreq <= m+75*16) {
-	    SIMPLE_MODEL(256, _encodeSymbol)(&byte_model1[last1], &rc, in[i]);
-	    SIMPLE_MODEL(256, _updateSymbol)(&byte_model[last1*256 + last2], &rc, in[i]);
-	} else {
-	    SIMPLE_MODEL(256, _encodeSymbol)(&byte_model[last1*256 + last2], &rc, in[i]);
-	    //SIMPLE_MODEL(256, _updateSymbol)(&byte_model1[last1], &rc, in[i]);
-	}
-	last2 = last1;
-	last1 = in[i];
-    }
-
-    free(byte_model);
-    RC_FinishEncode(&rc);
-
-    // Finalise block size and return it
-    *out_size = RC_OutSize(&rc)+1;
-
-    return out;
-}
-#endif
-
-unsigned char *arith_uncompress_O2(unsigned char *in, unsigned int in_size,
-				   unsigned char *out, unsigned int out_sz) {
-    RangeCoder rc;
-
-    SIMPLE_MODEL(256,_) *byte_model;
-    byte_model = malloc(256*256*sizeof(*byte_model));
-    unsigned int m = in[0] ? in[0] : 256, i, j;
-    for (i = 0; i < 256; i++)
-	for (j = 0; j < 256; j++)
-	    SIMPLE_MODEL(256,_init)(&byte_model[i*256+j], m);
-    
-    if (!out)
-	out = malloc(out_sz);
-    if (!out)
-	return NULL;
-
-    RC_SetInput(&rc, (char *)in+1, (char *)in+in_size);
-    RC_StartDecode(&rc);
-
-    unsigned char last1 = 0, last2 = 0;
-    for (i = 0; i < out_sz; i++) {
-	out[i] = SIMPLE_MODEL(256, _decodeSymbol)(&byte_model[last1*256 + last2], &rc);
-	last2 = last1;
-	last1 = out[i];
-    }
-
-    free(byte_model);
-    RC_FinishDecode(&rc);
-    
-    return out;
-}
-
-#endif // Disable O2
-/*-----------------------------------------------------------------------------
- */
-
-#undef NSYM
-#define NSYM 258
-#include "c_simple_model.h"
-#define MAX_RUN 4
-
-static
-unsigned char *arith_compress_O0_RLE(unsigned char *in, unsigned int in_size,
-				     unsigned char *out, unsigned int *out_size) {
-    int i, bound = arith_compress_bound(in_size,0)-5; // -5 for order/size
-
-    if (!out) {
-	*out_size = bound;
-	out = malloc(*out_size);
-    }
-    if (!out || bound > *out_size)
-	return NULL;
-
-    unsigned int m = 0;
-    for (i = 0; i < in_size; i++)
-	if (m < in[i])
-	    m = in[i];
-    m++;
-    *out = m;
-
-    SIMPLE_MODEL(256,_) byte_model;
-    SIMPLE_MODEL(256,_init)(&byte_model, m);
-
-    SIMPLE_MODEL(NSYM,_) run_model[NSYM];
-    for (i = 0; i < NSYM; i++)
-	SIMPLE_MODEL(NSYM,_init)(&run_model[i], MAX_RUN);
-
-    RangeCoder rc;
-    RC_SetOutput(&rc, (char *)out+1);
-    RC_StartEncode(&rc);
-
-    unsigned char last = 0;
-    for (i = 0; i < in_size;) {
-	//SIMPLE_MODEL(256, _encodeSymbol)(&byte_model, &rc, in[i]);
-	SIMPLE_MODEL(256, _encodeSymbol)(&byte_model, &rc, in[i]);
-	//fprintf(stderr, "lit %c (ctx %c)\n", in[i], last);
-	int run = 0;
-	last = in[i++];
-	while (i < in_size && in[i] == last/* && run < MAX_RUN-1*/)
-	    run++, i++;
-	int rctx = last;
-	do {
-	    int c = run < MAX_RUN ? run : MAX_RUN-1;
-	    SIMPLE_MODEL(NSYM, _encodeSymbol)(&run_model[rctx], &rc, c);
-	    run -= c;
-
-	    if (rctx == last)
-		rctx = 256;
-	    else
-		rctx += (rctx < NSYM-1);
-	    if (c == MAX_RUN-1 && run == 0)
-		SIMPLE_MODEL(NSYM, _encodeSymbol)(&run_model[rctx], &rc, 0);
-	} while (run);
-    }
-
-    RC_FinishEncode(&rc);
-
-    // Finalise block size and return it
-    *out_size = RC_OutSize(&rc)+1;
-
-    //fprintf(stderr, "RLE %d to %d\n", in_size, *out_size);
-
-    return out;
-}
-
-static
-unsigned char *arith_uncompress_O0_RLE(unsigned char *in, unsigned int in_size,
-				       unsigned char *out, unsigned int out_sz) {
-    RangeCoder rc;
-    int i;
-    unsigned int m = in[0] ? in[0] : 256;
-
-    SIMPLE_MODEL(256,_) byte_model;
-    SIMPLE_MODEL(256,_init)(&byte_model, m);
-
-    SIMPLE_MODEL(NSYM,_) run_model[NSYM];
-    for (i = 0; i < NSYM; i++)
-	SIMPLE_MODEL(NSYM,_init)(&run_model[i], MAX_RUN);
-
-    if (!out)
-	out = malloc(out_sz);
-    if (!out)
-	return NULL;
-
-    RC_SetInput(&rc, (char *)in+1, (char *)in+in_size);
-    RC_StartDecode(&rc);
-
-    for (i = 0; i < out_sz; i++) {
-	unsigned char last;
-	last = out[i] = SIMPLE_MODEL(256, _decodeSymbol)(&byte_model, &rc);
-	//fprintf(stderr, "lit %c\n", last);
-	int run = 0, r = 0, rctx = out[i];
-	do {
-	    r = SIMPLE_MODEL(NSYM, _decodeSymbol)(&run_model[rctx], &rc);
-	    if (rctx == last)
-		rctx = 256;
-	    else
-		rctx += (rctx < NSYM-1);
-	    //fprintf(stderr, "run %d (ctx %d, %d)\n", r, last, l);
-	    run += r;
-	} while (r == MAX_RUN-1 && run < out_sz);
-	while (run-- && i+1 < out_sz)
-	    out[++i] = last;
-    }
-
-    RC_FinishDecode(&rc);
-
-    return out;
-}
-
-static
-unsigned char *arith_compress_O1_RLE(unsigned char *in, unsigned int in_size,
-				     unsigned char *out, unsigned int *out_size) {
-    int i, bound = arith_compress_bound(in_size,0)-5; // -5 for order/size
-
-    if (!out) {
-	*out_size = bound;
-	out = malloc(*out_size);
-    }
-    if (!out || bound > *out_size)
-	return NULL;
-
-    unsigned int m = 0;
-    for (i = 0; i < in_size; i++)
-	if (m < in[i])
-	    m = in[i];
-    m++;
-    *out = m;
-
-    //SIMPLE_MODEL(256,_) byte_model;
-    //SIMPLE_MODEL(256,_init)(&byte_model, m);
-
-    SIMPLE_MODEL(256,_) byte_model[256];
-    for (i = 0; i < 256; i++)
-	SIMPLE_MODEL(256,_init)(&byte_model[i], m);
-
-    SIMPLE_MODEL(NSYM,_) run_model[NSYM];
-    for (i = 0; i < NSYM; i++)
-	SIMPLE_MODEL(NSYM,_init)(&run_model[i], MAX_RUN);
-
-    RangeCoder rc;
-    RC_SetOutput(&rc, (char *)out+1);
-    RC_StartEncode(&rc);
-
-    unsigned char last = 0;
-    for (i = 0; i < in_size;) {
-	//SIMPLE_MODEL(256, _encodeSymbol)(&byte_model, &rc, in[i]);
-	SIMPLE_MODEL(256, _encodeSymbol)(&byte_model[last], &rc, in[i]);
-	//fprintf(stderr, "lit %c (ctx %c)\n", in[i], last);
-	int run = 0;
-	last = in[i++];
-	while (i < in_size && in[i] == last/* && run < MAX_RUN-1*/)
-	    run++, i++;
-	int rctx = last;
-	do {
-	    int c = run < MAX_RUN ? run : MAX_RUN-1;
-	    SIMPLE_MODEL(NSYM, _encodeSymbol)(&run_model[rctx], &rc, c);
-	    run -= c;
-
-	    if (rctx == last)
-		rctx = 256;
-	    else
-		rctx += (rctx < NSYM-1);
-	    if (c == MAX_RUN-1 && run == 0)
-		SIMPLE_MODEL(NSYM, _encodeSymbol)(&run_model[rctx], &rc, 0);
-	} while (run);
-    }
-
-    RC_FinishEncode(&rc);
-
-    // Finalise block size and return it
-    *out_size = RC_OutSize(&rc)+1;
-
-    //fprintf(stderr, "RLE %d to %d\n", in_size, *out_size);
-
-    return out;
-}
-
-static
-unsigned char *arith_uncompress_O1_RLE(unsigned char *in, unsigned int in_size,
-				       unsigned char *out, unsigned int out_sz) {
-    RangeCoder rc;
-    int i;
-    unsigned int m = in[0] ? in[0] : 256;
-
-    SIMPLE_MODEL(256,_) byte_model[256];
-    for (i = 0; i < 256; i++)
-	SIMPLE_MODEL(256,_init)(&byte_model[i], m);
-
-    SIMPLE_MODEL(NSYM,_) run_model[NSYM];
-    for (i = 0; i < NSYM; i++)
-	SIMPLE_MODEL(NSYM,_init)(&run_model[i], MAX_RUN);
-
-    if (!out)
-	out = malloc(out_sz);
-    if (!out)
-	return NULL;
-
-    RC_SetInput(&rc, (char *)in+1, (char *)in+in_size);
-    RC_StartDecode(&rc);
-
-    unsigned char last = 0;
-    for (i = 0; i < out_sz; i++) {
-	out[i] = SIMPLE_MODEL(256, _decodeSymbol)(&byte_model[last], &rc);
-	//fprintf(stderr, "lit %c (ctx %c)\n", out[i], last);
-	last = out[i];
-	int run = 0, r = 0, rctx = last;
-
-	do {
-	    r = SIMPLE_MODEL(NSYM, _decodeSymbol)(&run_model[rctx], &rc);
-	    if (rctx == last)
-		rctx = 256;
-	    else
-		rctx += (rctx < NSYM-1);
-	    run += r;
-	} while (r == MAX_RUN-1 && run < out_sz);
-	while (run-- && i+1 < out_sz)
-	    out[++i] = last;
-    }
-
-    RC_FinishDecode(&rc);
-
-    return out;
-}
-
-/*-----------------------------------------------------------------------------
- * Simple interface to the order-0 vs order-1 encoders and decoders.
- *
- * Smallest is method, <in_size> <input>, so worst case 2 bytes longer.
- */
-unsigned char *arith_compress_to(unsigned char *in,  unsigned int in_size,
-				 unsigned char *out, unsigned int *out_size,
-				 int order) {
-    unsigned int c_meta_len;
-    uint8_t *rle = NULL, *packed = NULL;
-
-    if (!out) {
-	*out_size = arith_compress_bound(in_size, order);
-	if (!(out = malloc(*out_size)))
-	    return NULL;
-    }
-    unsigned char *out_end = out + *out_size;
-
-    if (in_size <= 20)
-	order &= ~X_STRIPE;
-
-    if (order & X_CAT) {
-	out[0] = X_CAT;
-	c_meta_len = 1 + var_put_u32(&out[1], out_end, in_size);
-	memcpy(out+c_meta_len, in, in_size);
-	*out_size = in_size+c_meta_len;
-    }
-
-    if (order & X_STRIPE) {
-	int N = (order>>8);
-	if (N == 0) N = 4; // default for compatibility with old tests
-
-	if (N > 255)
-	    return NULL;
-
-	unsigned char *transposed = malloc(in_size);
-	unsigned int part_len[256];
-	unsigned int idx[256];
-	if (!transposed)
-	    return NULL;
-	int i, j, x;
-
-	for (i = 0; i < N; i++) {
-	    part_len[i] = in_size / N + ((in_size % N) > i);
-	    idx[i] = i ? idx[i-1] + part_len[i-1] : 0; // cumulative index
-	}
-
-	for (i = x = 0; i < in_size-N; i += N, x++) {
-	    for (j = 0; j < N; j++)
-		transposed[idx[j]+x] = in[i+j];
-	}
-	for (; i < in_size; i += N, x++) {
-	    for (j = 0; i+j < in_size; j++)
-		transposed[idx[j]+x] = in[i+j];
-	}
-
-	unsigned int olen2;
-	unsigned char *out2, *out2_start;
-	c_meta_len = 1;
-	*out = order & ~X_NOSZ;
-	c_meta_len += var_put_u32(out+c_meta_len, out_end, in_size);
-	out[c_meta_len++] = N;
-
-	out2_start = out2 = out+2+5*N; // shares a buffer with c_meta
-        for (i = 0; i < N; i++) {
-	    // Brute force try all methods.
-	    // FIXME: optimise this bit.  Maybe learn over time?
-	    int j, best_j = 0, best_sz = INT_MAX;
-
-	    // Works OK with read names. The first byte is the most important,
-	    // as it has most variability (little-endian).  After that it's
-	    // often quite predictable.
-	    //
-	    // Do we gain in any other context in CRAM? Aux tags maybe?
-	    int m[][4] = {{3, 1,64,0},
-			  {2, 1,0},
-			  {2, 1,128},
-			  {2, 1,128}};
-
-//	    int m[][6] = {{4, 1,64,2,0},  //test of adding in an order-2 codec
-//			  {3, 1,2,0},
-//			  {3, 1,2,128},
-//			  {3, 1,2,128}};
-
-// Other possibilities for methods to try.
-//	    int m[][10] = {{8, 1,128,129,64,65,192,193,4,0},
-//			   {8, 1,128,129,64,65,192,193,4,0},
-//			   {8, 1,128,129,64,65,192,193,4,0},
-//			   {8, 1,128,129,64,65,192,193,4,0}};
-
-//	    int m[][9] = {{5, 1,128,64,65,0},
-//			  {5, 1,128,64,65,0},
-//			  {5, 1,128,64,65,0},
-//			  {5, 1,128,64,65,0}};
-
-//	    int m[][6] = {{4, 0,1,128,64},
-//			  {5, 0,1,128,65,193},
-//			  {3, 0,1,128},
-//			  {3, 0,1,128}};
-
-//	    int m[][6] = {{4, 1,128,64,0},
-//			  {4, 1,128,65,0},
-//			  {2, 128,0},
-//			  {2, 128,0}};
-
-//	    int m[][6] = {{2, 64,0},
-//			  {1, 0},
-//			  {1, 128},
-//			  {1, 128}};
-
-//	    int m[][6] = {{1, 0},
-//			  {2, 128,0},
-//			  {1, 128},
-//			  {1, 128}};
-
-	    for (j = 1; j <= m[MIN(i,3)][0]; j++) {
-		olen2 = *out_size - (out2 - out);
-		//fprintf(stderr, "order=%d m=%d\n", order&3, m[MIN(i,4)][j]);
-		if ((order&3) == 0 && (m[MIN(i,3)][j]&1))
-		    continue;
-
-                arith_compress_to(transposed+idx[i], part_len[i],
-				  out2, &olen2, m[MIN(i,3)][j] | X_NOSZ);
-		if (best_sz > olen2) {
-		    best_sz = olen2;
-		    best_j = j;
-		}
-	    }
-//	    if (best_j == 0) // none desireable
-//		return NULL;
-	    if (best_j != j-1) {
-		olen2 = *out_size - (out2 - out);
-		arith_compress_to(transposed+idx[i], part_len[i],
-				  out2, &olen2, m[MIN(i,3)][best_j] | X_NOSZ);
-	    }
-	    out2 += olen2;
-	    c_meta_len += var_put_u32(out+c_meta_len, out_end, olen2);
-	}
-	memmove(out+c_meta_len, out2_start, out2-out2_start);
-	free(transposed);
-	*out_size = c_meta_len + out2-out2_start;
-	return out;
-    }
-
-    int do_pack = order & X_PACK;
-    int do_rle  = order & X_RLE;
-    int no_size = order & X_NOSZ;
-    int do_ext  = order & X_EXT;
-
-    out[0] = order;
-    c_meta_len = 1;
-
-    if (!no_size)
-	c_meta_len += var_put_u32(&out[1], out_end, in_size);
-
-    order &= 0x3;
-
-    // Format is compressed meta-data, compressed data.
-    // Meta-data can be empty, pack, rle lengths, or pack + rle lengths.
-    // Data is either the original data, bit-packed packed, rle literals or
-    // packed + rle literals.
-
-    if (do_pack && in_size) {
-	// PACK 2, 4 or 8 symbols into one byte.
-	int pmeta_len;
-	uint64_t packed_len;
-	packed = hts_pack(in, in_size, out+c_meta_len, &pmeta_len, &packed_len);
-	if (!packed || (pmeta_len == 1 && out[c_meta_len] > 16)) {
-	    out[0] &= ~X_PACK;
-	    do_pack = 0;
-	    free(packed);
-	    packed = NULL;
-	} else {
-	    in = packed;
-	    in_size = packed_len;
-	    c_meta_len += pmeta_len;
-
-	    // Could derive this rather than storing verbatim.
-	    // Orig size * 8/nbits (+1 if not multiple of 8/n)
-	    int sz = var_put_u32(out+c_meta_len, out_end, in_size);
-	    c_meta_len += sz;
-	    *out_size -= sz;
-	}
-    } else if (do_pack) {
-	out[0] &= ~X_PACK;
-    }
-
-    if (do_rle && !in_size) {
-	out[0] &= ~X_RLE;
-    }
-
-    *out_size -= c_meta_len;
-    if (order && in_size < 8) {
-	out[0] &= ~3;
-	order  &= ~3;
-    }
-
-    if (do_ext) {
-	// Use an external compression library instead.
-	// For now, bzip2
-#ifdef HAVE_LIBBZ2
-	if (BZ_OK != BZ2_bzBuffToBuffCompress((char *)out+c_meta_len, out_size,
-					      (char *)in, in_size, 9, 0, 30))
-	    *out_size = in_size; // Didn't fit with bz2; force X_CAT below instead
-#else
-	fprintf(stderr, "Htscodecs has been compiled without libbz2 support\n");
-	free(out);
-	return NULL;
-#endif
-
-//      // lzma doesn't help generally, at least not for the name tokeniser
-//	size_t lzma_size = 0;
-//	lzma_easy_buffer_encode(9, LZMA_CHECK_CRC32, NULL,
-//				in, in_size, out+c_meta_len, &lzma_size,
-//				*out_size);
-//	*out_size = lzma_size;
-
-    } else {
-	if (do_rle) {
-	    if (order == 0)
-		arith_compress_O0_RLE(in, in_size, out+c_meta_len, out_size);
-	    else
-		arith_compress_O1_RLE(in, in_size, out+c_meta_len, out_size);
-	} else {
-	    //if (order == 2)
-	    //	arith_compress_O2(in, in_size, out+c_meta_len, out_size);
-	    //else
-	    if (order == 1)
-		arith_compress_O1(in, in_size, out+c_meta_len, out_size);
-	    else
-		arith_compress_O0(in, in_size, out+c_meta_len, out_size);
-	}
-    }
-
-    if (*out_size >= in_size) {
-	out[0] &= ~(3|X_EXT); // no entropy encoding, but keep e.g. PACK
-	out[0] |= X_CAT | no_size;
-	memcpy(out+c_meta_len, in, in_size);
-	*out_size = in_size;
-    }
-
-    free(rle);
-    free(packed);
-
-    *out_size += c_meta_len;
-
-    return out;
-}
-
-unsigned char *arith_compress(unsigned char *in, unsigned int in_size,
-			      unsigned int *out_size, int order) {
-    return arith_compress_to(in, in_size, NULL, out_size, order);
-}
-
-unsigned char *arith_uncompress_to(unsigned char *in,  unsigned int in_size,
-				   unsigned char *out, unsigned int *out_size) {
-    unsigned char *in_end = in + in_size;
-    unsigned char *out_free = NULL;
-    unsigned char *tmp_free = NULL;
-
-    if (in_size == 0)
-	return NULL;
-
-    if (*in & X_STRIPE) {
-	unsigned int ulen, olen, c_meta_len = 1;
-	int i;
-	uint64_t clen_tot = 0;
-
-	// Decode lengths
-	c_meta_len += var_get_u32(in+c_meta_len, in_end, &ulen);
-	if (c_meta_len >= in_size)
-	    return NULL;
-	unsigned int N = in[c_meta_len++];
-	unsigned int clenN[256], ulenN[256], idxN[256];
-	if (!out) {
-	    if (ulen >= INT_MAX)
-		return NULL;
-	    if (!(out_free = out = malloc(ulen))) {
-		return NULL;
-	    }
-	    *out_size = ulen;
-	}
-	if (ulen != *out_size) {
-	    free(out_free);
-	    return NULL;
-	}
-
-	for (i = 0; i < N; i++) {
-	    ulenN[i] = ulen / N + ((ulen % N) > i);
-	    idxN[i] = i ? idxN[i-1] + ulenN[i-1] : 0;
-	    c_meta_len += var_get_u32(in+c_meta_len, in_end, &clenN[i]);
-	    clen_tot += clenN[i];
-	    if (c_meta_len > in_size || clenN[i] > in_size || clenN[i] < 1) {
-		free(out_free);
-		return NULL;
-	    }
-	}
-
-	// We can call this with a larger buffer, but once we've determined
-	// how much we really use we limit it so the recursion becomes easier
-	// to limit.
-	if (c_meta_len + clen_tot > in_size) {
-	    free(out_free);
-	    return NULL;
-	}
-	in_size = c_meta_len + clen_tot;
-
-	//fprintf(stderr, "    stripe meta %d\n", c_meta_len); //c-size
-
-	// Uncompress the N streams
-	unsigned char *outN = malloc(ulen);
-	if (!outN) {
-	    free(out_free);
-	    return NULL;
-	}
-	for (i = 0; i < N; i++) {
-	    olen = ulenN[i];
-	    if (in_size < c_meta_len) {
-		free(out_free);
-		free(outN);
-		return NULL;
-	    }
-	    if (!arith_uncompress_to(in+c_meta_len, in_size-c_meta_len, outN + idxN[i], &olen)
-		|| olen != ulenN[i]) {
-		free(out_free);
-		free(outN);
-		return NULL;
-	    }
-	    c_meta_len += clenN[i];
-	}
-
-	unstripe(out, outN, ulen, N, idxN);
-
-	free(outN);
-	*out_size = ulen;
-	return out;
-    }
-
-    int order = *in++;  in_size--;
-    int do_pack = order & X_PACK;
-    int do_rle  = order & X_RLE;
-    int do_cat  = order & X_CAT;
-    int no_size = order & X_NOSZ;
-    int do_ext  = order & X_EXT;
-    order &= 3;
-
-    int sz = 0;
-    unsigned int osz;
-    if (!no_size)
-	sz = var_get_u32(in, in_end, &osz);
-    else
-	sz = 0, osz = *out_size;
-    in += sz;
-    in_size -= sz;
-
-    if (osz >= INT_MAX)
-	return NULL;
-
-#ifdef FUZZING_BUILD_MODE_UNSAFE_FOR_PRODUCTION
-	// Limit maximum size to get fast turnaround on fuzzing test cases
-	if (osz > 100000)
-	    goto err;
-#endif
-
-    if (no_size && !out)
-	return NULL; // Need one or the other
-
-    if (!out) {
-	*out_size = osz;
-	if (!(out_free = out = malloc(*out_size)))
-	    return NULL;
-    } else {
-	if (*out_size < osz)
-	    return NULL;
-	*out_size = osz;
-    }
-
-    uint32_t c_meta_size = 0;
-    unsigned int tmp1_size = *out_size;
-    unsigned int tmp2_size = *out_size;
-    unsigned char *tmp1 = NULL, *tmp2 = NULL, *tmp = NULL;
-
-    // Need In, Out and Tmp buffers with temporary buffer of the same size
-    // as output.  Our entropy decode is either arithmetic (with/without RLE)
-    // or external (bz2, gzip, lzma) but with an optional unPACK transform
-    // at the end.
-    //
-    // To avoid pointless memcpy when unpacking we switch around which
-    // buffers we're writing to accordingly.
-
-    // Format is pack meta data if present, followed by compressed data.
-    if (do_pack) {
-	if (!(tmp_free = tmp = malloc(*out_size)))
-	    goto err;
-	tmp1 = tmp;  // uncompress
-	tmp2 = out;  // unpack
-    } else {
-	// no pack
-	tmp  = NULL;
-	tmp1 = out;  // uncompress
-	tmp2 = out;  // NOP
-    }
-
-    
-    // Decode the bit-packing map.
-    uint8_t map[16] = {0};
-    int npacked_sym = 0;
-    uint64_t unpacked_sz = 0; // FIXME: rename to packed_per_byte
-    if (do_pack) {
-	c_meta_size = hts_unpack_meta(in, in_size, *out_size, map, &npacked_sym);
-	if (c_meta_size == 0)
-	    goto err;
-
-	unpacked_sz = osz;
-	in      += c_meta_size;
-	in_size -= c_meta_size;
-
-	// New unpacked size.  We could derive this bit from *out_size
-	// and npacked_sym.
-	unsigned int osz;
-	sz = var_get_u32(in, in_end, &osz);
-	in += sz;
-	in_size -= sz;
-	if (osz > tmp1_size)
-	    goto err;
-	tmp1_size = osz;
-    }
-
-    //fprintf(stderr, "    meta_size %d bytes\n", (int)(in - orig_in)); //c-size
-
-    // uncompress RLE data.  in -> tmp1
-    if (in_size) {
-#ifdef FUZZING_BUILD_MODE_UNSAFE_FOR_PRODUCTION
-	// Limit maximum size to get fast turnaround on fuzzing test cases
-	if (tmp1_size > 100000)
-	    goto err;
-#endif
-	if (do_cat) {
-	    //fprintf(stderr, "    CAT %d\n", tmp1_size); //c-size
-	    if (tmp1_size > in_size)
-		goto err;
-	    if (tmp1_size > *out_size)
-		goto err;
-	    memcpy(tmp1, in, tmp1_size);
-	} else if (do_ext) {
-#ifdef HAVE_LIBBZ2
-	    if (BZ_OK != BZ2_bzBuffToBuffDecompress((char *)tmp1, &tmp1_size,
-						    (char *)in, in_size, 0, 0))
-		goto err;
-#else
-	    fprintf(stderr, "Htscodecs has been compiled without libbz2 support\n");
-	    goto err;
-#endif
-	  } else {
-	    // in -> tmp1
-	    if (do_rle) {
-		tmp1 = order == 1
-		    ? arith_uncompress_O1_RLE(in, in_size, tmp1, tmp1_size)
-		    : arith_uncompress_O0_RLE(in, in_size, tmp1, tmp1_size);
-	    } else {
-		//if (order == 2)
-		//    tmp1 = arith_uncompress_O2(in, in_size, tmp1, tmp1_size)
-		//else
-		tmp1 = order == 1
-		    ? arith_uncompress_O1(in, in_size, tmp1, tmp1_size)
-		    : arith_uncompress_O0(in, in_size, tmp1, tmp1_size);
-	    }
-	    if (!tmp1)
-		goto err;
-	}
-    } else {
-	tmp1 = NULL;
-	tmp1_size = 0;
-    }
-
-    if (do_pack) {
-	// Unpack bits via pack-map.  tmp1 -> tmp2
-	if (npacked_sym == 1)
-	    unpacked_sz = tmp1_size;
-	//uint8_t *porig = unpack(tmp2, tmp2_size, unpacked_sz, npacked_sym, map);
-	//memcpy(tmp3, porig, unpacked_sz);
-	if (!hts_unpack(tmp1, tmp1_size, tmp2, unpacked_sz, npacked_sym, map))
-	    goto err;
-	tmp2_size = unpacked_sz;
-    } else {
-	tmp2_size = tmp1_size;
-    }
-
-    if (tmp)
-	free(tmp);
-
-    *out_size = tmp2_size;
-    return tmp2;
-
- err:
-    free(tmp_free);
-    free(out_free);
-    return NULL;
-}
-
-unsigned char *arith_uncompress(unsigned char *in, unsigned int in_size,
-				unsigned int *out_size) {
-    return arith_uncompress_to(in, in_size, NULL, out_size);
-}
diff -ruN stringtie.orig/htslib/htscodecs/htscodecs/arith_dynamic.h stringtie/htslib/htscodecs/htscodecs/arith_dynamic.h
--- stringtie.orig/htslib/htscodecs/htscodecs/arith_dynamic.h	2024-02-28 13:57:39.701246126 +0100
+++ stringtie/htslib/htscodecs/htscodecs/arith_dynamic.h	1970-01-01 01:00:00.000000000 +0100
@@ -1,60 +0,0 @@
-/*
- * Copyright (c) 2019 Genome Research Ltd.
- * Author(s): James Bonfield
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions are met:
- *
- *    1. Redistributions of source code must retain the above copyright notice,
- *       this list of conditions and the following disclaimer.
- *
- *    2. Redistributions in binary form must reproduce the above
- *       copyright notice, this list of conditions and the following
- *       disclaimer in the documentation and/or other materials provided
- *       with the distribution.
- *
- *    3. Neither the names Genome Research Ltd and Wellcome Trust Sanger
- *       Institute nor the names of its contributors may be used to endorse
- *       or promote products derived from this software without specific
- *       prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY GENOME RESEARCH LTD AND CONTRIBUTORS "AS
- * IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
- * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
- * PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL GENOME RESEARCH
- * LTD OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
- * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
- * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
- * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
- * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
- * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
- * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- */
-
-#ifndef ARITH_DYNAMIC_H
-#define ARITH_DYNAMIC_H
-
-#ifdef __cplusplus
-extern "C" {
-#endif
-
-unsigned char *arith_compress(unsigned char *in, unsigned int in_size,
-			      unsigned int *out_size, int order);
-
-unsigned char *arith_uncompress(unsigned char *in, unsigned int in_size,
-				unsigned int *out_size);
-
-unsigned char *arith_compress_to(unsigned char *in,  unsigned int in_size,
-				 unsigned char *out, unsigned int *out_size,
-				 int order);
-
-unsigned char *arith_uncompress_to(unsigned char *in, unsigned int in_size,
-				   unsigned char *out, unsigned int *out_sz);
-
-unsigned int arith_compress_bound(unsigned int size, int order);
-
-#ifdef __cplusplus
-}
-#endif
-
-#endif /* ARITH_DYNAMIC_H */
diff -ruN stringtie.orig/htslib/htscodecs/htscodecs/c_range_coder.h stringtie/htslib/htscodecs/htscodecs/c_range_coder.h
--- stringtie.orig/htslib/htscodecs/htscodecs/c_range_coder.h	2024-02-28 13:57:39.701246126 +0100
+++ stringtie/htslib/htscodecs/htscodecs/c_range_coder.h	1970-01-01 01:00:00.000000000 +0100
@@ -1,129 +0,0 @@
-// Copyright Eugene Shelwien.
-// Release into public domain.
-
-// Modifications by James Bonfield (2019)
-
-
-/*
- * Note it is up to the calling code to ensure that no overruns on input and
- * output buffers occur.
- *
- * Call the input() and output() functions to set and query the current
- * buffer locations.
- *
-
- */
-
-#ifndef C_RANGER_CODER_H
-#define C_RANGER_CODER_H
-
-#define  DO(n)	   int _;for (_=0; _<n; _++)
-#define  TOP	   (1<<24)
-#define  Thres (unsigned)255*TOP
-
-typedef unsigned char uc;
-
-typedef struct {
-    uint32_t low, code, range;
-    uint32_t FFNum;  // Number of consecutive FFs
-    uint32_t Cache;  // Top 8-bits of low ready to emit
-    uint32_t Carry;  // Flag to indicate if we emit Cache or Cache+1
-    uc *in_buf;
-    uc *out_buf;
-    uc *in_end;
-} RangeCoder;
-
-static inline void RC_SetInput(RangeCoder *rc, char *in, char *in_end) {
-    rc->out_buf = rc->in_buf = (uc *)in;
-    rc->in_end = (uc *)in_end;
-}
-static inline void RC_SetOutput(RangeCoder *rc, char *out) { rc->in_buf = rc->out_buf = (uc *)out; }
-static inline char *RC_GetInput(RangeCoder *rc) { return (char *)rc->in_buf; }
-static inline char *RC_GetOutput(RangeCoder *rc) { return (char *)rc->out_buf; }
-static inline size_t RC_OutSize(RangeCoder *rc) { return rc->out_buf - rc->in_buf; }
-static inline size_t RC_InSize(RangeCoder *rc) { return rc->in_buf - rc->out_buf; }
-
-static inline void RC_StartEncode(RangeCoder *rc)
-{ 
-    rc->range = 0xFFFFFFFF;
-    rc->low   = 0;
-    rc->FFNum = 0;
-    rc->Carry = 0;
-    rc->Cache = 0;
-    rc->code  = 0;
-}
-
-static inline void RC_StartDecode(RangeCoder *rc)
-{ 
-    rc->range = 0xFFFFFFFF;
-    rc->low   = 0;
-    rc->FFNum = 0;
-    rc->Carry = 0;
-    rc->Cache = 0;
-    rc->code  = 0;
-    if (rc->in_buf+5 >= rc->in_end) {
-        rc->in_buf = rc->in_end; // prevent decode
-        return;
-    }
-    DO(5) rc->code = (rc->code<<8) | *rc->in_buf++;
-}
-
-static inline void RC_ShiftLow(RangeCoder *rc) {
-    if (rc->low < Thres || rc->Carry) {
-	*rc->out_buf++ = rc->Cache + rc->Carry;
-
-	// Flush any stored FFs
-	while (rc->FFNum) {
-	    *rc->out_buf++ = rc->Carry-1; // (Carry-1)&255;
-	    rc->FFNum--;
-	}
-
-	// Take copy of top byte ready for next flush
-	rc->Cache = rc->low >> 24;
-	rc->Carry = 0;
-    } else {
-	// Low if FFxx xxxx.  Bump FF count and shift in as before
-	rc->FFNum++;
-    }
-    rc->low = rc->low<<8;
-}
-
-static inline void RC_FinishEncode(RangeCoder *rc) 
-{ 
-    DO(5) RC_ShiftLow(rc);
-}
-
-static inline void RC_FinishDecode(RangeCoder *rc) {}
-
-static inline void RC_Encode (RangeCoder *rc, uint32_t cumFreq, uint32_t freq, uint32_t totFreq) 
-{
-    uint32_t tmp = rc->low;
-    rc->low  += cumFreq * (rc->range/= totFreq);
-    rc->range*= freq;
-
-    rc->Carry += rc->low<tmp; // Overflow
-
-    while (rc->range < TOP) {
-	rc->range <<= 8;
-	RC_ShiftLow(rc);
-    }
-}
-
-static inline uint32_t RC_GetFreq (RangeCoder *rc, uint32_t totFreq) {
-    //return rc->code/(rc->range/=totFreq);
-    return (totFreq && rc->range >= totFreq) ? rc->code/(rc->range/=totFreq) : 0;
-}
-
-static inline void RC_Decode (RangeCoder *rc, uint32_t cumFreq, uint32_t freq, uint32_t totFreq) 
-{
-    rc->code -= cumFreq * rc->range;
-    rc->range *= freq;
-    while (rc->range < TOP) {
-        if (rc->in_buf >= rc->in_end)
-            return; // FIXME: could signal error, instead of caller just generating nonsense
-	rc->code = (rc->code<<8) + *rc->in_buf++;
-	rc->range <<= 8;
-    }
-}
-
-#endif /* C_RANGER_CODER_H */
diff -ruN stringtie.orig/htslib/htscodecs/htscodecs/c_simple_model.h stringtie/htslib/htscodecs/htscodecs/c_simple_model.h
--- stringtie.orig/htslib/htscodecs/htscodecs/c_simple_model.h	2024-02-28 13:57:39.701246126 +0100
+++ stringtie/htslib/htscodecs/htscodecs/c_simple_model.h	1970-01-01 01:00:00.000000000 +0100
@@ -1,179 +0,0 @@
-/*
- * Copyright (c) 2012, 2018-2019 Genome Research Ltd.
- * Author(s): James Bonfield
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions are met:
- *
- *    1. Redistributions of source code must retain the above copyright notice,
- *       this list of conditions and the following disclaimer.
- *
- *    2. Redistributions in binary form must reproduce the above
- *       copyright notice, this list of conditions and the following
- *       disclaimer in the documentation and/or other materials provided
- *       with the distribution.
- *
- *    3. Neither the names Genome Research Ltd and Wellcome Trust Sanger
- *       Institute nor the names of its contributors may be used to endorse
- *       or promote products derived from this software without specific
- *       prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY GENOME RESEARCH LTD AND CONTRIBUTORS "AS
- * IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
- * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
- * PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL GENOME RESEARCH
- * LTD OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
- * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
- * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
- * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
- * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
- * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
- * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- */
-
-#include <stdint.h>
-#include "c_range_coder.h"
-
-/*
- *--------------------------------------------------------------------------
- * A simple frequency model.
- *
- * Define NSYM to be an integer value before including this file.
- * It will then generate types and functions specific to that
- * maximum number of symbols.
- *
- * This keeps a list of symbols and their frequencies, approximately
- * sorted by symbol frequency. We allow for a single symbol to periodically
- * move up the list when emitted, effectively doing a single step of
- * bubble sort periodically. This means it's largely the same complexity
- * irrespective of alphabet size.
- * It's more efficient on strongly biased distributions than random data.
- *
- * There is no escape symbol, so the model is tailored to relatively
- * stationary samples (although we do have occasional normalisation to
- * avoid frequency counters getting too high).
- *--------------------------------------------------------------------------
- */
-
-//-----------------------------------------------------------------------------
-// Bits we want included once only - constants, types, etc
-#ifndef C_SIMPLE_MODEL_H
-#define C_SIMPLE_MODEL_H
-
-#define MAX_FREQ (1<<16)-17
-#define PASTE3(a,b,c) a##b##c
-#define SIMPLE_MODEL(a,b) PASTE3(SIMPLE_MODEL,a,b)
-#define STEP 16
-typedef struct {
-    uint16_t Freq;
-    uint16_t Symbol;
-} SymFreqs;
-#endif /* C_SIMPLE_MODEL_H */
-
-
-//-----------------------------------------------------------------------------
-// Bits we regenerate for each NSYM value.
-
-typedef struct {
-    uint32_t TotFreq;  // Total frequency
-
-    // Array of Symbols approximately sorted by Freq. 
-    SymFreqs sentinel, F[NSYM+1], terminal;
-} SIMPLE_MODEL(NSYM,_);
-
-
-static inline void SIMPLE_MODEL(NSYM,_init)(SIMPLE_MODEL(NSYM,_) *m, int max_sym) {
-    int i;
-    
-    for (i=0; i<max_sym; i++) {
-	m->F[i].Symbol = i;
-	m->F[i].Freq   = 1;
-    }
-    for (; i<NSYM; i++) {
-	m->F[i].Symbol = i;
-	m->F[i].Freq   = 0;
-    }
-
-    m->TotFreq         = max_sym;
-    m->sentinel.Symbol = 0;
-    m->sentinel.Freq   = MAX_FREQ; // Always first; simplifies sorting.
-    m->terminal.Symbol = 0;
-    m->terminal.Freq   = MAX_FREQ;
-    m->F[NSYM].Freq    = 0; // terminates normalize() loop. See below.
-}
-
-
-static inline void SIMPLE_MODEL(NSYM,_normalize)(SIMPLE_MODEL(NSYM,_) *m) {
-    SymFreqs *s;
-
-    /* Faster than F[i].Freq for 0 <= i < NSYM */
-    m->TotFreq=0;
-    for (s = m->F; s->Freq; s++) {
-	s->Freq -= s->Freq>>1;
-	m->TotFreq += s->Freq;
-    }
-}
-
-#ifdef __SSE__
-#   include <xmmintrin.h>
-#else
-#   define _mm_prefetch(a,b)
-#endif
-
-static inline void SIMPLE_MODEL(NSYM,_encodeSymbol)(SIMPLE_MODEL(NSYM,_) *m,
-                                                    RangeCoder *rc, uint16_t sym) {
-    SymFreqs *s = m->F;
-    uint32_t AccFreq  = 0;
-
-    while (s->Symbol != sym) {
-	AccFreq += s++->Freq;
-        _mm_prefetch((const char *)(s+1), _MM_HINT_T0);
-    }
-
-    RC_Encode(rc, AccFreq, s->Freq, m->TotFreq);
-    s->Freq    += STEP;
-    m->TotFreq += STEP;
-
-    if (m->TotFreq > MAX_FREQ)
-	SIMPLE_MODEL(NSYM,_normalize)(m);
-
-    /* Keep approx sorted */
-    if (s[0].Freq > s[-1].Freq) {
-	SymFreqs t = s[0];
-	s[0] = s[-1];
-	s[-1] = t;
-    }
-}
-
-static inline uint16_t SIMPLE_MODEL(NSYM,_decodeSymbol)(SIMPLE_MODEL(NSYM,_) *m, RangeCoder *rc) {
-    SymFreqs* s = m->F;
-    uint32_t freq = RC_GetFreq(rc, m->TotFreq);
-    uint32_t AccFreq;
-
-    if (freq > MAX_FREQ)
-        return 0; // error
-
-    for (AccFreq = 0; (AccFreq += s->Freq) <= freq; s++)
-        _mm_prefetch((const char *)s, _MM_HINT_T0);
-    if (s - m->F > NSYM)
-        return 0; // error
-
-    AccFreq -= s->Freq;
-
-    RC_Decode(rc, AccFreq, s->Freq, m->TotFreq);
-    s->Freq    += STEP;
-    m->TotFreq += STEP;
-
-    if (m->TotFreq > MAX_FREQ)
-	SIMPLE_MODEL(NSYM,_normalize)(m);
-
-    /* Keep approx sorted */
-    if (s[0].Freq > s[-1].Freq) {
-	SymFreqs t = s[0];
-	s[0] = s[-1];
-	s[-1] = t;
-	return t.Symbol;
-    }
-
-    return s->Symbol;
-}
diff -ruN stringtie.orig/htslib/htscodecs/htscodecs/fqzcomp_qual.c stringtie/htslib/htscodecs/htscodecs/fqzcomp_qual.c
--- stringtie.orig/htslib/htscodecs/htscodecs/fqzcomp_qual.c	2024-02-28 13:57:39.701246126 +0100
+++ stringtie/htslib/htscodecs/htscodecs/fqzcomp_qual.c	1970-01-01 01:00:00.000000000 +0100
@@ -1,1502 +0,0 @@
-/*
- * Copyright (c) 2011-2013, 2018-2019 Genome Research Ltd.
- * Author(s): James Bonfield
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions are met:
- *
- *    1. Redistributions of source code must retain the above copyright notice,
- *       this list of conditions and the following disclaimer.
- *
- *    2. Redistributions in binary form must reproduce the above
- *       copyright notice, this list of conditions and the following
- *       disclaimer in the documentation and/or other materials provided
- *       with the distribution.
- *
- *    3. Neither the names Genome Research Ltd and Wellcome Trust Sanger
- *       Institute nor the names of its contributors may be used to endorse
- *       or promote products derived from this software without specific
- *       prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY GENOME RESEARCH LTD AND CONTRIBUTORS "AS
- * IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
- * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
- * PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL GENOME RESEARCH
- * LTD OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
- * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
- * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
- * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
- * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
- * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
- * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- */
-
-// We use generic maps to turn 0-M into 0-N where N <= M
-// before adding these into the context.  These are used
-// for positions, running-diffs and quality values.
-//
-// This can be used as a simple divisor, eg pos/24 to get
-// 2 bits of positional data for each quarter along a 100bp
-// read, or it can be tailored for specific such as noting
-// the first 5 cycles are poor, then we have stability and
-// a gradual drop off in the last 20 or so.  Perhaps we then
-// map pos 0-4=0, 5-79=1, 80-89=2, 90-99=3.
-//
-// We don't need to specify how many bits of data we are
-// using (2 in the above example), as that is just implicit
-// in the values in the map.  Specify not to use a map simply
-// disables that context type (our map is essentially 0-M -> 0).
-
-// Example of command line usage:
-//
-// f=~/scratch/data/q4
-// cc -Wall -DTEST_MAIN -O3 -g fqzcomp_qual2.c -lm
-// ./a.out $f > /tmp/_ && ./a.out -d < /tmp/_ > /tmp/__ && cmp /tmp/__ $f
-
-#include "config.h"
-
-#include <stdio.h>
-#include <stdlib.h>
-#include <assert.h>
-#include <string.h>
-#include <math.h>
-#include <limits.h>
-#include <ctype.h>
-#include <math.h>
-#include <inttypes.h>
-#include <sys/types.h>
-
-//#define NO_THREADS
-#ifndef NO_THREADS
-#include <pthread.h>
-#endif
-
-#include "fqzcomp_qual.h"
-#include "varint.h"
-
-#define CTX_BITS 16
-#define CTX_SIZE (1<<CTX_BITS)
-
-#ifndef MIN
-#  define MIN(a,b) ((a)<(b)?(a):(b))
-#  define MAX(a,b) ((a)>(b)?(a):(b))
-#endif
-
-#define QMAX 256
-#define QBITS 12
-#define QSIZE (1<<QBITS)
-
-#define NSYM 2
-#include "c_simple_model.h"
-
-#undef NSYM
-#define NSYM QMAX
-//#include "c_escape_model.h"
-#include "c_simple_model.h"
-//#include "c_cdf_model.h"
-//#include "c_cdf16_model.h"
-
-// An array of 0,0,0, 1,1,1,1, 3, 5,5
-// is turned into a run-length of 3x0, 4x1, 0x2, 1x4, 0x4, 2x5,
-// which then becomes 3 4 0 1 0 2.
-//
-// NB: size > 255 therefore means we need to repeatedly read to find
-// the actual run length.
-// Alternatively we could bit-encode instead of byte encode, eg BETA.
-static int store_array(unsigned char *out, unsigned int *array, int size) {
-    unsigned char tmp[2048];
-
-    int i, j, k;
-    for (i = j = k = 0; i < size; j++) {
-	int run_len = i;
-	while (i < size && array[i] == j)
-	    i++;
-	run_len = i-run_len;
-
-	int r;
-	do {
-	    r = MIN(255, run_len);
-	    tmp[k++] = r;
-	    run_len -= r;
-	} while (r == 255);
-    }
-    while (i < size)
-	tmp[k++] = 0, j++;
-
-    // RLE on out.
-    //    1 2 3 3 3 3 3 4 4    5
-    // => 1 2 3 3 +3... 4 4 +0 5
-    int last = -1;
-    for (i = j = 0; j < k; i++) {
-	out[i] = tmp[j++];
-	if (out[i] == last) {
-	    int n = j;
-	    while (j < k && tmp[j] == last)
-		j++;
-	    out[++i] = j-n;
-	} else {
-	    last = out[i];
-	}
-    }
-    k = i;
-
-//    fprintf(stderr, "Store_array %d => %d {", size, k);
-//    for (i = 0; i < k; i++)
-//	fprintf(stderr, "%d,", out[i]);
-//    fprintf(stderr, "}\n");
-    return k;
-}
-
-static int read_array(unsigned char *in, size_t in_size, unsigned int *array, int size) {
-    unsigned char R[1024];
-    int i, j, z, last = -1, nb = 0;
-
-    size = MIN(1024, size);
-
-    // Remove level one of run-len encoding
-    for (i = j = z = 0; z < size && i < in_size; i++) {
-	int run = in[i];
-	R[j++] = run;
-	z += run;
-	if (run == last) {
-	    if (i+1 >= in_size)
-		return -1;
-	    int copy = in[++i];
-	    z += run * copy;
-	    while (copy-- && z < size && j < 1024)
-		R[j++] = run;
-	}
-	if (j >= 1024)
-	    return -1;
-	last = run;
-    }
-    nb = i;
-
-    // Now expand inner level of run-length encoding
-    int R_max = j;
-    for (i = j = z = 0; j < size; i++) {
-	int run_len = 0;
-	int run_part;
-	if (z >= R_max)
-	    return -1;
-	do {
-	    run_part = R[z++];
-	    run_len += run_part;
-	} while (run_part == 255 && z < R_max);
-	if (run_part == 255)
-	    return -1;
-
-	while (run_len && j < size)
-	    run_len--, array[j++] = i;
-    }
-
-    return nb;
-}
-
-// FIXME: how to auto-tune these rather than trial and error?
-// r2 = READ2
-// qa = qual avg (0, 2, 4)
-static int strat_opts[][12] = {
-//   qb  qs pb ps db ds ql sl pl  dl  r2 qa
-    {10, 5, 4,-1, 2, 1, 0, 14, 10, 14, 0,-1}, // basic options (level < 7)
-    {8,  5, 7, 0, 0, 0, 0, 14, 8,  14, 1,-1}, // e.g. HiSeq 2000
-    {12, 6, 2, 0, 2, 3, 0, 9,  12, 14, 0, 0}, // e.g. MiSeq
-    {12, 6, 0, 0, 0, 0, 0, 12, 0,  0,  0, 0}, // e.g. IonTorrent; adaptive O1
-    {0,  0, 0, 0, 0, 0, 0, 0,  0,  0,  0, 0}, // custom
-};
-static int nstrats = sizeof(strat_opts) / sizeof(*strat_opts);
-
-#ifdef __SSE__
-#   include <xmmintrin.h>
-#else
-#   define _mm_prefetch(a,b)
-#endif
-
-typedef struct {
-    unsigned int qctx;  // quality sub-context
-    unsigned int p;     // pos (bytes remaining)
-    unsigned int add_d; // whether to update delta (skip first cycle)
-    unsigned int delta; // delta running total
-    unsigned int prevq; // previous quality
-    unsigned int s;     // selector
-    unsigned int qtot, qlen;
-    unsigned int first_len;
-} fqz_state;
-
-static void dump_table(unsigned int *tab, int size, char *name) {
-    int i, last = -99, run = 0;
-    fprintf(stderr, "\t%s\t{", name);
-    for (i = 0; i < size; i++) {
-	if (tab[i] == last) {
-	    run++;
-	} else if (run == 1 && tab[i] == last+1) {
-	    int first = last;
-	    do {
-		last = tab[i];
-		i++;
-	    } while (i < size && tab[i] == last+1);
-	    i--;
-
-	    // Want 0,1,2,3,3,3 as 0..2 3x3, not 0..3 3x2
-	    if (tab[i] == tab[i+1])
-		i--;
-	    if (tab[i] != first)
-		fprintf(stderr, "..%d", tab[i]);
-	    run = 1;
-	    last = -99;
-	} else {
-	    if (run > 1)
-		fprintf(stderr, " x %d%s%d", run, i?", ":"", tab[i]);
-	    else
-		fprintf(stderr, "%s%d", i?", ":"", tab[i]);
-	    run = 1;
-	    last = tab[i];
-	}
-    }
-    if (run > 1)
-	fprintf(stderr, " x %d", run);
-    fprintf(stderr, "}\n");
-}
-
-static void dump_map(unsigned int *map, int size, char *name) {
-    int i, c = 0;
-    fprintf(stderr, "\t%s\t{", name);
-    for (i = 0; i < size; i++)
-	if (map[i] != INT_MAX)
-	    fprintf(stderr, "%s%d=%d", c++?", ":"", i, map[i]);
-    fprintf(stderr, "}\n");
-}
-
-#pragma GCC diagnostic ignored "-Wunused-function"
-static void dump_params(fqz_gparams *gp) {
-    fprintf(stderr, "Global params = {\n");
-    fprintf(stderr, "\tvers\t%d\n", gp->vers);
-    fprintf(stderr, "\tgflags\t0x%02x\n", gp->gflags);
-    fprintf(stderr, "\tnparam\t%d\n", gp->nparam);
-    fprintf(stderr, "\tmax_sel\t%d\n", gp->max_sel);
-    fprintf(stderr, "\tmax_sym\t%d\n", gp->max_sym);
-    if (gp->gflags & GFLAG_HAVE_STAB)
-	dump_table(gp->stab, 256, "stab");
-    fprintf(stderr, "}\n");
-
-    int i;
-    for (i = 0; i < gp->nparam; i++) {
-	fqz_param *pm = &gp->p[i];
-	fprintf(stderr, "\nParam[%d] = {\n", i);
-	fprintf(stderr, "\tcontext\t0x%04x\n", pm->context);
-	fprintf(stderr, "\tpflags\t0x%02x\n",  pm->pflags);
-	fprintf(stderr, "\tmax_sym\t%d\n",  pm->max_sym);
-	fprintf(stderr, "\tqbits\t%d\n",   pm->qbits);
-	fprintf(stderr, "\tqshift\t%d\n",  pm->qshift);
-	fprintf(stderr, "\tqloc\t%d\n",    pm->qloc);
-	fprintf(stderr, "\tsloc\t%d\n",    pm->sloc);
-	fprintf(stderr, "\tploc\t%d\n",    pm->ploc);
-	fprintf(stderr, "\tdloc\t%d\n",    pm->dloc);
-
-	if (pm->pflags & PFLAG_HAVE_QMAP)
-	    dump_map(pm->qmap, 256, "qmap");
-
-	if (pm->pflags & PFLAG_HAVE_QTAB)
-	    dump_table(pm->qtab, 256, "qtab");
-	if (pm->pflags & PFLAG_HAVE_PTAB)
-	    dump_table(pm->ptab, 1024, "ptab");
-	if (pm->pflags & PFLAG_HAVE_DTAB)
-	    dump_table(pm->dtab, 256, "dtab");
-	fprintf(stderr, "}\n");
-    }
-}
-
-typedef struct {
-    SIMPLE_MODEL(QMAX,_) *qual;
-    SIMPLE_MODEL(256,_)   len[4];
-    SIMPLE_MODEL(2,_)     revcomp;
-    SIMPLE_MODEL(256,_)   sel;
-    SIMPLE_MODEL(2,_)     dup;
-} fqz_model;
-
-#ifndef NO_THREADS
-/*
- * Thread local storage, used to avoid repeated malloc/free calls.
- */
-pthread_once_t fqz_once = PTHREAD_ONCE_INIT;
-pthread_key_t fqz_key;
-
-static void fqz_tls_init(void) {
-    pthread_key_create(&fqz_key, free);
-}
-#endif
-
-static int fqz_create_models(fqz_model *m, fqz_gparams *gp) {
-    int i;
-
-#ifndef NO_THREADS
-    pthread_once(&fqz_once, fqz_tls_init);
-
-    m->qual = pthread_getspecific(fqz_key);
-
-    if (!m->qual) {
-        if (!(m->qual = malloc(sizeof(*m->qual) * CTX_SIZE)))
-	    return -1;
-	pthread_setspecific(fqz_key, m->qual);
-    }
-#else
-    if (!(m->qual = malloc(sizeof(*m->qual) * CTX_SIZE)))
-	return -1;
-#endif
-
-    for (i = 0; i < CTX_SIZE; i++)
-	SIMPLE_MODEL(QMAX,_init)(&m->qual[i], gp->max_sym+1);
-
-    for (i = 0; i < 4; i++)
-	SIMPLE_MODEL(256,_init)(&m->len[i],256);
-
-    SIMPLE_MODEL(2,_init)(&m->revcomp,2);
-    SIMPLE_MODEL(2,_init)(&m->dup,2);
-    if (gp->max_sel > 0)
-	SIMPLE_MODEL(256,_init)(&m->sel, gp->max_sel+1);
-
-    return 0;
-}
-
-static void fqz_destroy_models(fqz_model *m) {
-#ifdef NO_THREADS
-    free(m->qual);
-#endif
-}
-
-static inline unsigned int fqz_update_ctx(fqz_param *pm, fqz_state *state, int q) {
-    unsigned int last = 0; // pm->context
-    state->qctx = (state->qctx << pm->qshift) + pm->qtab[q];
-    last += (state->qctx & pm->qmask) << pm->qloc;
-
-    // The final shifts have been factored into the tables already.
-    last += pm->ptab[MIN(1023, state->p)];      // << pm->ploc
-    last += pm->dtab[MIN(255,  state->delta)];  // << pm->dloc
-    last += state->s << pm->sloc;
-
-    // On the fly average is slow work.
-    // However it can be slightly better than using a selector bit
-    // as it's something we can compute on the fly and thus doesn't
-    // consume output bits for storing the selector itself.
-    //
-    // Q4 (novaseq.bam)
-    // qtot+=q*q -DQ1=8.84 -DQ2=8.51 -DQ3=7.70; 7203598 (-0.7%)
-    // qtot+=q   -DQ1=2.96 -DQ2=2.85 -DQ3=2.69; 7207315
-    // vs old delta;                            7255614 (default params)
-    // vs 2 bit selector (no delta)             7203006 (-x 0x8261000e80)
-    // vs 2 bit selector (no delta)             7199153 (-x 0x7270000e70) -0.8%
-    // vs 2 bit selector (no delta)             7219668 (-x 0xa243000ea0)
-    //{
-    //	double qa = state->qtot / (state->qlen+.01);
-    //	//fprintf(stderr, "%f\n", qa);
-    //	int x = 0;
-    //	if (qa>=Q1) x=3;
-    //	else if (qa>=Q2) x=2;
-    //	else if (qa>=Q3) x=1;
-    //	else x=0;
-    //	last += x << pm->dloc; // tmp reuse of delta pos
-    //  state->qtot += q*q;
-    //  state->qlen++;
-    //}
-
-    // Only update delta after 1st base.
-    //state->delta += state->add_d * (state->prevq != q);
-    //state->add_d = 1;
-    state->delta += (state->prevq != q);
-    state->prevq = q;
-
-    state->p--;
-
-    return last & (CTX_SIZE-1);
-}
-
-
-// Build quality stats for qhist and set nsym, do_dedup and do_sel params.
-// One_param is -1 to gather stats on all data, or >= 0 to gather data
-// on one specific selector parameter.  Used only in TEST_MAIN via
-// fqz_manual_parameters at the moment.
-void fqz_qual_stats(fqz_slice *s,
-		    unsigned char *in, size_t in_size,
-		    fqz_param *pm,
-		    uint32_t qhist[256],
-		    int one_param) {
-#define NP 128
-    uint32_t qhistb[NP][256] = {{0}};  // both
-    uint32_t qhist1[NP][256] = {{0}};  // READ1 only
-    uint32_t qhist2[NP][256] = {{0}};  // READ2 only
-    uint64_t t1[NP] = {0};             // Count for READ1
-    uint64_t t2[NP] = {0};             // COUNT for READ2
-    uint32_t avg[2560] = {0};          // Avg qual *and later* avg-to-selector map.
-
-    int dir = 0;
-    int last_len = 0;
-    int do_dedup = 0;
-    size_t rec;
-    size_t i, j;
-    int num_rec = 0;
-
-    // See what info we've been given.
-    // Do we have READ1 / READ2?
-    // Do we have selector hidden in the top bits of flag?
-    int max_sel = 0;
-    int has_r2 = 0;
-    for (rec = 0; rec < s->num_records; rec++) {
-	if (one_param >= 0 && (s->flags[rec] >> 16) != one_param)
-	    continue;
-	num_rec++;
-	if (max_sel < (s->flags[rec] >> 16))
-	    max_sel = (s->flags[rec] >> 16);
-	if (s->flags[rec] & FQZ_FREAD2)
-	    has_r2 = 1;
-    }
-
-    // Dedup detection and histogram stats gathering
-    int *avg_qual = calloc((s->num_records+1), sizeof(int));
-    if (!avg_qual)
-	return;
-
-    rec = i = j = 0;
-    while (i < in_size) {
-	if (one_param >= 0 && (s->flags[rec] >> 16) != one_param) {
-	    avg_qual[rec] = 0;
-	    i += s->len[rec++];
-	    continue;
-	}
-	if (rec < s->num_records) {
-	    j = s->len[rec];
-	    dir = s->flags[rec] & FQZ_FREAD2 ? 1 : 0;
-	    if (i > 0 && j == last_len
-		&& !memcmp(in+i-last_len, in+i, j))
-		do_dedup++; // cache which records are dup?
-	} else {
-	    j = in_size - i;
-	    dir = 0;
-	}
-	last_len = j;
-
-	uint32_t (*qh)[256] = dir ? qhist2 : qhist1;
-	uint64_t *th        = dir ? t2     : t1;
-
-	uint32_t tot = 0;
-	for (; i < in_size && j > 0; i++, j--) {
-	    tot += in[i];
-	    qhist[in[i]]++;
-	    qhistb[j & (NP-1)][in[i]]++;
-	    qh[j & (NP-1)][in[i]]++;
-	    th[j & (NP-1)]++;
-	}
-	tot = last_len ? (tot*10.0)/last_len+.5 : 0;
-
-	avg_qual[rec] = tot;
-	avg[MIN(2559, tot)]++;
-
-	rec++;
-    }
-    pm->do_dedup = ((rec+1)/(do_dedup+1) < 500);
-
-    last_len = 0;
-
-    // Unique symbol count
-    for (i = pm->max_sym = pm->nsym = 0; i < 256; i++) {
-	if (qhist[i])
-	    pm->max_sym = i, pm->nsym++;
-    }
-
-
-    // Auto tune: does average quality helps us?
-    if (pm->do_qa != 0) {
-	// Histogram of average qual in avg[]
-	// NB: we convert avg[] from count to selector index
-
-	// Few symbols means high compression which means
-	// selector bits become more significant fraction.
-	// Reduce selector bits by skewing the distribution
-	// to not be even binning.
-	double qf0 = pm->nsym > 8 ? 0.2 : 0.05;
-	double qf1 = pm->nsym > 8 ? 0.5 : 0.22;
-	double qf2 = pm->nsym > 8 ? 0.8 : 0.60;
-
-	int total = 0;
-	i = 0;
-	while (i < 2560) {
-	    total += avg[i];
-	    if (total > qf0 * num_rec) {
-		//fprintf(stderr, "Q1=%d\n", (int)i);
-		break;
-	    }
-	    avg[i++] = 0;
-	}
-	while (i < 2560) {
-	    total += avg[i];
-	    if (total > qf1 * num_rec) {
-		//fprintf(stderr, "Q2=%d\n", (int)i);
-		break;
-	    }
-	    avg[i++] = 1;
-	}
-	while (i < 2560) {
-	    total += avg[i];
-	    if (total > qf2 * num_rec) {
-		//fprintf(stderr, "Q3=%d\n", (int)i);
-		break;
-	    }
-	    avg[i++] = 2;
-	}
-	while (i < 2560)
-	    avg[i++] = 3;
-
-	// Compute simple entropy of merged signal vs split signal.
-        i = 0;
-	rec = 0;
-
-	int qbin4[4][NP][256] = {{{0}}};
-	int qbin2[2][NP][256] = {{{0}}};
-	int qbin1   [NP][256] = {{0}};
-	int qcnt4[4][NP] = {{0}};
-	int qcnt2[4][NP] = {{0}};
-	int qcnt1   [NP] = {0};
-        while (i < in_size) {
-	    if (one_param >= 0 && (s->flags[rec] >> 16) != one_param) {
-		i += s->len[rec++];
-		continue;
-	    }
-	    if (rec < s->num_records)
-		j = s->len[rec];
-	    else
-		j = in_size - i;
-	    last_len = j;
-
-	    uint32_t tot = avg_qual[rec];
-	    int qb4 = avg[MIN(2559, tot)];
-	    int qb2 = qb4/2;
-
-	    for (; i < in_size && j > 0; i++, j--) {
-		int x = j & (NP-1);
-		qbin4[qb4][x][in[i]]++;  qcnt4[qb4][x]++;
-		qbin2[qb2][x][in[i]]++;  qcnt2[qb2][x]++;
-		qbin1     [x][in[i]]++;  qcnt1     [x]++;
-	    }
-	    rec++;
-	}
-
-	double e1 = 0, e2 = 0, e4 = 0;
-	for (j = 0; j < NP; j++) {
-	    for (i = 0; i < 256; i++) {
-		if (qbin1   [j][i]) e1 += qbin1   [j][i] * log(qbin1   [j][i] / (double)qcnt1   [j]);
-		if (qbin2[0][j][i]) e2 += qbin2[0][j][i] * log(qbin2[0][j][i] / (double)qcnt2[0][j]);
-		if (qbin2[1][j][i]) e2 += qbin2[1][j][i] * log(qbin2[1][j][i] / (double)qcnt2[1][j]);
-		if (qbin4[0][j][i]) e4 += qbin4[0][j][i] * log(qbin4[0][j][i] / (double)qcnt4[0][j]);
-		if (qbin4[1][j][i]) e4 += qbin4[1][j][i] * log(qbin4[1][j][i] / (double)qcnt4[1][j]);
-		if (qbin4[2][j][i]) e4 += qbin4[2][j][i] * log(qbin4[2][j][i] / (double)qcnt4[2][j]);
-		if (qbin4[3][j][i]) e4 += qbin4[3][j][i] * log(qbin4[3][j][i] / (double)qcnt4[3][j]);
-	    }
-	}
-	e1 /= -log(2)/8;
-	e2 /= -log(2)/8;
-	e4 /= -log(2)/8;
-	//fprintf(stderr, "E1=%f E2=%f E4=%f\n", e1, e2+s->num_records/8, e4+s->num_records/4);
-
-	// Note by using the selector we're robbing bits from elsewhere in
-	// the context, which may reduce compression better.
-	// We don't know how much by, so this is basically a guess!
-	// For now we just say need 5% saving here.
-	double qm = pm->do_qa > 0 ? 1 : 0.98;
-	if ((pm->do_qa == -1 || pm->do_qa >= 4) &&
-	    e4 + s->num_records/4 < e2*qm + s->num_records/8 &&
-	    e4 + s->num_records/4 < e1*qm) {
-	    //fprintf(stderr, "do q4\n");
-	    for (i = 0; i < s->num_records; i++) {
-		//fprintf(stderr, "%d -> %d -> %d, %d\n", (int)i, avg_qual[i], avg[MIN(2559, avg_qual[i])], s->flags[i]>>16);
-		s->flags[i] |= avg[MIN(2559, avg_qual[i])] <<16;
-	    }
-	    pm->do_sel = 1;
-	    max_sel = 3;
-	} else if ((pm->do_qa == -1 || pm->do_qa >= 2) && e2 + s->num_records/8 < e1*qm) {
-	    //fprintf(stderr, "do q2\n");
-	    for (i = 0; i < s->num_records; i++)
-		s->flags[i] |= (avg[MIN(2559, avg_qual[i])]>>1) <<16;
-	    pm->do_sel = 1;
-	    max_sel = 1;
-	}
-
-	if (pm->do_qa == -1) {
-	    // assume qual, pos, delta in that order.
-	    if (pm->pbits > 0 && pm->dbits > 0) {
-		// 1 from pos/delta
-		pm->sloc = pm->dloc-1;
-		pm->pbits--;
-		pm->dbits--;
-		pm->dloc++;
-	    } else if (pm->dbits >= 2) {
-		// 2 from delta
-		pm->sloc = pm->dloc;
-		pm->dbits -= 2;
-		pm->dloc += 2;
-	    } else if (pm->qbits >= 2) {
-		pm->qbits -= 2;
-		pm->ploc -= 2;
-		pm->sloc = 16-2 - pm->do_r2;
-		if (pm->qbits == 6 && pm->qshift == 5)
-		    pm->qbits--;
-	    }
-	    pm->do_qa = 4;
-	}
-    }
-
-    // Auto tune: does splitting up READ1 and READ2 help us?
-    if (has_r2 || pm->do_r2) { // FIXME: && but debug for now
-	double e1 = 0, e2 = 0; // entropy sum
-
-	for (j = 0; j < NP; j++) {
-	    if (!t1[j] || !t2[j]) continue;
-	    for (i = 0; i < 256; i++) {
-		if (!qhistb[j][i]) continue;
-		e1 -= (qhistb[j][i])*log(qhistb[j][i] / (double)(t1[j]+t2[j]));
-		if (qhist1[j][i])
-		    e2 -= qhist1[j][i] * log(qhist1[j][i] / (double)t1[j]);
-		if (qhist2[j][i])
-		    e2 -= qhist2[j][i] * log(qhist2[j][i] / (double)t2[j]);
-	    }
-	}
-	e1 /= log(2)*8; // bytes
-	e2 /= log(2)*8;
-
-	//fprintf(stderr, "read1/2 entropy merge %f split %f\n", e1, e2);
-
-	// Note by using the selector we're robbing bits from elsewhere in
-	// the context, which may reduce compression better.
-	// We don't know how much by, so this is basically a guess!
-	// For now we just say need 5% saving here.
-	double qm = pm->do_r2 > 0 ? 1 : 0.95;
-	if (e2 + (8+s->num_records/8) < e1*qm) {
-	    for (rec = 0; rec < s->num_records; rec++) {
-		if (one_param >= 0 && (s->flags[rec] >> 16) != one_param)
-		    continue;
-		int sel = s->flags[rec] >> 16;
-		s->flags[rec] =  (s->flags[rec] & 0xffff)
-		    | ((s->flags[rec] & FQZ_FREAD2)
-		       ? ((sel*2)+1) << 16
-		       : ((sel*2)+0) << 16);
-		if (max_sel < (s->flags[rec]>>16))
-		    max_sel = (s->flags[rec]>>16);
-	    }
-	}
-    }
-
-    // We provided explicit selector data or auto-tuned it
-    if (max_sel > 0) {
-	pm->do_sel = 1;
-	pm->max_sel = max_sel;
-    }
-
-    free(avg_qual);
-}
-
-static inline
-int fqz_store_parameters1(fqz_param *pm, unsigned char *comp) {
-    int comp_idx = 0, i, j;
-
-    // Starting context
-    comp[comp_idx++] = pm->context;
-    comp[comp_idx++] = pm->context >> 8;
-
-    comp[comp_idx++] = pm->pflags;
-    comp[comp_idx++] = pm->max_sym;
-
-    comp[comp_idx++] = (pm->qbits<<4)|pm->qshift;
-    comp[comp_idx++] = (pm->qloc<<4)|pm->sloc;
-    comp[comp_idx++] = (pm->ploc<<4)|pm->dloc;
-
-    if (pm->store_qmap) {
-	for (i = j = 0; i < 256; i++)
-	    if (pm->qmap[i] != INT_MAX)
-		comp[comp_idx++] = i;
-    }
-
-    if (pm->qbits && pm->use_qtab)
-	// custom qtab
-	comp_idx += store_array(comp+comp_idx, pm->qtab, 256);
-
-    if (pm->pbits && pm->use_ptab)
-	// custom ptab
-	comp_idx += store_array(comp+comp_idx, pm->ptab, 1024);
-
-    if (pm->dbits && pm->use_dtab)
-	// custom dtab
-	comp_idx += store_array(comp+comp_idx, pm->dtab, 256);
-
-    return comp_idx;
-}
-
-static 
-int fqz_store_parameters(fqz_gparams *gp, unsigned char *comp) {
-    int comp_idx = 0;
-    comp[comp_idx++] = gp->vers; // Format number
-
-    comp[comp_idx++] = gp->gflags;
-
-    if (gp->gflags & GFLAG_MULTI_PARAM)
-	comp[comp_idx++] = gp->nparam;
-
-    if (gp->gflags & GFLAG_HAVE_STAB) {
-	comp[comp_idx++] = gp->max_sel;
-	comp_idx += store_array(comp+comp_idx, gp->stab, 256);
-    }
-
-    int i;
-    for (i = 0; i < gp->nparam; i++)
-	comp_idx += fqz_store_parameters1(&gp->p[i], comp+comp_idx);
-
-    //fprintf(stderr, "Encoded %d bytes of param\n", comp_idx);
-    return comp_idx;
-}
-
-// Choose a set of parameters based on quality statistics and
-// some predefined options (selected via "strat").
-static inline
-int fqz_pick_parameters(fqz_gparams *gp,
-			int vers,
-			int strat,
-			fqz_slice *s,
-			unsigned char *in,
-			size_t in_size) {
-    //approx sqrt(delta), must be sequential
-    int dsqr[] = {
-	0, 1, 1, 1, 2, 2, 2, 2, 2, 3, 3, 3, 3, 3, 3, 3,
-	4, 4, 4, 4, 4, 4, 4, 4, 4, 5, 5, 5, 5, 5, 5, 5,
-	5, 5, 5, 5, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6,
-	6, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7
-    };
-    uint32_t qhist[256] = {0};
-
-    if (strat >= nstrats) strat = nstrats-1;
-
-    // Start with 1 set of parameters.
-    // FIXME: add support for multiple params later.
-    memset(gp, 0, sizeof(*gp));
-    gp->vers = FQZ_VERS;
-
-    if (!(gp->p = calloc(1, sizeof(fqz_param))))
-	return -1;
-    gp->nparam = 1;
-    gp->max_sel = 0;
-
-    if (vers == 3) // V3.0 doesn't store qual in original orientation
-	gp->gflags |= GFLAG_DO_REV;
-
-    fqz_param *pm = gp->p;
-
-    // Programmed strategies, which we then amend based on our
-    // statistical analysis of the quality stream.
-    pm->qbits  = strat_opts[strat][0];
-    pm->qshift = strat_opts[strat][1];
-    pm->pbits  = strat_opts[strat][2];
-    pm->pshift = strat_opts[strat][3];
-    pm->dbits  = strat_opts[strat][4];
-    pm->dshift = strat_opts[strat][5];
-    pm->qloc   = strat_opts[strat][6];
-    pm->sloc   = strat_opts[strat][7];
-    pm->ploc   = strat_opts[strat][8];
-    pm->dloc   = strat_opts[strat][9];
-
-    // Params for controlling behaviour here.
-    pm->do_r2 = strat_opts[strat][10];
-    pm->do_qa = strat_opts[strat][11];
-
-    // Validity check input lengths and buffer size
-    size_t tlen = 0, i;
-    for (i = 0; i < s->num_records; i++) {
-	if (tlen + s->len[i] > in_size)
-	    // Oversized buffer
-	    s->len[i] = in_size - tlen;
-	tlen += s->len[i];
-    }
-    if (s->num_records > 0 && tlen < in_size)
-	// Undersized buffer
-	s->len[s->num_records-1] += in_size - tlen;
-
-    // Quality metrics, for all recs
-    fqz_qual_stats(s, in, in_size, pm, qhist, -1);
-
-    pm->store_qmap = (pm->nsym <= 8 && pm->nsym*2 < pm->max_sym);
-
-    // Check for fixed length.
-    uint32_t first_len = s->len[0];
-    for (i = 1; i < s->num_records; i++) {
-	if (s->len[i] != first_len)
-	    break;
-    }
-    pm->fixed_len = (i == s->num_records);
-    pm->use_qtab = 0; // unused by current encoder
-
-    if (strat >= nstrats-1)
-	goto manually_set; // used in TEST_MAIN for debugging
-
-    if (pm->pshift < 0)
-	pm->pshift = MAX(0, log((double)s->len[0]/(1<<pm->pbits))/log(2)+.5);
-
-    if (pm->nsym <= 4) {
-	// NovaSeq
-	pm->qshift = 2; // qmax 64, although we can store up to 256 if needed
-	if (in_size < 5000000) {
-	    pm->pbits =2;
-	    pm->pshift=5;
-	}
-    } else if (pm->nsym <= 8) {
-	// HiSeqX
-	pm->qbits =MIN(pm->qbits,9);
-	pm->qshift=3;
-	if (in_size < 5000000)
-	    pm->qbits =6;
-    }
-
-    if (in_size < 300000) {
-	pm->qbits=pm->qshift;
-	pm->dbits=2;
-    }
-
- manually_set:
-//    fprintf(stderr, "-x 0x%x%x%x%x%x%x%x%x%x%x%x%x\n",
-//	    pm->qbits, pm->qshift,
-//	    pm->pbits, pm->pshift,
-//	    pm->dbits, pm->dshift,
-//	    pm->qloc, pm->sloc, pm->ploc, pm->dloc,
-//	    pm->do_r2, pm->do_qa);
-
-    for (i = 0; i < sizeof(dsqr)/sizeof(*dsqr); i++)
-	if (dsqr[i] > (1<<pm->dbits)-1)
-	    dsqr[i] = (1<<pm->dbits)-1;
-
-    if (pm->store_qmap) {
-	int j;
-	for (i = j = 0; i < 256; i++)
-	    if (qhist[i])
-		pm->qmap[i] = j++;
-	    else
-		pm->qmap[i] = INT_MAX;
-	pm->max_sym = pm->nsym;
-    } else {
-	pm->nsym = 255;
-	for (i = 0; i < 256; i++)
-	    pm->qmap[i] = i;
-    }
-    if (gp->max_sym < pm->max_sym)
-	gp->max_sym = pm->max_sym;
-
-    // Produce ptab from pshift.
-    if (pm->qbits) {
-	for (i = 0; i < 256; i++) {
-	    pm->qtab[i] = i; // 1:1
-
-	    // Alternative mappings:
-	    //qtab[i] = i > 30 ? MIN(max_sym,i)-15 : i/2;  // eg for 9827 BAM
-	}
-
-    }
-    pm->qmask = (1<<pm->qbits)-1;
-
-    if (pm->pbits) {
-	for (i = 0; i < 1024; i++)
-	    pm->ptab[i] = MIN((1<<pm->pbits)-1, i>>pm->pshift);
-
-	// Alternatively via analysis of quality distributions we
-	// may select a bunch of positions that are special and
-	// have a non-uniform ptab[].
-	// Manual experimentation on a NovaSeq run saved 2.8% here.
-    }
-
-    if (pm->dbits) {
-	for (i = 0; i < 256; i++)
-	    pm->dtab[i] = dsqr[MIN(sizeof(dsqr)/sizeof(*dsqr)-1, i>>pm->dshift)];
-    }
-
-    pm->use_ptab = (pm->pbits > 0);
-    pm->use_dtab = (pm->dbits > 0);
-
-    pm->pflags =
-	(pm->use_qtab   ?PFLAG_HAVE_QTAB :0)|
-	(pm->use_dtab   ?PFLAG_HAVE_DTAB :0)|
-	(pm->use_ptab   ?PFLAG_HAVE_PTAB :0)|
-	(pm->do_sel     ?PFLAG_DO_SEL    :0)|
-	(pm->fixed_len  ?PFLAG_DO_LEN    :0)|
-	(pm->do_dedup   ?PFLAG_DO_DEDUP  :0)|
-	(pm->store_qmap ?PFLAG_HAVE_QMAP :0);
-
-    gp->max_sel = 0;
-    if (pm->do_sel) {
-	// 2 selectors values, but 1 parameter block.
-	// We'll use the sloc instead to encode the selector bits into
-	// the context.
-	gp->max_sel = 1; // indicator to check recs
-	gp->gflags |= GFLAG_HAVE_STAB;
-	// NB: stab is already all zero
-    }
-
-    if (gp->max_sel) {
-	int max = 0;
-	for (i = 0; i < s->num_records; i++) {
-	    if (max < (s->flags[i] >> 16))
-		max = (s->flags[i] >> 16);
-	}
-	gp->max_sel = max;
-    }
-
-    return 0;
-}
-
-static void fqz_free_parameters(fqz_gparams *gp) {
-    if (gp && gp->p) free(gp->p);
-}
-
-static
-unsigned char *compress_block_fqz2f(int vers,
-				    int strat,
-				    fqz_slice *s,
-				    unsigned char *in,
-				    size_t in_size,
-				    size_t *out_size,
-				    fqz_gparams *gp) {
-    fqz_gparams local_gp;
-    int free_params = 0;
-
-    unsigned int last = 0;
-    size_t i, j;
-    ssize_t rec = 0;
-
-    int last_len = 0;
-    int comp_idx = 0;
-    RangeCoder rc;
-
-    unsigned char *comp = (unsigned char *)malloc(in_size*1.1+100000);
-    unsigned char *compe = comp + (size_t)(in_size*1.1+100000);
-    if (!comp)
-	return NULL;
-
-    // Pick and store params
-    if (!gp) {
-	gp = &local_gp;
-	if (fqz_pick_parameters(gp, vers, strat, s, in, in_size) < 0)
-	    return NULL;
-	free_params = 1;
-    }
-
-    //dump_params(gp);
-    comp_idx = var_put_u32(comp, compe, in_size);
-    comp_idx += fqz_store_parameters(gp, comp+comp_idx);
-
-    fqz_param *pm;
-
-    // Optimise tables to remove shifts in loop (NB: cannot do this in next vers)
-    for (j = 0; j < gp->nparam; j++) {
-	pm = &gp->p[j];
-
-	for (i = 0; i < 1024; i++)
-	    pm->ptab[i] <<= pm->ploc;
-
-	for (i = 0; i < 256; i++)
-	    pm->dtab[i] <<= pm->dloc;
-    }
-
-    // Create models and initialise range coder
-    fqz_model model;
-    if (fqz_create_models(&model, gp) < 0)
-	return NULL;
-
-    RC_SetOutput(&rc, (char *)comp+comp_idx);
-    RC_StartEncode(&rc);
-
-    // For CRAM3.1, reverse upfront if needed
-    pm = &gp->p[0];
-    if (gp->gflags & GFLAG_DO_REV) {
-	i = rec = j = 0;
-	while (i < in_size) {
-	    int len = rec < s->num_records-1
-		? s->len[rec] : in_size - i;
-
-	    if (s->flags[rec] & FQZ_FREVERSE) {
-		// Reverse complement sequence - note: modifies buffer
-		int I,J;
-		unsigned char *cp = in+i;
-		for (I = 0, J = len-1; I < J; I++, J--) {
-		    unsigned char c;
-		    c = cp[I];
-		    cp[I] = cp[J];
-		    cp[J] = c;
-		}
-	    }
-
-	    i += len;
-	    rec++;
-	}
-	rec = 0;
-    }
-
-    fqz_state state = {0};
-    pm = &gp->p[0];
-    state.p = 0;
-    state.first_len = 1;
-    int x;
-
-    for (i = 0; i < in_size; i++) {
-	if (state.p == 0) {
-	    if (pm->do_sel || (gp->gflags & GFLAG_MULTI_PARAM)) {
-		state.s = rec < s->num_records
-		    ? s->flags[rec] >> 16 // reuse spare bits
-		    : 0;
-		SIMPLE_MODEL(256,_encodeSymbol)(&model.sel, &rc, state.s);
-		//fprintf(stderr, "State %d\n", state.s);
-	    } else {
-		state.s = 0;
-	    }
-	    x = (gp->gflags & GFLAG_HAVE_STAB) ? gp->stab[state.s] : state.s;
-	    pm = &gp->p[x];
-
-	    //fprintf(stderr, "sel %d param %d\n", state.s, x);
-
-	    int len = s->len[rec];
-	    if (!pm->fixed_len || state.first_len) {
-		SIMPLE_MODEL(256,_encodeSymbol)(&model.len[0], &rc, (len>> 0) & 0xff);
-		SIMPLE_MODEL(256,_encodeSymbol)(&model.len[1], &rc, (len>> 8) & 0xff);
-		SIMPLE_MODEL(256,_encodeSymbol)(&model.len[2], &rc, (len>>16) & 0xff);
-		SIMPLE_MODEL(256,_encodeSymbol)(&model.len[3], &rc, (len>>24) & 0xff);
-		//fprintf(stderr, "Len %d\n", len);
-		state.first_len = 0;
-	    }
-
-	    if (gp->gflags & GFLAG_DO_REV) {
-		// no need to reverse complement for V4.0 as the core format
-		// already has this feature.
-		if (s->flags[rec] & FQZ_FREVERSE)
-		    SIMPLE_MODEL(2,_encodeSymbol)(&model.revcomp, &rc, 1);
-		else
-		    SIMPLE_MODEL(2,_encodeSymbol)(&model.revcomp, &rc, 0);
-		//fprintf(stderr, "Rev %d\n", (s->flags[rec] & FQZ_FREVERSE) ? 1 : 0);
-	    }
-
-	    rec++;
-
-	    state.qtot = 0;
-	    state.qlen = 0;
-
-	    state.p = len;
-	    state.add_d = 0;
-	    state.delta = 0;
-	    state.qctx = 0;
-	    state.prevq = 0;
-
-	    last = pm->context;
-
-	    if (pm->do_dedup) {
-		// Possible dup of previous read?
-		if (i && len == last_len && !memcmp(in+i-last_len, in+i, len)) {
-		    SIMPLE_MODEL(2,_encodeSymbol)(&model.dup, &rc, 1);
-		    i += len-1;
-		    state.p = 0;
-		    //fprintf(stderr, "Dup 1\n");
-		    continue;
-		} else {
-		    SIMPLE_MODEL(2,_encodeSymbol)(&model.dup, &rc, 0);
-		    //fprintf(stderr, "Dup 0\n");
-		}
-
-		last_len = len;
-	    }
-	}
-
-	unsigned char q = in[i];
-	unsigned char qm = pm->qmap[q];
-
-	SIMPLE_MODEL(QMAX,_encodeSymbol)(&model.qual[last], &rc, qm);
-	//fprintf(stderr, "Sym %d with ctx %04x delta %d prevq %d q %d\n", qm, last, state.delta, state.prevq, qm);
-	//fprintf(stderr, "pos=%d, delta=%d\n", state.p, state.delta);
-	last = fqz_update_ctx(pm, &state, qm);
-    }
-
-    RC_FinishEncode(&rc);
-
-    // For CRAM3.1, undo our earlier reversal step
-    if (gp->gflags & GFLAG_DO_REV) {
-	i = rec = j = 0;
-	while (i < in_size) {
-	    int len = rec < s->num_records-1
-		? s->len[rec]
-		: in_size - i;
-
-	    if (s->flags[rec] & FQZ_FREVERSE) {
-		// Reverse complement sequence - note: modifies buffer
-		int I,J;
-		unsigned char *cp = in+i;
-		for (I = 0, J = len-1; I < J; I++, J--) {
-		    unsigned char c;
-		    c = cp[I];
-		    cp[I] = cp[J];
-		    cp[J] = c;
-		}
-	    }
-
-	    i += len;
-	    rec++;
-	}
-    }
-
-    // Clear selector abuse of flags
-    for (rec = 0; rec < s->num_records; rec++)
-	s->flags[rec] &= 0xffff;
-
-    *out_size = comp_idx + RC_OutSize(&rc);
-    //fprintf(stderr, "%d -> %d\n", (int)in_size, (int)*out_size);
-
-    fqz_destroy_models(&model);
-    if (free_params)
-	fqz_free_parameters(gp);
-
-    return comp;
-}
-
-// Read fqz paramaters.
-//
-// FIXME: pass in and check in_size.
-//
-// Returns number of bytes read on success,
-//         -1 on failure.
-static inline
-int fqz_read_parameters1(fqz_param *pm, unsigned char *in, size_t in_size) {
-    int in_idx = 0;
-    size_t i;
-
-    if (in_size < 7)
-	return -1;
-
-    // Starting context
-    pm->context = in[in_idx] + (in[in_idx+1]<<8);
-    in_idx += 2;
-
-    // Bit flags
-    pm->pflags     = in[in_idx++];
-    pm->use_qtab   = pm->pflags & PFLAG_HAVE_QTAB;
-    pm->use_dtab   = pm->pflags & PFLAG_HAVE_DTAB;
-    pm->use_ptab   = pm->pflags & PFLAG_HAVE_PTAB;
-    pm->do_sel     = pm->pflags & PFLAG_DO_SEL;
-    pm->fixed_len  = pm->pflags & PFLAG_DO_LEN;
-    pm->do_dedup   = pm->pflags & PFLAG_DO_DEDUP;
-    pm->store_qmap = pm->pflags & PFLAG_HAVE_QMAP;
-    pm->max_sym    = in[in_idx++];
-
-    // Sub-context sizes and locations
-    pm->qbits      = in[in_idx]>>4;
-    pm->qmask      = (1<<pm->qbits)-1;
-    pm->qshift     = in[in_idx++]&15;
-    pm->qloc       = in[in_idx]>>4;
-    pm->sloc       = in[in_idx++]&15;
-    pm->ploc       = in[in_idx]>>4;
-    pm->dloc       = in[in_idx++]&15;
-
-    // Maps and tables
-    if (pm->store_qmap) {
-	for (i = 0; i < 256; i++) pm->qmap[i] = INT_MAX; // so dump_map works
-	if (in_idx + pm->max_sym > in_size)
-	    return -1;
-	for (i = 0; i < pm->max_sym; i++)
-	    pm->qmap[i] = in[in_idx++];
-    } else {
-	for (i = 0; i < 256; i++)
-	    pm->qmap[i] = i;
-    }
-
-    if (pm->qbits) {
-	if (pm->use_qtab)
-	    in_idx += read_array(in+in_idx, in_size-in_idx, pm->qtab, 256);
-	else
-	    for (i = 0; i < 256; i++)
-		pm->qtab[i] = i;
-    }
-
-    if (pm->use_ptab)
-	in_idx += read_array(in+in_idx, in_size-in_idx, pm->ptab, 1024);
-    else
-	for (i = 0; i < 1024; i++)
-	    pm->ptab[i] = 0;
-
-    if (pm->use_dtab)
-        in_idx += read_array(in+in_idx, in_size-in_idx, pm->dtab, 256);
-    else
-	for (i = 0; i < 256; i++)
-	    pm->dtab[i] = 0;
-
-    return in_idx;
-}
-
-static
-int fqz_read_parameters(fqz_gparams *gp, unsigned char *in, size_t in_size) {
-    int in_idx = 0;
-    int i;
-
-    if (in_size < 10)
-	return -1;
-
-    // Format version
-    gp->vers = in[in_idx++];
-    if (gp->vers != FQZ_VERS)
-	return -1;
-
-    // Global glags
-    gp->gflags = in[in_idx++];
-
-    // Number of param blocks and param selector details
-    gp->nparam = (gp->gflags & GFLAG_MULTI_PARAM) ? in[in_idx++] : 1;
-    if (gp->nparam <= 0)
-	return -1;
-    gp->max_sel = gp->nparam > 1 ? gp->nparam : 0;
-
-    if (gp->gflags & GFLAG_HAVE_STAB) {
-	gp->max_sel = in[in_idx++];
-	in_idx += read_array(in+in_idx, in_size-in_idx, gp->stab, 256);
-    } else {
-	for (i = 0; i < gp->nparam; i++)
-	    gp->stab[i] = i;
-	for (; i < 256; i++)
-	    gp->stab[i] = gp->nparam-1;
-    }
-
-    // Load the individual parameter locks
-    if (!(gp->p = malloc(gp->nparam * sizeof(*gp->p))))
-	return -1;
-
-    gp->max_sym = 0;
-    for (i = 0; i < gp->nparam; i++) {
-	int e = fqz_read_parameters1(&gp->p[i], in + in_idx, in_size-in_idx);
-	if (e < 0)
-	    goto err;
-	in_idx += e;
-
-	if (gp->max_sym < gp->p[i].max_sym)
-	    gp->max_sym = gp->p[i].max_sym;
-    }
-
-    //fprintf(stderr, "Decoded %d bytes of param\n", in_idx);
-    return in_idx;
-
- err:
-    fqz_free_parameters(gp);
-    gp->nparam = 0;
-    return -1;
-}
-
-static
-unsigned char *uncompress_block_fqz2f(fqz_slice *s,
-				      unsigned char *in,
-				      size_t in_size,
-				      size_t *out_size,
-				      int *lengths,
-				      int nlengths) {
-    fqz_gparams gp;
-    fqz_param *pm;
-    char *rev_a = NULL;
-    int *len_a = NULL;
-    memset(&gp, 0, sizeof(gp));
-
-    uint32_t len;
-    ssize_t i, rec = 0, in_idx;
-    in_idx = var_get_u32(in, in+in_size, &len);
-    *out_size = len;
-
-#ifdef FUZZING_BUILD_MODE_UNSAFE_FOR_PRODUCTION
-    if (len > 100000)
-	return NULL;
-#endif
-
-    unsigned char *uncomp = NULL;
-    RangeCoder rc;
-    unsigned int last = 0;
-
-    // Decode parameter blocks
-    if ((i = fqz_read_parameters(&gp, in+in_idx, in_size-in_idx)) < 0)
-	return NULL;
-    //dump_params(&gp);
-    in_idx += i;
-
-    // Optimisations to remove shifts from main loop
-    for (i = 0; i < gp.nparam; i++) {
-	int j;
-	pm = &gp.p[i];
-	for (j = 0; j < 1024; j++)
-	    pm->ptab[j] <<= pm->ploc;
-	for (j = 0; j < 256; j++)
-	    pm->dtab[j] <<= pm->dloc;
-    }
-
-    // Initialise models and entropy coder
-    fqz_model model;
-    if (fqz_create_models(&model, &gp) < 0)
-	return NULL;
-
-    RC_SetInput(&rc, (char *)in+in_idx, (char *)in+in_size);
-    RC_StartDecode(&rc);
-
-
-    // Allocate buffers
-    uncomp = (unsigned char *)malloc(*out_size);
-    if (!uncomp)
-	goto err;
-
-    int nrec = 1000;
-    rev_a = malloc(nrec);
-    len_a = malloc(nrec * sizeof(int));
-    if (!rev_a || !len_a)
-	goto err;
-
-    // Main decode loop
-    fqz_state state;
-    state.delta = 0;
-    state.prevq = 0;
-    state.qctx = 0;
-    state.p = 0;
-    state.s = 0;
-    state.first_len = 1;
-
-    int rev = 0;
-    int last_len = 0;
-    int x = 0;
-    pm = &gp.p[x];
-    for (rec = i = 0; i < len; i++) {
-	if (rec >= nrec) {
-	    nrec *= 2;
-	    rev_a = realloc(rev_a, nrec);
-	    len_a = realloc(len_a, nrec*sizeof(int));
-	    if (!rev_a || !len_a)
-		goto err;
-	}
-
-	if (state.p == 0) {
-	    // New record
-	    if (pm->do_sel) {
-		state.s = SIMPLE_MODEL(256,_decodeSymbol)(&model.sel, &rc);
-		//fprintf(stderr, "State %d\n", state.s);
-	    } else {
-		state.s = 0;
-	    }
-	    x = (gp.gflags & GFLAG_HAVE_STAB) ? gp.stab[MIN(255, state.s)] : state.s;
-	    if (x >= gp.nparam)
-		goto err;
-	    pm = &gp.p[x];
-
-	    unsigned int len = last_len;
-	    if (!pm->fixed_len || state.first_len) {
-		len  = SIMPLE_MODEL(256,_decodeSymbol)(&model.len[0], &rc);
-		len |= SIMPLE_MODEL(256,_decodeSymbol)(&model.len[1], &rc)<<8;
-		len |= SIMPLE_MODEL(256,_decodeSymbol)(&model.len[2], &rc)<<16;
-		len |= ((unsigned)SIMPLE_MODEL(256,_decodeSymbol)(&model.len[3], &rc))<<24;
-		//fprintf(stderr, "Len %d\n", len);
-		state.first_len = 0;
-		last_len = len;
-	    }
-	    if (len > *out_size-i || len <= 0)
-		goto err;
-
-	    if (lengths && rec < nlengths)
-		lengths[rec] = len;
-
-	    if (gp.gflags & GFLAG_DO_REV) {
-		rev = SIMPLE_MODEL(2,_decodeSymbol)(&model.revcomp, &rc);
-		//fprintf(stderr, "rev %d\n", rev);
-		rev_a[rec] = rev;
-		len_a[rec] = len;
-	    }
-
-	    if (pm->do_dedup) {
-		if (SIMPLE_MODEL(2,_decodeSymbol)(&model.dup, &rc)) {
-		    //fprintf(stderr, "Dup 1\n");
-		    // Dup of last line
-		    if (len > i)
-			goto err;
-		    memcpy(uncomp+i, uncomp+i-len, len);
-		    i += len-1;
-		    state.p = 0;
-		    rec++;
-		    continue;
-		} else {
-		    //fprintf(stderr, "Dup 0\n");
-		}
-	    }
-
-	    rec++;
-
-	    state.p = len;
-	    state.add_d = 0;
-	    state.delta = 0;
-	    state.prevq = 0;
-	    state.qctx = 0;
-
-	    last = pm->context;
-	}
-
-	// Decode and output quality
-	unsigned char Q = SIMPLE_MODEL(QMAX,_decodeSymbol)(&model.qual[last], &rc);
-	unsigned char q = pm->qmap[Q];
-	//fprintf(stderr, "Sym %d with ctx %04x delta %d prevq %d q %d\n", Q, last, state.delta, state.prevq, Q);
-        uncomp[i] = q;
-
-	// Compute new quality context
-	last = fqz_update_ctx(pm, &state, Q);
-    }
-
-    if (rec >= nrec) {
-	nrec *= 2;
-	rev_a = realloc(rev_a, nrec);
-	len_a = realloc(len_a, nrec*sizeof(int));
-	if (!rev_a || !len_a)
-	    goto err;
-    }
-    rev_a[rec] = rev;
-    len_a[rec] = len;
-
-    if (gp.gflags & GFLAG_DO_REV) {
-	for (i = rec = 0; i < len && rec < nrec; i += len_a[rec++]) {
-	    if (!rev_a[rec])
-		continue;
-
-	    int I, J;
-	    unsigned char *cp = uncomp+i;
-	    for (I = 0, J = len_a[rec]-1; I < J; I++, J--) {
-		unsigned char c;
-		c = cp[I];
-		cp[I] = cp[J];
-		cp[J] = c;
-	    }
-	}
-    }
-
-    RC_FinishDecode(&rc);
-    fqz_destroy_models(&model);
-    //free(model.qual);
-    free(rev_a);
-    free(len_a);
-    fqz_free_parameters(&gp);
-
-#ifdef TEST_MAIN
-    s->num_records = rec;
-#endif
-
-    return uncomp;
-
- err:
-    fqz_destroy_models(&model);
-    free(rev_a);
-    free(len_a);
-    fqz_free_parameters(&gp);
-    free(uncomp);
-
-    return NULL;
-}
-
-char *fqz_compress(int vers, fqz_slice *s, char *in, size_t uncomp_size,
-		   size_t *comp_size, int strat, fqz_gparams *gp) {
-    return (char *)compress_block_fqz2f(vers, strat, s, (unsigned char *)in,
-					uncomp_size, comp_size, gp);
-}
-
-char *fqz_decompress(char *in, size_t comp_size, size_t *uncomp_size,
-		     int *lengths, int nlengths) {
-    return (char *)uncompress_block_fqz2f(NULL, (unsigned char *)in,
-					  comp_size, uncomp_size, lengths, nlengths);
-}
diff -ruN stringtie.orig/htslib/htscodecs/htscodecs/fqzcomp_qual.h stringtie/htslib/htscodecs/htscodecs/fqzcomp_qual.h
--- stringtie.orig/htslib/htscodecs/htscodecs/fqzcomp_qual.h	2024-02-28 13:57:39.704579460 +0100
+++ stringtie/htslib/htscodecs/htscodecs/fqzcomp_qual.h	1970-01-01 01:00:00.000000000 +0100
@@ -1,184 +0,0 @@
-/*
- * Copyright (c) 2011-2013, 2018-2019 Genome Research Ltd.
- * Author(s): James Bonfield
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions are met:
- *
- *    1. Redistributions of source code must retain the above copyright notice,
- *       this list of conditions and the following disclaimer.
- *
- *    2. Redistributions in binary form must reproduce the above
- *       copyright notice, this list of conditions and the following
- *       disclaimer in the documentation and/or other materials provided
- *       with the distribution.
- *
- *    3. Neither the names Genome Research Ltd and Wellcome Trust Sanger
- *       Institute nor the names of its contributors may be used to endorse
- *       or promote products derived from this software without specific
- *       prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY GENOME RESEARCH LTD AND CONTRIBUTORS "AS
- * IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
- * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
- * PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL GENOME RESEARCH
- * LTD OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
- * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
- * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
- * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
- * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
- * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
- * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- */
-
-#ifndef FQZ_COMP_QUAL_H
-#define FQZ_COMP_QUAL_H
-
-#ifdef __cplusplus
-extern "C" {
-#endif
-
-#include <stdint.h>
-
-/* Bit flags, deliberately mirroring BAM ones */
-#define FQZ_FREVERSE 16
-#define FQZ_FREAD2 128
-
-/* Current FQZ format version */
-#define FQZ_VERS 5
-
-#define FQZ_MAX_STRAT 3
-
-/*
- * Minimal per-record information taken from a cram slice.
- *
- * To compress we need to know the junction from one quality string to
- * the next (len), whether it is first/second read and whether it is
- * reverse complemented (flags).
- */
-typedef struct {
-    int num_records;
-    uint32_t *len;    // of size num_records
-    uint32_t *flags;  // of size num_records
-} fqz_slice;
-
-
-// Global flags
-static const int GFLAG_MULTI_PARAM = 1;
-static const int GFLAG_HAVE_STAB   = 2;
-static const int GFLAG_DO_REV      = 4;
-
-// Param flags
-// Add PFLAG_HAVE_DMAP and a dmap[] for delta incr?
-static const int PFLAG_DO_DEDUP    = 2;
-static const int PFLAG_DO_LEN      = 4;
-static const int PFLAG_DO_SEL      = 8;
-static const int PFLAG_HAVE_QMAP   = 16;
-static const int PFLAG_HAVE_PTAB   = 32;
-static const int PFLAG_HAVE_DTAB   = 64;
-static const int PFLAG_HAVE_QTAB   = 128;
-
-/*
- * FQZ parameters.  These may be simply passed in as NULL to fqz_compress
- * and it'll automatically choose, but if we wish to have complete control
- * then this (long) struct contains all the details.
- *
- * TODO: document all this!
- */
-
-// A single parameter block
-typedef struct {
-    // Starting context value
-    uint16_t context;
-
-    // flags
-    unsigned int pflags;
-    unsigned int do_sel, do_dedup, store_qmap, fixed_len;
-    unsigned char use_qtab, use_dtab, use_ptab;
-
-    // context bits and locations
-    unsigned int qbits, qloc;
-    unsigned int pbits, ploc;
-    unsigned int dbits, dloc;
-    unsigned int sbits, sloc;
-
-    // models
-    int max_sym, nsym, max_sel;
-
-    // tables / maps
-    unsigned int qmap[256];
-    unsigned int qtab[256];
-    unsigned int ptab[1024];
-    unsigned int dtab[256];
-
-    // Not stored paramters, but computed as part of encoder
-    // parameterisation.
-    int qshift;
-    int pshift;
-    int dshift;
-    int sshift;
-    unsigned int qmask; // (1<<qbits)-1
-    int do_r2, do_qa;
-} fqz_param;
-
-// The global params, which is a collection of parameter blocks plus
-// a few pieces of meta-data.
-typedef struct {
-    int vers;               // Format version; Set to FQZ_VERS
-    unsigned int gflags;    // global param flags
-    int nparam;             // Number of fqz_param blocks
-    int max_sel;            // Number of selector values
-    unsigned int stab[256]; // Selector to parameter no. table
-
-    int max_sym;            // max symbol value across all sub-params
-
-    fqz_param *p;           // 1 or more parameter blocks
-} fqz_gparams;
-
-
-/** Compress a block of quality values.
- *
- * @param vers          The CRAM version number (<<8) plus fqz strategy (0-3)
- * @param s             Length and flag data CRAM per-record
- * @param in            Buffer of concatenated quality values (no separator)
- * @param in_size       Size of in buffer
- * @param out_size      Size of returned output
- * @param strat         FQZ compression strategy (0 to FQZ_MAX_STRAT)
- * @param gp            Optional fqzcomp paramters (may be NULL).
- *
- * @return              The compressed quality buffer on success,
- *                      NULL on failure.
- */
-char *fqz_compress(int vers, fqz_slice *s, char *in, size_t in_size,
-                   size_t *out_size, int strat, fqz_gparams *gp);
-
-/** Decompress a block of quality values.
- *
- * @param in            Buffer of compressed quality values
- * @param in_size       Size of in buffer
- * @param out_size      Size of returned output
- * @param lengths       Optional array filled out with record lengths.
- *                      May be NULL.  If not, preallocate it to correct size.
- *
- * @return              The uncompressed concatenated qualities on success,
- *                      NULL on failure.
- */
-char *fqz_decompress(char *in, size_t in_size, size_t *out_size,
-                     int *lengths, int nlengths);
-
-/** A utlity function to analyse a quality buffer to gather statistical
- *  information.  This is written into qhist and pm.  This function is only
- *  useful if you intend on passing your own fqz_gparams block to
- *  fqz_compress.
- */
-void fqz_qual_stats(fqz_slice *s,
-		    unsigned char *in, size_t in_size,
-		    fqz_param *pm,
-		    uint32_t qhist[256],
-		    int one_param);
-
-#ifdef __cplusplus
-}
-#endif
-
-#endif
diff -ruN stringtie.orig/htslib/htscodecs/htscodecs/htscodecs.c stringtie/htslib/htscodecs/htscodecs/htscodecs.c
--- stringtie.orig/htslib/htscodecs/htscodecs/htscodecs.c	2024-02-28 13:57:39.704579460 +0100
+++ stringtie/htslib/htscodecs/htscodecs/htscodecs.c	1970-01-01 01:00:00.000000000 +0100
@@ -1,44 +0,0 @@
-/*
- * Copyright (c) 2021 Genome Research Ltd.
- * Author(s): James Bonfield
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions are met:
- *
- *    1. Redistributions of source code must retain the above copyright notice,
- *       this list of conditions and the following disclaimer.
- *
- *    2. Redistributions in binary form must reproduce the above
- *       copyright notice, this list of conditions and the following
- *       disclaimer in the documentation and/or other materials provided
- *       with the distribution.
- *
- *    3. Neither the names Genome Research Ltd and Wellcome Trust Sanger
- *       Institute nor the names of its contributors may be used to endorse
- *       or promote products derived from this software without specific
- *       prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY GENOME RESEARCH LTD AND CONTRIBUTORS "AS
- * IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
- * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
- * PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL GENOME RESEARCH
- * LTD OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
- * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
- * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
- * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
- * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
- * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
- * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- */
-
-#include "htscodecs.h"
-#include "version.h"
-
-/*
- * A const string form of the HTSCODECS_VERSION define.
- * NB: This is obtained from the auto-generated version.h, so
- * we can include release number and git hash.
- */
-const char *htscodecs_version() {
-    return HTSCODECS_VERSION_TEXT;
-}
diff -ruN stringtie.orig/htslib/htscodecs/htscodecs/htscodecs_endian.h stringtie/htslib/htscodecs/htscodecs/htscodecs_endian.h
--- stringtie.orig/htslib/htscodecs/htscodecs/htscodecs_endian.h	2024-02-28 13:57:39.704579460 +0100
+++ stringtie/htslib/htscodecs/htscodecs/htscodecs_endian.h	1970-01-01 01:00:00.000000000 +0100
@@ -1,93 +0,0 @@
-/*
- * Copyright (c) 2020 Genome Research Ltd.
- * Author(s): James Bonfield
- * 
- * Redistribution and use in source and binary forms, with or without 
- * modification, are permitted provided that the following conditions are met:
- * 
- *    1. Redistributions of source code must retain the above copyright notice,
- *       this list of conditions and the following disclaimer.
- * 
- *    2. Redistributions in binary form must reproduce the above
- *       copyright notice, this list of conditions and the following
- *       disclaimer in the documentation and/or other materials provided
- *       with the distribution.
- * 
- *    3. Neither the names Genome Research Ltd and Wellcome Trust Sanger
- *    Institute nor the names of its contributors may be used to endorse
- *    or promote products derived from this software without specific
- *    prior written permission.
- * 
- * THIS SOFTWARE IS PROVIDED BY GENOME RESEARCH LTD AND CONTRIBUTORS "AS
- * IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
- * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
- * PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL GENOME RESEARCH
- * LTD OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
- * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
- * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
- * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
- * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
- * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
- * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- */
-
-#ifndef HTSCODECS_ENDIAN_H
-#define HTSCODECS_ENDIAN_H
-
-// Endianness checking.
-
-// Sets HTSCODECS_ENDIAN_KNOWN if system type detected and either
-// HTSCODECS_LITTLE_ENDIAN or HTSCODECS_BIG_ENDIAN.
-
-/*
- * In general our preferred route is to write code in an endian agnostic
- * fashion, but our data formats are natively little endian.  Therefore
- * in time critical code it's sometimes best to exploit that.
- *
- * Therefore we'll optimise code along the lines of:
- *
- * #ifdef HTSCODECS_LITTLE_ENDIAN
- *     // do something little endian specific
- * #else
- *     // do something in an endian agnostic fashion
- * #endif
- *
- * This means our code works even if we fail to recognise the
- * specific machine type.
- */
-
-#if (defined(__i386__)      \
- ||  defined(__i386)        \
- ||  defined(__amd64__)     \
- ||  defined(__amd64)       \
- ||  defined(__x86_64__)    \
- ||  defined(__x86_64)      \
- ||  defined(__i686__)      \
- ||  defined(__i686))       \
- || (defined(__BYTE_ORDER__) && __BYTE_ORDER__ == __ORDER_LITTLE_ENDIAN__) \
- ||  defined(__LITTLE_ENDIAN__)                                            \
- ||  defined(__ARMEL__)     \
- ||  defined(__THUMBEL__)   \
- ||  defined(__AARCH64EL__) \
- ||  defined(_MIPSEL)       \
- ||  defined(__MIPSEL)      \
- ||  defined(__MIPSEL__) 
-    // Little endian
-#   define HTSCODECS_LITTLE_ENDIAN
-#   define HTSCODECS_ENDIAN_KNOWN
-#elif (defined(__BYTE_ORDER__) && __BYTE_ORDER__ == __ORDER_BIG_ENDIAN__) \
-   ||  defined(__BIG_ENDIAN__) \
-   || defined(__ARMEB__)       \
-   || defined(__THUMBEB__)     \
-   || defined(__AAARCHEB__)    \
-   || defined(_MIPSEB)         \
-   || defined(__MIPSEB)        \
-   || defined(__MIPSEB__)
-    // Big endian
-#   define HTSCODECS_BIG_ENDIAN
-#   define HTSCODECS_ENDIAN_KNOWN
-#else
-//    Unknown - code will need to check HTSCODES_ENDIAN_KNOWN and do endian agnostic
-#endif
-
-#endif /* HTSCODECS_ENDIAN_H */
diff -ruN stringtie.orig/htslib/htscodecs/htscodecs/htscodecs.h stringtie/htslib/htscodecs/htscodecs/htscodecs.h
--- stringtie.orig/htslib/htscodecs/htscodecs/htscodecs.h	2024-02-28 13:57:39.704579460 +0100
+++ stringtie/htslib/htscodecs/htscodecs/htscodecs.h	1970-01-01 01:00:00.000000000 +0100
@@ -1,55 +0,0 @@
-/*
- * Copyright (c) 2021 Genome Research Ltd.
- * Author(s): James Bonfield
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions are met:
- *
- *    1. Redistributions of source code must retain the above copyright notice,
- *       this list of conditions and the following disclaimer.
- *
- *    2. Redistributions in binary form must reproduce the above
- *       copyright notice, this list of conditions and the following
- *       disclaimer in the documentation and/or other materials provided
- *       with the distribution.
- *
- *    3. Neither the names Genome Research Ltd and Wellcome Trust Sanger
- *       Institute nor the names of its contributors may be used to endorse
- *       or promote products derived from this software without specific
- *       prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY GENOME RESEARCH LTD AND CONTRIBUTORS "AS
- * IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
- * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
- * PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL GENOME RESEARCH
- * LTD OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
- * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
- * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
- * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
- * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
- * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
- * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- */
-
-#ifndef HTSCODECS_H
-#define HTSCODECS_H
-
-/*
- * Version X.Y.Z encoded as XYYYZZ.
- * We mainly increment X and Y.  Z *may* get bumped in between official
- * releases in order to distinguish untagged github checkouts from
- * official release tarballs.
- *
- * Note currently this needs manually editing as it isn't automatically
- * updated by autoconf.
- */
-#define HTSCODECS_VERSION 100000
-
-/*
- * A const string form of the HTSCODECS_VERSION define.
- * NB: This is obtained from the auto-generated version.h, so
- * we can include release number and git hash.
- */
-const char *htscodecs_version();
-
-#endif /* HTSCODECS_H */
diff -ruN stringtie.orig/htslib/htscodecs/htscodecs/Makefile.am stringtie/htslib/htscodecs/htscodecs/Makefile.am
--- stringtie.orig/htslib/htscodecs/htscodecs/Makefile.am	2024-02-28 13:57:39.701246126 +0100
+++ stringtie/htslib/htscodecs/htscodecs/Makefile.am	1970-01-01 01:00:00.000000000 +0100
@@ -1,85 +0,0 @@
-# Copyright (c) 2003, 2005-2007, 2009-2010, 2013 Genome Research Ltd.
-# Author(s): James Bonfield
-# 
-# Redistribution and use in source and binary forms, with or without 
-# modification, are permitted provided that the following conditions are met:
-# 
-#    1. Redistributions of source code must retain the above copyright notice,
-#       this list of conditions and the following disclaimer.
-# 
-#    2. Redistributions in binary form must reproduce the above
-#       copyright notice, this list of conditions and the following
-#       disclaimer in the documentation and/or other materials provided
-#       with the distribution.
-# 
-#    3. Neither the names Genome Research Ltd and Wellcome Trust Sanger
-#    Institute nor the names of its contributors may be used to endorse
-#    or promote products derived from this software without specific
-#    prior written permission.
-# 
-# THIS SOFTWARE IS PROVIDED BY GENOME RESEARCH LTD AND CONTRIBUTORS "AS
-# IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
-# TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
-# PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL GENOME RESEARCH
-# LTD OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
-# SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
-# LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
-# DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
-# THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
-# (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
-# OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-# 
-lib_LTLIBRARIES = libhtscodecs.la
-
-libhtscodecs_la_SOURCES = \
-	pack.c \
-	pack.h \
-	rle.c \
-	rle.h \
-	fqzcomp_qual.c \
-	fqzcomp_qual.h \
-	rANS_static.c \
-	rANS_static.h \
-	rANS_byte.h \
-	rANS_static4x16pr.c \
-	rANS_static4x16.h \
-	rANS_word.h \
-	tokenise_name3.c \
-	tokenise_name3.h \
-	pooled_alloc.h \
-	arith_dynamic.c \
-	arith_dynamic.h \
-	c_range_coder.h \
-	c_simple_model.h \
-	varint.h \
-	htscodecs.c \
-	htscodecs.h \
-	htscodecs_endian.h \
-	utils.h
-
-libhtscodecs_la_LDFLAGS = -version-info @VERS_CURRENT@:@VERS_REVISION@:@VERS_AGE@ 
-libhtscodecs_la_LIBADD = @LIBZ@
-
-version.h: force
-	@ if `git describe 2>/dev/null >/dev/null`; then \
-	    echo '#define HTSCODECS_VERSION_TEXT "'`git describe --match 'v[0-9]\.[0-9]*' --dirty|sed 's/^v//'`'"' > _version.h; \
-	else \
-	    echo '#define HTSCODECS_VERSION_TEXT "@PACKAGE_VERSION@"' > _version.h; \
-	fi;
-	@ if ( [ ! -e version.h ] || ! cmp -s version.h _version.h); then \
-	    echo "Update version.h: `cat _version.h`"; \
-	    mv _version.h version.h; \
-	else \
-	    rm _version.h; \
-	fi
-
-force:
-
-.PHONY: force
-
-# Manually added as the auto-dependency generation won't pick up a file that
-# may not yet exist.
-BUILT_SOURCES = version.h
-
-distclean-local:
-	rm version.h
diff -ruN stringtie.orig/htslib/htscodecs/htscodecs/pack.c stringtie/htslib/htscodecs/htscodecs/pack.c
--- stringtie.orig/htslib/htscodecs/htscodecs/pack.c	2024-02-28 13:57:39.704579460 +0100
+++ stringtie/htslib/htscodecs/htscodecs/pack.c	1970-01-01 01:00:00.000000000 +0100
@@ -1,398 +0,0 @@
-/*
- * Copyright (c) 2019 Genome Research Ltd.
- * Author(s): James Bonfield
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions are met:
- *
- *    1. Redistributions of source code must retain the above copyright notice,
- *       this list of conditions and the following disclaimer.
- *
- *    2. Redistributions in binary form must reproduce the above
- *       copyright notice, this list of conditions and the following
- *       disclaimer in the documentation and/or other materials provided
- *       with the distribution.
- *
- *    3. Neither the names Genome Research Ltd and Wellcome Trust Sanger
- *       Institute nor the names of its contributors may be used to endorse
- *       or promote products derived from this software without specific
- *       prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY GENOME RESEARCH LTD AND CONTRIBUTORS "AS
- * IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
- * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
- * PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL GENOME RESEARCH
- * LTD OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
- * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
- * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
- * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
- * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
- * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
- * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- */
-
-#include "config.h"
-
-#include <stdint.h>
-#include <string.h>
-#include <stdlib.h>
-#include <stdio.h>
-
-#include "pack.h"
-
-//-----------------------------------------------------------------------------
-
-/*
- * Packs multiple symbols into a single byte if the total alphabet of symbols
- * used is <= 16.  Each new symbol takes up 1, 2, 4 or 8 bits, or 0 if the
- * alphabet used is 1 (constant).
- *
- * If successful, out_meta/out_meta_len are set to hold the mapping table
- * to be used during decompression.
- *
- * Returns the packed buffer on success with new length in out_len,
- *         NULL of failure
- */
-uint8_t *hts_pack(uint8_t *data, int64_t len,
-		  uint8_t *out_meta, int *out_meta_len, uint64_t *out_len) {
-    int p[256] = {0}, n;
-    uint64_t i, j;
-    uint8_t *out = malloc(len+1);
-    if (!out)
-	return NULL;
-
-    // count syms
-    for (i = 0; i < len; i++)
-	p[data[i]]=1;
-    
-    for (i = n = 0; i < 256; i++) {
-	if (p[i]) {
-	    p[i] = n++; // p[i] is now the code number
-	    out_meta[n] = i;
-	}
-    }
-    out_meta[0] = n; // 256 wraps to 0
-    j = n+1;
-
-    // 1 value per byte
-    if (n > 16) {
-	*out_meta_len = 1;
-	// FIXME shortcut this by returning data and checking later.
-	memcpy(out, data, len);
-	*out_len = len;
-	return out;
-    }
-
-    // Work out how many values per byte to encode.
-    int val_per_byte;
-    if (n > 4)
-	val_per_byte = 2;
-    else if (n > 2)
-	val_per_byte = 4;
-    else if (n > 1)
-	val_per_byte = 8;
-    else
-	val_per_byte = 0; // infinite
-
-    *out_meta_len = j;
-    j = 0;
-
-    switch (val_per_byte) {
-    case 2:
-	for (i = 0; i < (len & ~1); i+=2)
-	    out[j++] = (p[data[i]]<<0) | (p[data[i+1]]<<4);
-	switch (len-i) {
-	case 1: out[j++] = p[data[i]];
-	}
-	*out_len = j;
-	return out;
-
-    case 4: {
-	for (i = 0; i < (len & ~3); i+=4)
-	    out[j++] = (p[data[i]]<<0) | (p[data[i+1]]<<2) | (p[data[i+2]]<<4) | (p[data[i+3]]<<6);
-	out[j] = 0;
-	int s = len-i, x = 0;
-	switch (s) {
-	case 3: out[j] |= p[data[i++]] << x; x+=2;
-	case 2: out[j] |= p[data[i++]] << x; x+=2;
-	case 1: out[j] |= p[data[i++]] << x; x+=2;
-	    j++;
-	}
-	*out_len = j;
-	return out;
-    }
-
-    case 8: {
-	for (i = 0; i < (len & ~7); i+=8)
-	    out[j++] = (p[data[i+0]]<<0) | (p[data[i+1]]<<1) | (p[data[i+2]]<<2) | (p[data[i+3]]<<3)
-		     | (p[data[i+4]]<<4) | (p[data[i+5]]<<5) | (p[data[i+6]]<<6) | (p[data[i+7]]<<7);
-	out[j] = 0;
-	int s = len-i, x = 0;
-	switch (s) {
-	case 7: out[j] |= p[data[i++]] << x++;
-	case 6: out[j] |= p[data[i++]] << x++;
-	case 5: out[j] |= p[data[i++]] << x++;
-	case 4: out[j] |= p[data[i++]] << x++;
-	case 3: out[j] |= p[data[i++]] << x++;
-	case 2: out[j] |= p[data[i++]] << x++;
-	case 1: out[j] |= p[data[i++]] << x++;
-	    j++;
-	}
-	*out_len = j;
-	return out;
-    }
-
-    case 0:
-	*out_len = j;
-	return out;
-    }
-
-    return NULL;
-}
-
-
-/*
- * Unpacks the meta-data portions of the hts_pack algorithm.
- * This consists of the count of symbols and their values.
- *
- * The "map" array is filled out with the used symbols.
- * "nsym" is set to contain the number of symbols per byte;
- * 0, 1, 2, 4 or 8.
- *
- * Returns number of bytes of data[] consumed on success,
- *         zero on failure.
- */
-uint8_t hts_unpack_meta(uint8_t *data, uint32_t data_len,
-			uint64_t udata_len, uint8_t *map, int *nsym) {
-    if (data_len == 0)
-	return 0;
-
-    // Number of symbols used
-    unsigned int n = data[0];
-    if (n == 0)
-	n = 256;
-
-    // Symbols per byte
-    if (n <= 1)
-	*nsym = 0;
-    else if (n <= 2)
-	*nsym = 8;
-    else if (n <= 4)
-	*nsym = 4;
-    else if (n <= 16)
-	*nsym = 2;
-    else {
-	*nsym = 1; // no packing
-	return 1;
-    }
-
-    if (data_len <= 1)
-	return 0;
-
-    int j = 1, c = 0;
-    do {
-	map[c++] = data[j++];
-    } while (c < n && j < data_len);
-
-    return c < n ? 0 : j;
-}
-
-/*
- * Unpacks a packed data steam (given the unpacked meta-data).
- *
- * "map" is the pack map, mapping 0->n to the expanded symbols.
- * The "out" buffer must be preallocated by the caller to be the correct
- * size.  For error checking purposes, out_len is set to the size of
- * this buffer.
- *
- * Returns uncompressed data (out) on success,
- *         NULL on failure.
- */
-uint8_t *hts_unpack(uint8_t *data, int64_t len, uint8_t *out, uint64_t out_len, int nsym, uint8_t *p) {
-    //uint8_t *out;
-    uint8_t c = 0;
-    int64_t i, j = 0, olen;
-
-    if (nsym == 1) {
-	// raw data; FIXME: shortcut the need for malloc & memcpy here
-	memcpy(out, data, len);
-	return out;
-    }
-
-    switch(nsym) {
-    case 8: {
-	union {
-	    uint64_t w;
-	    uint8_t c[8];
-	} map[256];
-	int x;
-	for (x = 0; x < 256; x++) {
-	    map[x].c[0] = p[x>>0&1];
-	    map[x].c[1] = p[x>>1&1];
-	    map[x].c[2] = p[x>>2&1];
-	    map[x].c[3] = p[x>>3&1];
-	    map[x].c[4] = p[x>>4&1];
-	    map[x].c[5] = p[x>>5&1];
-	    map[x].c[6] = p[x>>6&1];
-	    map[x].c[7] = p[x>>7&1];
-	}
-	if ((out_len+7)/8 > len)
-	    return NULL;
-	olen = out_len & ~7;
-
-	for (i = 0; i < olen; i+=8)
-	    memcpy(&out[i], &map[data[j++]].w, 8);
-
-	if (out_len != olen) {
-	    c = data[j++];
-	    while (i < out_len) {
-		out[i++] = p[c & 1];
-		c >>= 1;
-	    }
-	}
-	break;
-    }
-
-    case 4: {
-	union {
-	    uint32_t w;
-	    uint8_t c[4];
-	} map[256];
-
-	int x, y, z, _, P=0;
-	for (x = 0; x < 4; x++)
-	    for (y = 0; y < 4; y++)
-		for (z = 0; z < 4; z++)
-		    for (_ = 0; _ < 4; _++, P++) {
-			map[P].c[0] = p[_];
-			map[P].c[1] = p[z];
-			map[P].c[2] = p[y];
-			map[P].c[3] = p[x];
-		    }
-
-	if ((out_len+3)/4 > len)
-	    return NULL;
-	olen = out_len & ~3;
-
-	for (i = 0; i < olen-12; i+=16) {
-	    uint32_t w[] = {
-		map[data[j+0]].w,
-		map[data[j+1]].w,
-		map[data[j+2]].w,
-		map[data[j+3]].w
-	    };
-	    j += 4;
-	    memcpy(&out[i], &w, 16);
-	}
-
-	for (; i < olen; i+=4)
-	    memcpy(&out[i], &map[data[j++]].w, 4);
-
-	if (out_len != olen) {
-	    c = data[j++];
-	    while (i < out_len) {
-		out[i++] = p[c & 3];
-		c >>= 2;
-	    }
-	}
-	break;
-    }
-
-    case 2: {
-	union {
-	    uint16_t w;
-	    uint8_t c[2];
-	} map[256];
-
-	int x, y;
-	for (x = 0; x < 16; x++) {
-	    for (y = 0; y < 16; y++) {
-		map[x*16+y].c[0] = p[y];
-		map[x*16+y].c[1] = p[x];
-	    }
-	}
-
-	if ((out_len+1)/2 > len)
-	    return NULL;
-	olen = out_len & ~1;
-
-	for (i = j = 0; i+2 < olen; i+=4) {
-	    uint16_t w[] = {
-	    	map[data[j+0]].w,
-	    	map[data[j+1]].w
-	    };
-	    memcpy(&out[i], &w, 4);
-
-	    j += 2;
-	}
-
-	for (; i < olen; i+=2)
-	    memcpy(&out[i], &map[data[j++]].w, 2);
-
-	if (out_len != olen) {
-	    c = data[j++];
-	    out[i+0] = p[c&15];
-	}
-	break;
-    }
-
-    case 0:
-	memset(out, p[0], out_len);
-	break;
-
-    default:
-	return NULL;
-    }
-
-    return out;
-}
-
-
-uint8_t *hts_unpack_(uint8_t *data, int64_t len, uint8_t *out, uint64_t out_len, int nsym, uint8_t *p) {
-    //uint8_t *out;
-    uint8_t c = 0;
-    int64_t i, j = 0, olen;
-
-    if (nsym == 1) {
-	// raw data; FIXME: shortcut the need for malloc & memcpy here
-	memcpy(out, data, len);
-	return out;
-    }
-
-    switch(nsym) {
-    case 2: {
-	uint16_t map[256], x, y;
-	for (x = 0; x < 16; x++)
-	    for (y = 0; y < 16; y++)
-		map[x*16+y] = p[x]*256+p[y];
-
-	if ((out_len+1)/2 > len)
-	    return NULL;
-	olen = out_len & ~1;
-
-	uint16_t *o16 = (uint16_t *)out;
-	for (i = 0; i+4 < olen/2; i+=4) {
-	    int k;
-	    for (k = 0; k < 4; k++)
-		o16[i+k] = map[data[i+k]];
-	}
-	j = i; i *= 2;
-
-	for (; i < olen; i+=2) {
-	    uint16_t w1 = map[data[j++]];
-	    *(uint16_t *)&out[i] = w1;
-	}
-
-	if (out_len != olen) {
-	    c = data[j++];
-	    out[i+0] = p[c&15];
-	}
-	break;
-    }
-
-    default:
-	return NULL;
-    }
-
-    return out;
-}
diff -ruN stringtie.orig/htslib/htscodecs/htscodecs/pack.h stringtie/htslib/htscodecs/htscodecs/pack.h
--- stringtie.orig/htslib/htscodecs/htscodecs/pack.h	2024-02-28 13:57:39.704579460 +0100
+++ stringtie/htslib/htscodecs/htscodecs/pack.h	1970-01-01 01:00:00.000000000 +0100
@@ -1,86 +0,0 @@
-/*
- * Copyright (c) 2019 Genome Research Ltd.
- * Author(s): James Bonfield
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions are met:
- *
- *    1. Redistributions of source code must retain the above copyright notice,
- *       this list of conditions and the following disclaimer.
- *
- *    2. Redistributions in binary form must reproduce the above
- *       copyright notice, this list of conditions and the following
- *       disclaimer in the documentation and/or other materials provided
- *       with the distribution.
- *
- *    3. Neither the names Genome Research Ltd and Wellcome Trust Sanger
- *       Institute nor the names of its contributors may be used to endorse
- *       or promote products derived from this software without specific
- *       prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY GENOME RESEARCH LTD AND CONTRIBUTORS "AS
- * IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
- * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
- * PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL GENOME RESEARCH
- * LTD OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
- * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
- * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
- * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
- * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
- * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
- * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- */
-
-#ifndef HTS_PACK_H
-#define HTS_PACK_H
-
-#ifdef __cplusplus
-extern "C" {
-#endif
-
-/*
- * Packs multiple symbols into a single byte if the total alphabet of symbols
- * used is <= 16.  Each new symbol takes up 1, 2, 4 or 8 bits, or 0 if the
- * alphabet used is 1 (constant).
- *
- * If successful, out_meta/out_meta_len are set to hold the mapping table
- * to be used during decompression.
- *
- * Returns the packed buffer on success with new length in out_len,
- *         NULL of failure
- */
-uint8_t *hts_pack(uint8_t *data, int64_t len,
-		  uint8_t *out_meta, int *out_meta_len, uint64_t *out_len);
-
-/*
- * Unpacks the meta-data portions of the hts_pack algorithm.
- * This consists of the count of symbols and their values.
- *
- * The "map" array is filled out with the used symbols.
- * "nsym" is set to contain the number of symbols per byte;
- * 0, 1, 2, 4 or 8.
- *
- * Returns number of bytes of data[] consumed on success,
- *         zero on failure.
- */
-uint8_t hts_unpack_meta(uint8_t *data, uint32_t data_len,
-			uint64_t udata_len, uint8_t *map, int *nsym);
-
-/*
- * Unpacks a packed data steam (given the unpacked meta-data).
- *
- * "map" is the pack map, mapping 0->n to the expanded symbols.
- * The "out" buffer must be preallocated by the caller to be the correct
- * size.  For error checking purposes, out_len is set to the size of
- * this buffer.
- *
- * Returns uncompressed data (out) on success,
- *         NULL on failure.
- */
-uint8_t *hts_unpack(uint8_t *data, int64_t len, uint8_t *out, uint64_t out_len, int nsym, uint8_t *map);
-
-#ifdef __cplusplus
-}
-#endif
-
-#endif /* HTS_PACK_H */
diff -ruN stringtie.orig/htslib/htscodecs/htscodecs/pooled_alloc.h stringtie/htslib/htscodecs/htscodecs/pooled_alloc.h
--- stringtie.orig/htslib/htscodecs/htscodecs/pooled_alloc.h	2024-02-28 13:57:39.704579460 +0100
+++ stringtie/htslib/htscodecs/htscodecs/pooled_alloc.h	1970-01-01 01:00:00.000000000 +0100
@@ -1,145 +0,0 @@
-/*
- * Copyright (c) 2009-2010, 2013 Genome Research Ltd.
- * Author(s): James Bonfield
- * 
- * Redistribution and use in source and binary forms, with or without 
- * modification, are permitted provided that the following conditions are met:
- * 
- *    1. Redistributions of source code must retain the above copyright notice,
- *       this list of conditions and the following disclaimer.
- * 
- *    2. Redistributions in binary form must reproduce the above
- *       copyright notice, this list of conditions and the following
- *       disclaimer in the documentation and/or other materials provided
- *       with the distribution.
- * 
- *    3. Neither the names Genome Research Ltd and Wellcome Trust Sanger
- *    Institute nor the names of its contributors may be used to endorse
- *    or promote products derived from this software without specific
- *    prior written permission.
- * 
- * THIS SOFTWARE IS PROVIDED BY GENOME RESEARCH LTD AND CONTRIBUTORS "AS
- * IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
- * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
- * PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL GENOME RESEARCH
- * LTD OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
- * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
- * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
- * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
- * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
- * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
- * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- */
-
-// Defined static here as we only use in one file for now and don't
-// want to pollute the library name space (io_lib has the same named
-// functions).
-
-#ifndef _POOLED_ALLOC_H_
-#define _POOLED_ALLOC_H_
-
-#include <stdlib.h>
-#include <stdio.h>
-#include <stdint.h>
-
-/*
- * Implements a pooled block allocator where all items are the same size,
- * but we need many of them.
- */
-typedef struct {
-    void   *pool;
-    size_t  used;
-} pool_t;
-
-typedef struct {
-    size_t dsize;
-    size_t npools;
-    pool_t *pools;
-    void *free;
-} pool_alloc_t;
-
-#define PSIZE 1024*1024
-
-static pool_alloc_t *pool_create(size_t dsize) {
-    pool_alloc_t *p;
-
-    if (NULL == (p = (pool_alloc_t *)malloc(sizeof(*p))))
-	return NULL;
-
-    /* Minimum size is a pointer, for free list */
-    dsize = (dsize + sizeof(void *) - 1) & ~(sizeof(void *)-1);
-    if (dsize < sizeof(void *))
-	dsize = sizeof(void *);
-    p->dsize = dsize;
-
-    p->npools = 0;
-    p->pools = NULL;
-    p->free  = NULL;
-
-    return p;
-}
-
-static pool_t *new_pool(pool_alloc_t *p) {
-    size_t n = PSIZE / p->dsize;
-    pool_t *pool;
-    
-    pool = realloc(p->pools, (p->npools + 1) * sizeof(*p->pools));
-    if (NULL == pool) return NULL;
-    p->pools = pool;
-    pool = &p->pools[p->npools];
-
-    pool->pool = malloc(n * p->dsize);
-    if (NULL == pool->pool) return NULL;
-
-    pool->used = 0;
-
-    p->npools++;
-
-    return pool;
-}
-
-static void pool_destroy(pool_alloc_t *p) {
-    size_t i;
-
-    for (i = 0; i < p->npools; i++) {
-        free(p->pools[i].pool);
-    }
-    free(p->pools);
-    free(p);
-}
-
-static void *pool_alloc(pool_alloc_t *p) {
-    pool_t *pool;
-    void *ret;
-
-    /* Look on free list */
-    if (NULL != p->free) {
-        ret = p->free;
-	p->free = *((void **)p->free);
-	return ret;
-    }
-
-    /* Look for space in the last pool */
-    if (p->npools) {
-        pool = &p->pools[p->npools - 1];
-        if (pool->used + p->dsize < PSIZE) {
-	    ret = ((char *) pool->pool) + pool->used;
-	    pool->used += p->dsize;
-	    return ret;
-	}
-    }
-
-    /* Need a new pool */
-    pool = new_pool(p);
-    if (NULL == pool) return NULL;
-
-    pool->used = p->dsize;
-    return pool->pool;
-}
-
-// static void pool_free(pool_alloc_t *p, void *ptr) {
-//     *(void **)ptr = p->free;
-//     p->free = ptr;
-// }
-
-#endif /*_POOLED_ALLOC_H_*/
diff -ruN stringtie.orig/htslib/htscodecs/htscodecs/rANS_byte.h stringtie/htslib/htscodecs/htscodecs/rANS_byte.h
--- stringtie.orig/htslib/htscodecs/htscodecs/rANS_byte.h	2024-02-28 13:57:39.704579460 +0100
+++ stringtie/htslib/htscodecs/htscodecs/rANS_byte.h	1970-01-01 01:00:00.000000000 +0100
@@ -1,566 +0,0 @@
-/* rans_byte.h originally from https://github.com/rygorous/ryg_rans
- *
- * This is a public-domain implementation of several rANS variants. rANS is an
- * entropy coder from the ANS family, as described in Jarek Duda's paper
- * "Asymmetric numeral systems" (http://arxiv.org/abs/1311.2540).
- */
-
-/*-------------------------------------------------------------------------- */
-/* rans_byte.h from https://github.com/rygorous/ryg_rans */
-
-// Simple byte-aligned rANS encoder/decoder - public domain - Fabian 'ryg' Giesen 2014
-//
-// Not intended to be "industrial strength"; just meant to illustrate the general
-// idea.
-
-#ifndef RANS_BYTE_HEADER
-#define RANS_BYTE_HEADER
-
-#include <stdio.h>
-#include <stdint.h>
-#include <assert.h>
-
-#ifdef assert
-#define RansAssert assert
-#else
-#define RansAssert(x)
-#endif
-
-// READ ME FIRST:
-//
-// This is designed like a typical arithmetic coder API, but there's three
-// twists you absolutely should be aware of before you start hacking:
-//
-// 1. You need to encode data in *reverse* - last symbol first. rANS works
-//    like a stack: last in, first out.
-// 2. Likewise, the encoder outputs bytes *in reverse* - that is, you give
-//    it a pointer to the *end* of your buffer (exclusive), and it will
-//    slowly move towards the beginning as more bytes are emitted.
-// 3. Unlike basically any other entropy coder implementation you might
-//    have used, you can interleave data from multiple independent rANS
-//    encoders into the same bytestream without any extra signaling;
-//    you can also just write some bytes by yourself in the middle if
-//    you want to. This is in addition to the usual arithmetic encoder
-//    property of being able to switch models on the fly. Writing raw
-//    bytes can be useful when you have some data that you know is
-//    incompressible, and is cheaper than going through the rANS encode
-//    function. Using multiple rANS coders on the same byte stream wastes
-//    a few bytes compared to using just one, but execution of two
-//    independent encoders can happen in parallel on superscalar and
-//    Out-of-Order CPUs, so this can be *much* faster in tight decoding
-//    loops.
-//
-//    This is why all the rANS functions take the write pointer as an
-//    argument instead of just storing it in some context struct.
-
-// --------------------------------------------------------------------------
-
-// L ('l' in the paper) is the lower bound of our normalization interval.
-// Between this and our byte-aligned emission, we use 31 (not 32!) bits.
-// This is done intentionally because exact reciprocals for 31-bit uints
-// fit in 32-bit uints: this permits some optimizations during encoding.
-#define RANS_BYTE_L (1u << 23)  // lower bound of our normalization interval
-
-// State for a rANS encoder. Yep, that's all there is to it.
-typedef uint32_t RansState;
-
-// Initialize a rANS encoder.
-static inline void RansEncInit(RansState* r)
-{
-    *r = RANS_BYTE_L;
-}
-
-#if 0 /* Curently unused */
-// Renormalize the encoder. Internal function.
-static inline RansState RansEncRenorm(RansState x, uint8_t** pptr, uint32_t freq, uint32_t scale_bits)
-{
-    uint32_t x_max = ((RANS_BYTE_L >> scale_bits) << 8) * freq; // this turns into a shift.
-    if (x >= x_max) {
-        uint8_t* ptr = *pptr;
-        do {
-            *--ptr = (uint8_t) (x & 0xff);
-            x >>= 8;
-        } while (x >= x_max);
-        *pptr = ptr;
-    }
-    return x;
-}
-
-// Encodes a single symbol with range start "start" and frequency "freq".
-// All frequencies are assumed to sum to "1 << scale_bits", and the
-// resulting bytes get written to ptr (which is updated).
-//
-// NOTE: With rANS, you need to encode symbols in *reverse order*, i.e. from
-// beginning to end! Likewise, the output bytestream is written *backwards*:
-// ptr starts pointing at the end of the output buffer and keeps decrementing.
-static inline void RansEncPut(RansState* r, uint8_t** pptr, uint32_t start, uint32_t freq, uint32_t scale_bits)
-{
-    // renormalize
-    RansState x = RansEncRenorm(*r, pptr, freq, scale_bits);
-
-    // x = C(s,x)
-    *r = ((x / freq) << scale_bits) + (x % freq) + start;
-}
-#endif /* Curently unused */
-
-// Flushes the rANS encoder.
-static inline void RansEncFlush(RansState* r, uint8_t** pptr)
-{
-    uint32_t x = *r;
-    uint8_t* ptr = *pptr;
-
-    ptr -= 4;
-    ptr[0] = (uint8_t) (x >> 0);
-    ptr[1] = (uint8_t) (x >> 8);
-    ptr[2] = (uint8_t) (x >> 16);
-    ptr[3] = (uint8_t) (x >> 24);
-
-    *pptr = ptr;
-}
-
-// Initializes a rANS decoder.
-// Unlike the encoder, the decoder works forwards as you'd expect.
-static inline void RansDecInit(RansState* r, uint8_t** pptr)
-{
-    uint32_t x;
-    uint8_t* ptr = *pptr;
-
-    x  = ptr[0] << 0;
-    x |= ptr[1] << 8;
-    x |= ptr[2] << 16;
-    x |= ((uint32_t)ptr[3]) << 24;
-    ptr += 4;
-
-    *pptr = ptr;
-    *r = x;
-}
-
-// Returns the current cumulative frequency (map it to a symbol yourself!)
-static inline uint32_t RansDecGet(RansState* r, uint32_t scale_bits)
-{
-    return *r & ((1u << scale_bits) - 1);
-}
-
-// Advances in the bit stream by "popping" a single symbol with range start
-// "start" and frequency "freq". All frequencies are assumed to sum to "1 << scale_bits",
-// and the resulting bytes get written to ptr (which is updated).
-static inline void RansDecAdvance(RansState* r, uint8_t** pptr, uint32_t start, uint32_t freq, uint32_t scale_bits)
-{
-    uint32_t mask = (1u << scale_bits) - 1;
-
-    // s, x = D(x)
-    uint32_t x = *r;
-    x = freq * (x >> scale_bits) + (x & mask) - start;
-
-    // renormalize
-    if (x < RANS_BYTE_L) {
-        uint8_t* ptr = *pptr;
-        do x = (x << 8) | *ptr++; while (x < RANS_BYTE_L);
-        *pptr = ptr;
-    }
-
-    *r = x;
-}
-
-// --------------------------------------------------------------------------
-
-// That's all you need for a full encoder; below here are some utility
-// functions with extra convenience or optimizations.
-
-// Encoder symbol description
-// This (admittedly odd) selection of parameters was chosen to make
-// RansEncPutSymbol as cheap as possible.
-typedef struct {
-    uint32_t x_max;     // (Exclusive) upper bound of pre-normalization interval
-    uint32_t rcp_freq;  // Fixed-point reciprocal frequency
-    uint32_t bias;      // Bias
-    uint16_t cmpl_freq; // Complement of frequency: (1 << scale_bits) - freq
-    uint16_t rcp_shift; // Reciprocal shift
-} RansEncSymbol;
-
-// Decoder symbols are straightforward.
-// 32-bit means more memory, but oddly faster on old gcc? Why?
-// 322MB/s vs 309MB/s for order-1.
-typedef struct {
-    uint16_t freq;      // Symbol frequency.
-    uint16_t start;     // Start of range.
-} RansDecSymbol;
-
-typedef struct {
-    uint32_t freq;      // Symbol frequency.
-    uint32_t start;     // Start of range.
-} RansDecSymbol32;
-
-// Initializes an encoder symbol to start "start" and frequency "freq"
-static inline void RansEncSymbolInit(RansEncSymbol* s, uint32_t start, uint32_t freq, uint32_t scale_bits)
-{
-    RansAssert(scale_bits <= 16);
-    RansAssert(start <= (1u << scale_bits));
-    RansAssert(freq <= (1u << scale_bits) - start);
-
-    // Say M := 1 << scale_bits.
-    //
-    // The original encoder does:
-    //   x_new = (x/freq)*M + start + (x%freq)
-    //
-    // The fast encoder does (schematically):
-    //   q     = mul_hi(x, rcp_freq) >> rcp_shift   (division)
-    //   r     = x - q*freq                         (remainder)
-    //   x_new = q*M + bias + r                     (new x)
-    // plugging in r into x_new yields:
-    //   x_new = bias + x + q*(M - freq)
-    //        =: bias + x + q*cmpl_freq             (*)
-    //
-    // and we can just precompute cmpl_freq. Now we just need to
-    // set up our parameters such that the original encoder and
-    // the fast encoder agree.
-
-    s->x_max = ((RANS_BYTE_L >> scale_bits) << 8) * freq;
-    s->cmpl_freq = (uint16_t) ((1 << scale_bits) - freq);
-    if (freq < 2) {
-        // freq=0 symbols are never valid to encode, so it doesn't matter what
-        // we set our values to.
-        //
-        // freq=1 is tricky, since the reciprocal of 1 is 1; unfortunately,
-        // our fixed-point reciprocal approximation can only multiply by values
-        // smaller than 1.
-        //
-        // So we use the "next best thing": rcp_freq=0xffffffff, rcp_shift=0.
-        // This gives:
-        //   q = mul_hi(x, rcp_freq) >> rcp_shift
-        //     = mul_hi(x, (1<<32) - 1)) >> 0
-        //     = floor(x - x/(2^32))
-        //     = x - 1 if 1 <= x < 2^32
-        // and we know that x>0 (x=0 is never in a valid normalization interval).
-        //
-        // So we now need to choose the other parameters such that
-        //   x_new = x*M + start
-        // plug it in:
-        //     x*M + start                   (desired result)
-        //   = bias + x + q*cmpl_freq        (*)
-        //   = bias + x + (x - 1)*(M - 1)    (plug in q=x-1, cmpl_freq)
-        //   = bias + 1 + (x - 1)*M
-        //   = x*M + (bias + 1 - M)
-        //
-        // so we have start = bias + 1 - M, or equivalently
-        //   bias = start + M - 1.
-        s->rcp_freq = ~0u;
-        s->rcp_shift = 0;
-        s->bias = start + (1 << scale_bits) - 1;
-    } else {
-        // Alverson, "Integer Division using reciprocals"
-        // shift=ceil(log2(freq))
-        uint32_t shift = 0;
-        while (freq > (1u << shift))
-            shift++;
-
-        s->rcp_freq = (uint32_t) (((1ull << (shift + 31)) + freq-1) / freq);
-        s->rcp_shift = shift - 1;
-
-        // With these values, 'q' is the correct quotient, so we
-        // have bias=start.
-        s->bias = start;
-    }
-
-    s->rcp_shift += 32; // Avoid the extra >>32 in RansEncPutSymbol
-}
-
-// Initialize a decoder symbol to start "start" and frequency "freq"
-static inline void RansDecSymbolInit(RansDecSymbol* s, uint32_t start, uint32_t freq)
-{
-    RansAssert(start <= (1 << 16));
-    RansAssert(freq <= (1 << 16) - start);
-    s->start = (uint16_t) start;
-    s->freq = (uint16_t) freq;
-}
-
-// Encodes a given symbol. This is faster than straight RansEnc since we can do
-// multiplications instead of a divide.
-//
-// See RansEncSymbolInit for a description of how this works.
-static inline void RansEncPutSymbol(RansState* r, uint8_t** pptr, RansEncSymbol const* sym)
-{
-    RansAssert(sym->x_max != 0); // can't encode symbol with freq=0
-
-    // renormalize
-    uint32_t x = *r;
-    uint32_t x_max = sym->x_max;
-
-    // This is better for 40-qual illumina (3.7% quicker overall CRAM).
-    // The old method was better for low complexity data such as NovaSeq
-    // quals (2.6% quicker overall CRAM).
-    int o = x >= x_max;
-    uint8_t* ptr = *pptr;
-    ptr[-1] = x & 0xff;
-    ptr -= o;
-    x >>= o*8;
-    if (x >= x_max) {
-        *--ptr = (uint8_t) (x & 0xff);
-        x >>= 8;
-    }
-    *pptr = ptr;
-
-    //uint32_t q = (uint32_t) (((uint64_t)x * sym->rcp_freq) >> sym->rcp_shift);
-    //*r = q * sym->cmpl_freq + x + sym->bias;
-
-    // x = C(s,x)
-    // NOTE: written this way so we get a 32-bit "multiply high" when
-    // available. If you're on a 64-bit platform with cheap multiplies
-    // (e.g. x64), just bake the +32 into rcp_shift.
-    //uint32_t q = (uint32_t) (((uint64_t)x * sym->rcp_freq) >> 32) >> sym->rcp_shift;
-
-    // The extra >>32 has already been added to RansEncSymbolInit
-    uint32_t q = (uint32_t) (((uint64_t)x * sym->rcp_freq) >> sym->rcp_shift);
-    *r = q * sym->cmpl_freq + x + sym->bias;
-}
-
-// A 4-way version of RansEncPutSymbol, renormalising 4 states
-// simulatenously with their results written to the same ptr buffer.
-// (This is perhaps a failing as it makes optmisation tricky.)
-static inline void RansEncPutSymbol4(RansState *r0,
-                                     RansState *r1,
-                                     RansState *r2,
-                                     RansState *r3,
-                                     uint8_t** pptr,
-                                     RansEncSymbol const *sym0,
-                                     RansEncSymbol const *sym1,
-                                     RansEncSymbol const *sym2,
-                                     RansEncSymbol const *sym3)
-{
-    RansAssert(sym0->x_max != 0); // can't encode symbol with freq=0
-    RansAssert(sym1->x_max != 0); // can't encode symbol with freq=0
-    RansAssert(sym2->x_max != 0); // can't encode symbol with freq=0
-    RansAssert(sym3->x_max != 0); // can't encode symbol with freq=0
-
-    // renormalize
-    uint32_t x0, x1, x2, x3;
-    uint8_t* ptr = *pptr;
-
-    int o;
-    uint32_t m[4] = {
-        sym0->x_max,
-        sym1->x_max,
-        sym2->x_max,
-        sym3->x_max
-    };
-
-    x0 = *r0;
-    o = x0 >= m[0];
-    ptr[-1] = x0;
-    ptr -= o;
-    x0 >>= o*8;
-    if (x0 >= m[0]) {
-        *--ptr = x0;
-        x0 >>= 8;
-    }
-
-    x1 = *r1;
-    o = x1 >= m[1];
-    ptr[-1] = x1;
-    ptr -= o;
-    x1 >>= o*8;
-    if (x1 >= m[1]) {
-        *--ptr = x1;
-        x1 >>= 8;
-    }
-
-    x2 = *r2;
-    o = x2 >= m[2];
-    ptr[-1] = x2;
-    ptr -= o;
-    x2 >>= o*8;
-    if (x2 >= m[2]) {
-        *--ptr = x2;
-        x2 >>= 8;
-    }
-
-    x3 = *r3;
-    o = x3 >= m[3];
-    ptr[-1] = x3;
-    ptr -= o;
-    x3 >>= o*8;
-    if (x3 >= m[3]) {
-        *--ptr = x3;
-        x3 >>= 8;
-    }
-
-    *pptr = ptr;
-
-    // x = C(s,x)
-    uint32_t qa, qb;
-    qa = (uint32_t) (((uint64_t)x0 * sym0->rcp_freq) >> sym0->rcp_shift);
-    uint32_t X0 = qa * sym0->cmpl_freq;
-    qb = (uint32_t) (((uint64_t)x1 * sym1->rcp_freq) >> sym1->rcp_shift);
-    uint32_t X1 = qb * sym1->cmpl_freq;
-
-    *r0 = X0 + x0 + sym0->bias;
-    *r1 = X1 + x1 + sym1->bias;
-
-    qa = (uint32_t) (((uint64_t)x2 * sym2->rcp_freq) >> sym2->rcp_shift);
-    uint32_t X2 = qa * sym2->cmpl_freq;
-    qb = (uint32_t) (((uint64_t)x3 * sym3->rcp_freq) >> sym3->rcp_shift);
-    uint32_t X3 = qb * sym3->cmpl_freq;
-
-    *r2 = X2 + x2 + sym2->bias;
-    *r3 = X3 + x3 + sym3->bias;
-}
-
-// Equivalent to RansDecAdvance that takes a symbol.
-static inline void RansDecAdvanceSymbol(RansState* r, uint8_t** pptr, RansDecSymbol const* sym, uint32_t scale_bits)
-{
-    RansDecAdvance(r, pptr, sym->start, sym->freq, scale_bits);
-}
-
-// Advances in the bit stream by "popping" a single symbol with range start
-// "start" and frequency "freq". All frequencies are assumed to sum to "1 << scale_bits".
-// No renormalization or output happens.
-static inline void RansDecAdvanceStep(RansState* r, uint32_t start, uint32_t freq, uint32_t scale_bits)
-{
-    uint32_t mask = (1u << scale_bits) - 1;
-
-    // s, x = D(x)
-    uint32_t x = *r;
-    *r = freq * (x >> scale_bits) + (x & mask) - start;
-}
-
-// Equivalent to RansDecAdvanceStep that takes a symbol.
-static inline void RansDecAdvanceSymbolStep(RansState* r, RansDecSymbol const* sym, uint32_t scale_bits)
-{
-    RansDecAdvanceStep(r, sym->start, sym->freq, scale_bits);
-}
-
-// Renormalize.
-#if defined(__x86_64) && !defined(__ILP32__)
-/*
- * Assembly variants of the RansDecRenorm code.
- * These are based on joint ideas from Rob Davies and from looking at
- * the clang assembly output.
- */
-static inline void RansDecRenorm(RansState* r, uint8_t** pptr) {
-    uint32_t  x   = *r;
-    uint8_t  *ptr = *pptr;
-
-    __asm__ ("movzbl (%0), %%eax\n\t"
-	     "mov    %1, %%edx\n\t"
-	     "shl    $0x8,%%edx\n\t"
-             "or     %%eax,%%edx\n\t"
-             "cmp    $0x800000,%1\n\t"
-             "cmovb  %%edx,%1\n\t"
-             "adc    $0x0,%0\n\t"
-             : "=r" (ptr), "=r" (x)
-             : "0" (ptr), "1" (x)
-             : "eax", "edx"
-             );
-    if (x < 0x800000) x = (x << 8) | *ptr++;
-    *pptr = ptr;
-    *r = x;
-}
-
-/*
- * A variant that normalises two rans states.
- * The only minor tweak here is to adjust the reorder a few opcodes
- * to reduce dependency delays.
- */
-static inline void RansDecRenorm2(RansState* r1, RansState* r2, uint8_t** pptr) {
-    uint32_t  x1   = *r1;
-    uint32_t  x2   = *r2;
-    uint8_t  *ptr = *pptr;
-
-    __asm__ ("movzbl (%0), %%eax\n\t"
-             "mov    %1, %%edx\n\t"
-             "shl    $0x8, %%edx\n\t"
-             "or     %%eax, %%edx\n\t"
-             "cmp    $0x800000, %1\n\t"
-             "cmovb  %%edx, %1\n\t"
-             "adc    $0x0, %0\n\t"
-             "mov    %2, %%edx\n\t"
-             "shl    $0x8, %%edx\n\t"
-             "cmp    $0x800000, %1\n\t"
-             "jae    1f\n\t"
-             "movzbl (%0), %%eax\n\t"
-             "shl    $0x8, %1\n\t"
-             "or     %%eax, %1\n\t"
-             "add    $0x1, %0\n\t"
-             "1:\n\t"
-             "movzbl (%0), %%eax\n\t"
-             "or     %%eax, %%edx\n\t"
-             "cmp    $0x800000, %2\n\t"
-             "cmovb  %%edx, %2\n\t"
-             "adc    $0x0, %0\n\t"
-             "cmp    $0x800000, %2\n\t"
-             "jae    2f\n\t"
-             "movzbl (%0), %%eax\n\t"
-             "shl    $0x8, %2\n\t"
-             "or     %%eax, %2\n\t"
-             "add    $0x1, %0\n\t"
-             "2:\n\t"
-             : "=r" (ptr), "=r" (x1), "=r" (x2)
-             : "0" (ptr), "1" (x1), "2" (x2)
-             : "eax", "edx"
-             );
-
-    *pptr = ptr;
-    *r1 = x1;
-    *r2 = x2;
-}
-
-#else /* __x86_64 */
-
-static inline void RansDecRenorm(RansState* r, uint8_t** pptr)
-{
-    // renormalize
-    uint32_t x = *r;
-
-#ifdef __clang__
-    // Generates cmov instructions on clang, but alas not gcc
-    uint8_t* ptr = *pptr;
-    uint32_t y = (x << 8) | *ptr;
-    uint32_t cond = x < RANS_BYTE_L;
-    x    = cond ? y : x;
-    ptr += cond ? 1 : 0;
-    if (x < RANS_BYTE_L) x = (x<<8) | *ptr++;
-    *pptr = ptr;
-#else
-    if (x >= RANS_BYTE_L) return;
-    uint8_t* ptr = *pptr;
-    x = (x << 8) | *ptr++;
-    if (x < RANS_BYTE_L) x = (x << 8) | *ptr++;
-    *pptr = ptr;
-#endif /* __clang__ */
-
-    *r = x;
-}
-
-static inline void RansDecRenorm2(RansState* r1, RansState* r2, uint8_t** pptr) {
-    RansDecRenorm(r1, pptr);
-    RansDecRenorm(r2, pptr);
-}
-
-#endif /* __x86_64 */
-
-static inline void RansDecRenormSafe(RansState* r, uint8_t** pptr, uint8_t *ptr_end)
-{
-    uint32_t x = *r;
-    uint8_t* ptr = *pptr;
-    if (x >= RANS_BYTE_L || ptr >= ptr_end) return;
-    x = (x << 8) | *ptr++;
-    if (x < RANS_BYTE_L && ptr < ptr_end)
-	x = (x << 8) | *ptr++;
-    *pptr = ptr;
-    *r = x;
-}
-
-static inline void RansDecSymbolInit32(RansDecSymbol32* s, uint32_t start, uint32_t freq)
-{
-    RansAssert(start <= (1 << 16));
-    RansAssert(freq <= (1 << 16) - start);
-    s->start = (uint16_t) start;
-    s->freq = (uint16_t) freq;
-}
-
-static inline void RansDecAdvanceSymbol32(RansState* r, uint8_t** pptr, RansDecSymbol32 const* sym, uint32_t scale_bits)
-{
-    RansDecAdvance(r, pptr, sym->start, sym->freq, scale_bits);
-}
-
-#endif // RANS_BYTE_HEADER
diff -ruN stringtie.orig/htslib/htscodecs/htscodecs/rANS_static4x16.h stringtie/htslib/htscodecs/htscodecs/rANS_static4x16.h
--- stringtie.orig/htslib/htscodecs/htscodecs/rANS_static4x16.h	2024-02-28 13:57:39.704579460 +0100
+++ stringtie/htslib/htscodecs/htscodecs/rANS_static4x16.h	1970-01-01 01:00:00.000000000 +0100
@@ -1,56 +0,0 @@
-/*
- * Copyright (c) 2017-2019 Genome Research Ltd.
- * Author(s): James Bonfield
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions are met:
- *
- *    1. Redistributions of source code must retain the above copyright notice,
- *       this list of conditions and the following disclaimer.
- *
- *    2. Redistributions in binary form must reproduce the above
- *       copyright notice, this list of conditions and the following
- *       disclaimer in the documentation and/or other materials provided
- *       with the distribution.
- *
- *    3. Neither the names Genome Research Ltd and Wellcome Trust Sanger
- *       Institute nor the names of its contributors may be used to endorse
- *       or promote products derived from this software without specific
- *       prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY GENOME RESEARCH LTD AND CONTRIBUTORS "AS
- * IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
- * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
- * PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL GENOME RESEARCH
- * LTD OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
- * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
- * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
- * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
- * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
- * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
- * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- */
-
-#ifndef RANS_STATIC4x16_H
-#define RANS_STATIC4x16_H
-
-#ifdef __cplusplus
-extern "C" {
-#endif
-
-unsigned int rans_compress_bound_4x16(unsigned int size, int order);
-unsigned char *rans_compress_to_4x16(unsigned char *in,  unsigned int in_size,
-				     unsigned char *out, unsigned int *out_size,
-				     int order);
-unsigned char *rans_compress_4x16(unsigned char *in, unsigned int in_size,
-				  unsigned int *out_size, int order);
-unsigned char *rans_uncompress_to_4x16(unsigned char *in,  unsigned int in_size,
-				       unsigned char *out, unsigned int *out_size);
-unsigned char *rans_uncompress_4x16(unsigned char *in, unsigned int in_size,
-				    unsigned int *out_size);
-
-#ifdef __cplusplus
-}
-#endif
-
-#endif /* RANS_STATIC4x16_H */
diff -ruN stringtie.orig/htslib/htscodecs/htscodecs/rANS_static4x16pr.c stringtie/htslib/htscodecs/htscodecs/rANS_static4x16pr.c
--- stringtie.orig/htslib/htscodecs/htscodecs/rANS_static4x16pr.c	2024-02-28 13:57:39.704579460 +0100
+++ stringtie/htslib/htscodecs/htscodecs/rANS_static4x16pr.c	1970-01-01 01:00:00.000000000 +0100
@@ -1,1641 +0,0 @@
-/*
- * Copyright (c) 2017-2020 Genome Research Ltd.
- * Author(s): James Bonfield
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions are met:
- *
- *    1. Redistributions of source code must retain the above copyright notice,
- *       this list of conditions and the following disclaimer.
- *
- *    2. Redistributions in binary form must reproduce the above
- *       copyright notice, this list of conditions and the following
- *       disclaimer in the documentation and/or other materials provided
- *       with the distribution.
- *
- *    3. Neither the names Genome Research Ltd and Wellcome Trust Sanger
- *       Institute nor the names of its contributors may be used to endorse
- *       or promote products derived from this software without specific
- *       prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY GENOME RESEARCH LTD AND CONTRIBUTORS "AS
- * IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
- * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
- * PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL GENOME RESEARCH
- * LTD OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
- * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
- * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
- * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
- * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
- * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
- * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- */
-
-// As per standard rANS_static but using optional RLE or bit-packing
-// techniques prior to entropy encoding.  This is a significant
-// reduction in some data sets.
-
-// top bits in order byte
-#define X_PACK   0x80    // Pack 2,4,8 or infinite symbols into a byte.
-#define X_RLE    0x40    // Run length encoding with runs & lits encoded separately
-#define X_CAT    0x20    // Nop; for tiny segments where rANS overhead is too big
-#define X_NOSZ   0x10    // Don't store the original size; used by STRIPE mode
-#define X_STRIPE 0x08    // For N-byte integer data; rotate & encode N streams.
-
-// FIXME Can we get decoder to return the compressed sized read, avoiding
-// us needing to store it?  Yes we can.  See c-size comments.  If we added all these
-// together we could get rans_uncompress_to_4x16 to return the number of bytes
-// consumed, avoiding the calling code from needed to explicitly stored the size.
-// However the effect on name tokeniser is to save 0.1 to 0.2% so not worth it.
-
-/*-------------------------------------------------------------------------- */
-/*
- * Example wrapper to use the rans_byte.h functions included above.
- *
- * This demonstrates how to use, and unroll, an order-0 and order-1 frequency
- * model.
- */
-
-#include "config.h"
-
-#include <stdint.h>
-#include <stdlib.h>
-#include <stdio.h>
-#include <unistd.h>
-#include <assert.h>
-#include <string.h>
-#include <sys/time.h>
-#include <limits.h>
-#include <math.h>
-#ifndef NO_THREADS
-#include <pthread.h>
-#endif
-
-#include "rANS_word.h"
-#include "rANS_static4x16.h"
-#include "varint.h"
-#include "pack.h"
-#include "rle.h"
-#include "utils.h"
-
-#define TF_SHIFT 12
-#define TOTFREQ (1<<TF_SHIFT)
-
-// 9-11 is considerably faster in the O1 variant due to reduced table size.
-// We auto-tune between 10 and 12 though.  Anywhere from 9 to 14 are viable.
-#ifndef TF_SHIFT_O1
-#define TF_SHIFT_O1 12
-#endif
-#ifndef TF_SHIFT_O1_FAST
-#define TF_SHIFT_O1_FAST 10
-#endif
-#define TOTFREQ_O1 (1<<TF_SHIFT_O1)
-#define TOTFREQ_O1_FAST (1<<TF_SHIFT_O1_FAST)
-
-
-/*-----------------------------------------------------------------------------
- * Memory to memory compression functions.
- *
- * These are original versions without any manual loop unrolling. They
- * are easier to understand, but can be up to 2x slower.
- */
-
-// Rounds to next power of 2.
-// credit to http://graphics.stanford.edu/~seander/bithacks.html
-static uint32_t round2(uint32_t v) {
-    v--;
-    v |= v >> 1;
-    v |= v >> 2;
-    v |= v >> 4;
-    v |= v >> 8;
-    v |= v >> 16;
-    v++;
-    return v;
-}
-
-static int normalise_freq(uint32_t *F, int size, uint32_t tot) {
-    int m, M, j, loop = 0;
-    uint64_t tr;
-    if (!size)
-	return 0;
-
- again:
-    tr = ((uint64_t)tot<<31)/size + (1<<30)/size;
-
-    for (size = m = M = j = 0; j < 256; j++) {
-	if (!F[j])
-	    continue;
-
-	if (m < F[j])
-	    m = F[j], M = j;
-
-	if ((F[j] = (F[j]*tr)>>31) == 0)
-	    F[j] = 1;
-	size += F[j];
-    }
-
-    int adjust = tot - size;
-    if (adjust > 0) {
-	F[M] += adjust;
-    } else if (adjust < 0) {
-	if (F[M] > -adjust && (loop == 1 || F[M]/2 >= -adjust)) {
-	    F[M] += adjust;
-	} else {
-	    if (loop < 1) {
-		loop++;
-		goto again;
-	    }
-	    adjust += F[M]-1;
-	    F[M] = 1;
-	    for (j = 0; adjust && j < 256; j++) {
-		if (F[j] < 2) continue;
-
-		int d = F[j] > -adjust;
-		int m = d ? adjust : 1-F[j];
-		F[j]   += m;
-		adjust -= m;
-	    }
-	}
-    }
-
-    //printf("F[%d]=%d\n", M, F[M]);
-    return F[M]>0 ? 0 : -1;
-}
-
-// A specialised version of normalise_freq_shift where the input size
-// is already normalised to a power of 2, meaning we can just perform
-// shifts instead of hard to define multiplications and adjustments.
-static void normalise_freq_shift(uint32_t *F, uint32_t size,
-				 uint32_t max_tot) {
-    if (size == 0 || size == max_tot)
-	return;
-
-    int shift = 0, i;
-    while (size < max_tot)
-	size*=2, shift++;
-
-    for (i = 0; i < 256; i++)
-	F[i] <<= shift;
-}
-
-// symbols only
-static int encode_alphabet(uint8_t *cp, uint32_t *F) {
-    uint8_t *op = cp;
-    int rle, j;
-
-    for (rle = j = 0; j < 256; j++) {
-	if (F[j]) {
-	    // j
-	    if (rle) {
-		rle--;
-	    } else {
-		*cp++ = j;
-		if (!rle && j && F[j-1])  {
-		    for(rle=j+1; rle<256 && F[rle]; rle++)
-			;
-		    rle -= j+1;
-		    *cp++ = rle;
-		}
-		//fprintf(stderr, "%d: %d %d\n", j, rle, N[j]);
-	    }
-	}
-    }
-    *cp++ = 0;
-    
-    return cp - op;
-}
-
-static int decode_alphabet(uint8_t *cp, uint8_t *cp_end, uint32_t *F) {
-    if (cp == cp_end)
-	return 0;
-
-    uint8_t *op = cp;
-    int rle = 0;
-    int j = *cp++;
-    if (cp+2 >= cp_end)
-	goto carefully;
-
-    do {
-	F[j] = 1;
-	if (!rle && j+1 == *cp) {
-	    j = *cp++;
-	    rle = *cp++;
-	} else if (rle) {
-	    rle--;
-	    j++;
-	    if (j > 255)
-		return 0;
-	} else {
-	    j = *cp++;
-	}
-    } while(j && cp+2 < cp_end);
-
- carefully:
-    if (j) {
-	do {
-	    F[j] = 1;
-	    if(cp >= cp_end) return 0;
-	    if (!rle && j+1 == *cp) {
-		if (cp+1 >= cp_end) return 0;
-		j = *cp++;
-		rle = *cp++;
-	    } else if (rle) {
-		rle--;
-		j++;
-		if (j > 255)
-		    return 0;
-	    } else {
-		if (cp >= cp_end) return 0;
-		j = *cp++;
-	    }
-	} while(j && cp < cp_end);
-    }
-
-    return cp - op;
-}
-
-static int encode_freq(uint8_t *cp, uint32_t *F) {
-    uint8_t *op = cp;
-    int j;
-
-    cp += encode_alphabet(cp, F);
-
-    for (j = 0; j < 256; j++) {
-	if (F[j])
-	    cp += var_put_u32(cp, NULL, F[j]);
-    }
-
-    return cp - op;
-}
-
-static int decode_freq(uint8_t *cp, uint8_t *cp_end, uint32_t *F,
-		       uint32_t *fsum) {
-    if (cp == cp_end)
-	return 0;
-
-    uint8_t *op = cp;
-    cp += decode_alphabet(cp, cp_end, F);
-
-    int j, tot = 0;
-    for (j = 0; j < 256; j++) {
-	if (F[j]) {
-	    cp += var_get_u32(cp, cp_end, (unsigned int *)&F[j]);
-	    tot += F[j];
-	}
-    }
-
-    *fsum = tot;
-    return cp - op;
-}
-
-
-// Use the order-0 freqs in F0 to encode the order-1 stats in F.
-// All symbols present in F are present in F0, but some in F0 will
-// be empty in F.  Thus we run-length encode the 0 frequencies.
-static int encode_freq_d(uint8_t *cp, uint32_t *F0, uint32_t *F) {
-    uint8_t *op = cp;
-    int j, dz;
-
-    for (dz = j = 0; j < 256; j++) {
-	if (F0[j]) {
-	    if (F[j] != 0) {
-		if (dz) {
-		    // Replace dz zeros with zero + dz-1 run length
-		    cp -= dz-1;
-		    *cp++ = dz-1;
-		}
-		dz = 0;
-		cp += var_put_u32(cp, NULL, F[j]);
-	    } else {
-		//fprintf(stderr, "2: j=%d F0[j]=%d, F[j]=%d, dz=%d\n", j, F0[j], F[j], dz);
-		dz++;
-		*cp++ = 0;
-	    }
-	} else {
-	    assert(F[j] == 0);
-	}
-    }
-    
-    if (dz) {
-	cp -= dz-1;
-	*cp++ = dz-1;
-    }
-
-    return cp - op;
-}
-
-static int decode_freq_d(uint8_t *cp, uint8_t *cp_end, uint32_t *F0,
-			 uint32_t *F, uint32_t *total) {
-    if (cp == cp_end)
-	return 0;
-
-    uint8_t *op = cp;
-    int j, dz, T = 0;
-
-    for (j = dz = 0; j < 256 && cp < cp_end; j++) {
-	//if (F0[j]) fprintf(stderr, "F0[%d]=%d\n", j, F0[j]);
-	if (!F0[j])
-	    continue;
-
-	uint32_t f;
-	if (dz) {
-	    f = 0;
-	    dz--;
-	} else {
-	    if (cp >= cp_end) return 0;
-	    cp += var_get_u32(cp, cp_end, &f);
-	    if (f == 0) {
-		if (cp >= cp_end) return 0;
-		dz = *cp++;
-	    }
-	}
-	F[j] = f;
-	T += f;
-    }
-
-    if (total) *total = T;
-    return cp - op;
-}
-
-unsigned int rans_compress_bound_4x16(unsigned int size, int order) {
-    int N = order>>8;
-    if (!N) N=4;
-
-    order &= 0xff;
-    int sz = (order == 0
-	? 1.05*size + 257*3 + 4
-	: 1.05*size + 257*257*3 + 4 + 257*3+4) +
-	((order & X_PACK) ? 1 : 0) +
-	((order & X_RLE) ? 1 + 257*3+4: 0) + 20 +
-	((order & X_STRIPE) ? 1 + 5*N: 0);
-    return sz + (sz&1) + 2; // make this even so buffers are word aligned
-}
-
-// Compresses in_size bytes from 'in' to *out_size bytes in 'out'.
-//
-// NB: The output buffer does not hold the original size, so it is up to
-// the caller to store this.
-static
-unsigned char *rans_compress_O0_4x16(unsigned char *in, unsigned int in_size,
-				     unsigned char *out, unsigned int *out_size) {
-    unsigned char *cp, *out_end;
-    RansEncSymbol syms[256];
-    RansState rans0;
-    RansState rans2;
-    RansState rans1;
-    RansState rans3;
-    uint8_t* ptr;
-    uint32_t F[256+MAGIC] = {0};
-    int i, j, tab_size = 0, rle, x;
-    int bound = rans_compress_bound_4x16(in_size,0)-20; // -20 for order/size/meta
-
-    if (!out) {
-	*out_size = bound;
-	out = malloc(*out_size);
-    }
-    if (!out || bound > *out_size)
-	return NULL;
-
-    // If "out" isn't word aligned, tweak out_end/ptr to ensure it is.
-    // We already added more round in bound to allow for this.
-    if (((size_t)out)&1)
-	bound--;
-    ptr = out_end = out + bound;
-
-    if (in_size == 0)
-	goto empty;
-
-    // Compute statistics
-    hist8(in, in_size, F);
-
-    // Normalise so frequences sum to power of 2
-    uint32_t fsum = in_size;
-    uint32_t max_val = round2(fsum);
-    if (max_val > TOTFREQ)
-	max_val = TOTFREQ;
-
-    if (normalise_freq(F, fsum, max_val) < 0)
-	return NULL;
-    fsum=max_val;
-
-    cp = out;
-    cp += encode_freq(cp, F);
-    tab_size = cp-out;
-    //write(2, out+4, cp-(out+4));
-
-    if (normalise_freq(F, fsum, TOTFREQ) < 0)
-	return NULL;
-
-    // Encode statistics.
-    for (x = rle = j = 0; j < 256; j++) {
-	if (F[j]) {
-	    RansEncSymbolInit(&syms[j], x, F[j], TF_SHIFT);
-	    x += F[j];
-	}
-    }
-
-    RansEncInit(&rans0);
-    RansEncInit(&rans1);
-    RansEncInit(&rans2);
-    RansEncInit(&rans3);
-
-    switch (i=(in_size&3)) {
-    case 3: RansEncPutSymbol(&rans2, &ptr, &syms[in[in_size-(i-2)]]);
-    case 2: RansEncPutSymbol(&rans1, &ptr, &syms[in[in_size-(i-1)]]);
-    case 1: RansEncPutSymbol(&rans0, &ptr, &syms[in[in_size-(i-0)]]);
-    case 0:
-	break;
-    }
-    for (i=(in_size &~3); i>0; i-=4) {
-	RansEncSymbol *s3 = &syms[in[i-1]];
-	RansEncSymbol *s2 = &syms[in[i-2]];
-	RansEncSymbol *s1 = &syms[in[i-3]];
-	RansEncSymbol *s0 = &syms[in[i-4]];
-
-#if 1
-	RansEncPutSymbol(&rans3, &ptr, s3);
-	RansEncPutSymbol(&rans2, &ptr, s2);
-	RansEncPutSymbol(&rans1, &ptr, s1);
-	RansEncPutSymbol(&rans0, &ptr, s0);
-#else
-	// Slightly beter on gcc, much better on clang
-	uint16_t *ptr16 = (uint16_t *)ptr;
-
-	if (rans3 >= s3->x_max) *--ptr16 = (uint16_t)rans3, rans3 >>= 16;
-	if (rans2 >= s2->x_max) *--ptr16 = (uint16_t)rans2, rans2 >>= 16;
-	uint32_t q3 = (uint32_t) (((uint64_t)rans3 * s3->rcp_freq) >> s3->rcp_shift);
-	uint32_t q2 = (uint32_t) (((uint64_t)rans2 * s2->rcp_freq) >> s2->rcp_shift);
-	rans3 += s3->bias + q3 * s3->cmpl_freq;
-	rans2 += s2->bias + q2 * s2->cmpl_freq;
-
-	if (rans1 >= s1->x_max) *--ptr16 = (uint16_t)rans1, rans1 >>= 16;
-	if (rans0 >= s0->x_max) *--ptr16 = (uint16_t)rans0, rans0 >>= 16;
-	uint32_t q1 = (uint32_t) (((uint64_t)rans1 * s1->rcp_freq) >> s1->rcp_shift);
-	uint32_t q0 = (uint32_t) (((uint64_t)rans0 * s0->rcp_freq) >> s0->rcp_shift);
-	rans1 += s1->bias + q1 * s1->cmpl_freq;
-	rans0 += s0->bias + q0 * s0->cmpl_freq;
-
-	ptr = (uint8_t *)ptr16;
-#endif
-    }
-
-    RansEncFlush(&rans3, &ptr);
-    RansEncFlush(&rans2, &ptr);
-    RansEncFlush(&rans1, &ptr);
-    RansEncFlush(&rans0, &ptr);
-
- empty:
-    // Finalise block size and return it
-    *out_size = (out_end - ptr) + tab_size;
-
-    memmove(out + tab_size, ptr, out_end-ptr);
-
-    return out;
-}
-
-typedef struct {
-    unsigned char R[TOTFREQ];
-} ari_decoder;
-
-static
-unsigned char *rans_uncompress_O0_4x16(unsigned char *in, unsigned int in_size,
-				       unsigned char *out, unsigned int out_sz) {
-    if (in_size < 16) // 4-states at least
-	return NULL;
-
-    if (out_sz >= INT_MAX)
-	return NULL; // protect against some overflow cases
-
-#ifdef FUZZING_BUILD_MODE_UNSAFE_FOR_PRODUCTION
-    if (out_sz > 100000)
-	return NULL;
-#endif
-
-    /* Load in the static tables */
-    unsigned char *cp = in, *out_free = NULL;
-    unsigned char *cp_end = in + in_size - 8; // within 8 => be extra safe
-    int i, j;
-    unsigned int x, y;
-    uint16_t sfreq[TOTFREQ+32];
-    uint16_t sbase[TOTFREQ+32]; // faster to use 32-bit on clang
-    uint8_t  ssym [TOTFREQ+64]; // faster to use 16-bit on clang
-
-    if (!out)
-	out_free = out = malloc(out_sz);
-    if (!out)
-	return NULL;
-
-    // Precompute reverse lookup of frequency.
-    uint32_t F[256] = {0}, fsum;
-    int fsz = decode_freq(cp, cp_end, F, &fsum);
-    if (!fsz)
-	goto err;
-    cp += fsz;
-
-    normalise_freq_shift(F, fsum, TOTFREQ);
-
-    // Build symbols; fixme, do as part of decode, see the _d variant
-    for (j = x = 0; j < 256; j++) {
-	if (F[j]) {
-	    if (F[j] > TOTFREQ - x)
-		goto err;
-	    for (y = 0; y < F[j]; y++) {
-		ssym [y + x] = j;
-		sfreq[y + x] = F[j];
-		sbase[y + x] = y;
-	    }
-	    x += F[j];
-	}
-    }
-
-    if (x != TOTFREQ)
-	goto err;
-
-    if (cp+16 > cp_end+8)
-	goto err;
-
-    RansState R[4];
-    RansDecInit(&R[0], &cp); if (R[0] < RANS_BYTE_L) goto err;
-    RansDecInit(&R[1], &cp); if (R[1] < RANS_BYTE_L) goto err;
-    RansDecInit(&R[2], &cp); if (R[2] < RANS_BYTE_L) goto err;
-    RansDecInit(&R[3], &cp); if (R[3] < RANS_BYTE_L) goto err;
-
-// Simple version is comparable to below, but only with -O3
-//
-//    for (i = 0; cp < cp_end-8 && i < (out_sz&~7); i+=8) {
-//        for(j=0; j<8;j++) {
-//	    RansState m = RansDecGet(&R[j%4], TF_SHIFT);
-//	    R[j%4] = sfreq[m] * (R[j%4] >> TF_SHIFT) + sbase[m];
-//	    out[i+j] = ssym[m];
-//	    RansDecRenorm(&R[j%4], &cp);
-//        }
-//    }
-
-    for (i = 0; cp < cp_end-8 && i < (out_sz&~7); i+=8) {
-	for (j = 0; j < 8; j+=4) {
-	    RansState m0 = RansDecGet(&R[0], TF_SHIFT);
-	    RansState m1 = RansDecGet(&R[1], TF_SHIFT);
-	    R[0] = sfreq[m0] * (R[0] >> TF_SHIFT) + sbase[m0];
-	    R[1] = sfreq[m1] * (R[1] >> TF_SHIFT) + sbase[m1];
-
-	    RansDecRenorm(&R[0], &cp);
-	    RansDecRenorm(&R[1], &cp);
-
-	    out[i+j+0] = ssym[m0];
-	    out[i+j+1] = ssym[m1];
-
-	    RansState m3 = RansDecGet(&R[2], TF_SHIFT);
-	    RansState m4 = RansDecGet(&R[3], TF_SHIFT);
-
-	    R[2] = sfreq[m3] * (R[2] >> TF_SHIFT) + sbase[m3];
-	    R[3] = sfreq[m4] * (R[3] >> TF_SHIFT) + sbase[m4];
-
-	    out[i+j+2] = ssym[m3];
-	    out[i+j+3] = ssym[m4];
-
-	    RansDecRenorm(&R[2], &cp);
-	    RansDecRenorm(&R[3], &cp);
-	}
-    }
-
-    // remainder
-    for (; i < out_sz; i++) {
-        RansState m = RansDecGet(&R[i%4], TF_SHIFT);
-	R[i%4] = sfreq[m] * (R[i%4] >> TF_SHIFT) + sbase[m];
-	out[i] = ssym[m];
-	RansDecRenormSafe(&R[i%4], &cp, cp_end+8);
-    }
-
-    //fprintf(stderr, "    0 Decoded %d bytes\n", (int)(cp-in)); //c-size
-
-    return out;
-
- err:
-    free(out_free);
-    return NULL;
-}
-
-//-----------------------------------------------------------------------------
-
-double fast_log(double a) {
-  union { double d; long long x; } u = { a };
-  return (u.x - 4606921278410026770) * 1.539095918623324e-16; /* 1 / 6497320848556798.0; */
-}
-
-// Compute the entropy of 12-bit vs 10-bit frequency tables.
-// 10 bit means smaller memory footprint when decoding and
-// more speed due to cache hits, but it *may* be a poor
-// compression fit.
-static int compute_shift(uint32_t *F0, uint32_t (*F)[256], uint32_t *T,
-			 int *S) {
-    int i, j;
-
-    double e10 = 0, e12 = 0;
-    int max_tot = 0;
-    for (i = 0; i < 256; i++) {
-	if (F0[i] == 0)
-	    continue;
-	int max_val = round2(T[i]);
-	int ns = 0;
-#define MAX(a,b) ((a)>(b)?(a):(b))
-
-	// Number of samples that get their freq bumped to 1
-	int sm10 = 0, sm12 = 0;
-	for (j = 0; j < 256; j++) {
-	    if (F[i][j] && max_val / F[i][j] > TOTFREQ_O1_FAST)
-		sm10++;
-	    if (F[i][j] && max_val / F[i][j] > TOTFREQ_O1)
-		sm12++;
-	}
-
-	double l10 = log(TOTFREQ_O1_FAST + sm10);
-	double l12 = log(TOTFREQ_O1      + sm12);
-
-	for (j = 0; j < 256; j++) {
-	    if (F[i][j]) {
-		ns++;
-
-		int x = (double)TOTFREQ_O1_FAST * F[i][j]/T[i];
-		e10 -= F[i][j] * (fast_log(MAX(x,1)) - l10);
-
-		x = (double)TOTFREQ_O1 * F[i][j]/T[i];
-		e12 -= F[i][j] * (fast_log(MAX(x,1)) - l12);
-
-		// Estimation of compressedf symbol freq table too.
-		e10 += 4;
-		e12 += 6;
-	    }
-	}
-
-	// Order-1 frequencies often end up totalling under TOTFREQ.
-	// In this case it's smaller to output the real frequencies
-	// prior to normalisation and normalise after (with an extra
-	// normalisation step needed in the decoder too).
-	//
-	// Thus we normalise to a power of 2 only, store those,
-	// and renormalise later here (and in decoder) by bit-shift
-	// to get to the fixed size.
-	if (ns < 64 && max_val > 128) max_val /= 2;
-	if (max_val > 1024)           max_val /= 2;
-	if (max_val > TOTFREQ_O1)     max_val = TOTFREQ_O1;
-	S[i] = max_val; // scale to max this
-	if (max_tot < max_val)
-	    max_tot = max_val;
-    }
-    int shift = e10/e12 < 1.01 || max_tot <= TOTFREQ_O1_FAST ? TF_SHIFT_O1_FAST : TF_SHIFT_O1;
-
-//    fprintf(stderr, "e10/12 = %f %f %f, shift %d\n",
-//    	    e10/log(256), e12/log(256), e10/e12, shift);
-
-    return shift;
-}
-
-
-static
-unsigned char *rans_compress_O1_4x16(unsigned char *in, unsigned int in_size,
-				     unsigned char *out, unsigned int *out_size) {
-    unsigned char *cp, *out_end, *op;
-    unsigned int tab_size;
-    RansEncSymbol syms[256][256];
-    int bound = rans_compress_bound_4x16(in_size,1)-20; // -20 for order/size/meta
-
-    if (!out) {
-	*out_size = bound;
-	out = malloc(*out_size);
-    }
-    if (!out || bound > *out_size)
-	return NULL;
-
-    if (((size_t)out)&1)
-	bound--;
-    out_end = out + bound;
-
-    uint32_t F[256][256] = {{0}}, T[256+MAGIC] = {0};
-    int i, j;
-
-    //memset(F, 0, 256*256*sizeof(int));
-    //memset(T, 0, 256*sizeof(int));
-
-    hist1_4(in, in_size, F, T);
-    F[0][in[1*(in_size>>2)]]++;
-    F[0][in[2*(in_size>>2)]]++;
-    F[0][in[3*(in_size>>2)]]++;
-    T[0]+=3;
-
-    op = cp = out;
-    *cp++ = 0; // uncompressed header marker
-
-    // Encode the order-0 symbols for use in the order-1 frequency tables
-    uint32_t F0[256+MAGIC] = {0};
-    present8(in, in_size, F0);
-    F0[0]=1;
-    cp += encode_alphabet(cp, F0);
-
-    // Decide between 10-bit and 12-bit freqs.
-    // Fills out S[] to hold the new scaled maximum value.
-    int S[256] = {0};
-    int shift = compute_shift(F0, F, T, S);
-
-    // Normalise so T[i] == TOTFREQ_O1
-    for (i = 0; i < 256; i++) {
-	unsigned int x;
-
-	if (F0[i] == 0)
-	    continue;
-
-	int max_val = S[i];
-	if (shift == TF_SHIFT_O1_FAST && max_val > TOTFREQ_O1_FAST)
-	    max_val = TOTFREQ_O1_FAST;
-
-	if (normalise_freq(F[i], T[i], max_val) < 0)
-	    return NULL;
-	T[i]=max_val;
-
-	cp += encode_freq_d(cp, F0, F[i]);
-
-	normalise_freq_shift(F[i], T[i], 1<<shift); T[i]=1<<shift;
-
-	uint32_t *F_i_ = F[i];
-	for (x = j = 0; j < 256; j++) {
-	    RansEncSymbolInit(&syms[i][j], x, F_i_[j], shift);
-	    x += F_i_[j];
-	}
-
-    }
-
-    *op = shift<<4;
-    if (cp - op > 1000) {
-	// try rans0 compression of header
-	unsigned int u_freq_sz = cp-(op+1);
-	unsigned int c_freq_sz;
-	unsigned char *c_freq = rans_compress_O0_4x16(op+1, u_freq_sz, NULL, &c_freq_sz);
-	if (c_freq && c_freq_sz + 6 < cp-op) {
-	    *op++ |= 1; // compressed
-	    op += var_put_u32(op, NULL, u_freq_sz);
-	    op += var_put_u32(op, NULL, c_freq_sz);
-	    memcpy(op, c_freq, c_freq_sz);
-	    cp = op+c_freq_sz;
-	}
-	free(c_freq);
-    }
-
-    //write(2, out+4, cp-(out+4));
-    tab_size = cp - out;
-    assert(tab_size < 257*257*3);
-
-    RansState rans0, rans1, rans2, rans3;
-    RansEncInit(&rans0);
-    RansEncInit(&rans1);
-    RansEncInit(&rans2);
-    RansEncInit(&rans3);
-
-    uint8_t* ptr = out_end;
-
-    int isz4 = in_size>>2;
-    int i0 = 1*isz4-2;
-    int i1 = 2*isz4-2;
-    int i2 = 3*isz4-2;
-    int i3 = 4*isz4-2;
-
-    unsigned char l0 = in[i0+1];
-    unsigned char l1 = in[i1+1];
-    unsigned char l2 = in[i2+1];
-    unsigned char l3 = in[i3+1];
-
-    // Deal with the remainder
-    l3 = in[in_size-1];
-    for (i3 = in_size-2; i3 > 4*isz4-2; i3--) {
-	unsigned char c3 = in[i3];
-	RansEncPutSymbol(&rans3, &ptr, &syms[c3][l3]);
-	l3 = c3;
-    }
-
-    for (; i0 >= 0; i0--, i1--, i2--, i3--) {
-	unsigned char c0, c1, c2, c3;
-	RansEncSymbol *s3 = &syms[c3 = in[i3]][l3];
-	RansEncSymbol *s2 = &syms[c2 = in[i2]][l2];
-	RansEncSymbol *s1 = &syms[c1 = in[i1]][l1];
-	RansEncSymbol *s0 = &syms[c0 = in[i0]][l0];
-
-	RansEncPutSymbol(&rans3, &ptr, s3);
-	RansEncPutSymbol(&rans2, &ptr, s2);
-	RansEncPutSymbol(&rans1, &ptr, s1);
-	RansEncPutSymbol(&rans0, &ptr, s0);
-
-	l0 = c0;
-	l1 = c1;
-	l2 = c2;
-	l3 = c3;
-    }
-
-    RansEncPutSymbol(&rans3, &ptr, &syms[0][l3]);
-    RansEncPutSymbol(&rans2, &ptr, &syms[0][l2]);
-    RansEncPutSymbol(&rans1, &ptr, &syms[0][l1]);
-    RansEncPutSymbol(&rans0, &ptr, &syms[0][l0]);
-
-    RansEncFlush(&rans3, &ptr);
-    RansEncFlush(&rans2, &ptr);
-    RansEncFlush(&rans1, &ptr);
-    RansEncFlush(&rans0, &ptr);
-
-    *out_size = (out_end - ptr) + tab_size;
-
-    cp = out;
-    memmove(out + tab_size, ptr, out_end-ptr);
-
-    return out;
-}
-
-#ifndef NO_THREADS
-/*
- * Thread local storage per thread in the pool.
- */
-pthread_once_t rans_once = PTHREAD_ONCE_INIT;
-pthread_key_t rans_key;
-
-static void rans_tls_init(void) {
-    pthread_key_create(&rans_key, free);
-}
-#endif
-
-//#define MAGIC2 111
-#define MAGIC2 179
-//#define MAGIC2 0
-typedef struct {
-    uint16_t f;
-    uint16_t b;
-} fb_t;
-
-static
-unsigned char *rans_uncompress_O1_4x16(unsigned char *in, unsigned int in_size,
-				       unsigned char *out, unsigned int out_sz) {
-    if (in_size < 16) // 4-states at least
-	return NULL;
-
-    if (out_sz >= INT_MAX)
-	return NULL; // protect against some overflow cases
-
-#ifdef FUZZING_BUILD_MODE_UNSAFE_FOR_PRODUCTION
-    if (out_sz > 100000)
-	return NULL;
-#endif
-
-    /* Load in the static tables */
-    unsigned char *cp = in, *cp_end = in+in_size, *out_free = NULL;
-    unsigned char *c_freq = NULL;
-    int i, j = -999;
-    unsigned int x;
-
-#ifndef NO_THREADS
-    /*
-     * The calloc below is expensive as it's a large structure.  We
-     * could use malloc, but we're only initialising parts of the structure
-     * that we need to, as dictated by the frequency table.  This is far
-     * faster than initialising everything (ie malloc+memset => calloc).
-     * Not initialising the data means malformed input with mismatching
-     * frequency tables to actual data can lead to accessing of the
-     * uninitialised sfb table and in turn potential leakage of the
-     * uninitialised memory returned by malloc.  That could be anything at
-     * all, including important encryption keys used within a server (for
-     * example).
-     *
-     * However (I hope!) we don't care about leaking about the sfb symbol
-     * frequencies previously computed by an earlier execution of *this*
-     * code.  So calloc once and reuse is the fastest alternative.
-     *
-     * We do this through pthread local storage as we don't know if this
-     * code is being executed in many threads simultaneously.
-     */
-    pthread_once(&rans_once, rans_tls_init);
-
-    uint8_t *sfb_ = pthread_getspecific(rans_key);
-    if (!sfb_) {
-	sfb_ = calloc(256*(TOTFREQ_O1+MAGIC2), sizeof(*sfb_));
-	pthread_setspecific(rans_key, sfb_);
-    }
-#else
-    uint8_t *sfb_ = calloc(256*(TOTFREQ_O1+MAGIC2), sizeof(*sfb_));
-#endif
-
-    if (!sfb_)
-	return NULL;
-    fb_t fb[256][256];
-    uint8_t *sfb[256];
-    if ((*cp >> 4) == TF_SHIFT_O1) {
-	for (i = 0; i < 256; i++)
-	    sfb[i]=  sfb_ + i*(TOTFREQ_O1+MAGIC2);
-    } else {
-	for (i = 0; i < 256; i++)
-	    sfb[i]=  sfb_ + i*(TOTFREQ_O1_FAST+MAGIC2);
-    }
-
-    if (!out)
-	out_free = out = malloc(out_sz);
-
-    if (!out)
-	goto err;
-
-    //fprintf(stderr, "out_sz=%d\n", out_sz);
-
-    // compressed header? If so uncompress it
-    unsigned char *tab_end = NULL;
-    unsigned char *c_freq_end = cp_end;
-    unsigned int shift = *cp >> 4;
-    if (*cp++ & 1) {
-	uint32_t u_freq_sz, c_freq_sz;
-	cp += var_get_u32(cp, cp_end, &u_freq_sz);
-	cp += var_get_u32(cp, cp_end, &c_freq_sz);
-	if (c_freq_sz >= cp_end - cp - 16)
-	    goto err;
-	tab_end = cp + c_freq_sz;
-	if (!(c_freq = rans_uncompress_O0_4x16(cp, c_freq_sz, NULL, u_freq_sz)))
-	    goto err;
-	cp = c_freq;
-	c_freq_end = c_freq + u_freq_sz;
-    }
-
-    // Decode order-0 symbol list; avoids needing in order-1 tables
-    uint32_t F0[256] = {0};
-    int fsz = decode_alphabet(cp, c_freq_end, F0);
-    if (!fsz)
-	goto err;
-    cp += fsz;
-
-    if (cp >= c_freq_end)
-	goto err;
-
-    for (i = 0; i < 256; i++) {
-	if (F0[i] == 0)
-	    continue;
-
-	uint32_t F[256] = {0}, T = 0;
-	fsz = decode_freq_d(cp, c_freq_end, F0, F, &T);
-	if (!fsz)
-	    goto err;
-	cp += fsz;
-
-	if (!T) {
-	    //fprintf(stderr, "No freq for F_%d\n", i);
-	    continue;
-	}
-
-	normalise_freq_shift(F, T, 1<<shift);
-
-	// Build symbols; fixme, do as part of decode, see the _d variant
-	for (j = x = 0; j < 256; j++) {
-	    if (F[j]) {
-		if (F[j] > (1<<shift) - x)
-		    goto err;
-
-		memset(&sfb[i][x], j, F[j]);
-		fb[i][j].f = F[j];
-		fb[i][j].b = x;
-		x += F[j];
-	    }
-	}
-	if (x != (1<<shift))
-	    goto err;
-    }
-
-    if (tab_end)
-	cp = tab_end;
-    free(c_freq);
-    c_freq = NULL;
-
-    if (cp+16 > cp_end)
-	goto err;
-
-    RansState rans0, rans1, rans2, rans3;
-    uint8_t *ptr = cp, *ptr_end = in + in_size - 8;
-    RansDecInit(&rans0, &ptr); if (rans0 < RANS_BYTE_L) goto err;
-    RansDecInit(&rans1, &ptr); if (rans1 < RANS_BYTE_L) goto err;
-    RansDecInit(&rans2, &ptr); if (rans2 < RANS_BYTE_L) goto err;
-    RansDecInit(&rans3, &ptr); if (rans3 < RANS_BYTE_L) goto err;
-
-    unsigned int isz4 = out_sz>>2;
-    int l0 = 0, l1 = 0, l2 = 0, l3 = 0;
-    unsigned int i4[] = {0*isz4, 1*isz4, 2*isz4, 3*isz4};
-
-    RansState R[4];
-    R[0] = rans0;
-    R[1] = rans1;
-    R[2] = rans2;
-    R[3] = rans3;
-
-    // Around 15% faster to specialise for 10/12 than to have one
-    // loop with shift as a variable.
-    if (shift == TF_SHIFT_O1) {
-	// TF_SHIFT_O1 = 12
-
-	const uint32_t mask = ((1u << TF_SHIFT_O1)-1);
-	for (; i4[0] < isz4; i4[0]++, i4[1]++, i4[2]++, i4[3]++) {
-	    uint16_t m, c;
-	    c = sfb[l0][m = R[0] & mask];
-	    R[0] = fb[l0][c].f * (R[0]>>TF_SHIFT_O1) + m - fb[l0][c].b;
-	    out[i4[0]] = l0 = c;
-
-	    c = sfb[l1][m = R[1] & mask];
-	    R[1] = fb[l1][c].f * (R[1]>>TF_SHIFT_O1) + m - fb[l1][c].b;
-	    out[i4[1]] = l1 = c;
-
-	    c = sfb[l2][m = R[2] & mask];
-	    R[2] = fb[l2][c].f * (R[2]>>TF_SHIFT_O1) + m - fb[l2][c].b;
-	    out[i4[2]] = l2 = c;
-
-	    c = sfb[l3][m = R[3] & mask];
-	    R[3] = fb[l3][c].f * (R[3]>>TF_SHIFT_O1) + m - fb[l3][c].b;
-	    out[i4[3]] = l3 = c;
-
-	    if (ptr < ptr_end) {
-		RansDecRenorm(&R[0], &ptr);
-		RansDecRenorm(&R[1], &ptr);
-		RansDecRenorm(&R[2], &ptr);
-		RansDecRenorm(&R[3], &ptr);
-	    } else {
-		RansDecRenormSafe(&R[0], &ptr, ptr_end+8);
-		RansDecRenormSafe(&R[1], &ptr, ptr_end+8);
-		RansDecRenormSafe(&R[2], &ptr, ptr_end+8);
-		RansDecRenormSafe(&R[3], &ptr, ptr_end+8);
-	    }
-	}
-
-	// Remainder
-	for (; i4[3] < out_sz; i4[3]++) {
-	    uint32_t m3 = R[3] & ((1u<<TF_SHIFT_O1)-1);
-	    unsigned char c3 = sfb[l3][m3];
-	    out[i4[3]] = c3;
-	    R[3] = fb[l3][c3].f * (R[3]>>TF_SHIFT_O1) + m3 - fb[l3][c3].b;
-	    RansDecRenormSafe(&R[3], &ptr, ptr_end + 8);
-	    l3 = c3;
-	}
-    } else {
-	// TF_SHIFT_O1 = 10
-	const uint32_t mask = ((1u << TF_SHIFT_O1_FAST)-1);
-	for (; i4[0] < isz4; i4[0]++, i4[1]++, i4[2]++, i4[3]++) {
-	    uint16_t m, c;
-	    c = sfb[l0][m = R[0] & mask];
-	    R[0] = fb[l0][c].f * (R[0]>>TF_SHIFT_O1_FAST) + m - fb[l0][c].b;
-	    out[i4[0]] = l0 = c;
-
-	    c = sfb[l1][m = R[1] & mask];
-	    R[1] = fb[l1][c].f * (R[1]>>TF_SHIFT_O1_FAST) + m - fb[l1][c].b;
-	    out[i4[1]] = l1 = c;
-
-	    c = sfb[l2][m = R[2] & mask];
-	    R[2] = fb[l2][c].f * (R[2]>>TF_SHIFT_O1_FAST) + m - fb[l2][c].b;
-	    out[i4[2]] = l2 = c;
-
-	    c = sfb[l3][m = R[3] & mask];
-	    R[3] = fb[l3][c].f * (R[3]>>TF_SHIFT_O1_FAST) + m - fb[l3][c].b;
-	    out[i4[3]] = l3 = c;
-
-	    if (ptr < ptr_end) {
-		RansDecRenorm(&R[0], &ptr);
-		RansDecRenorm(&R[1], &ptr);
-		RansDecRenorm(&R[2], &ptr);
-		RansDecRenorm(&R[3], &ptr);
-	    } else {
-		RansDecRenormSafe(&R[0], &ptr, ptr_end+8);
-		RansDecRenormSafe(&R[1], &ptr, ptr_end+8);
-		RansDecRenormSafe(&R[2], &ptr, ptr_end+8);
-		RansDecRenormSafe(&R[3], &ptr, ptr_end+8);
-	    }
-	}
-
-	// Remainder
-	for (; i4[3] < out_sz; i4[3]++) {
-	    uint32_t m3 = R[3] & ((1u<<TF_SHIFT_O1_FAST)-1);
-	    unsigned char c3 = sfb[l3][m3];
-	    out[i4[3]] = c3;
-	    R[3] = fb[l3][c3].f * (R[3]>>TF_SHIFT_O1_FAST) + m3 - fb[l3][c3].b;
-	    RansDecRenormSafe(&R[3], &ptr, ptr_end + 8);
-	    l3 = c3;
-	}
-    }
-    //fprintf(stderr, "    1 Decoded %d bytes\n", (int)(ptr-in)); //c-size
-
-#ifdef NO_THREADS
-    free(sfb_);
-#endif
-    return out;
-
- err:
-#ifdef NO_THREADS
-    free(sfb_);
-#endif
-    free(out_free);
-    free(c_freq);
-
-    return NULL;
-}
-
-
-/*-----------------------------------------------------------------------------
- * Simple interface to the order-0 vs order-1 encoders and decoders.
- *
- * Smallest is method, <in_size> <input>, so worst case 2 bytes longer.
- */
-unsigned char *rans_compress_to_4x16(unsigned char *in,  unsigned int in_size,
-				     unsigned char *out, unsigned int *out_size,
-				     int order) {
-    unsigned int c_meta_len;
-    uint8_t *meta = NULL, *rle = NULL, *packed = NULL;
-
-    if (!out) {
-	*out_size = rans_compress_bound_4x16(in_size, order);
-	if (!(out = malloc(*out_size)))
-	    return NULL;
-    }
-    unsigned char *out_end = out + *out_size;
-
-    if (in_size <= 20)
-	order &= ~X_STRIPE;
-
-    if (order & X_STRIPE) {
-	int N = (order>>8);
-	if (N == 0) N = 4; // default for compatibility with old tests
-
-	if (N > 255)
-	    return NULL;
-
-	unsigned char *transposed = malloc(in_size);
-	unsigned int part_len[256];
-	unsigned int idx[256];
-	if (!transposed)
-	    return NULL;
-	int i, j, x;
-
-	for (i = 0; i < N; i++) {
-	    part_len[i] = in_size / N + ((in_size % N) > i);
-	    idx[i] = i ? idx[i-1] + part_len[i-1] : 0; // cumulative index
-	}
-
-	for (i = x = 0; i < in_size-N; i += N, x++) {
-	    for (j = 0; j < N; j++)
-		transposed[idx[j]+x] = in[i+j];
-	}
-	for (; i < in_size; i += N, x++) {
-	    for (j = 0; i+j < in_size; j++)
-		transposed[idx[j]+x] = in[i+j];
-	}
-
-	unsigned int olen2;
-	unsigned char *out2, *out2_start;
-	c_meta_len = 1;
-	*out = order & ~X_NOSZ;
-	c_meta_len += var_put_u32(out+c_meta_len, out_end, in_size);
-	out[c_meta_len++] = N;
-	
-	out2_start = out2 = out+2+5*N; // shares a buffer with c_meta
-        for (i = 0; i < N; i++) {
-            // Brute force try all methods.
-            int j, m[] = {1,64,128,0}, best_j = 0, best_sz = in_size+10;
-            for (j = 0; j < 4; j++) {
-		if ((order & m[j]) != m[j])
-                    continue;
-                olen2 = *out_size - (out2 - out);
-                rans_compress_to_4x16(transposed+idx[i], part_len[i],
-				      out2, &olen2, m[j] | X_NOSZ);
-                if (best_sz > olen2) {
-                    best_sz = olen2;
-                    best_j = j;
-                }
-            }
-	    if (best_j != j-1) {
-		olen2 = *out_size - (out2 - out);
-		rans_compress_to_4x16(transposed+idx[i], part_len[i],
-				      out2, &olen2, m[best_j] | X_NOSZ);
-	    }
-            out2 += olen2;
-            c_meta_len += var_put_u32(out+c_meta_len, out_end, olen2);
-        }
-	memmove(out+c_meta_len, out2_start, out2-out2_start);
-	free(transposed);
-	*out_size = c_meta_len + out2-out2_start;
-	return out;
-    }
-
-    if (order & X_CAT) {
-	out[0] = X_CAT;
-	c_meta_len = 1;
-	c_meta_len += var_put_u32(&out[1], out_end, in_size);
-	memcpy(out+c_meta_len, in, in_size);
-	*out_size = c_meta_len + in_size;
-	return out;
-    }
-
-    int do_pack = order & X_PACK;
-    int do_rle  = order & X_RLE;
-    int no_size = order & X_NOSZ;
-
-    out[0] = order;
-    c_meta_len = 1;
-
-    if (!no_size)
-	c_meta_len += var_put_u32(&out[1], out_end, in_size);
-
-    order &= 0xf;
-
-    // Format is compressed meta-data, compressed data.
-    // Meta-data can be empty, pack, rle lengths, or pack + rle lengths.
-    // Data is either the original data, bit-packed packed, rle literals or
-    // packed + rle literals.
-
-    if (do_pack && in_size) {
-	// PACK 2, 4 or 8 symbols into one byte.
-	int pmeta_len;
-	uint64_t packed_len;
-	packed = hts_pack(in, in_size, out+c_meta_len, &pmeta_len, &packed_len);
-	if (!packed || (pmeta_len == 1 && out[c_meta_len] > 16)) {
-	    out[0] &= ~X_PACK;
-	    do_pack = 0;
-	    free(packed);
-	    packed = NULL;
-	} else {
-	    in = packed;
-	    in_size = packed_len;
-	    c_meta_len += pmeta_len;
-
-	    // Could derive this rather than storing verbatim.
-	    // Orig size * 8/nbits (+1 if not multiple of 8/n)
-	    int sz = var_put_u32(out+c_meta_len, out_end, in_size);
-	    c_meta_len += sz;
-	    *out_size -= sz;
-	}
-    } else if (do_pack) {
-	out[0] &= ~X_PACK;
-    }
-
-    if (do_rle && in_size) {
-	// RLE 'in' -> rle_length + rle_literals arrays
-	unsigned int rmeta_len, c_rmeta_len;
-	uint64_t rle_len;
-	c_rmeta_len = in_size+257;
-	if (!(meta = malloc(c_rmeta_len)))
-	    return NULL;
-
-	uint8_t rle_syms[256];
-	int rle_nsyms = 0;
-	uint64_t rmeta_len64;
-	rle = rle_encode(in, in_size, meta, &rmeta_len64,
-			 rle_syms, &rle_nsyms, NULL, &rle_len);
-	memmove(meta+1+rle_nsyms, meta, rmeta_len64);
-	meta[0] = rle_nsyms;
-	memcpy(meta+1, rle_syms, rle_nsyms);
-	rmeta_len = rmeta_len64 + rle_nsyms+1;
-
-	if (!rle || rle_len + rmeta_len >= .99*in_size) {
-	    // Not worth the speed hit.
-	    out[0] &= ~X_RLE;
-	    do_rle = 0;
-	    free(rle);
-	    rle = NULL;
-	} else {
-	    // Compress lengths with O0 and literals with O0/O1 ("order" param)
-	    int sz = var_put_u32(out+c_meta_len, out_end, rmeta_len*2), sz2;
-	    sz += var_put_u32(out+c_meta_len+sz, out_end, rle_len);
-	    c_rmeta_len = *out_size - (c_meta_len+sz+5);
-	    rans_compress_O0_4x16(meta, rmeta_len, out+c_meta_len+sz+5, &c_rmeta_len);
-	    if (c_rmeta_len < rmeta_len) {
-		sz2 = var_put_u32(out+c_meta_len+sz, out_end, c_rmeta_len);
-		memmove(out+c_meta_len+sz+sz2, out+c_meta_len+sz+5, c_rmeta_len);
-	    } else {
-		// Uncompressed RLE meta-data as too small
-		sz = var_put_u32(out+c_meta_len, out_end, rmeta_len*2+1);
-		sz2 = var_put_u32(out+c_meta_len+sz, out_end, rle_len);
-		memcpy(out+c_meta_len+sz+sz2, meta, rmeta_len);
-		c_rmeta_len = rmeta_len;
-	    }
-
-	    c_meta_len += sz + sz2 + c_rmeta_len;
-
-	    in = rle;
-	    in_size = rle_len;
-	}
-
-	free(meta);
-    } else if (do_rle) {
-	out[0] &= ~X_RLE;
-    }
-
-    *out_size -= c_meta_len;
-    if (order && in_size < 8) {
-	out[0] &= ~1;
-	order  &= ~1;
-    }
-
-    if (order == 1)
-	rans_compress_O1_4x16(in, in_size, out+c_meta_len, out_size);
-    else
-	rans_compress_O0_4x16(in, in_size, out+c_meta_len, out_size);
-
-    if (*out_size >= in_size) {
-	out[0] &= ~3;
-	out[0] |= X_CAT | no_size;
-	memcpy(out+c_meta_len, in, in_size);
-	*out_size = in_size;
-    }
-
-    free(rle);
-    free(packed);
-
-    *out_size += c_meta_len;
-
-    return out;
-}
-
-unsigned char *rans_compress_4x16(unsigned char *in, unsigned int in_size,
-				  unsigned int *out_size, int order) {
-    return rans_compress_to_4x16(in, in_size, NULL, out_size, order);
-}
-
-unsigned char *rans_uncompress_to_4x16(unsigned char *in,  unsigned int in_size,
-				       unsigned char *out, unsigned int *out_size) {
-    unsigned char *in_end = in + in_size;
-    unsigned char *out_free = NULL, *tmp_free = NULL, *meta_free = NULL;
-
-    if (in_size == 0)
-	return NULL;
-
-    if (*in & X_STRIPE) {
-	unsigned int ulen, olen, c_meta_len = 1;
-	int i;
-	uint64_t clen_tot = 0;
-
-	// Decode lengths
-	c_meta_len += var_get_u32(in+c_meta_len, in_end, &ulen);
-	if (c_meta_len >= in_size)
-	    return NULL;
-	unsigned int N = in[c_meta_len++];
-	unsigned int clenN[256], ulenN[256], idxN[256];
-	if (!out) {
-	    if (ulen >= INT_MAX)
-		return NULL;
-	    if (!(out_free = out = malloc(ulen))) {
-		return NULL;
-	    }
-	    *out_size = ulen;
-	}
-	if (ulen != *out_size) {
-	    free(out_free);
-	    return NULL;
-	}
-
-	for (i = 0; i < N; i++) {
-	    ulenN[i] = ulen / N + ((ulen % N) > i);
-	    idxN[i] = i ? idxN[i-1] + ulenN[i-1] : 0;
-	    c_meta_len += var_get_u32(in+c_meta_len, in_end, &clenN[i]);
-	    clen_tot += clenN[i];
-	    if (c_meta_len > in_size || clenN[i] > in_size || clenN[i] < 1) {
-		free(out_free);
-		return NULL;
-	    }
-	}
-
-	// We can call this with a larger buffer, but once we've determined
-	// how much we really use we limit it so the recursion becomes easier
-	// to limit.
-	if (c_meta_len + clen_tot > in_size) {
-	    free(out_free);
-	    return NULL;
-	}
-	in_size = c_meta_len + clen_tot;
-
-	//fprintf(stderr, "    stripe meta %d\n", c_meta_len); //c-size
-
-	// Uncompress the N streams
-	unsigned char *outN = malloc(ulen);
-	if (!outN) {
-	    free(out_free);
-	    return NULL;
-	}
-	for (i = 0; i < N; i++) {
-	    olen = ulenN[i];
-	    if (in_size < c_meta_len) {
-		free(out_free);
-		free(outN);
-		return NULL;
-	    }
-	    if (!rans_uncompress_to_4x16(in+c_meta_len, in_size-c_meta_len, outN + idxN[i], &olen)
-		|| olen != ulenN[i]) {
-		free(out_free);
-		free(outN);
-		return NULL;
-	    }
-	    c_meta_len += clenN[i];
-	}
-
-	unstripe(out, outN, ulen, N, idxN);
-
-	free(outN);
-	*out_size = ulen;
-	return out;
-    }
-
-    int order = *in++;  in_size--;
-    int do_pack = order & X_PACK;
-    int do_rle  = order & X_RLE;
-    int do_cat  = order & X_CAT;
-    int no_size = order & X_NOSZ;
-    order &= 1;
-
-    int sz = 0;
-    unsigned int osz;
-    if (!no_size)
-	sz = var_get_u32(in, in_end, &osz);
-    else
-	sz = 0, osz = *out_size;
-    in += sz;
-    in_size -= sz;
-
-#ifdef FUZZING_BUILD_MODE_UNSAFE_FOR_PRODUCTION
-    if (osz > 100000)
-	return NULL;
-#endif
-
-    if (no_size && !out)
-	goto err; // Need one or the other
-
-    if (!out) {
-	*out_size = osz;
-	if (!(out = out_free = malloc(*out_size)))
-	    return NULL;
-    } else {
-	if (*out_size < osz)
-	goto err;
-	*out_size = osz;
-    }
-
-//    if (do_pack || do_rle) {
-//	in += sz; // size field not needed when pure rANS
-//	in_size -= sz;
-//    }
-
-    uint32_t c_meta_size = 0;
-    unsigned int tmp1_size = *out_size;
-    unsigned int tmp2_size = *out_size;
-    unsigned int tmp3_size = *out_size;
-    unsigned char *tmp1 = NULL, *tmp2 = NULL, *tmp3 = NULL, *tmp = NULL;
-
-    // Need In, Out and Tmp buffers with temporary buffer of the same size
-    // as output.  All use rANS, but with optional transforms (none, RLE,
-    // Pack, or both).
-    //
-    //                    rans   unrle  unpack
-    // If none:     in -> out
-    // If RLE:      in -> tmp -> out
-    // If Pack:     in -> tmp        -> out
-    // If RLE+Pack: in -> out -> tmp -> out
-    //                    tmp1   tmp2   tmp3
-    //
-    // So rans is in   -> tmp1
-    // RLE     is tmp1 -> tmp2
-    // Unpack  is tmp2 -> tmp3
-
-    // Format is meta data (Pack and RLE in that order if present),
-    // followed by rANS compressed data.
-
-    if (do_pack || do_rle) {
-	if (!(tmp = tmp_free = malloc(*out_size)))
-	    goto err;
-	if (do_pack && do_rle) {
-	    tmp1 = out;
-	    tmp2 = tmp;
-	    tmp3 = out;
-	} else if (do_pack) {
-	    tmp1 = tmp;
-	    tmp2 = tmp1;
-	    tmp3 = out;
-	} else if (do_rle) {
-	    tmp1 = tmp;
-	    tmp2 = out;
-	    tmp3 = out;
-	}
-    } else {
-	// neither
-	tmp  = NULL;
-	tmp1 = out;
-	tmp2 = out;
-	tmp3 = out;
-    }
-
-    
-    // Decode the bit-packing map.
-    uint8_t map[16] = {0};
-    int npacked_sym = 0;
-    uint64_t unpacked_sz = 0; // FIXME: rename to packed_per_byte
-    if (do_pack) {
-	c_meta_size = hts_unpack_meta(in, in_size, *out_size, map, &npacked_sym);
-	if (c_meta_size == 0)
-	    goto err;
-
-	unpacked_sz = osz;
-	in      += c_meta_size;
-	in_size -= c_meta_size;
-
-	// New unpacked size.  We could derive this bit from *out_size
-	// and npacked_sym.
-	unsigned int osz;
-	sz = var_get_u32(in, in_end, &osz);
-	in += sz;
-	in_size -= sz;
-	if (osz > tmp1_size)
-	    goto err;
-	tmp1_size = osz;
-    }
-
-    uint8_t *meta = NULL;
-    uint32_t u_meta_size = 0;
-    if (do_rle) {
-	// Uncompress meta data
-	uint32_t c_meta_size, rle_len, sz;
-	sz  = var_get_u32(in,    in_end, &u_meta_size);
-	sz += var_get_u32(in+sz, in_end, &rle_len);
-	if (rle_len > tmp1_size) // should never grow
-	    goto err;
-	if (u_meta_size & 1) {
-	    meta = in + sz;
-	    u_meta_size = u_meta_size/2 > (in_end-meta) ? (in_end-meta) : u_meta_size/2;
-	    c_meta_size = u_meta_size;
-	} else {
-	    sz += var_get_u32(in+sz, in_end, &c_meta_size);
-	    u_meta_size /= 2;
-	    meta_free = meta = rans_uncompress_O0_4x16(in+sz, in_size-sz, NULL, u_meta_size);
-	    if (!meta)
-		goto err;
-	}
-	if (c_meta_size+sz > in_size)
-	    goto err;
-	in      += c_meta_size+sz;
-	in_size -= c_meta_size+sz;
-	tmp1_size = rle_len;
-    }
-   
-    //fprintf(stderr, "    meta_size %d bytes\n", (int)(in - orig_in)); //c-size
-
-    // uncompress RLE data.  in -> tmp1
-    if (in_size) {
-	if (do_cat) {
-	    //fprintf(stderr, "    CAT %d\n", tmp1_size); //c-size
-	    if (tmp1_size > in_size)
-		goto err;
-	    if (tmp1_size > *out_size)
-		goto err;
-	    memcpy(tmp1, in, tmp1_size);
-	} else {
-	    tmp1 = order
-		? rans_uncompress_O1_4x16(in, in_size, tmp1, tmp1_size)
-		: rans_uncompress_O0_4x16(in, in_size, tmp1, tmp1_size);
-	    if (!tmp1)
-		goto err;
-	}
-    } else {
-	tmp1 = NULL;
-	tmp1_size = 0;
-    }
-    tmp2_size = tmp3_size = tmp1_size;
-
-    if (do_rle) {
-	// Unpack RLE.  tmp1 -> tmp2.
-	if (u_meta_size == 0)
-	    goto err;
-	uint64_t unrle_size = *out_size;
-	int rle_nsyms = *meta ? *meta : 256;
-	if (u_meta_size < 1+rle_nsyms)
-	    goto err;
-	if (!rle_decode(tmp1, tmp1_size,
-			meta+1+rle_nsyms, u_meta_size-(1+rle_nsyms),
-			meta+1, rle_nsyms, tmp2, &unrle_size))
-	    goto err;
-	tmp3_size = tmp2_size = unrle_size;
-	free(meta_free);
-	meta_free = NULL;
-    }
-    if (do_pack) {
-	// Unpack bits via pack-map.  tmp2 -> tmp3
-	if (npacked_sym == 1)
-	    unpacked_sz = tmp2_size;
-	//uint8_t *porig = unpack(tmp2, tmp2_size, unpacked_sz, npacked_sym, map);
-	//memcpy(tmp3, porig, unpacked_sz);
-	if (!hts_unpack(tmp2, tmp2_size, tmp3, unpacked_sz, npacked_sym, map))
-	    goto err;
-	tmp3_size = unpacked_sz;
-    }
-
-    if (tmp)
-	free(tmp);
-
-    *out_size = tmp3_size;
-    return tmp3;
-
- err:
-    free(meta_free);
-    free(out_free);
-    free(tmp_free);
-    return NULL;
-}
-
-unsigned char *rans_uncompress_4x16(unsigned char *in, unsigned int in_size,
-				    unsigned int *out_size) {
-    return rans_uncompress_to_4x16(in, in_size, NULL, out_size);
-}
diff -ruN stringtie.orig/htslib/htscodecs/htscodecs/rANS_static.c stringtie/htslib/htscodecs/htscodecs/rANS_static.c
--- stringtie.orig/htslib/htscodecs/htscodecs/rANS_static.c	2024-02-28 13:57:39.704579460 +0100
+++ stringtie/htslib/htscodecs/htscodecs/rANS_static.c	1970-01-01 01:00:00.000000000 +0100
@@ -1,943 +0,0 @@
-/*
- * Copyright (c) 2014-2020 Genome Research Ltd.
- * Author(s): James Bonfield
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions are met:
- *
- *    1. Redistributions of source code must retain the above copyright notice,
- *       this list of conditions and the following disclaimer.
- *
- *    2. Redistributions in binary form must reproduce the above
- *       copyright notice, this list of conditions and the following
- *       disclaimer in the documentation and/or other materials provided
- *       with the distribution.
- *
- *    3. Neither the names Genome Research Ltd and Wellcome Trust Sanger
- *       Institute nor the names of its contributors may be used to endorse
- *       or promote products derived from this software without specific
- *       prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY GENOME RESEARCH LTD AND CONTRIBUTORS "AS
- * IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
- * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
- * PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL GENOME RESEARCH
- * LTD OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
- * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
- * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
- * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
- * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
- * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
- * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- */
-
-#include "config.h"
-
-#if defined(NO_THREADS) && (defined(__APPLE__) || defined(_WIN32))
-// When pthreads is available, we use a single malloc, otherwise we'll
-// (normally) use the stack instead.
-//
-// However the MacOS X default stack size can be tiny (512K), albeit
-// I think only when threading?  We request malloc/free for the large
-// local arrays instead to avoid this, but it does have a performance hit.
-#define USE_HEAP
-#endif
-
-// Use 11 for order-1?
-#define TF_SHIFT 12
-#define TOTFREQ (1<<TF_SHIFT)
-
-#include "rANS_byte.h"
-#include "utils.h"
-
-/*-------------------------------------------------------------------------- */
-/*
- * Example wrapper to use the rans_byte.h functions included above.
- *
- * This demonstrates how to use, and unroll, an order-0 and order-1 frequency
- * model.
- */
-
-#include <stdint.h>
-#include <stdlib.h>
-#include <stdio.h>
-#include <unistd.h>
-#include <assert.h>
-#include <string.h>
-#include <limits.h>
-#include <sys/time.h>
-#ifndef NO_THREADS
-#include <pthread.h>
-#endif
-
-#include "rANS_static.h"
-
-#define ABS(a) ((a)>0?(a):-(a))
-
-/*-----------------------------------------------------------------------------
- * Memory to memory compression functions.
- *
- * These are original versions without any manual loop unrolling. They
- * are easier to understand, but can be up to 2x slower.
- */
-
-static
-unsigned char *rans_compress_O0(unsigned char *in, unsigned int in_size,
-				unsigned int *out_size) {
-    unsigned char *out_buf = malloc(1.05*in_size + 257*257*3 + 9);
-    unsigned char *cp, *out_end;
-    RansEncSymbol syms[256];
-    RansState rans0;
-    RansState rans2;
-    RansState rans1;
-    RansState rans3;
-    uint8_t* ptr;
-    int F[256+MAGIC] = {0}, i, j, tab_size, rle, x, fsum = 0;
-    int m = 0, M = 0;
-    uint64_t tr;
-
-    if (!out_buf)
-	return NULL;
-
-    ptr = out_end = out_buf + (int)(1.05*in_size) + 257*257*3 + 9;
-
-    // Compute statistics
-    hist8(in, in_size, (uint32_t *)F);
-    tr = ((uint64_t)TOTFREQ<<31)/in_size + (1<<30)/in_size;
-
- normalise_harder:
-    // Normalise so T[i] == TOTFREQ
-    for (fsum = m = M = j = 0; j < 256; j++) {
-	if (!F[j])
-	    continue;
-
-	if (m < F[j])
-	    m = F[j], M = j;
-
-	if ((F[j] = (F[j]*tr)>>31) == 0)
-	    F[j] = 1;
-	fsum += F[j];
-    }
-
-    fsum++;
-    if (fsum < TOTFREQ) {
-	F[M] += TOTFREQ-fsum;
-    } else if (fsum-TOTFREQ > F[M]/2) {
-	// Corner case to avoid excessive frequency reduction
-	tr = 2104533975; goto normalise_harder; // equiv to *0.98.
-    } else {
-	F[M] -= fsum-TOTFREQ;
-    }
-
-    //printf("F[%d]=%d\n", M, F[M]);
-    assert(F[M]>0);
-
-    // Encode statistics.
-    cp = out_buf+9;
-
-    for (x = rle = j = 0; j < 256; j++) {
-	if (F[j]) {
-	    // j
-	    if (rle) {
-		rle--;
-	    } else {
-		*cp++ = j;
-		if (!rle && j && F[j-1])  {
-		    for(rle=j+1; rle<256 && F[rle]; rle++)
-			;
-		    rle -= j+1;
-		    *cp++ = rle;
-		}
-		//fprintf(stderr, "%d: %d %d\n", j, rle, N[j]);
-	    }
-	    
-	    // F[j]
-	    if (F[j]<128) {
-		*cp++ = F[j];
-	    } else {
-		*cp++ = 128 | (F[j]>>8);
-		*cp++ = F[j]&0xff;
-	    }
-	    RansEncSymbolInit(&syms[j], x, F[j], TF_SHIFT);
-	    x += F[j];
-	}
-    }
-    *cp++ = 0;
-
-    //write(2, out_buf+4, cp-(out_buf+4));
-    tab_size = cp-out_buf;
-
-    RansEncInit(&rans0);
-    RansEncInit(&rans1);
-    RansEncInit(&rans2);
-    RansEncInit(&rans3);
-
-    switch (i=(in_size&3)) {
-    case 3: RansEncPutSymbol(&rans2, &ptr, &syms[in[in_size-(i-2)]]);
-    case 2: RansEncPutSymbol(&rans1, &ptr, &syms[in[in_size-(i-1)]]);
-    case 1: RansEncPutSymbol(&rans0, &ptr, &syms[in[in_size-(i-0)]]);
-    case 0:
-	break;
-    }
-    for (i=(in_size &~3); i>0; i-=4) {
-	RansEncSymbol *s3 = &syms[in[i-1]];
-	RansEncSymbol *s2 = &syms[in[i-2]];
-	RansEncSymbol *s1 = &syms[in[i-3]];
-	RansEncSymbol *s0 = &syms[in[i-4]];
-
-	RansEncPutSymbol(&rans3, &ptr, s3);
-	RansEncPutSymbol(&rans2, &ptr, s2);
-	RansEncPutSymbol(&rans1, &ptr, s1);
-	RansEncPutSymbol(&rans0, &ptr, s0);
-    }
-
-    RansEncFlush(&rans3, &ptr);
-    RansEncFlush(&rans2, &ptr);
-    RansEncFlush(&rans1, &ptr);
-    RansEncFlush(&rans0, &ptr);
-
-    // Finalise block size and return it
-    *out_size = (out_end - ptr) + tab_size;
-
-    cp = out_buf;
-
-    *cp++ = 0; // order
-    *cp++ = ((*out_size-9)>> 0) & 0xff;
-    *cp++ = ((*out_size-9)>> 8) & 0xff;
-    *cp++ = ((*out_size-9)>>16) & 0xff;
-    *cp++ = ((*out_size-9)>>24) & 0xff;
-
-    *cp++ = (in_size>> 0) & 0xff;
-    *cp++ = (in_size>> 8) & 0xff;
-    *cp++ = (in_size>>16) & 0xff;
-    *cp++ = (in_size>>24) & 0xff;
-
-    memmove(out_buf + tab_size, ptr, out_end-ptr);
-
-    return out_buf;
-}
-
-typedef struct {
-    unsigned char R[TOTFREQ];
-} ari_decoder;
-
-static
-unsigned char *rans_uncompress_O0(unsigned char *in, unsigned int in_size,
-				  unsigned int *out_size) {
-    /* Load in the static tables */
-    unsigned char *cp = in + 9;
-    unsigned char *cp_end = in + in_size;
-    const uint32_t mask = (1u << TF_SHIFT)-1;
-    int i, j, rle;
-    unsigned int x, y;
-    unsigned int out_sz, in_sz;
-    char *out_buf;
-    RansState R[4];
-    RansState m[4];
-    uint16_t sfreq[TOTFREQ+32];
-    uint16_t ssym [TOTFREQ+32]; // faster, but only needs uint8_t
-    uint32_t sbase[TOTFREQ+16]; // faster, but only needs uint16_t
-
-    if (in_size < 26) // Need at least this many bytes just to start
-        return NULL;
-
-    if (*in++ != 0) // Order-0 check
-	return NULL;
-    
-    in_sz  = ((in[0])<<0) | ((in[1])<<8) | ((in[2])<<16) | (((uint32_t)in[3])<<24);
-    out_sz = ((in[4])<<0) | ((in[5])<<8) | ((in[6])<<16) | (((uint32_t)in[7])<<24);
-    if (in_sz != in_size-9)
-	return NULL;
-
-    if (out_sz >= INT_MAX)
-	return NULL; // protect against some overflow cases
-
-    // For speeding up the fuzzer only.
-    // Small input can lead to large uncompressed data.
-    // We reject this as it just slows things up instead of testing more code
-    // paths (once we've verified a few times for large data).
-#ifdef FUZZING_BUILD_MODE_UNSAFE_FOR_PRODUCTION
-    if (out_sz > 100000)
-	return NULL;
-#endif
-
-    out_buf = malloc(out_sz);
-    if (!out_buf)
-	return NULL;
-
-    //fprintf(stderr, "out_sz=%d\n", out_sz);
-
-    // Precompute reverse lookup of frequency.
-    rle = x = y = 0;
-    j = *cp++;
-    do {
-	int F, C;
-        if (cp > cp_end - 16) goto cleanup; // Not enough input bytes left
-	if ((F = *cp++) >= 128) {
-	    F &= ~128;
-	    F = ((F & 127) << 8) | *cp++;
-	}
-	C = x;
-
-	if (x + F > TOTFREQ)
-	    goto cleanup;
-
-        for (y = 0; y < F; y++) {
-            ssym [y + C] = j;
-            sfreq[y + C] = F;
-            sbase[y + C] = y;
-        }
-	x += F;
-
-	if (!rle && j+1 == *cp) {
-	    j = *cp++;
-	    rle = *cp++;
-	} else if (rle) {
-	    rle--;
-	    j++;
-	    if (j > 255)
-		goto cleanup;
-	} else {
-	    j = *cp++;
-	}
-    } while(j);
-
-    if (x < TOTFREQ-1 || x > TOTFREQ)
-	goto cleanup;
-
-    // 16 bytes of cp here. Also why cp - 16 in above loop.
-    if (cp > cp_end - 16) goto cleanup; // Not enough input bytes left
-
-    RansDecInit(&R[0], &cp); if (R[0] < RANS_BYTE_L) goto cleanup;
-    RansDecInit(&R[1], &cp); if (R[1] < RANS_BYTE_L) goto cleanup;
-    RansDecInit(&R[2], &cp); if (R[2] < RANS_BYTE_L) goto cleanup;
-    RansDecInit(&R[3], &cp); if (R[3] < RANS_BYTE_L) goto cleanup;
-
-    int out_end = (out_sz&~3);
-    cp_end -= 8; // within 8 for simplicity of loop below
-    for (i=0; i < out_end; i+=4) {
-	m[0] = R[0] & mask;
-        out_buf[i+0] = ssym[m[0]];
-        R[0] = sfreq[m[0]] * (R[0] >> TF_SHIFT) + sbase[m[0]];
-
-        m[1] = R[1] & mask;
-	out_buf[i+1] = ssym[m[1]];
-        R[1] = sfreq[m[1]] * (R[1] >> TF_SHIFT) + sbase[m[1]];
-
-        m[2] = R[2] & mask;
-	out_buf[i+2] = ssym[m[2]];
-        R[2] = sfreq[m[2]] * (R[2] >> TF_SHIFT) + sbase[m[2]];
-
-        m[3] = R[3] & mask;
-	out_buf[i+3] = ssym[m[3]];
-        R[3] = sfreq[m[3]] * (R[3] >> TF_SHIFT) + sbase[m[3]];
-
-	if (cp < cp_end) {
-	    RansDecRenorm2(&R[0], &R[1], &cp);
-	    RansDecRenorm2(&R[2], &R[3], &cp);
-	} else {
-	    RansDecRenormSafe(&R[0], &cp, cp_end+8);
-	    RansDecRenormSafe(&R[1], &cp, cp_end+8);
-	    RansDecRenormSafe(&R[2], &cp, cp_end+8);
-	    RansDecRenormSafe(&R[3], &cp, cp_end+8);
-	}
-    }
-
-    switch(out_sz&3) {
-    case 3:
-        out_buf[out_end + 2] = ssym[R[2] & mask];
-    case 2:
-        out_buf[out_end + 1] = ssym[R[1] & mask];
-    case 1:
-        out_buf[out_end] = ssym[R[0] & mask];
-    default:
-        break;
-    }
-    
-    *out_size = out_sz;
-    return (unsigned char *)out_buf;
-
- cleanup:
-    free(out_buf);
-    return NULL;
-}
-
-
-#ifndef NO_THREADS
-/*
- * Thread local storage per thread in the pool.
- * This avoids needing to memset/calloc F and syms in the encoder,
- * which can be speed things this encoder up a little.
- */
-static pthread_once_t rans_enc_once = PTHREAD_ONCE_INIT;
-static pthread_key_t rans_enc_key;
-
-typedef struct {
-    RansEncSymbol (*syms)[256];
-    int (*F)[256];
-} thread_enc_data;
-
-static void rans_enc_free(void *vp) {
-    thread_enc_data *te = (thread_enc_data *)vp;
-    if (!te)
-	return;
-    free(te->F);
-    free(te->syms);
-    free(te);
-}
-
-static thread_enc_data *rans_enc_alloc(void) {
-    thread_enc_data *te = malloc(sizeof(*te));
-    if (!te)
-	return NULL;
-    te->F = calloc(256, sizeof(*te->F));
-    te->syms = calloc(256, sizeof(*te->syms));
-    if (!te->F || !te->syms) {
-	rans_enc_free(te);
-	return NULL;
-    }
-
-    return te;
-}
-
-static void rans_tls_enc_init(void) {
-    pthread_key_create(&rans_enc_key, rans_enc_free);
-}
-#endif
-
-static
-unsigned char *rans_compress_O1(unsigned char *in, unsigned int in_size,
-				unsigned int *out_size) {
-    unsigned char *out_buf = NULL, *out_end, *cp;
-    unsigned int tab_size, rle_i, rle_j;
-
-
-#ifndef NO_THREADS
-    pthread_once(&rans_enc_once, rans_tls_enc_init);
-    thread_enc_data *te = pthread_getspecific(rans_enc_key);
-    if (!te) {
-	if (!(te = rans_enc_alloc()))
-	    return NULL;
-	pthread_setspecific(rans_enc_key, te);
-    }
-    RansEncSymbol (*syms)[256] = te->syms;
-    int (*F)[256] = te->F;
-    memset(F, 0, 256*sizeof(*F));
-#else
-#ifdef USE_HEAP
-    RansEncSymbol (*syms)[256] = malloc(256 * sizeof(*syms));
-    int (*F)[256] = calloc(256, sizeof(*F));
-#else
-    RansEncSymbol syms[256][256];
-    int F[256][256] = {{0}};
-#endif
-#endif
-    int T[256+MAGIC] = {0};
-    int i, j;
-
-    if (in_size < 4)
-	return rans_compress_O0(in, in_size, out_size);
-
-#ifdef USE_HEAP
-    if (!syms) goto cleanup;
-    if (!F) goto cleanup;
-#endif
-
-    out_buf = malloc(1.05*in_size + 257*257*3 + 9);
-    if (!out_buf) goto cleanup;
-
-    out_end = out_buf + (int)(1.05*in_size) + 257*257*3 + 9;
-    cp = out_buf+9;
-
-    hist1_4(in, in_size, (uint32_t (*)[256])F, (uint32_t *)T);
-
-    F[0][in[1*(in_size>>2)]]++;
-    F[0][in[2*(in_size>>2)]]++;
-    F[0][in[3*(in_size>>2)]]++;
-    T[0]+=3;
-
-    
-    // Normalise so T[i] == TOTFREQ
-    for (rle_i = i = 0; i < 256; i++) {
-	int t2, m, M;
-	unsigned int x;
-
-	if (T[i] == 0)
-	    continue;
-
-	//uint64_t p = (TOTFREQ * TOTFREQ) / t;
-	double p = ((double)TOTFREQ)/T[i];
-    normalise_harder:
-	for (t2 = m = M = j = 0; j < 256; j++) {
-	    if (!F[i][j])
-		continue;
-
-	    if (m < F[i][j])
-		m = F[i][j], M = j;
-
-	    //if ((F[i][j] = (F[i][j] * p) / TOTFREQ) == 0)
-	    if ((F[i][j] *= p) == 0)
-		F[i][j] = 1;
-	    t2 += F[i][j];
-	}
-
-	t2++;
-	if (t2 < TOTFREQ) {
-	    F[i][M] += TOTFREQ-t2;
-	} else if (t2-TOTFREQ >= F[i][M]/2) {
-	    // Corner case to avoid excessive frequency reduction
-	    p = .98; goto normalise_harder;
-	} else {
-	    F[i][M] -= t2-TOTFREQ;
-	}
-
-	// Store frequency table
-	// i
-	if (rle_i) {
-	    rle_i--;
-	} else {
-	    *cp++ = i;
-	    // FIXME: could use order-0 statistics to observe which alphabet
-	    // symbols are present and base RLE on that ordering instead.
-	    if (i && T[i-1]) {
-		for(rle_i=i+1; rle_i<256 && T[rle_i]; rle_i++)
-		    ;
-		rle_i -= i+1;
-		*cp++ = rle_i;
-	    }
-	}
-
-	int *F_i_ = F[i];
-	x = 0;
-	rle_j = 0;
-	for (j = 0; j < 256; j++) {
-	    if (F_i_[j]) {
-		//fprintf(stderr, "F[%d][%d]=%d, x=%d\n", i, j, F_i_[j], x);
-
-		// j
-		if (rle_j) {
-		    rle_j--;
-		} else {
-		    *cp++ = j;
-		    if (!rle_j && j && F_i_[j-1]) {
-			for(rle_j=j+1; rle_j<256 && F_i_[rle_j]; rle_j++)
-			    ;
-			rle_j -= j+1;
-			*cp++ = rle_j;
-		    }
-		}
-
-		// F_i_[j]
-		if (F_i_[j]<128) {
- 		    *cp++ = F_i_[j];
-		} else {
-		    *cp++ = 128 | (F_i_[j]>>8);
-		    *cp++ = F_i_[j]&0xff;
-		}
-
-		RansEncSymbolInit(&syms[i][j], x, F_i_[j], TF_SHIFT);
-		x += F_i_[j];
-	    }
-	}
-	*cp++ = 0;
-    }
-    *cp++ = 0;
-
-    //write(2, out_buf+4, cp-(out_buf+4));
-    tab_size = cp - out_buf;
-    assert(tab_size < 257*257*3);
-    
-    RansState rans0, rans1, rans2, rans3;
-    RansEncInit(&rans0);
-    RansEncInit(&rans1);
-    RansEncInit(&rans2);
-    RansEncInit(&rans3);
-
-    uint8_t* ptr = out_end;
-
-    int isz4 = in_size>>2;
-    int i0 = 1*isz4-2;
-    int i1 = 2*isz4-2;
-    int i2 = 3*isz4-2;
-    int i3 = 4*isz4-2;
-
-    unsigned char l0 = in[i0+1];
-    unsigned char l1 = in[i1+1];
-    unsigned char l2 = in[i2+1];
-    unsigned char l3 = in[i3+1];
-
-    // Deal with the remainder
-    l3 = in[in_size-1];
-    for (i3 = in_size-2; i3 > 4*isz4-2; i3--) {
-	unsigned char c3 = in[i3];
-	RansEncPutSymbol(&rans3, &ptr, &syms[c3][l3]);
-	l3 = c3;
-    }
-
-    for (; i0 >= 0; i0--, i1--, i2--, i3--) {
-	unsigned char c3 = in[i3];
-	unsigned char c2 = in[i2];
-	unsigned char c1 = in[i1];
-	unsigned char c0 = in[i0];
-
-	RansEncSymbol *s3 = &syms[c3][l3];
-	RansEncSymbol *s2 = &syms[c2][l2];
-	RansEncSymbol *s1 = &syms[c1][l1];
-	RansEncSymbol *s0 = &syms[c0][l0];
-
-	RansEncPutSymbol4(&rans3, &rans2, &rans1, &rans0, &ptr,
-			  s3, s2, s1, s0);
-
-	l3 = c3;
-	l2 = c2;
-	l1 = c1;
-	l0 = c0;
-    }
-
-    RansEncPutSymbol(&rans3, &ptr, &syms[0][l3]);
-    RansEncPutSymbol(&rans2, &ptr, &syms[0][l2]);
-    RansEncPutSymbol(&rans1, &ptr, &syms[0][l1]);
-    RansEncPutSymbol(&rans0, &ptr, &syms[0][l0]);
-
-    RansEncFlush(&rans3, &ptr);
-    RansEncFlush(&rans2, &ptr);
-    RansEncFlush(&rans1, &ptr);
-    RansEncFlush(&rans0, &ptr);
-
-    *out_size = (out_end - ptr) + tab_size;
-
-    cp = out_buf;
-    *cp++ = 1; // order
-
-    *cp++ = ((*out_size-9)>> 0) & 0xff;
-    *cp++ = ((*out_size-9)>> 8) & 0xff;
-    *cp++ = ((*out_size-9)>>16) & 0xff;
-    *cp++ = ((*out_size-9)>>24) & 0xff;
-
-    *cp++ = (in_size>> 0) & 0xff;
-    *cp++ = (in_size>> 8) & 0xff;
-    *cp++ = (in_size>>16) & 0xff;
-    *cp++ = (in_size>>24) & 0xff;
-
-    memmove(out_buf + tab_size, ptr, out_end-ptr);
-
- cleanup:
-#ifdef USE_HEAP
-    free(syms);
-    free(F);
-#endif
-
-    return out_buf;
-}
-
-#ifndef NO_THREADS
-/*
- * Thread local storage per thread in the pool.
- * This avoids needing to memset/calloc D and syms in the decoder,
- * which can be speed things this decoder up a little (~10%).
- */
-static pthread_once_t rans_once = PTHREAD_ONCE_INIT;
-static pthread_key_t rans_key;
-
-typedef struct {
-    ari_decoder *D;
-    RansDecSymbol32 (*syms)[256];
-} thread_data;
-
-static void rans_tb_free(void *vp) {
-    thread_data *tb = (thread_data *)vp;
-    if (!tb)
-	return;
-    free(tb->D);
-    free(tb->syms);
-    free(tb);
-}
-
-static thread_data *rans_tb_alloc(void) {
-    thread_data *tb = malloc(sizeof(*tb));
-    if (!tb)
-	return NULL;
-    tb->D = calloc(256, sizeof(*tb->D));
-    tb->syms = calloc(256, sizeof(*tb->syms));
-    if (!tb->D || !tb->syms) {
-	rans_tb_free(tb);
-	return NULL;
-    }
-
-    return tb;
-}
-
-static void rans_tls_init(void) {
-    pthread_key_create(&rans_key, rans_tb_free);
-}
-#endif
-
-static
-unsigned char *rans_uncompress_O1(unsigned char *in, unsigned int in_size,
-				  unsigned int *out_size) {
-    /* Load in the static tables */
-    unsigned char *cp = in + 9;
-    unsigned char *ptr_end = in + in_size;
-    int i, j = -999, rle_i, rle_j;
-    unsigned int x;
-    unsigned int out_sz, in_sz;
-    char *out_buf = NULL;
-    // D[] is 1Mb and syms[][] is 0.5Mb.
-#ifndef NO_THREADS
-    pthread_once(&rans_once, rans_tls_init);
-    thread_data *tb = pthread_getspecific(rans_key);
-    if (!tb) {
-	if (!(tb = rans_tb_alloc()))
-	    return NULL;
-	pthread_setspecific(rans_key, tb);
-    }
-    ari_decoder *const D = tb->D;
-    RansDecSymbol32 (*const syms)[256] = tb->syms;
-#else
-#ifdef USE_HEAP
-    //ari_decoder *const D = malloc(256 * sizeof(*D));
-    ari_decoder *const D = calloc(256, sizeof(*D));
-    RansDecSymbol32 (*const syms)[256] = malloc(256 * sizeof(*syms));
-    for (i = 1; i < 256; i++) memset(&syms[i][0], 0, sizeof(syms[0][0]));
-#else
-    ari_decoder D[256] = {{{0}}}; //256*4k    => 1.0Mb
-    RansDecSymbol32 syms[256][256+6] = {{{0}}}; //256*262*8 => 0.5Mb
-#endif
-#endif
-    int16_t map[256], map_i = 0;
-    
-    memset(map, -1, 256*sizeof(*map));
-
-    if (in_size < 27) // Need at least this many bytes to start
-        return NULL;
-
-    if (*in++ != 1) // Order-1 check
-	return NULL;
-
-    in_sz  = ((in[0])<<0) | ((in[1])<<8) | ((in[2])<<16) | (((uint32_t)in[3])<<24);
-    out_sz = ((in[4])<<0) | ((in[5])<<8) | ((in[6])<<16) | (((uint32_t)in[7])<<24);
-    if (in_sz != in_size-9)
-	return NULL;
-
-    if (out_sz >= INT_MAX)
-	return NULL; // protect against some overflow cases
-
-    // For speeding up the fuzzer only.
-    // Small input can lead to large uncompressed data.
-    // We reject this as it just slows things up instead of testing more code
-    // paths (once we've verified a few times for large data).
-#ifdef FUZZING_BUILD_MODE_UNSAFE_FOR_PRODUCTION
-    if (out_sz > 100000)
-	return NULL;
-#endif
-
-#if defined(USE_HEAP)
-    if (!D || !syms) goto cleanup;
-    /* These memsets prevent illegal memory access in syms due to
-       broken compressed data.  As D is calloc'd, all illegal transitions
-       will end up in either row or column 0 of syms. */
-    memset(&syms[0], 0, sizeof(syms[0]));
-    for (i = 0; i < 256; i++)
-	memset(&syms[i][0], 0, sizeof(syms[0][0]));
-#endif
-
-    //fprintf(stderr, "out_sz=%d\n", out_sz);
-
-    //i = *cp++;
-    rle_i = 0;
-    i = *cp++;
-    do {
-	// Map arbitrary a,b,c to 0,1,2 to improve cache locality.
-	if (map[i] == -1)
-	    map[i] = map_i++;
-	int m_i = map[i];
-
-	rle_j = x = 0;
-	j = *cp++;
-	do {
-	    if (map[j] == -1)
-		map[j] = map_i++;
-
-	    int F, C;
-            if (cp > ptr_end - 16) goto cleanup; // Not enough input bytes left
-	    if ((F = *cp++) >= 128) {
-		F &= ~128;
-		F = ((F & 127) << 8) | *cp++;
-	    }
-	    C = x;
-
-	    //fprintf(stderr, "i=%d j=%d F=%d C=%d\n", i, j, F, C);
-
-	    if (!F)
-		F = TOTFREQ;
-
-	    RansDecSymbolInit32(&syms[m_i][j], C, F);
-
-	    /* Build reverse lookup table */
-	    //if (!D[i].R) D[i].R = (unsigned char *)malloc(TOTFREQ);
-	    if (x + F > TOTFREQ)
-		goto cleanup;
-
-	    memset(&D[m_i].R[x], j, F);
-	    x += F;
-
-	    if (!rle_j && j+1 == *cp) {
-		j = *cp++;
-		rle_j = *cp++;
-	    } else if (rle_j) {
-		rle_j--;
-		j++;
-		if (j > 255)
-		    goto cleanup;
-	    } else {
-		j = *cp++;
-	    }
-	} while(j);
-
-        if (x < TOTFREQ-1 || x > TOTFREQ)
-            goto cleanup;
-        if (x < TOTFREQ) // historically we fill 4095, not 4096
-            D[i].R[x] = D[i].R[x-1];
-
-	if (!rle_i && i+1 == *cp) {
-	    i = *cp++;
-	    rle_i = *cp++;
-	} else if (rle_i) {
-	    rle_i--;
-	    i++;
-	    if (i > 255)
-		goto cleanup;
-	} else {
-	    i = *cp++;
-	}
-    } while (i);
-    for (i = 0; i < 256; i++)
-	if (map[i] == -1)
-	    map[i] = 0;
-
-    RansState rans0, rans1, rans2, rans3;
-    uint8_t *ptr = cp;
-    if (cp > ptr_end - 16) goto cleanup; // Not enough input bytes left
-    RansDecInit(&rans0, &ptr); if (rans0 < RANS_BYTE_L) return NULL;
-    RansDecInit(&rans1, &ptr); if (rans1 < RANS_BYTE_L) return NULL;
-    RansDecInit(&rans2, &ptr); if (rans2 < RANS_BYTE_L) return NULL;
-    RansDecInit(&rans3, &ptr); if (rans3 < RANS_BYTE_L) return NULL;
-
-    RansState R[4];
-    R[0] = rans0;
-    R[1] = rans1;
-    R[2] = rans2;
-    R[3] = rans3;
-
-    unsigned int isz4 = out_sz>>2;
-    uint32_t l0 = 0;
-    uint32_t l1 = 0;
-    uint32_t l2 = 0;
-    uint32_t l3 = 0;
-    
-    unsigned int i4[] = {0*isz4, 1*isz4, 2*isz4, 3*isz4};
-
-    /* Allocate output buffer */
-    out_buf = malloc(out_sz);
-    if (!out_buf) goto cleanup;
-
-    uint8_t cc0 = D[map[l0]].R[R[0] & ((1u << TF_SHIFT)-1)];
-    uint8_t cc1 = D[map[l1]].R[R[1] & ((1u << TF_SHIFT)-1)];
-    uint8_t cc2 = D[map[l2]].R[R[2] & ((1u << TF_SHIFT)-1)];
-    uint8_t cc3 = D[map[l3]].R[R[3] & ((1u << TF_SHIFT)-1)];
-
-    ptr_end -= 8;
-    for (; i4[0] < isz4; i4[0]++, i4[1]++, i4[2]++, i4[3]++) {
-	out_buf[i4[0]] = cc0;
-	out_buf[i4[1]] = cc1;
-	out_buf[i4[2]] = cc2;
-	out_buf[i4[3]] = cc3;
-
-	//RansDecAdvanceStep(&R[0], syms[l0][cc0].start, syms[l0][cc0].freq, TF_SHIFT);
-	//RansDecAdvanceStep(&R[1], syms[l1][cc1].start, syms[l1][cc1].freq, TF_SHIFT);
-	//RansDecAdvanceStep(&R[2], syms[l2][cc2].start, syms[l2][cc2].freq, TF_vSHIFT);
-	//RansDecAdvanceStep(&R[3], syms[l3][cc3].start, syms[l3][cc3].freq, TF_SHIFT);
-
-	{
-	    uint32_t m[4];
-
-	    // Ordering to try and improve OoO cpu instructions
-	    m[0] = R[0] & ((1u << TF_SHIFT)-1);
-	    R[0] = syms[l0][cc0].freq * (R[0]>>TF_SHIFT);
-	    m[1] = R[1] & ((1u << TF_SHIFT)-1);
-	    R[0] += m[0] - syms[l0][cc0].start;
-	    R[1] = syms[l1][cc1].freq * (R[1]>>TF_SHIFT);
-	    m[2] = R[2] & ((1u << TF_SHIFT)-1);
-	    R[1] += m[1] - syms[l1][cc1].start;
-	    R[2] = syms[l2][cc2].freq * (R[2]>>TF_SHIFT);
-	    m[3] = R[3] & ((1u << TF_SHIFT)-1);
-	    R[3] = syms[l3][cc3].freq * (R[3]>>TF_SHIFT);
-	    R[2] += m[2] - syms[l2][cc2].start;
-	    R[3] += m[3] - syms[l3][cc3].start;
-	}
-
-	l0 = map[cc0];
-	l1 = map[cc1];
-	l2 = map[cc2];
-	l3 = map[cc3];
-
-	if (ptr < ptr_end) {
-	    RansDecRenorm2(&R[0], &R[1], &ptr);
-	    RansDecRenorm2(&R[2], &R[3], &ptr);
-	} else {
-	    RansDecRenormSafe(&R[0], &ptr, ptr_end+8);
-	    RansDecRenormSafe(&R[1], &ptr, ptr_end+8);
-	    RansDecRenormSafe(&R[2], &ptr, ptr_end+8);
-	    RansDecRenormSafe(&R[3], &ptr, ptr_end+8);
-	}
-
-	cc0 = D[l0].R[R[0] & ((1u << TF_SHIFT)-1)];
-	cc1 = D[l1].R[R[1] & ((1u << TF_SHIFT)-1)];
-	cc2 = D[l2].R[R[2] & ((1u << TF_SHIFT)-1)];
-	cc3 = D[l3].R[R[3] & ((1u << TF_SHIFT)-1)];
-    }
-
-    // Remainder
-    for (; i4[3] < out_sz; i4[3]++) {
-	unsigned char c3 = D[l3].R[RansDecGet(&R[3], TF_SHIFT)];
-	out_buf[i4[3]] = c3;
-
-	uint32_t m = R[3] & ((1u << TF_SHIFT)-1);
-	R[3] = syms[l3][c3].freq * (R[3]>>TF_SHIFT) + m - syms[l3][c3].start;
-	RansDecRenormSafe(&R[3], &ptr, ptr_end+8);
-	l3 = map[c3];
-    }
-    
-    *out_size = out_sz;
-
- cleanup:
-#if defined(USE_HEAP)
-    if (D)
-        free(D);
-
-    free(syms);
-#endif
-
-    return (unsigned char *)out_buf;
-}
-
-/*-----------------------------------------------------------------------------
- * Simple interface to the order-0 vs order-1 encoders and decoders.
- */
-unsigned char *rans_compress(unsigned char *in, unsigned int in_size,
-			     unsigned int *out_size, int order) {
-    return order
-	? rans_compress_O1(in, in_size, out_size)
-	: rans_compress_O0(in, in_size, out_size);
-}
-
-unsigned char *rans_uncompress(unsigned char *in, unsigned int in_size,
-			       unsigned int *out_size) {
-    /* Both rans_uncompress functions need to be able to read at least 9
-       bytes. */
-    if (in_size < 9)
-        return NULL;
-    return in[0]
-	? rans_uncompress_O1(in, in_size, out_size)
-	: rans_uncompress_O0(in, in_size, out_size);
-}
diff -ruN stringtie.orig/htslib/htscodecs/htscodecs/rANS_static.h stringtie/htslib/htscodecs/htscodecs/rANS_static.h
--- stringtie.orig/htslib/htscodecs/htscodecs/rANS_static.h	2024-02-28 13:57:39.704579460 +0100
+++ stringtie/htslib/htscodecs/htscodecs/rANS_static.h	1970-01-01 01:00:00.000000000 +0100
@@ -1,50 +0,0 @@
-/*
- * Copyright (c) 2014-2019 Genome Research Ltd.
- * Author(s): James Bonfield
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions are met:
- *
- *    1. Redistributions of source code must retain the above copyright notice,
- *       this list of conditions and the following disclaimer.
- *
- *    2. Redistributions in binary form must reproduce the above
- *       copyright notice, this list of conditions and the following
- *       disclaimer in the documentation and/or other materials provided
- *       with the distribution.
- *
- *    3. Neither the names Genome Research Ltd and Wellcome Trust Sanger
- *       Institute nor the names of its contributors may be used to endorse
- *       or promote products derived from this software without specific
- *       prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY GENOME RESEARCH LTD AND CONTRIBUTORS "AS
- * IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
- * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
- * PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL GENOME RESEARCH
- * LTD OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
- * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
- * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
- * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
- * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
- * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
- * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- */
-
-#ifndef RANS_STATIC_H
-#define RANS_STATIC_H
-
-#ifdef __cplusplus
-extern "C" {
-#endif
-
-unsigned char *rans_compress(unsigned char *in, unsigned int in_size,
-			     unsigned int *out_size, int order);
-unsigned char *rans_uncompress(unsigned char *in, unsigned int in_size,
-			       unsigned int *out_size);
-
-#ifdef __cplusplus
-}
-#endif
-
-#endif /* RANS_STATIC_H */
diff -ruN stringtie.orig/htslib/htscodecs/htscodecs/rANS_word.h stringtie/htslib/htscodecs/htscodecs/rANS_word.h
--- stringtie.orig/htslib/htscodecs/htscodecs/rANS_word.h	2024-02-28 13:57:39.704579460 +0100
+++ stringtie/htslib/htscodecs/htscodecs/rANS_word.h	1970-01-01 01:00:00.000000000 +0100
@@ -1,412 +0,0 @@
-/* rans_byte.h originally from https://github.com/rygorous/ryg_rans
- *
- * This is a public-domain implementation of several rANS variants. rANS is an
- * entropy coder from the ANS family, as described in Jarek Duda's paper
- * "Asymmetric numeral systems" (http://arxiv.org/abs/1311.2540).
- */
-
-/*-------------------------------------------------------------------------- */
-/* rans_byte.h from https://github.com/rygorous/ryg_rans */
-
-// Simple byte-aligned rANS encoder/decoder - public domain - Fabian 'ryg' Giesen 2014
-//
-// Not intended to be "industrial strength"; just meant to illustrate the general
-// idea.
-
-#ifndef RANS_WORD_HEADER
-#define RANS_WORD_HEADER
-
-#include <stdio.h>
-#include <stdint.h>
-#include <assert.h>
-#include "htscodecs_endian.h"
-
-#ifdef assert
-#define RansAssert assert
-#else
-#define RansAssert(x)
-#endif
-
-// READ ME FIRST:
-//
-// This is designed like a typical arithmetic coder API, but there's three
-// twists you absolutely should be aware of before you start hacking:
-//
-// 1. You need to encode data in *reverse* - last symbol first. rANS works
-//    like a stack: last in, first out.
-// 2. Likewise, the encoder outputs bytes *in reverse* - that is, you give
-//    it a pointer to the *end* of your buffer (exclusive), and it will
-//    slowly move towards the beginning as more bytes are emitted.
-// 3. Unlike basically any other entropy coder implementation you might
-//    have used, you can interleave data from multiple independent rANS
-//    encoders into the same bytestream without any extra signaling;
-//    you can also just write some bytes by yourself in the middle if
-//    you want to. This is in addition to the usual arithmetic encoder
-//    property of being able to switch models on the fly. Writing raw
-//    bytes can be useful when you have some data that you know is
-//    incompressible, and is cheaper than going through the rANS encode
-//    function. Using multiple rANS coders on the same byte stream wastes
-//    a few bytes compared to using just one, but execution of two
-//    independent encoders can happen in parallel on superscalar and
-//    Out-of-Order CPUs, so this can be *much* faster in tight decoding
-//    loops.
-//
-//    This is why all the rANS functions take the write pointer as an
-//    argument instead of just storing it in some context struct.
-
-// --------------------------------------------------------------------------
-
-// L ('l' in the paper) is the lower bound of our normalization interval.
-// Between this and our byte-aligned emission, we use 31 (not 32!) bits.
-// This is done intentionally because exact reciprocals for 31-bit uints
-// fit in 32-bit uints: this permits some optimizations during encoding.
-#define RANS_BYTE_L (1u << 15)  // lower bound of our normalization interval
-
-// State for a rANS encoder. Yep, that's all there is to it.
-typedef uint32_t RansState;
-
-// Initialize a rANS encoder.
-static inline void RansEncInit(RansState* r)
-{
-    *r = RANS_BYTE_L;
-}
-
-// Renormalize the encoder. Internal function.
-static inline RansState RansEncRenorm(RansState x, uint8_t** pptr, uint32_t freq, uint32_t scale_bits)
-{
-    uint32_t x_max = ((RANS_BYTE_L >> scale_bits) << 16) * freq; // this turns into a shift.
-    if (x >= x_max) {
-        uint16_t* ptr = (uint16_t *)*pptr;
-        *--ptr = (uint16_t) (x & 0xffff);
-        x >>= 16;
-        *pptr = (uint8_t *)ptr;
-    }
-    return x;
-}
-
-// Encodes a single symbol with range start "start" and frequency "freq".
-// All frequencies are assumed to sum to "1 << scale_bits", and the
-// resulting bytes get written to ptr (which is updated).
-//
-// NOTE: With rANS, you need to encode symbols in *reverse order*, i.e. from
-// beginning to end! Likewise, the output bytestream is written *backwards*:
-// ptr starts pointing at the end of the output buffer and keeps decrementing.
-static inline void RansEncPut(RansState* r, uint8_t** pptr, uint32_t start, uint32_t freq, uint32_t scale_bits)
-{
-    // renormalize
-    RansState x = RansEncRenorm(*r, pptr, freq, scale_bits);
-
-    // x = C(s,x)
-    *r = ((x / freq) << scale_bits) + (x % freq) + start;
-}
-
-// Flushes the rANS encoder.
-static inline void RansEncFlush(RansState* r, uint8_t** pptr)
-{
-    uint32_t x = *r;
-    uint8_t* ptr = *pptr;
-
-    ptr -= 4;
-    ptr[0] = (uint8_t) (x >> 0);
-    ptr[1] = (uint8_t) (x >> 8);
-    ptr[2] = (uint8_t) (x >> 16);
-    ptr[3] = (uint8_t) (x >> 24);
-
-    *pptr = ptr;
-}
-
-// Initializes a rANS decoder.
-// Unlike the encoder, the decoder works forwards as you'd expect.
-static inline void RansDecInit(RansState* r, uint8_t** pptr)
-{
-    uint32_t x;
-    uint8_t* ptr = *pptr;
-
-    x  = ptr[0] << 0;
-    x |= ptr[1] << 8;
-    x |= ptr[2] << 16;
-    x |= ((uint32_t)ptr[3]) << 24;
-    ptr += 4;
-
-    *pptr = ptr;
-    *r = x;
-}
-
-// Returns the current cumulative frequency (map it to a symbol yourself!)
-static inline uint32_t RansDecGet(RansState* r, uint32_t scale_bits)
-{
-    return *r & ((1u << scale_bits) - 1);
-}
-
-// Advances in the bit stream by "popping" a single symbol with range start
-// "start" and frequency "freq". All frequencies are assumed to sum to "1 << scale_bits",
-// and the resulting bytes get written to ptr (which is updated).
-static inline void RansDecAdvance(RansState* r, uint8_t** pptr, uint32_t start, uint32_t freq, uint32_t scale_bits)
-{
-    uint32_t mask = (1u << scale_bits) - 1;
-
-    // s, x = D(x)
-    uint32_t x = *r;
-    x = freq * (x >> scale_bits) + (x & mask) - start;
-
-    // renormalize
-    if (x < RANS_BYTE_L) {
-        uint8_t* ptr = *pptr;
-        do x = (x << 8) | *ptr++; while (x < RANS_BYTE_L);
-        *pptr = ptr;
-    }
-
-    *r = x;
-}
-
-// --------------------------------------------------------------------------
-
-// That's all you need for a full encoder; below here are some utility
-// functions with extra convenience or optimizations.
-
-// Encoder symbol description
-// This (admittedly odd) selection of parameters was chosen to make
-// RansEncPutSymbol as cheap as possible.
-typedef struct {
-    uint32_t x_max;     // (Exclusive) upper bound of pre-normalization interval
-    uint32_t rcp_freq;  // Fixed-point reciprocal frequency
-    uint32_t bias;      // Bias
-    uint16_t cmpl_freq; // Complement of frequency: (1 << scale_bits) - freq
-    uint16_t rcp_shift; // Reciprocal shift
-
-    // FIXME: temporary
-    uint16_t scale_bits;
-    uint16_t freq;
-    uint16_t start;
-} RansEncSymbol;
-
-// Decoder symbols are straightforward.
-typedef struct {
-    uint16_t start;     // Start of range.
-    uint16_t freq;      // Symbol frequency.
-} RansDecSymbol;
-
-// Initializes an encoder symbol to start "start" and frequency "freq"
-static inline void RansEncSymbolInit(RansEncSymbol* s, uint32_t start, uint32_t freq, uint32_t scale_bits)
-{
-    RansAssert(scale_bits <= 16);
-    RansAssert(start <= (1u << scale_bits));
-    RansAssert(freq <= (1u << scale_bits) - start);
-
-    // Say M := 1 << scale_bits.
-    //
-    // The original encoder does:
-    //   x_new = (x/freq)*M + start + (x%freq)
-    //
-    // The fast encoder does (schematically):
-    //   q     = mul_hi(x, rcp_freq) >> rcp_shift   (division)
-    //   r     = x - q*freq                         (remainder)
-    //   x_new = q*M + bias + r                     (new x)
-    // plugging in r into x_new yields:
-    //   x_new = bias + x + q*(M - freq)
-    //        =: bias + x + q*cmpl_freq             (*)
-    //
-    // and we can just precompute cmpl_freq. Now we just need to
-    // set up our parameters such that the original encoder and
-    // the fast encoder agree.
-    
-    // FIXME: temporary
-    s->scale_bits = scale_bits;
-    s->freq = freq;
-    s->start = start;
-
-    s->x_max = ((RANS_BYTE_L >> scale_bits) << 16) * freq;
-    s->cmpl_freq = (uint16_t) ((1 << scale_bits) - freq);
-    if (freq < 2) {
-        // freq=0 symbols are never valid to encode, so it doesn't matter what
-        // we set our values to.
-        //
-        // freq=1 is tricky, since the reciprocal of 1 is 1; unfortunately,
-        // our fixed-point reciprocal approximation can only multiply by values
-        // smaller than 1.
-        //
-        // So we use the "next best thing": rcp_freq=0xffffffff, rcp_shift=0.
-        // This gives:
-        //   q = mul_hi(x, rcp_freq) >> rcp_shift
-        //     = mul_hi(x, (1<<32) - 1)) >> 0
-        //     = floor(x - x/(2^32))
-        //     = x - 1 if 1 <= x < 2^32
-        // and we know that x>0 (x=0 is never in a valid normalization interval).
-        //
-        // So we now need to choose the other parameters such that
-        //   x_new = x*M + start
-        // plug it in:
-        //     x*M + start                   (desired result)
-        //   = bias + x + q*cmpl_freq        (*)
-        //   = bias + x + (x - 1)*(M - 1)    (plug in q=x-1, cmpl_freq)
-        //   = bias + 1 + (x - 1)*M
-        //   = x*M + (bias + 1 - M)
-        //
-        // so we have start = bias + 1 - M, or equivalently
-        //   bias = start + M - 1.
-        s->rcp_freq = ~0u;
-        s->rcp_shift = 0;
-        s->bias = start + (1 << scale_bits) - 1;
-    } else {
-        // Alverson, "Integer Division using reciprocals"
-        // shift=ceil(log2(freq))
-        uint32_t shift = 0;
-        while (freq > (1u << shift))
-            shift++;
-
-        s->rcp_freq = (uint32_t) (((1ull << (shift + 31)) + freq-1) / freq);
-        s->rcp_shift = shift - 1;
-
-        // With these values, 'q' is the correct quotient, so we
-        // have bias=start.
-        s->bias = start;
-    }
-
-    s->rcp_shift += 32; // Avoid the extra >>32 in RansEncPutSymbol
-}
-
-// Initialize a decoder symbol to start "start" and frequency "freq"
-static inline void RansDecSymbolInit(RansDecSymbol* s, uint32_t start, uint32_t freq)
-{
-    RansAssert(start <= (1 << 16));
-    RansAssert(freq <= (1 << 16) - start);
-    s->start = (uint16_t) start;
-    s->freq = (uint16_t) freq;
-}
-
-// Encodes a given symbol. This is faster than straight RansEnc since we can do
-// multiplications instead of a divide.
-//
-// See RansEncSymbolInit for a description of how this works.
-static inline void RansEncPutSymbol(RansState* r, uint8_t** pptr, RansEncSymbol const* sym)
-{
-    RansAssert(sym->x_max != 0); // can't encode symbol with freq=0
-
-    // renormalize
-    uint32_t x = *r;
-    uint32_t x_max = sym->x_max;
-
-#ifdef HTSCODECS_LITTLE_ENDIAN
-    if (x >= x_max) {
-	(*pptr) -= 2;
-        **(uint16_t **)pptr = x;
-	x >>= 16;
-    }
-#else
-    if (x >= x_max) {
-	uint8_t* ptr = *pptr;
-        ptr -= 2;
-	ptr[0] = x & 0xff;
-	ptr[1] = (x >> 8) & 0xff;
-	x >>= 16;
-	*pptr = ptr;
-    }
-#endif
-
-    // x = C(s,x)
-    // NOTE: written this way so we get a 32-bit "multiply high" when
-    // available. If you're on a 64-bit platform with cheap multiplies
-    // (e.g. x64), just bake the +32 into rcp_shift.
-    //uint32_t q = (uint32_t) (((uint64_t)x * sym->rcp_freq) >> 32) >> sym->rcp_shift;
-
-    // Slow method, but robust
-//    *r = ((x / sym->freq) << sym->scale_bits) + (x % sym->freq) + sym->start;
-//    return;
-
-    // The extra >>32 has already been added to RansEncSymbolInit
-    uint32_t q = (uint32_t) (((uint64_t)x * sym->rcp_freq) >> sym->rcp_shift);
-    *r = x + sym->bias + q * sym->cmpl_freq;
-
-//    assert(((x / sym->freq) << sym->scale_bits) + (x % sym->freq) + sym->start == *r);
-}
-
-// Equivalent to RansDecAdvance that takes a symbol.
-static inline void RansDecAdvanceSymbol(RansState* r, uint8_t** pptr, RansDecSymbol const* sym, uint32_t scale_bits)
-{
-    RansDecAdvance(r, pptr, sym->start, sym->freq, scale_bits);
-}
-
-// Advances in the bit stream by "popping" a single symbol with range start
-// "start" and frequency "freq". All frequencies are assumed to sum to "1 << scale_bits".
-// No renormalization or output happens.
-static inline void RansDecAdvanceStep(RansState* r, uint32_t start, uint32_t freq, uint32_t scale_bits)
-{
-    uint32_t mask = (1u << scale_bits) - 1;
-
-    // s, x = D(x)
-    uint32_t x = *r;
-    *r = freq * (x >> scale_bits) + (x & mask) - start;
-}
-
-// Equivalent to RansDecAdvanceStep that takes a symbol.
-static inline void RansDecAdvanceSymbolStep(RansState* r, RansDecSymbol const* sym, uint32_t scale_bits)
-{
-    RansDecAdvanceStep(r, sym->start, sym->freq, scale_bits);
-}
-
-// Renormalize.
-
-#if defined(__x86_64) && !defined(__ILP32__)
-
-/*
- * Assembly variants of the RansDecRenorm code.
- * These are based on joint ideas from Rob Davies and from looking at
- * the clang assembly output.
- */
-static inline void RansDecRenorm(RansState* r, uint8_t** pptr) {
-    //       q4        q40
-    // clang 730/608   717/467
-    // gcc8  733/588   737/458
-    uint32_t  x   = *r;
-    uint16_t  *ptr = *(uint16_t **)pptr;
-    __asm__ ("movzwl (%0),  %%eax\n\t"
-	     "mov    %1,    %%edx\n\t"
-	     "shl    $0x10, %%edx\n\t"
-             "or     %%eax, %%edx\n\t"
-	     "xor    %%eax, %%eax\n\t"
-             "cmp    $0x8000,%1\n\t"
-             "cmovb  %%edx, %1\n\t"
-	     "lea    2(%0), %%rax\n\t"
-	     "cmovb  %%rax, %0\n\t"
-             : "=r" (ptr), "=r" (x)
-             : "0"  (ptr), "1"  (x)
-             : "eax", "edx"
-             );
-    *pptr = (uint8_t *)ptr;
-    *r = x;
-}
-
-#else /* __x86_64 */
-
-static inline void RansDecRenorm(RansState* r, uint8_t** pptr)
-{
-    // renormalize
-    uint32_t x = *r;
-
-    // Up to 6% quicker (rans4x16pr -t) if using unaligned access,
-    // but normally closer.
-    uint32_t y = (*pptr)[0] | ((*pptr)[1]<<8);
-
-    if (x < RANS_BYTE_L)
-	(*pptr)+=2;
-    if (x < RANS_BYTE_L)
-	x = (x << 16) | y;
-
-    *r = x;
-}
-#endif /* __x86_64 */
-
-// Note the data may not be word aligned here.
-// This function is only used sparingly, for the last few bytes in the buffer,
-// so speed isn't critical.
-static inline void RansDecRenormSafe(RansState* r, uint8_t** pptr, uint8_t *ptr_end)
-{
-    uint32_t x = *r;
-    if (x >= RANS_BYTE_L || *pptr+1 >= ptr_end) return;
-    uint16_t y = (*pptr)[0] + ((*pptr)[1]<<8);
-    x = (x << 16) | y;
-    (*pptr) += 2;
-    *r = x;
-}
-
-#endif // RANS_WORD_HEADER
diff -ruN stringtie.orig/htslib/htscodecs/htscodecs/rle.c stringtie/htslib/htscodecs/htscodecs/rle.c
--- stringtie.orig/htslib/htscodecs/htscodecs/rle.c	2024-02-28 13:57:39.704579460 +0100
+++ stringtie/htslib/htscodecs/htscodecs/rle.c	1970-01-01 01:00:00.000000000 +0100
@@ -1,188 +0,0 @@
-/*
- * Copyright (c) 2019,2020 Genome Research Ltd.
- * Author(s): James Bonfield
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions are met:
- *
- *    1. Redistributions of source code must retain the above copyright notice,
- *       this list of conditions and the following disclaimer.
- *
- *    2. Redistributions in binary form must reproduce the above
- *       copyright notice, this list of conditions and the following
- *       disclaimer in the documentation and/or other materials provided
- *       with the distribution.
- *
- *    3. Neither the names Genome Research Ltd and Wellcome Trust Sanger
- *       Institute nor the names of its contributors may be used to endorse
- *       or promote products derived from this software without specific
- *       prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY GENOME RESEARCH LTD AND CONTRIBUTORS "AS
- * IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
- * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
- * PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL GENOME RESEARCH
- * LTD OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
- * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
- * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
- * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
- * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
- * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
- * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- */
-
-#include "config.h"
-
-#include <stdint.h>
-#include <stdlib.h>
-#include <string.h>
-#include <stdio.h>
-
-#include "varint.h"
-#include "rle.h"
-
-#define MAGIC 8
-
-//-----------------------------------------------------------------------------
-// Auto compute rle_syms / rle_nsyms
-static void rle_find_syms(uint8_t *data, uint64_t data_len,
-			  int64_t *saved, // dim >= 256 
-			  uint8_t *rle_syms, int *rle_nsyms) {
-    int last = -1, n;
-    uint64_t i;
-
-    if (data_len > 256) {
-	// 186/450
-	// Interleaved buffers to avoid cache collisions
-	int64_t saved2[256+MAGIC] = {0};
-	int64_t saved3[256+MAGIC] = {0};
-	int64_t saved4[256+MAGIC] = {0};
-	int64_t len4 = data_len&~3;
-	for (i = 0; i < len4; i+=4) {
-	    int d1 = (data[i+0] == last)     <<1;
-	    int d2 = (data[i+1] == data[i+0])<<1;
-	    int d3 = (data[i+2] == data[i+1])<<1;
-	    int d4 = (data[i+3] == data[i+2])<<1;
-	    last = data[i+3];
-	    saved [data[i+0]] += d1-1;
-	    saved2[data[i+1]] += d2-1;
-	    saved3[data[i+2]] += d3-1;
-	    saved4[data[i+3]] += d4-1;
-	}
-	while (i < data_len) {
-	    int d = (data[i] == last)<<1;
-	    saved[data[i]] += d - 1;
-	    last = data[i];
-	    i++;
-	}
-	for (i = 0; i < 256; i++)
-	    saved[i] += saved2[i] + saved3[i] + saved4[i];
-    } else {
-	// 163/391
-	for (i = 0; i < data_len; i++) {
-	    if (data[i] == last) {
-		saved[data[i]]++;
-	    } else {
-		saved[data[i]]--;
-		last = data[i];
-	    }
-	}
-    }
-
-    // Map back to a list
-    for (i = n = 0; i < 256; i++) {
-	if (saved[i] > 0)
-	    rle_syms[n++] = i;
-    }
-    *rle_nsyms = n;
-}
-
-uint8_t *rle_encode(uint8_t *data, uint64_t data_len,
-		    uint8_t *run,  uint64_t *run_len,
-		    uint8_t *rle_syms, int *rle_nsyms,
-		    uint8_t *out, uint64_t *out_len) {
-    uint64_t i, j, k;
-    if (!out)
-	if (!(out = malloc(data_len*2)))
-	    return NULL;
-
-    // Two pass:  Firstly compute which symbols are worth using RLE on.
-    int64_t saved[256+MAGIC] = {0};
-
-    if (*rle_nsyms) {
-	for (i = 0; i < *rle_nsyms; i++)
-	    saved[rle_syms[i]] = 1;
-    } else {
-	// Writes back to rle_syms and rle_nsyms
-	rle_find_syms(data, data_len, saved, rle_syms, rle_nsyms);
-    }
-
-    // 2nd pass: perform RLE itself to out[] and run[] arrays.
-    for (i = j = k = 0; i < data_len; i++) {
-	out[k++] = data[i];
-	if (saved[data[i]] > 0) {
-	    int rlen = i;
-	    int last = data[i];
-	    while (i < data_len && data[i] == last)
-		i++;
-	    i--;
-	    rlen = i-rlen;
-
-	    j += var_put_u32(&run[j], NULL, rlen);
-	}
-    }
-    
-    *run_len = j;
-    *out_len = k;
-    return out;
-}
-
-// On input *out_len holds the allocated size of out[].
-// On output it holds the used size of out[].
-uint8_t *rle_decode(uint8_t *lit, uint64_t lit_len,
-		    uint8_t *run, uint64_t run_len,
-		    uint8_t *rle_syms, int rle_nsyms,
-		    uint8_t *out, uint64_t *out_len) {
-    uint64_t j;
-    uint8_t *run_end = run + run_len;
-
-#ifdef FUZZING_BUILD_MODE_UNSAFE_FOR_PRODUCTION
-    if (*out_len > 100000)
-	return NULL;
-#endif
-
-    int saved[256] = {0};
-    for (j = 0; j < rle_nsyms; j++)
-	saved[rle_syms[j]] = 1;
-
-    uint8_t *lit_end = lit + lit_len;
-    uint8_t *out_end = out + *out_len;
-    uint8_t *outp = out;
-    while (lit < lit_end) {
-	if (outp >= out_end)
-	    goto err;
-
-	uint8_t b = *lit++;
-	if (!saved[b]) {
-	    *outp++ = b;
-	} else {
-	    uint32_t rlen;
-	    run += var_get_u32(run, run_end, &rlen);
-	    if (rlen) {
-		if (outp + rlen >= out_end)
-		    goto err;
-		memset(outp, b, rlen+1);
-		outp += rlen+1;
-	    } else {
-		*outp++ = b;
-	    }
-	}
-    }
-
-    *out_len = outp-out;
-    return out;
-
- err:
-    return NULL;
-}
-
diff -ruN stringtie.orig/htslib/htscodecs/htscodecs/rle.h stringtie/htslib/htscodecs/htscodecs/rle.h
--- stringtie.orig/htslib/htscodecs/htscodecs/rle.h	2024-02-28 13:57:39.704579460 +0100
+++ stringtie/htslib/htscodecs/htscodecs/rle.h	1970-01-01 01:00:00.000000000 +0100
@@ -1,95 +0,0 @@
-/*
- * Copyright (c) 2019 Genome Research Ltd.
- * Author(s): James Bonfield
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions are met:
- *
- *    1. Redistributions of source code must retain the above copyright notice,
- *       this list of conditions and the following disclaimer.
- *
- *    2. Redistributions in binary form must reproduce the above
- *       copyright notice, this list of conditions and the following
- *       disclaimer in the documentation and/or other materials provided
- *       with the distribution.
- *
- *    3. Neither the names Genome Research Ltd and Wellcome Trust Sanger
- *       Institute nor the names of its contributors may be used to endorse
- *       or promote products derived from this software without specific
- *       prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY GENOME RESEARCH LTD AND CONTRIBUTORS "AS
- * IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
- * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
- * PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL GENOME RESEARCH
- * LTD OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
- * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
- * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
- * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
- * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
- * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
- * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- */
-
-#ifndef HTS_RLE_H
-#define HTS_RLE_H
-
-#ifdef __cplusplus
-extern "C" {
-#endif
-
-/*
- * Performs run length encoding of a byte stream, turning it into a
- * list of lengths and a list of literals.
- *
- * The method used is a bit different to traditional run length
- * encoding.  It always outputs run-lengths for symbols in the
- * 'rle_syms' list (even if that length is +0 more), and never outputs
- * lengths for symbols not in that list.
- *
- * "run" should be preallocated to be large enough;
- * e.g at least data_len bytes long as a worse case.
- * "rle_syms" should be allocated to be at least 256 bytes.
- *
- * If *rle_nsyms is zero this function will survey the input data
- * first to choose symbols automatically, writing back to rle_syms and
- * rle_nsyms.
- *
- * The "out" buffer may be passed in as NULL in which case it is
- * allocated and returned (and is up to the caller to free).
- * Otherwise if specified as non-NULL it will be written to, but
- * it is up to the caller to ensure the buffer size is large enough.
- * A worst case scenario is 2*data_len.
- *
- * Returns the literal buffer on success with new length in out_len,
- *         also fills out run buffer and run_len,  and potentially
- *         updates rle_syms / rle_nsyms too.
- * Returns NULL of failure
- */
-uint8_t *rle_encode(uint8_t *data, uint64_t data_len,
-		    uint8_t *run,  uint64_t *run_len,
-		    uint8_t *rle_syms, int *rle_nsyms,
-		    uint8_t *out, uint64_t *out_len);
-
-/*
- * Expands a run lengthed data steam from a pair of literal and
- * run-length buffers.
- *
- * On input *out_len holds the length of the supplied out
- * buffer.  On exit, it holds the used portion of this buffer.
- *
- * Returns uncompressed data (out) on success,
- *         NULL on failure.
- */
-uint8_t *rle_decode(uint8_t *lit, uint64_t lit_len,
-		    uint8_t *run, uint64_t run_len,
-		    uint8_t *rle_syms, int rle_nsyms,
-		    uint8_t *out, uint64_t *out_len);
-
-// TODO: Add rle scanning func to compute rle_syms.
-
-#ifdef __cplusplus
-}
-#endif
-
-#endif /* HTS_RLE_H */
diff -ruN stringtie.orig/htslib/htscodecs/htscodecs/tokenise_name3.c stringtie/htslib/htscodecs/htscodecs/tokenise_name3.c
--- stringtie.orig/htslib/htscodecs/htscodecs/tokenise_name3.c	2024-02-28 13:57:39.704579460 +0100
+++ stringtie/htslib/htscodecs/htscodecs/tokenise_name3.c	1970-01-01 01:00:00.000000000 +0100
@@ -1,1694 +0,0 @@
-/*
- * Copyright (c) 2016-2020 Genome Research Ltd.
- * Author(s): James Bonfield
- * 
- * Redistribution and use in source and binary forms, with or without 
- * modification, are permitted provided that the following conditions are met:
- * 
- *    1. Redistributions of source code must retain the above copyright notice,
- *       this list of conditions and the following disclaimer.
- * 
- *    2. Redistributions in binary form must reproduce the above
- *       copyright notice, this list of conditions and the following
- *       disclaimer in the documentation and/or other materials provided
- *       with the distribution.
- * 
- *    3. Neither the names Genome Research Ltd and Wellcome Trust Sanger
- *    Institute nor the names of its contributors may be used to endorse
- *    or promote products derived from this software without specific
- *    prior written permission.
- * 
- * THIS SOFTWARE IS PROVIDED BY GENOME RESEARCH LTD AND CONTRIBUTORS "AS
- * IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
- * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
- * PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL GENOME RESEARCH
- * LTD OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
- * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
- * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
- * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
- * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
- * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
- * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- */
-
-// cc -O3 -g -DTEST_TOKENISER tokenise_name3.c arith_dynamic.c rANS_static4x16pr.c pooled_alloc.c -I.. -I. -lbz2 -pthread
-
-// Name tokeniser.
-// It generates a series of byte streams (per token) and compresses these
-// either using static rANS or dynamic arithmetic coding.  Arith coding is
-// typically 1-5% smaller, but around 50-100% slower.  We only envisage it
-// being used at the higher compression levels.
-
-// TODO
-//
-// - Is it better when encoding 1, 2, 3, 3, 4, 5, 5, 6, 7, 9, 9, 10 to encode
-//   this as a mixture of MATCH and DELTA ops, or as entirely as DELTA ops
-//   with some delta values being zero?  I suspect the latter, but it is
-//   not implemented here.  See "last_token_delta" comments in code.
-//
-// - Consider variable size string implementations.
-//   Pascal style strings (length + str),
-//   C style strings (nul terminated),
-//   Or split blocks: length block and string contents block.
-//
-// - Is this one token-block or many serialised token-blocks?
-//   A) Lots of different models but feeding one bit-buffer emitted to
-//      by the entropy encoder => one block (fqzcomp).
-//   B) Lots of different models each feeding their own bit-buffers
-//      => many blocks.
-//
-// - multiple integer types depending on size; 1, 2, 4 byte long.
-//
-// - Consider token choice for isalnum instead of isalpha.  Sometimes better.
-//
-// - Consider token synchronisation (eg on matching chr symbols?) incase of
-//   variable number.  Eg consider foo:0999, foo:1000, foo:1001 (the leading
-//   zero adds an extra token).
-//
-// - Optimisation of tokens.  Eg:
-//     HS25_09827:2:2102:11274:80442#49
-//     HS25_09827:2:2109:12941:31311#49
-//
-//   We'll have tokens for HS 25 _ 09827 : 2 : that are entirely <MATCH>
-//   after the initial token.  These 7 tokens could be one ALPHA instead
-//   of 7 distinct tokens, with 1 MATCH instead of 7.  This is both a speed
-//   improvement for decoding as well as a space saving (fewer token-blocks
-//   and associated overhead).
-//
-// - XOR.  Like ALPHA, but used when previous symbol is ALPHA or XOR
-//   and string lengths match.  Useful when names are similar, eg:
-//   the sequence in 07.names:
-//
-//   @VP2-06:112:H7LNDMCVY:1:1105:26919:1172 1:N:0:ATTCAGAA+AGGAGAAG
-//   @VP2-06:112:H7LNDMCVY:1:1105:27100:1172 1:N:0:ATTCAGAA+AGGCGAAG
-//   @VP2-06:112:H7LNDMCVY:1:1105:27172:1172 1:N:0:ATTCAGAA+AGGCTAAG
-
-#include "config.h"
-
-#include <stdio.h>
-#include <stdlib.h>
-#include <string.h>
-#include <sys/types.h>
-#include <sys/stat.h>
-#include <unistd.h>
-#include <limits.h>
-#include <ctype.h>
-#include <assert.h>
-#include <inttypes.h>
-#include <math.h>
-#include <fcntl.h>
-#include <errno.h>
-#include <time.h>
-
-//#define NO_THREADS
-#ifndef NO_THREADS
-#include <pthread.h>
-#endif
-
-#include "pooled_alloc.h"
-#include "arith_dynamic.h"
-#include "rANS_static4x16.h"
-#include "tokenise_name3.h"
-#include "varint.h"
-
-// 128 is insufficient for SAM names (max 256 bytes) as
-// we may alternate a0a0a0a0a0 etc.  However if we fail,
-// we just give up and switch to another codec, so this
-// isn't a serious limit.  Maybe up to 256 to permit all
-// SAM names?
-#define MAX_TOKENS 128
-#define MAX_TBLOCKS (MAX_TOKENS<<4)
-
-// Number of names per block
-#define MAX_NAMES 1000000
-
-enum name_type {N_ERR = -1, N_TYPE = 0, N_ALPHA, N_CHAR, N_DIGITS0, N_DZLEN, N_DUP, N_DIFF, 
-		N_DIGITS, N_DDELTA, N_DDELTA0, N_MATCH, N_NOP, N_END, N_ALL};
-
-char *types[]={"TYPE", "ALPHA", "CHAR", "DIG0", "DZLEN", "DUP", "DIFF",
-	       "DIGITS", "DDELTA", "DDELTA0", "MATCH", "NOP", "END"};
-
-typedef struct trie {
-    char c;
-    int count;
-    struct trie *next, *sibling;
-    int n; // Nth line
-} trie_t;
-
-typedef struct {
-    char *last_name;
-    int last_ntok;
-    enum name_type last_token_type[MAX_TOKENS];
-    int last_token_int[MAX_TOKENS];
-    int last_token_str[MAX_TOKENS];
-    //int last_token_delta[MAX_TOKENS];
-} last_context;
-
-typedef struct {
-    uint8_t *buf;
-    size_t buf_a, buf_l; // alloc and used length.
-    int tnum, ttype;
-    int dup_from;
-} descriptor;
-
-typedef struct {
-    last_context *lc;
-
-    // For finding entire line dups
-    int counter;
-
-    // Trie used in encoder only
-    trie_t *t_head;
-    pool_alloc_t *pool;
-
-    // token blocks
-    descriptor desc[MAX_TBLOCKS];
-
-    // summary stats per token
-    int token_dcount[MAX_TOKENS];
-    int token_icount[MAX_TOKENS];
-    //int token_zcount[MAX_TOKENS];
-
-    int max_tok; // tracks which desc/[id]count elements have been initialised
-    int max_names;
-} name_context;
-
-#ifndef NO_THREADS
-/*
- * Thread local storage, used to avoid repeated malloc/free calls.
- */
-pthread_once_t tok_once = PTHREAD_ONCE_INIT;
-pthread_key_t tok_key;
-
-static void tok_tls_init(void) {
-    pthread_key_create(&tok_key, free);
-}
-#endif
-
-static name_context *create_context(int max_names) {
-    if (max_names <= 0)
-	return NULL;
-
-#ifdef FUZZING_BUILD_MODE_UNSAFE_FOR_PRODUCTION
-    if (max_names > 100000)
-	return NULL;
-#endif
-
-    // An arbitrary limit to prevent malformed data from consuming excessive
-    // amounts of memory.  Consider upping this if we have genuine use cases
-    // for larger blocks.
-    if (max_names > 1e7) {
-	fprintf(stderr, "Name codec currently has a max of 10 million rec.\n");
-	return NULL;
-    }
-
-#ifndef NO_THREADS
-    pthread_once(&tok_once, tok_tls_init);
-
-    name_context *ctx = pthread_getspecific(tok_key);
-    if (!ctx) {
-	ctx = malloc(sizeof(*ctx) + ++max_names*sizeof(*ctx->lc));
-	if (!ctx) return NULL;
-	ctx->max_names = max_names;
-	pthread_setspecific(tok_key, ctx);
-    } else if (ctx->max_names < max_names+1) {
-	ctx = realloc(ctx, sizeof(*ctx) + ++max_names*sizeof(*ctx->lc));
-	if (!ctx) return NULL;
-	ctx->max_names = max_names;
-	pthread_setspecific(tok_key, ctx);
-    }
-#else
-    name_context *ctx = malloc(sizeof(*ctx) + ++max_names*sizeof(*ctx->lc));
-    if (!ctx) return NULL;
-    ctx->max_names = max_names;
-#endif
-
-    ctx->counter = 0;
-    ctx->t_head = NULL;
-
-    ctx->lc = (last_context *)(((char *)ctx) + sizeof(*ctx));
-    ctx->pool = NULL;
-
-     memset(&ctx->desc[0], 0, 2*16 * sizeof(ctx->desc[0]));
-     memset(&ctx->token_dcount[0], 0, sizeof(int));
-     memset(&ctx->token_icount[0], 0, sizeof(int));
-     ctx->max_tok = 1;
-
-     ctx->lc[0].last_ntok = 0;
-
-    return ctx;
-}
-
-static void free_context(name_context *ctx) {
-    if (!ctx)
-	return;
-
-    if (ctx->t_head)
-	free(ctx->t_head);
-    if (ctx->pool)
-	pool_destroy(ctx->pool);
-
-    int i;
-    for (i = 0; i < ctx->max_tok*16; i++)
-	free(ctx->desc[i].buf);
-
-#ifdef NO_THREADS
-    free(ctx);
-#endif
-}
-
-//-----------------------------------------------------------------------------
-// Fast unsigned integer printing code.
-// Returns number of bytes written.
-static int append_uint32_fixed(char *cp, uint32_t i, uint8_t l) {
-    switch (l) {
-    case 9:*cp++ = i / 100000000 + '0', i %= 100000000;
-    case 8:*cp++ = i / 10000000  + '0', i %= 10000000;
-    case 7:*cp++ = i / 1000000   + '0', i %= 1000000;
-    case 6:*cp++ = i / 100000    + '0', i %= 100000;
-    case 5:*cp++ = i / 10000     + '0', i %= 10000;
-    case 4:*cp++ = i / 1000      + '0', i %= 1000;
-    case 3:*cp++ = i / 100       + '0', i %= 100;
-    case 2:*cp++ = i / 10        + '0', i %= 10;
-    case 1:*cp++ = i             + '0';
-    case 0:break;
-    }
-    return l;
-}
-
-static int append_uint32_var(char *cp, uint32_t i) {
-    char *op = cp;
-    uint32_t j;
-
-    //if (i < 10)         goto b0;
-    if (i < 100)        goto b1;
-    //if (i < 1000)       goto b2;
-    if (i < 10000)      goto b3;
-    //if (i < 100000)     goto b4;
-    if (i < 1000000)    goto b5;
-    //if (i < 10000000)   goto b6;
-    if (i < 100000000)  goto b7;
-
-    if ((j = i / 1000000000)) {*cp++ = j + '0'; i -= j*1000000000; goto x8;}
-    if ((j = i / 100000000))  {*cp++ = j + '0'; i -= j*100000000;  goto x7;}
- b7:if ((j = i / 10000000))   {*cp++ = j + '0'; i -= j*10000000;   goto x6;}
-    if ((j = i / 1000000))    {*cp++ = j + '0', i -= j*1000000;    goto x5;}
- b5:if ((j = i / 100000))     {*cp++ = j + '0', i -= j*100000;     goto x4;}
-    if ((j = i / 10000))      {*cp++ = j + '0', i -= j*10000;      goto x3;}
- b3:if ((j = i / 1000))       {*cp++ = j + '0', i -= j*1000;       goto x2;}
-    if ((j = i / 100))        {*cp++ = j + '0', i -= j*100;        goto x1;}
- b1:if ((j = i / 10))         {*cp++ = j + '0', i -= j*10;         goto x0;}
-    if (i)                     *cp++ = i + '0';
-    return cp-op;
-
- x8:*cp++ = i / 100000000 + '0', i %= 100000000;
- x7:*cp++ = i / 10000000  + '0', i %= 10000000;
- x6:*cp++ = i / 1000000   + '0', i %= 1000000;
- x5:*cp++ = i / 100000    + '0', i %= 100000;
- x4:*cp++ = i / 10000     + '0', i %= 10000;
- x3:*cp++ = i / 1000      + '0', i %= 1000;
- x2:*cp++ = i / 100       + '0', i %= 100;
- x1:*cp++ = i / 10        + '0', i %= 10;
- x0:*cp++ = i             + '0';
-
-    return cp-op;
-}
-
-//-----------------------------------------------------------------------------
-// Example descriptor encoding and IO.
-//
-// Here we just append to a buffer so we can dump out the results.
-// These could then be passed through a static entropy encoder that
-// encodes the entire buffer.
-//
-// Alternatively an adaptive entropy encoder could be place inline
-// here to encode as it goes using additional knowledge from the
-// supplied context.
-
-// Ensure room for sz more bytes.
-static int descriptor_grow(descriptor *fd, uint32_t sz) {
-    while (fd->buf_l + sz > fd->buf_a) {
-	size_t buf_a = fd->buf_a ? fd->buf_a*2 : 65536;
-	unsigned char *buf = realloc(fd->buf, buf_a);
-	if (!buf)
-	    return -1;
-	fd->buf = buf;
-	fd->buf_a = buf_a;
-    }
-
-    return 0;
-}
-
-static int encode_token_type(name_context *ctx, int ntok,
-			     enum name_type type) {
-    int id = ntok<<4;
-
-    if (descriptor_grow(&ctx->desc[id], 1) < 0) return -1;
-
-    ctx->desc[id].buf[ctx->desc[id].buf_l++] = type;
-
-    return 0;
-}
-
-static int encode_token_match(name_context *ctx, int ntok) {
-    return encode_token_type(ctx, ntok, N_MATCH);
-}
-
-static int encode_token_end(name_context *ctx, int ntok) {
-    return encode_token_type(ctx, ntok, N_END);
-}
-
-static enum name_type decode_token_type(name_context *ctx, int ntok) {
-    int id = ntok<<4;
-    if (ctx->desc[id].buf_l >= ctx->desc[id].buf_a) return -1;
-    return ctx->desc[id].buf[ctx->desc[id].buf_l++];
-}
-
-// int stored as 32-bit quantities
-static int encode_token_int(name_context *ctx, int ntok,
-			    enum name_type type, uint32_t val) {
-    int id = (ntok<<4) | type;
-
-    if (encode_token_type(ctx, ntok, type) < 0) return -1;
-    if (descriptor_grow(&ctx->desc[id], 4) < 0)	return -1;
-
-    uint8_t *cp = &ctx->desc[id].buf[ctx->desc[id].buf_l];
-    cp[0] = (val >>  0) & 0xff;
-    cp[1] = (val >>  8) & 0xff;
-    cp[2] = (val >> 16) & 0xff;
-    cp[3] = (val >> 24) & 0xff;
-    ctx->desc[id].buf_l += 4;
-
-    return 0;
-}
-
-// Return 0 on success, -1 on failure;
-static int decode_token_int(name_context *ctx, int ntok,
-			    enum name_type type, uint32_t *val) {
-    int id = (ntok<<4) | type;
-
-    if (ctx->desc[id].buf_l + 4 > ctx->desc[id].buf_a)
-	return -1;
-
-    uint8_t *cp = ctx->desc[id].buf + ctx->desc[id].buf_l;
-    *val = (cp[0]) + (cp[1]<<8) + (cp[2]<<16) + ((uint32_t)cp[3]<<24);
-    ctx->desc[id].buf_l += 4;
-
-    return 0;
-}
-
-// 8 bit integer quantity
-static int encode_token_int1(name_context *ctx, int ntok,
-			     enum name_type type, uint32_t val) {
-    int id = (ntok<<4) | type;
-
-    if (encode_token_type(ctx, ntok, type) < 0) return -1;
-    if (descriptor_grow(&ctx->desc[id], 1) < 0)	return -1;
-
-    ctx->desc[id].buf[ctx->desc[id].buf_l++] = val;
-
-    return 0;
-}
-
-static int encode_token_int1_(name_context *ctx, int ntok,
-			      enum name_type type, uint32_t val) {
-    int id = (ntok<<4) | type;
-
-    if (descriptor_grow(&ctx->desc[id], 1) < 0)	return -1;
-
-    ctx->desc[id].buf[ctx->desc[id].buf_l++] = val;
-
-    return 0;
-}
-
-// Return 0 on success, -1 on failure;
-static int decode_token_int1(name_context *ctx, int ntok,
-			     enum name_type type, uint32_t *val) {
-    int id = (ntok<<4) | type;
-
-    if (ctx->desc[id].buf_l  >= ctx->desc[id].buf_a)
-	return -1;
-    *val = ctx->desc[id].buf[ctx->desc[id].buf_l++];
-
-    return 0;
-}
-
-
-// Basic C-string style for now.
-//
-// Maybe XOR with previous string as context?
-// This permits partial match to be encoded efficiently.
-static int encode_token_alpha(name_context *ctx, int ntok,
-			      char *str, int len) {
-    int id = (ntok<<4) | N_ALPHA;
-
-    if (encode_token_type(ctx, ntok, N_ALPHA) < 0)  return -1;
-    if (descriptor_grow(&ctx->desc[id], len+1) < 0) return -1;
-    memcpy(&ctx->desc[id].buf[ctx->desc[id].buf_l], str, len);
-    ctx->desc[id].buf[ctx->desc[id].buf_l+len] = 0;
-    ctx->desc[id].buf_l += len+1;
-
-    return 0;
-}
-
-// FIXME: need limit on string length for security.
-// Return length on success, -1 on failure;
-static int decode_token_alpha(name_context *ctx, int ntok, char *str, int max_len) {
-    int id = (ntok<<4) | N_ALPHA;
-    char c;
-    int len = 0;
-    if (ctx->desc[id].buf_l  >= ctx->desc[id].buf_a)
-	return -1;
-    do {
-	c = ctx->desc[id].buf[ctx->desc[id].buf_l++];
-	str[len++] = c;
-    } while(c && len < max_len && ctx->desc[id].buf_l < ctx->desc[id].buf_a);
-
-    return len-1;
-}
-
-static int encode_token_char(name_context *ctx, int ntok, char c) {
-    int id = (ntok<<4) | N_CHAR;
-
-    if (encode_token_type(ctx, ntok, N_CHAR) < 0) return -1;
-    if (descriptor_grow(&ctx->desc[id], 1) < 0)    return -1;
-    ctx->desc[id].buf[ctx->desc[id].buf_l++] = c;
-
-    return 0;
-}
-
-// FIXME: need limit on string length for security
-// Return length on success, -1 on failure;
-static int decode_token_char(name_context *ctx, int ntok, char *str) {
-    int id = (ntok<<4) | N_CHAR;
-
-    if (ctx->desc[id].buf_l  >= ctx->desc[id].buf_a)
-	return -1;
-    *str = ctx->desc[id].buf[ctx->desc[id].buf_l++];
-
-    return 1;
-}
-
-
-// A duplicated name
-static int encode_token_dup(name_context *ctx, uint32_t val) {
-    return encode_token_int(ctx, 0, N_DUP, val);
-}
-
-// Which read to delta against
-static int encode_token_diff(name_context *ctx, uint32_t val) {
-    return encode_token_int(ctx, 0, N_DIFF, val);
-}
-
-
-//-----------------------------------------------------------------------------
-// Trie implementation for tracking common name prefixes.
-static
-int build_trie(name_context *ctx, char *data, size_t len, int n) {
-    int nlines = 0;
-    size_t i;
-    trie_t *t;
-
-    if (!ctx->t_head) {
-	ctx->t_head = calloc(1, sizeof(*ctx->t_head));
-	if (!ctx->t_head)
-	    return -1;
-    }
-
-    // Build our trie, also counting input lines
-    for (nlines = i = 0; i < len; i++, nlines++) {
-	t = ctx->t_head;
-	t->count++;
-	while (i < len && data[i] > '\n') {
-	    unsigned char c = data[i++];
-	    if (c & 0x80)
-		//fprintf(stderr, "8-bit ASCII is unsupported\n");
-		abort();
-	    c &= 127;
-
-
-	    trie_t *x = t->next, *l = NULL;
-	    while (x && x->c != c) {
-		l = x; x = x->sibling;
-	    }
-	    if (!x) {
-		if (!ctx->pool)
-		    ctx->pool = pool_create(sizeof(trie_t));
-		if (!(x = (trie_t *)pool_alloc(ctx->pool)))
-		    return -1;
-		memset(x, 0, sizeof(*x));
-		if (!l)
-		    x = t->next    = x;
-		else
-		    x = l->sibling = x;
-		x->n = n;
-		x->c = c;
-	    }
-	    t = x;
-	    t->c = c;
-	    t->count++;
-	}
-    }
-
-    return 0;
-}
-
-#if 0
-void dump_trie(trie_t *t, int depth) {
-    if (depth == 0) {
-	printf("graph x_%p {\n    splines = ortho\n    ranksep=2\n", t);
-	printf("    p_%p [label=\"\"];\n", t);
-	dump_trie(t, 1);
-	printf("}\n");
-    } else {
-	int j, k, count;//, cj;
-	char label[100], *cp;
-	trie_t *tp = t;
-
-//    patricia:
-//	for (count = j = 0; j < 128; j++)
-//	    if (t->next[j])
-//		count++, cj=j;
-//
-//	if (count == 1) {
-//	    t = t->next[cj];
-//	    *cp++ = cj;
-//	    goto patricia;
-//	}
-
-	trie_t *x;
-	for (x = t->next; x; x = x->sibling) {
-	    printf("    p_%p [label=\"%c\"];\n", x, x->c);
-	    printf("    p_%p -- p_%p [label=\"%d\", penwidth=\"%f\"];\n", tp, x, x->count, MAX((log(x->count)-3)*2,1));
-	    //if (depth <= 11)
-		dump_trie(x, depth+1);
-	}
-
-#if 0	    
-	for (j = 0; j < 128; j++) {
-	    trie_t *tn;
-
-	    if (!t->next[j])
-		continue;
-
-	    cp = label;
-	    tn = t->next[j];
-	    *cp++ = j;
-//	patricia:
-
-	    for (count = k = 0; k < 128; k++)
-		if (tn->next[k])
-		    count++;//, cj=k;
-
-//	    if (count == 1) {
-//		tn = tn->next[cj];
-//		*cp++ = cj;
-//		goto patricia;
-//	    }
-	    *cp++ = 0;
-
-	    printf("    p_%p [label=\"%s\"];\n", tn, label);
-	    printf("    p_%p -- p_%p [label=\"%d\", penwidth=\"%f\"];\n", tp, tn, tn->count, MAX((log(tn->count)-3)*2,1));
-	    if (depth <= 11)
-		dump_trie(tn, depth+1);
-	}
-#endif
-    }
-}
-#endif
-
-static
-int search_trie(name_context *ctx, char *data, size_t len, int n, int *exact, int *is_fixed, int *fixed_len) {
-    int nlines = 0;
-    size_t i;
-    trie_t *t;
-    int from = -1, p3 = -1;
-    *exact = 0;
-    *fixed_len = 0;
-    *is_fixed = 0;
-
-    // Horrid hack for the encoder only.
-    // We optimise per known name format here.
-    int prefix_len;
-    char *d = *data == '@' ? data+1 : data;
-    int l   = *data == '@' ? len-1  : len;
-    int f = (*data == '>') ? 1 : 0;
-    if (l > 70 && d[f+0] == 'm' && d[7] == '_' && d[f+14] == '_' && d[f+61] == '/') {
-	prefix_len = 60; // PacBio
-	*is_fixed = 0;
-    } else if (l == 17 && d[f+5] == ':' && d[f+11] == ':') {
-	prefix_len = 6;  // IonTorrent
-	*fixed_len = 6;
-	*is_fixed = 1;
-    } else if (l > 37 && d[f+8] == '-' && d[f+13] == '-' && d[f+18] == '-' && d[f+23] == '-' &&
-	       ((d[f+0] >= '0' && d[f+0] <='9') || (d[f+0] >= 'a' && d[f+0] <= 'f')) &&
-	       ((d[f+35] >= '0' && d[f+35] <='9') || (d[f+35] >= 'a' && d[f+35] <= 'f'))) {
-	// ONT: f33d30d5-6eb8-4115-8f46-154c2620a5da_Basecall_1D_template...
-	prefix_len = 37;
-	*fixed_len = 37;
-	*is_fixed = 1;
-    } else {
-	// Check Illumina and trim back to lane:tile:x:y.
-	int colons = 0;
-	for (i = 0; i < len && data[i] > ' '; i++)
-	    ;
-	while (i > 0 && colons < 4)
-	    if (data[--i] == ':')
-		colons++;
-
-	if (colons == 4) {
-	    // Constant illumina prefix
-	    *fixed_len = i+1;
-	    prefix_len = i+1;
-	    *is_fixed = 1;
-	} else {
-	    // Unknown, don't use a fixed len, but still search
-	    // for any exact matches.
-	    prefix_len = INT_MAX;
-	    *is_fixed = 0;
-	}
-    }
-    //prefix_len = INT_MAX;
-
-    if (!ctx->t_head) {
-	ctx->t_head = calloc(1, sizeof(*ctx->t_head));
-	if (!ctx->t_head)
-	    return -1;
-    }
-
-    // Find an item in the trie
-    for (nlines = i = 0; i < len; i++, nlines++) {
-	t = ctx->t_head;
-	while (i < len && data[i] > '\n') {
-	    unsigned char c = data[i++];
-	    if (c & 0x80)
-		//fprintf(stderr, "8-bit ASCII is unsupported\n");
-		abort();
-	    c &= 127;
-
-	    trie_t *x = t->next;
-	    while (x && x->c != c)
-		x = x->sibling;
-	    t = x;
-
-//	    t = t->next[c];
-
-//	    if (!t)
-//		return -1;
-
-	    from = t->n;
-	    if (i == prefix_len) p3 = t->n;
-	    //if (t->count >= .0035*ctx->t_head->count && t->n != n) p3 = t->n; // pacbio
-	    //if (i == 60) p3 = t->n; // pacbio
-	    //if (i == 7) p3 = t->n; // iontorrent
-	    t->n = n;
-	}
-    }
-
-    //printf("Looked for %d, found %d, prefix %d\n", n, from, p3);
-
-    *exact = (n != from) && len;
-    return *exact ? from : p3;
-}
-
-
-//-----------------------------------------------------------------------------
-// Name encoder
-
-/*
- * Tokenises a read name using ctx as context as the previous
- * tokenisation.
- *
- * Parsed elements are then emitted for encoding by calling the
- * encode_token() function with the context, token number (Nth token
- * in line), token type and token value.
- *
- * Returns 0 on success;
- *        -1 on failure.
- */
-static int encode_name(name_context *ctx, char *name, int len, int mode) {
-    int i, is_fixed, fixed_len;
-
-    int exact;
-    int cnum = ctx->counter++;
-    int pnum = search_trie(ctx, name, len, cnum, &exact, &is_fixed, &fixed_len);
-    if (pnum < 0) pnum = cnum ? cnum-1 : 0;
-    //pnum = pnum & (MAX_NAMES-1);
-    //cnum = cnum & (MAX_NAMES-1);
-    //if (pnum == cnum) {pnum = cnum ? cnum-1 : 0;}
-#ifdef ENC_DEBUG
-    fprintf(stderr, "%d: pnum=%d (%d), exact=%d\n%s\n%s\n",
-	    ctx->counter, pnum, cnum-pnum, exact, ctx->lc[pnum].last_name, name);
-#endif
-
-    // Return DUP or DIFF switch, plus the distance.
-    if (exact && len == strlen(ctx->lc[pnum].last_name)) {
-	encode_token_dup(ctx, cnum-pnum);
-	ctx->lc[cnum].last_name = name;
-	ctx->lc[cnum].last_ntok = ctx->lc[pnum].last_ntok;
-	// FIXME: optimise this
-	int nc = ctx->lc[cnum].last_ntok ? ctx->lc[cnum].last_ntok : MAX_TOKENS;
-	memcpy(ctx->lc[cnum].last_token_type, ctx->lc[pnum].last_token_type, nc * sizeof(int));
-	memcpy(ctx->lc[cnum].last_token_int , ctx->lc[pnum].last_token_int , nc * sizeof(int));
-	memcpy(ctx->lc[cnum].last_token_str , ctx->lc[pnum].last_token_str , nc * sizeof(int));
-	return 0;
-    }
-
-    encode_token_diff(ctx, cnum-pnum);
-
-    int ntok = 1;
-    i = 0;
-    if (is_fixed) {
-	if (ntok >= ctx->max_tok) {
-	    memset(&ctx->desc[ctx->max_tok << 4], 0, 16*sizeof(ctx->desc[0]));
-	    memset(&ctx->token_dcount[ctx->max_tok], 0, sizeof(int));
-	    memset(&ctx->token_icount[ctx->max_tok], 0, sizeof(int));
-	    ctx->max_tok = ntok+1;
-	}
-	if (pnum < cnum && ntok < ctx->lc[pnum].last_ntok && ctx->lc[pnum].last_token_type[ntok] == N_ALPHA) {
-	    if (ctx->lc[pnum].last_token_int[ntok] == fixed_len && memcmp(name, ctx->lc[pnum].last_name, fixed_len) == 0) {
-		encode_token_match(ctx, ntok);
-	    } else {
-		encode_token_alpha(ctx, ntok, name, fixed_len);
-	    }
-	} else {
-	    encode_token_alpha(ctx, ntok, name, fixed_len);
-	}
-	ctx->lc[cnum].last_token_int[ntok] = fixed_len;
-	ctx->lc[cnum].last_token_str[ntok] = 0;
-	ctx->lc[cnum].last_token_type[ntok++] = N_ALPHA;
-	i = fixed_len;
-    }
-
-    for (; i < len; i++) {
-	if (ntok >= ctx->max_tok) {
-	    memset(&ctx->desc[ctx->max_tok << 4], 0, 16*sizeof(ctx->desc[0]));
-	    memset(&ctx->token_dcount[ctx->max_tok], 0, sizeof(int));
-	    memset(&ctx->token_icount[ctx->max_tok], 0, sizeof(int));
-	    ctx->max_tok = ntok+1;
-	}
-
-	/* Determine data type of this segment */
-	if (isalpha(name[i])) {
-	    int s = i+1;
-//	    int S = i+1;
-
-//	    // FIXME: try which of these is best.  alnum is good sometimes.
-//	    while (s < len && isalpha(name[s]))
-	    while (s < len && (isalpha(name[s]) || ispunct(name[s])))
-//	    while (s < len && name[s] != ':')
-//	    while (s < len && !isdigit(name[s]) && name[s] != ':')
-		s++;
-
-//	    if (!is_fixed) {
-//		while (S < len && isalnum(name[S]))
-//		    S++;
-//		if (s < S)
-//		    s = S;
-//	    }
-
-	    // Single byte strings are better encoded as chars.
-	    if (s-i == 1) goto n_char;
-
-	    if (pnum < cnum && ntok < ctx->lc[pnum].last_ntok && ctx->lc[pnum].last_token_type[ntok] == N_ALPHA) {
-		if (s-i == ctx->lc[pnum].last_token_int[ntok] &&
-		    memcmp(&name[i], 
-			   &ctx->lc[pnum].last_name[ctx->lc[pnum].last_token_str[ntok]],
-			   s-i) == 0) {
-#ifdef ENC_DEBUG
-		    fprintf(stderr, "Tok %d (alpha-mat, %.*s)\n", N_MATCH, s-i, &name[i]);
-#endif
-		    if (encode_token_match(ctx, ntok) < 0) return -1;
-		} else {
-#ifdef ENC_DEBUG
-		    fprintf(stderr, "Tok %d (alpha, %.*s / %.*s)\n", N_ALPHA,
-		    	    s-i, &ctx->lc[pnum].last_name[ctx->lc[pnum].last_token_str[ntok]], s-i, &name[i]);
-#endif
-		    // same token/length, but mismatches
-		    if (encode_token_alpha(ctx, ntok, &name[i], s-i) < 0) return -1;
-		}
-	    } else {
-#ifdef ENC_DEBUG
-		fprintf(stderr, "Tok %d (new alpha, %.*s)\n", N_ALPHA, s-i, &name[i]);
-#endif
-		if (encode_token_alpha(ctx, ntok, &name[i], s-i) < 0) return -1;
-	    }
-
-	    ctx->lc[cnum].last_token_int[ntok] = s-i;
-	    ctx->lc[cnum].last_token_str[ntok] = i;
-	    ctx->lc[cnum].last_token_type[ntok] = N_ALPHA;
-
-	    i = s-1;
-	} else if (name[i] == '0') digits0: {
-	    // Digits starting with zero; encode length + value
-	    uint32_t s = i;
-	    uint32_t v = 0;
-	    int d = 0;
-
-	    while (s < len && isdigit(name[s]) && s-i < 9) {
-		v = v*10 + name[s] - '0';
-		//putchar(name[s]);
-		s++;
-	    }
-
-	    // TODO: optimise choice over whether to switch from DIGITS to DELTA
-	    // regularly vs all DIGITS, also MATCH vs DELTA 0.
-	    if (pnum < cnum && ntok < ctx->lc[pnum].last_ntok && ctx->lc[pnum].last_token_type[ntok] == N_DIGITS0) {
-		d = v - ctx->lc[pnum].last_token_int[ntok];
-		if (d == 0 && ctx->lc[pnum].last_token_str[ntok] == s-i) {
-#ifdef ENC_DEBUG
-		    fprintf(stderr, "Tok %d (dig-mat, %d)\n", N_MATCH, v);
-#endif
-		    if (encode_token_match(ctx, ntok) < 0) return -1;
-		    //ctx->lc[pnum].last_token_delta[ntok]=0;
-		} else if (mode == 1 && d < 256 && d >= 0 && ctx->lc[pnum].last_token_str[ntok] == s-i) {
-#ifdef ENC_DEBUG
-		    fprintf(stderr, "Tok %d (dig-delta, %d / %d)\n", N_DDELTA, ctx->lc[pnum].last_token_int[ntok], v);
-#endif
-		    //if (encode_token_int1_(ctx, ntok, N_DZLEN, s-i) < 0) return -1;
-		    if (encode_token_int1(ctx, ntok, N_DDELTA0, d) < 0) return -1;
-		    //ctx->lc[pnum].last_token_delta[ntok]=1;
-		} else {
-#ifdef ENC_DEBUG
-		    fprintf(stderr, "Tok %d (dig, %d / %d)\n", N_DIGITS, ctx->lc[pnum].last_token_int[ntok], v);
-#endif
-		    if (encode_token_int1_(ctx, ntok, N_DZLEN, s-i) < 0) return -1;
-		    if (encode_token_int(ctx, ntok, N_DIGITS0, v) < 0) return -1;
-		    //ctx->lc[pnum].last_token_delta[ntok]=0;
-		}
-	    } else {
-#ifdef ENC_DEBUG
-		fprintf(stderr, "Tok %d (new dig, %d)\n", N_DIGITS, v);
-#endif
-		if (encode_token_int1_(ctx, ntok, N_DZLEN, s-i) < 0) return -1;
-		if (encode_token_int(ctx, ntok, N_DIGITS0, v) < 0) return -1;
-		//ctx->lc[pnum].last_token_delta[ntok]=0;
-	    }
-
-	    ctx->lc[cnum].last_token_str[ntok] = s-i; // length
-	    ctx->lc[cnum].last_token_int[ntok] = v;
-	    ctx->lc[cnum].last_token_type[ntok] = N_DIGITS0;
-
-	    i = s-1;
-	} else if (isdigit(name[i])) {
-	    // digits starting 1-9; encode value
-	    uint32_t s = i;
-	    uint32_t v = 0;
-	    int d = 0;
-
-	    while (s < len && isdigit(name[s]) && s-i < 9) {
-		v = v*10 + name[s] - '0';
-		//putchar(name[s]);
-		s++;
-	    }
-
-	    // dataset/10/K562_cytosol_LID8465_TopHat_v2.names
-	    // col 4 is Illumina lane - we don't want match & delta in there
-	    // as it has multiple lanes (so not ALL match) and delta is just
-	    // random chance, increasing entropy instead.
-//	    if (ntok == 4  || ntok == 8 || ntok == 10) {
-//		encode_token_int(ctx, ntok, N_DIGITS, v);
-//	    } else {
-
-	    // If the last token was DIGITS0 and we are the same length, then encode
-	    // using that method instead as it seems likely the entire column is fixed
-	    // width, sometimes with leading zeros.
-	    if (pnum < cnum && ntok < ctx->lc[pnum].last_ntok &&
-		ctx->lc[pnum].last_token_type[ntok] == N_DIGITS0 &&
-		ctx->lc[pnum].last_token_str[ntok] == s-i)
-		goto digits0;
-	    
-	    // TODO: optimise choice over whether to switch from DIGITS to DELTA
-	    // regularly vs all DIGITS, also MATCH vs DELTA 0.
-	    if (pnum < cnum && ntok < ctx->lc[pnum].last_ntok && ctx->lc[pnum].last_token_type[ntok] == N_DIGITS) {
-		d = v - ctx->lc[pnum].last_token_int[ntok];
-		if (d == 0) {
-#ifdef ENC_DEBUG
-		    fprintf(stderr, "Tok %d (dig-mat, %d)\n", N_MATCH, v);
-#endif
-		    if (encode_token_match(ctx, ntok) < 0) return -1;
-		    //ctx->lc[pnum].last_token_delta[ntok]=0;
-		    //ctx->token_zcount[ntok]++;
-		} else if (mode == 1 && d < 256 && d >= 0
-			   //&& (10+ctx->token_dcount[ntok]) > (ctx->token_icount[ntok]+ctx->token_zcount[ntok])
-			   && (5+ctx->token_dcount[ntok]) > ctx->token_icount[ntok]
-			   ) {
-#ifdef ENC_DEBUG
-		    fprintf(stderr, "Tok %d (dig-delta, %d / %d)\n", N_DDELTA, ctx->lc[pnum].last_token_int[ntok], v);
-#endif
-		    if (encode_token_int1(ctx, ntok, N_DDELTA, d) < 0) return -1;
-		    //ctx->lc[pnum].last_token_delta[ntok]=1;
-		    ctx->token_dcount[ntok]++;
-		} else {
-#ifdef ENC_DEBUG
-		    fprintf(stderr, "Tok %d (dig, %d / %d)\n", N_DIGITS, ctx->lc[pnum].last_token_int[ntok], v);
-#endif
-		    if (encode_token_int(ctx, ntok, N_DIGITS, v) < 0) return -1;
-		    //ctx->lc[pnum].last_token_delta[ntok]=0;
-		    ctx->token_icount[ntok]++;
-		}
-	    } else {
-#ifdef ENC_DEBUG
-		fprintf(stderr, "Tok %d (new dig, %d)\n", N_DIGITS, v);
-#endif
-		if (encode_token_int(ctx, ntok, N_DIGITS, v) < 0) return -1;
-		//ctx->lc[pnum].last_token_delta[ntok]=0;
-	    }
-//	    }
-
-	    ctx->lc[cnum].last_token_int[ntok] = v;
-	    ctx->lc[cnum].last_token_type[ntok] = N_DIGITS;
-
-	    i = s-1;
-	} else {
-	n_char:
-	    //if (!isalpha(name[i])) putchar(name[i]);
-	    if (pnum < cnum && ntok < ctx->lc[pnum].last_ntok && ctx->lc[pnum].last_token_type[ntok] == N_CHAR) {
-		if (name[i] == ctx->lc[pnum].last_token_int[ntok]) {
-#ifdef ENC_DEBUG
-		    fprintf(stderr, "Tok %d (chr-mat, %c)\n", N_MATCH, name[i]);
-#endif
-		    if (encode_token_match(ctx, ntok) < 0) return -1;
-		} else {
-#ifdef ENC_DEBUG
-		    fprintf(stderr, "Tok %d (chr, %c / %c)\n", N_CHAR, ctx->lc[pnum].last_token_int[ntok], name[i]);
-#endif
-		    if (encode_token_char(ctx, ntok, name[i]) < 0) return -1;
-		}
-	    } else {
-#ifdef ENC_DEBUG
-		fprintf(stderr, "Tok %d (new chr, %c)\n", N_CHAR, name[i]);
-#endif
-		if (encode_token_char(ctx, ntok, name[i]) < 0) return -1;
-	    }
-
-	    ctx->lc[cnum].last_token_int[ntok] = name[i];
-	    ctx->lc[cnum].last_token_type[ntok] = N_CHAR;
-	}
-
-	ntok++;
-	//putchar(' ');
-    }
-
-#ifdef ENC_DEBUG
-    fprintf(stderr, "Tok %d (end)\n", N_END);
-#endif
-    if (ntok >= ctx->max_tok) {
-	memset(&ctx->desc[ctx->max_tok << 4], 0, 16*sizeof(ctx->desc[0]));
-	memset(&ctx->token_dcount[ctx->max_tok], 0, sizeof(int));
-	memset(&ctx->token_icount[ctx->max_tok], 0, sizeof(int));
-	ctx->max_tok = ntok+1;
-    }
-    if (encode_token_end(ctx, ntok) < 0) return -1;
-#ifdef ENC_DEBUG
-    fprintf(stderr, "ntok=%d max_tok=%d\n", ntok, ctx->max_tok);
-#endif
-
-    //printf("Encoded %.*s with %d tokens\n", len, name, ntok);
-    
-    ctx->lc[cnum].last_name = name;
-    ctx->lc[cnum].last_ntok = ntok;
-
-    return 0;
-}
-
-//-----------------------------------------------------------------------------
-// Name decoder
-
-static int decode_name(name_context *ctx, char *name, int name_len) {
-    int t0 = decode_token_type(ctx, 0);
-    uint32_t dist;
-    int pnum, cnum = ctx->counter++;
-
-    if (cnum >= ctx->max_names)
-	return -1;
-
-    if (t0 < 0 || t0 >= ctx->max_tok*16)
-	return 0;
-
-    if (decode_token_int(ctx, 0, t0, &dist) < 0 || dist > cnum)
-	return -1;
-    if ((pnum = cnum - dist) < 0) pnum = 0;
-
-    //fprintf(stderr, "t0=%d, dist=%d, pnum=%d, cnum=%d\n", t0, dist, pnum, cnum);
-
-    if (t0 == N_DUP) {
-	if (pnum == cnum)
-	    return -1;
-
-	if (strlen(ctx->lc[pnum].last_name) +1 >= name_len) return -1;
-	strcpy(name, ctx->lc[pnum].last_name);
-	// FIXME: optimise this
-	ctx->lc[cnum].last_name = name;
-	ctx->lc[cnum].last_ntok = ctx->lc[pnum].last_ntok;
-	int nc = ctx->lc[cnum].last_ntok ? ctx->lc[cnum].last_ntok : MAX_TOKENS;
-	memcpy(ctx->lc[cnum].last_token_type, ctx->lc[pnum].last_token_type, nc * sizeof(int));
-	memcpy(ctx->lc[cnum].last_token_int , ctx->lc[pnum].last_token_int , nc * sizeof(int));
-	memcpy(ctx->lc[cnum].last_token_str , ctx->lc[pnum].last_token_str , nc * sizeof(int));
-
-	return strlen(name)+1;
-    }
-
-    *name = 0;
-    int ntok, len = 0, len2;
-
-    for (ntok = 1; ntok < MAX_TOKENS && ntok < ctx->max_tok; ntok++) {
-	uint32_t v, vl;
-	enum name_type tok;
-	tok = decode_token_type(ctx, ntok);
-	//fprintf(stderr, "Tok %d = %d\n", ntok, tok);
-
-	ctx->lc[cnum].last_ntok = 0;
-
-	switch (tok) {
-	case N_CHAR:
-	    if (len+1 >= name_len) return -1;
-	    if (decode_token_char(ctx, ntok, &name[len]) < 0) return -1;
-	    //fprintf(stderr, "Tok %d CHAR %c\n", ntok, name[len]);
-	    ctx->lc[cnum].last_token_type[ntok] = N_CHAR;
-	    ctx->lc[cnum].last_token_int [ntok] = name[len++];
-	    break;
-
-	case N_ALPHA:
-	    if ((len2 = decode_token_alpha(ctx, ntok, &name[len], name_len - len)) < 0)
-		return -1;
-	    //fprintf(stderr, "Tok %d ALPHA %.*s\n", ntok, len2, &name[len]);
-	    ctx->lc[cnum].last_token_type[ntok] = N_ALPHA;
-	    ctx->lc[cnum].last_token_str [ntok] = len;
-	    ctx->lc[cnum].last_token_int [ntok] = len2;
-	    len += len2;
-	    break;
-
-	case N_DIGITS0: // [0-9]*
-	    if (decode_token_int1(ctx, ntok, N_DZLEN, &vl) < 0) return -1;
-	    if (decode_token_int(ctx, ntok, N_DIGITS0, &v) < 0) return -1;
-	    if (len+20+vl >= name_len) return -1;
-	    len += append_uint32_fixed(&name[len], v, vl);
-	    //fprintf(stderr, "Tok %d DIGITS0 %0*d\n", ntok, vl, v);
-	    ctx->lc[cnum].last_token_type[ntok] = N_DIGITS0;
-	    ctx->lc[cnum].last_token_int [ntok] = v;
-	    ctx->lc[cnum].last_token_str [ntok] = vl;
-	    break;
-
-	case N_DDELTA0:
-	    if (ntok >= ctx->lc[pnum].last_ntok) return -1;
-	    if (decode_token_int1(ctx, ntok, N_DDELTA0, &v) < 0) return -1;
-	    v += ctx->lc[pnum].last_token_int[ntok];
-	    if (len+ctx->lc[pnum].last_token_str[ntok]+1 >= name_len) return -1;
-	    len += append_uint32_fixed(&name[len], v, ctx->lc[pnum].last_token_str[ntok]);
-	    //fprintf(stderr, "Tok %d DELTA0 %0*d\n", ntok, ctx->lc[pnum].last_token_str[ntok], v);
-	    ctx->lc[cnum].last_token_type[ntok] = N_DIGITS0;
-	    ctx->lc[cnum].last_token_int [ntok] = v;
-	    ctx->lc[cnum].last_token_str [ntok] = ctx->lc[pnum].last_token_str[ntok];
-	    break;
-
-	case N_DIGITS: // [1-9][0-9]*
-	    if (decode_token_int(ctx, ntok, N_DIGITS, &v) < 0) return -1;
-	    if (len+20 >= name_len) return -1;
-	    len += append_uint32_var(&name[len], v);
-	    //fprintf(stderr, "Tok %d DIGITS %d\n", ntok, v);
-	    ctx->lc[cnum].last_token_type[ntok] = N_DIGITS;
-	    ctx->lc[cnum].last_token_int [ntok] = v;
-	    break;
-
-	case N_DDELTA:
-	    if (ntok >= ctx->lc[pnum].last_ntok) return -1;
-	    if (decode_token_int1(ctx, ntok, N_DDELTA, &v) < 0) return -1;
-	    v += ctx->lc[pnum].last_token_int[ntok];
-	    if (len+20 >= name_len) return -1;
-	    len += append_uint32_var(&name[len], v);
-	    //fprintf(stderr, "Tok %d DELTA %d\n", ntok, v);
-	    ctx->lc[cnum].last_token_type[ntok] = N_DIGITS;
-	    ctx->lc[cnum].last_token_int [ntok] = v;
-	    break;
-
-	case N_NOP:
-	    ctx->lc[cnum].last_token_type[ntok] = N_NOP;
-	    break;
-
-	case N_MATCH:
-	    if (ntok >= ctx->lc[pnum].last_ntok) return -1;
-	    switch (ctx->lc[pnum].last_token_type[ntok]) {
-	    case N_CHAR:
-		if (len+1 >= name_len) return -1;
-		name[len++] = ctx->lc[pnum].last_token_int[ntok];
-		//fprintf(stderr, "Tok %d MATCH CHAR %c\n", ntok, ctx->lc[pnum].last_token_int[ntok]);
-		ctx->lc[cnum].last_token_type[ntok] = N_CHAR;
-		ctx->lc[cnum].last_token_int [ntok] = ctx->lc[pnum].last_token_int[ntok];
-		break;
-
-	    case N_ALPHA:
-		if (ctx->lc[pnum].last_token_int[ntok] < 0 ||
-		    len+ctx->lc[pnum].last_token_int[ntok] >= name_len) return -1;
-		memcpy(&name[len],
-		       &ctx->lc[pnum].last_name[ctx->lc[pnum].last_token_str[ntok]],
-		       ctx->lc[pnum].last_token_int[ntok]);
-		//fprintf(stderr, "Tok %d MATCH ALPHA %.*s\n", ntok, ctx->lc[pnum].last_token_int[ntok], &name[len]);
-		ctx->lc[cnum].last_token_type[ntok] = N_ALPHA;
-		ctx->lc[cnum].last_token_str [ntok] = len;
-		ctx->lc[cnum].last_token_int [ntok] = ctx->lc[pnum].last_token_int[ntok];
-		len += ctx->lc[pnum].last_token_int[ntok];
-		break;
-
-	    case N_DIGITS:
-		if (len+20 >= name_len) return -1;
-		len += append_uint32_var(&name[len], ctx->lc[pnum].last_token_int[ntok]);
-		//fprintf(stderr, "Tok %d MATCH DIGITS %d\n", ntok, ctx->lc[pnum].last_token_int[ntok]);
-		ctx->lc[cnum].last_token_type[ntok] = N_DIGITS;
-		ctx->lc[cnum].last_token_int [ntok] = ctx->lc[pnum].last_token_int[ntok];
-		break;
-
-	    case N_DIGITS0:
-		if (len+ctx->lc[pnum].last_token_str[ntok] >= name_len) return -1;
-		len += append_uint32_fixed(&name[len], ctx->lc[pnum].last_token_int[ntok], ctx->lc[pnum].last_token_str[ntok]);
-		//fprintf(stderr, "Tok %d MATCH DIGITS %0*d\n", ntok, ctx->lc[pnum].last_token_str[ntok], ctx->lc[pnum].last_token_int[ntok]);
-		ctx->lc[cnum].last_token_type[ntok] = N_DIGITS0;
-		ctx->lc[cnum].last_token_int [ntok] = ctx->lc[pnum].last_token_int[ntok];
-		ctx->lc[cnum].last_token_str [ntok] = ctx->lc[pnum].last_token_str[ntok];
-		break;
-
-	    default:
-		return -1;
-	    }
-	    break;
-
-	default: // an elided N_END
-	case N_END:
-	    if (len+1 >= name_len) return -1;
-	    name[len++] = 0;
-	    ctx->lc[cnum].last_token_type[ntok] = N_END;
-
-	    ctx->lc[cnum].last_name = name;
-	    ctx->lc[cnum].last_ntok = ntok;
-
-	    return len;
-	}
-    }
-
-
-    return -1;
-}
-
-//-----------------------------------------------------------------------------
-// arith adaptive codec or static rANS 4x16pr codec
-static int arith_encode(uint8_t *in, uint64_t in_len, uint8_t *out, uint64_t *out_len, int method) {
-    unsigned int olen = *out_len-6, nb;
-    if (arith_compress_to(in, in_len, out+6, &olen, method) == NULL)
-	return -1;
-
-    nb = var_put_u32(out, out + *out_len, olen);
-    memmove(out+nb, out+6, olen);
-    *out_len = olen+nb;
-
-    return 0;
-}
-
-// Returns number of bytes read from 'in' on success,
-//        -1 on failure.
-static int64_t arith_decode(uint8_t *in, uint64_t in_len, uint8_t *out, uint64_t *out_len) {
-    unsigned int olen = *out_len;
-
-    uint32_t clen;
-    int nb = var_get_u32(in, in+in_len, &clen);
-    //fprintf(stderr, "Arith decode %x\n", in[nb]);
-    if (arith_uncompress_to(in+nb, in_len-nb, out, &olen) == NULL)
-	return -1;
-    //fprintf(stderr, "    Stored clen=%d\n", (int)clen);
-    return clen+nb;
-}
-
-static int rans_encode(uint8_t *in, uint64_t in_len, uint8_t *out, uint64_t *out_len, int method) {
-    unsigned int olen = *out_len-6, nb;
-    if (rans_compress_to_4x16(in, in_len, out+6, &olen, method) == NULL)
-	return -1;
-
-    nb = var_put_u32(out, out + *out_len, olen);
-    memmove(out+nb, out+6, olen);
-    *out_len = olen+nb;
-
-    return 0;
-}
-
-// Returns number of bytes read from 'in' on success,
-//        -1 on failure.
-static int64_t rans_decode(uint8_t *in, uint64_t in_len, uint8_t *out, uint64_t *out_len) {
-    unsigned int olen = *out_len;
-
-    uint32_t clen;
-    int nb = var_get_u32(in, in+in_len, &clen);
-    //fprintf(stderr, "Arith decode %x\n", in[nb]);
-    if (rans_uncompress_to_4x16(in+nb, in_len-nb, out, &olen) == NULL)
-	return -1;
-    //fprintf(stderr, "    Stored clen=%d\n", (int)clen);
-    return clen+nb;
-}
-
-static int compress(uint8_t *in, uint64_t in_len, int level, int use_arith,
-		    uint8_t *out, uint64_t *out_len) {
-    uint64_t best_sz = UINT64_MAX;
-    int best = 0;
-    uint64_t olen = *out_len;
-
-    //fprintf(stderr, "=== try %d ===\n", (int)in_len);
-
-    int m, rmethods[5][12] = {
-	{2,   0,      128},				      // 1
-	{2,   0,                         192+8},              // 3
-	{3,   0,  128,                   193+8},              // 5
-	{6,   0,1,    129,   65,    193, 193+8},              // 7
-	{9,   0,1,128,129,64,65,192,193, 193+8},              // 9
-    };
-
-    // 1-9 to 0-4
-    level = (level-1)/2;
-    if (level<0) level=0;
-    if (level>4) level=4;
-
-    for (m = 1; m <= rmethods[level][0]; m++) {
-	*out_len = olen;
-
-	if (in_len % 4 != 0 && (rmethods[level][m] & 8))
-	    continue;
-
-	if (use_arith) {
-	    if (arith_encode(in, in_len, out, out_len, rmethods[level][m]) < 0)
-		return -1;
-	} else {
-	    if (rans_encode(in, in_len, out, out_len, rmethods[level][m]) < 0)
-		return -1;
-	}
-
-	if (best_sz > *out_len) {
-	    best_sz = *out_len;
-	    best = rmethods[level][m];
-	}
-    }
-
-    *out_len = olen;
-    if (use_arith) {
-	if (arith_encode(in, in_len, out, out_len, best) < 0)
-	    return -1;
-    } else {
-	if (rans_encode(in, in_len, out, out_len, best) < 0)
-	    return -1;
-    }
-
-//    uint64_t tmp;
-//    fprintf(stderr, "%d -> %d via method %x, %x\n", (int)in_len, (int)best_sz, best, out[i7get(out,&tmp)]);
-
-    return 0;
-}
-
-static uint64_t uncompressed_size(uint8_t *in, uint64_t in_len) {
-    uint32_t clen, ulen;
-
-    // in[0] in part of buffer written by us
-    int nb = var_get_u32(in, in+in_len, &clen);
-
-    // in[nb] is part of buffer written to by arith_dynamic.
-    var_get_u32(in+nb+1, in+in_len, &ulen);
-
-    return ulen;
-}
-
-static int uncompress(int use_arith, uint8_t *in, uint64_t in_len,
-		      uint8_t *out, uint64_t *out_len) {
-    uint32_t clen;
-    var_get_u32(in, in+in_len, &clen);
-    return use_arith
-	? arith_decode(in, in_len, out, out_len)
-	: rans_decode(in, in_len, out, out_len);
-}
-
-//-----------------------------------------------------------------------------
-
-/*
- * Converts a line or \0 separated block of reading names to a compressed buffer.
- * The code can only encode whole lines and will not attempt a partial line.
- * Use the "last_start_p" return value to identify the partial line start
- * offset, for continuation purposes.
- *
- * Returns a malloced buffer holding compressed data of size *out_len,
- *         or NULL on failure
- */
-uint8_t *encode_names(char *blk, int len, int level, int use_arith,
-		      int *out_len, int *last_start_p) {
-    int last_start = 0, i, j, nreads;
-
-    // Count lines
-    for (nreads = i = 0; i < len; i++)
-	if (blk[i] <= '\n') // \n or \0 separated entries
-	    nreads++;
-
-    name_context *ctx = create_context(nreads);
-    if (!ctx)
-	return NULL;
-
-    // Construct trie
-    int ctr = 0;
-    for (i = j = 0; i < len; j=++i) {
-	while (i < len && blk[i] > '\n')
-	    i++;
-	if (i >= len)
-	    break;
-
-	//blk[i] = '\0';
-	last_start = i+1;
-	if (build_trie(ctx, &blk[j], i-j, ctr++) < 0) {
-	    free_context(ctx);
-	    return NULL;
-	}
-    }
-    if (last_start_p)
-	*last_start_p = last_start;
-
-    //fprintf(stderr, "Processed %d of %d in block, line %d\n", last_start, len, ctr);
-
-    // Encode name
-    for (i = j = 0; i < len; j=++i) {
-	while (i < len && blk[i] > '\n')
-	    i++;
-	if (i >= len)
-	    break;
-
-	blk[i] = '\0';
-	// try both 0 and 1 and pick best?
-	if (encode_name(ctx, &blk[j], i-j, 1) < 0) {
-	    free_context(ctx);
-	    return NULL;
-	}
-    }
-
-#if 0
-    for (i = 0; i < ctx->max_tok*16; i++) {
-	char fn[1024];
-	if (!ctx->desc[i].buf_l) continue;
-	sprintf(fn, "_tok.%02d_%02d.%d", i>>4,i&15,i);
-	FILE *fp = fopen(fn, "w");
-	fwrite(ctx->desc[i].buf, 1, ctx->desc[i].buf_l, fp);
-	fclose(fp);
-    }
-#endif
-
-    //dump_trie(t_head, 0);
-
-    // FIXME: merge descriptors
-    //
-    // If we see foo7:1 foo7:12 foo7:7 etc then foo: is constant,
-    // but it's encoded as alpha<foo>+dig<7>+char<:> instead of alpha<foo7:>.
-    // Any time token type 0 is all match beyond the first location we have
-    // a candidate for merging in string form.
-    //
-    // This saves around .1 to 1.3 percent on varying data sets.
-    // Cruder hack is dedicated prefix/suffix matching to short-cut this.
-
-
-    // Drop N_TYPE blocks if they all contain matches bar the first item,
-    // as we can regenerate these from the subsequent blocks types during
-    // decode.
-    for (i = 0; i < ctx->max_tok*16; i+=16) {
-	if (!ctx->desc[i].buf_l) continue;
-
-	int z;
-	for (z=1; z<ctx->desc[i].buf_l; z++) {
-	    if (ctx->desc[i].buf[z] != N_MATCH)
-		break;
-	}
-	if (z == ctx->desc[i].buf_l) {
-	    int k;
-	    for (k=1; k<16; k++)
-		if (ctx->desc[i+k].buf_l)
-		    break;
-
-	    if (k < 16) {
-		ctx->desc[i].buf_l = 0;
-		free(ctx->desc[i].buf);
-		ctx->desc[i].buf = NULL;
-	    }
-	}
-    }
-
-    // Serialise descriptors
-    uint32_t tot_size = 9;
-    int ndesc = 0;
-    for (i = 0; i < ctx->max_tok*16; i++) {
-	if (!ctx->desc[i].buf_l) continue;
-
-	ndesc++;
-
-	int tnum = i>>4;
-	int ttype = i&15;
-
-	uint64_t out_len = 1.5 * arith_compress_bound(ctx->desc[i].buf_l, 1); // guesswork
-	uint8_t *out = malloc(out_len);
-	if (!out) {
-	    free_context(ctx);
-	    return NULL;
-	}
-
-	if (compress(ctx->desc[i].buf, ctx->desc[i].buf_l, level, use_arith,
-		     out, &out_len) < 0) {
-	    free_context(ctx);
-	    return NULL;
-	}
-
-	free(ctx->desc[i].buf);
-	ctx->desc[i].buf = out;
-	ctx->desc[i].buf_l = out_len;
-	ctx->desc[i].tnum = tnum;
-	ctx->desc[i].ttype = ttype;
-
-	// Find dups
-	int j;
-	for (j = 0; j < i; j++) {
-	    if (!ctx->desc[j].buf)
-		continue;
-	    if (ctx->desc[i].buf_l != ctx->desc[j].buf_l || ctx->desc[i].buf_l <= 4)
-		continue;
-	    if (memcmp(ctx->desc[i].buf, ctx->desc[j].buf, ctx->desc[i].buf_l) == 0)
-		break;
-	}
-	if (j < i) {
-	    ctx->desc[i].dup_from = j;
-	    tot_size += 3; // flag, dup_from, ttype
-	} else {
-	    ctx->desc[i].dup_from = 0;
-	    tot_size += out_len + 1; // ttype
-	}
-    }
-
-#if 0
-    for (i = 0; i < ctx->max_tok*16; i++) {
-	char fn[1024];
-	if (!ctx->desc[i].buf_l && !ctx->desc[i].dup_from) continue;
-	sprintf(fn, "_tok.%02d_%02d.%d.comp", i>>4,i&15,i);
-	FILE *fp = fopen(fn, "w");
-	fwrite(ctx->desc[i].buf, 1, ctx->desc[i].buf_l, fp);
-	fclose(fp);
-    }
-#endif
-
-    // Write
-    uint8_t *out = malloc(tot_size+13);
-    if (!out) {
-	free_context(ctx);
-	return NULL;
-    }
-
-    uint8_t *cp = out;
-
-    *out_len = tot_size;
-//    *(uint32_t *)cp = last_start; cp += 4;
-//    *(uint32_t *)cp = nreads;     cp += 4;
-    *cp++ = (last_start >>  0) & 0xff;
-    *cp++ = (last_start >>  8) & 0xff;
-    *cp++ = (last_start >> 16) & 0xff;
-    *cp++ = (last_start >> 24) & 0xff;
-    *cp++ = (nreads     >>  0) & 0xff;
-    *cp++ = (nreads     >>  8) & 0xff;
-    *cp++ = (nreads     >> 16) & 0xff;
-    *cp++ = (nreads     >> 24) & 0xff;
-    *cp++ = use_arith;
-    //write(1, &nreads, 4);
-    int last_tnum = -1;
-    for (i = 0; i < ctx->max_tok*16; i++) {
-	if (!ctx->desc[i].buf_l) continue;
-	uint8_t ttype8 = ctx->desc[i].ttype;
-	if (ctx->desc[i].tnum != last_tnum) {
-	    ttype8 |= 128;
-	    last_tnum = ctx->desc[i].tnum;
-	}
-	if (ctx->desc[i].dup_from) {
-	    //fprintf(stderr, "Dup %d from %d, sz %d\n", i, ctx->desc[i].dup_from, ctx->desc[i].buf_l);
-	    *cp++ = ttype8 | 64;
-	    *cp++ = ctx->desc[i].dup_from >> 4;
-	    *cp++ = ctx->desc[i].dup_from & 15;
-	} else {
-	    *cp++ = ttype8;
-	    memcpy(cp, ctx->desc[i].buf, ctx->desc[i].buf_l);
-	    cp += ctx->desc[i].buf_l;
-	}
-    }
-
-    //assert(cp-out == tot_size);
-
-    free_context(ctx);
-
-    return out;
-}
-
-/*
- * Decodes a compressed block of read names into \0 separated names.
- * The size of the data returned (malloced) is in *out_len.
- *
- * Returns NULL on failure.
- */
-uint8_t *decode_names(uint8_t *in, uint32_t sz, uint32_t *out_len) {
-    if (sz < 9)
-	return NULL;
-
-    int i, o = 9;
-    //int ulen   = *(uint32_t *)in;
-    int ulen   = (in[0]<<0) | (in[1]<<8) | (in[2]<<16) |
-	(((uint32_t)in[3])<<24);
-
-    if (ulen < 0 || ulen >= INT_MAX-1024)
-	return NULL;
-
-    //int nreads = *(uint32_t *)(in+4);
-    int nreads = (in[4]<<0) | (in[5]<<8) | (in[6]<<16) | (((uint32_t)in[7])<<24);
-    int use_arith = in[8];
-    name_context *ctx = create_context(nreads);
-    if (!ctx)
-	return NULL;
-
-    // Unpack descriptors
-    int tnum = -1;
-    while (o < sz) {
-	uint8_t ttype = in[o++];
-	if (ttype & 64) {
-	    if (o+2 >= sz) goto err;
-	    int j = in[o++]<<4;
-	    j += in[o++];
-	    if (ttype & 128) {
-		tnum++;
-		if (tnum >= MAX_TOKENS)
-		    goto err;
-		ctx->max_tok = tnum+1;
-		memset(&ctx->desc[tnum<<4], 0, 16*sizeof(ctx->desc[tnum]));
-	    }
-
-	    if ((ttype & 15) != 0 && (ttype & 128)) {
-		if (tnum < 0) goto err;
-		ctx->desc[tnum<<4].buf = malloc(nreads);
-		if (!ctx->desc[tnum<<4].buf)
-		    goto err;
-
-		ctx->desc[tnum<<4].buf_l = 0;
-		ctx->desc[tnum<<4].buf_a = nreads;
-		ctx->desc[tnum<<4].buf[0] = ttype&15;
-		memset(&ctx->desc[tnum<<4].buf[1], N_MATCH, nreads-1);
-	    }
-
-	    if (tnum < 0) goto err;
-	    i = (tnum<<4) | (ttype&15);
-	    if (j >= i)
-		goto err;
-
-	    ctx->desc[i].buf_l = 0;
-	    ctx->desc[i].buf_a = ctx->desc[j].buf_a;
-	    if (ctx->desc[i].buf) free(ctx->desc[i].buf);
-	    ctx->desc[i].buf = malloc(ctx->desc[i].buf_a);
-	    if (!ctx->desc[i].buf)
-		goto err;
-
-	    memcpy(ctx->desc[i].buf, ctx->desc[j].buf, ctx->desc[i].buf_a);
-	    //fprintf(stderr, "Copy ttype %d, i=%d,j=%d, size %d\n", ttype, i, j, (int)ctx->desc[i].buf_a);
-	    continue;
-	}
-
-	//if (ttype == 0)
-	if (ttype & 128) {
-	    tnum++;
-	    if (tnum >= MAX_TOKENS)
-		goto err;
-	    ctx->max_tok = tnum+1;
-	    memset(&ctx->desc[tnum<<4], 0, 16*sizeof(ctx->desc[tnum]));
-	}
-
-	if ((ttype & 15) != 0 && (ttype & 128)) {
-	    if (tnum < 0) goto err;
-	    if (ctx->desc[tnum<<4].buf) free(ctx->desc[tnum<<4].buf);
-	    ctx->desc[tnum<<4].buf = malloc(nreads);
-	    if (!ctx->desc[tnum<<4].buf)
-		goto err;
-	    ctx->desc[tnum<<4].buf_l = 0;
-	    ctx->desc[tnum<<4].buf_a = nreads;
-	    ctx->desc[tnum<<4].buf[0] = ttype&15;
-	    memset(&ctx->desc[tnum<<4].buf[1], N_MATCH, nreads-1);
-	}
-
-	//fprintf(stderr, "Read %02x\n", c);
-
-	// Load compressed block
-	int64_t clen, ulen = uncompressed_size(&in[o], sz-o);
-	if (ulen < 0 || ulen >= INT_MAX)
-	    goto err;
-	if (tnum < 0) goto err;
-	i = (tnum<<4) | (ttype&15);
-
-	if (i >= MAX_TBLOCKS || i < 0)
-	    goto err;
-
-	ctx->desc[i].buf_l = 0;
-	if (ctx->desc[i].buf) free(ctx->desc[i].buf);
-	ctx->desc[i].buf = malloc(ulen);
-	if (!ctx->desc[i].buf)
-	    goto err;
-
-	ctx->desc[i].buf_a = ulen;
-	uint64_t usz = ctx->desc[i].buf_a; // convert from size_t for 32-bit sys
-	clen = uncompress(use_arith, &in[o], sz-o, ctx->desc[i].buf, &usz);
-	ctx->desc[i].buf_a = usz;
-	if (clen < 0)
-	    goto err;
-	assert(ctx->desc[i].buf_a == ulen);
-
-	// fprintf(stderr, "%d: Decode tnum %d type %d clen %d ulen %d via %d\n",
-	// 	o, tnum, ttype, (int)clen, (int)ctx->desc[i].buf_a, ctx->desc[i].buf[0]);
-
-	o += clen;
-
-	// Encode tnum 0 type 0 ulen 100000 clen 12530 via 2
-	// Encode tnum 0 type 6 ulen 196800 clen 43928 via 3
-	// Encode tnum 0 type 7 ulen 203200 clen 17531 via 3
-	// Encode tnum 1 type 0 ulen 50800 clen 10 via 1
-	// Encode tnum 1 type 1 ulen 3 clen 5 via 0
-	// Encode tnum 2 type 0 ulen 50800 clen 10 via 1
-	// 	
-    }
-
-    int ret;
-    ulen += 1024; // for easy coding in decode_name.
-    uint8_t *out = malloc(ulen);
-    if (!out)
-	goto err;
-
-    size_t out_sz = 0;
-    while ((ret = decode_name(ctx, (char *)out+out_sz, ulen)) > 0) {
-	out_sz += ret;
-	ulen -= ret;
-    }
-
-    if (ret < 0)
-	free(out);
-
-    free_context(ctx);
-
-    *out_len = out_sz;
-    return ret == 0 ? out : NULL;
-
- err:
-    free_context(ctx);
-    return NULL;
-}
diff -ruN stringtie.orig/htslib/htscodecs/htscodecs/tokenise_name3.h stringtie/htslib/htscodecs/htscodecs/tokenise_name3.h
--- stringtie.orig/htslib/htscodecs/htscodecs/tokenise_name3.h	2024-02-28 13:57:39.704579460 +0100
+++ stringtie/htslib/htscodecs/htscodecs/tokenise_name3.h	1970-01-01 01:00:00.000000000 +0100
@@ -1,65 +0,0 @@
-/*
- * Copyright (c) 2017, 2019 Genome Research Ltd.
- * Author(s): James Bonfield
- * 
- * Redistribution and use in source and binary forms, with or without 
- * modification, are permitted provided that the following conditions are met:
- * 
- *    1. Redistributions of source code must retain the above copyright notice,
- *       this list of conditions and the following disclaimer.
- * 
- *    2. Redistributions in binary form must reproduce the above
- *       copyright notice, this list of conditions and the following
- *       disclaimer in the documentation and/or other materials provided
- *       with the distribution.
- * 
- *    3. Neither the names Genome Research Ltd and Wellcome Trust Sanger
- *    Institute nor the names of its contributors may be used to endorse
- *    or promote products derived from this software without specific
- *    prior written permission.
- * 
- * THIS SOFTWARE IS PROVIDED BY GENOME RESEARCH LTD AND CONTRIBUTORS "AS
- * IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
- * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
- * PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL GENOME RESEARCH
- * LTD OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
- * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
- * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
- * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
- * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
- * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
- * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- */
-
-#ifndef _TOKENISE_NAME3_H_
-#define _TOKENISE_NAME3_H_
-
-#ifdef __cplusplus
-extern "C" {
-#endif
-
-/*
- * Converts a line or \0 separated block of reading names to a compressed buffer.
- * The code can only encode whole lines and will not attempt a partial line.
- * Use the "last_start_p" return value to identify the partial line start
- * offset, for continuation purposes.
- *
- * Returns a malloced buffer holding compressed data of size *out_len,
- *         or NULL on failure
- */
-uint8_t *encode_names(char *blk, int len, int level, int use_arith,
-		      int *out_len, int *last_start_p);
-
-/*
- * Decodes a compressed block of read names into \0 separated names.
- * The size of the data returned (malloced) is in *out_len.
- *
- * Returns NULL on failure.
- */
-uint8_t *decode_names(uint8_t *in, uint32_t sz, uint32_t *out_len);
-
-#ifdef __cplusplus
-}
-#endif
-
-#endif /* _TOKENISE_NAME3_H_ */
diff -ruN stringtie.orig/htslib/htscodecs/htscodecs/utils.h stringtie/htslib/htscodecs/htscodecs/utils.h
--- stringtie.orig/htslib/htscodecs/htscodecs/utils.h	2024-02-28 13:57:39.704579460 +0100
+++ stringtie/htslib/htscodecs/htscodecs/utils.h	1970-01-01 01:00:00.000000000 +0100
@@ -1,202 +0,0 @@
-/*
- * Copyright (c) 2019,2021 Genome Research Ltd.
- * Author(s): James Bonfield
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions are met:
- *
- *    1. Redistributions of source code must retain the above copyright notice,
- *       this list of conditions and the following disclaimer.
- *
- *    2. Redistributions in binary form must reproduce the above
- *       copyright notice, this list of conditions and the following
- *       disclaimer in the documentation and/or other materials provided
- *       with the distribution.
- *
- *    3. Neither the names Genome Research Ltd and Wellcome Trust Sanger
- *       Institute nor the names of its contributors may be used to endorse
- *       or promote products derived from this software without specific
- *       prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY GENOME RESEARCH LTD AND CONTRIBUTORS "AS
- * IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
- * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
- * PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL GENOME RESEARCH
- * LTD OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
- * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
- * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
- * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
- * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
- * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
- * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- */
-
-#include <string.h>
-
-/*
- * Data transpose by N.  Common to rANS4x16 and arith_dynamic decoders.
- *
- * Tuned for specific common cases of N.
- */
-static inline void unstripe(unsigned char *out, unsigned char *outN,
-			    unsigned int ulen, unsigned int N,
-			    unsigned int idxN[256]) {
-    int j = 0, k;
-
-    if (ulen >= N) {
-	switch (N) {
-	case 4:
-	    while (j < ulen-4) {
-		for (k = 0; k < 4; k++)
-		    out[j++] = outN[idxN[k]++];
-	    }
-	    break;
-
-	case 2:
-	    while (j < ulen-2) {
-		for (k = 0; k < 2; k++)
-		    out[j++] = outN[idxN[k]++];
-	    }
-	    break;
-
-	default:
-	    // General case, around 25% slower overall decode
-	    while (j < ulen-N) {
-		for (k = 0; k < N; k++)
-		    out[j++] = outN[idxN[k]++];
-	    }
-	    break;
-	}
-    }
-    for (k = 0; j < ulen; k++)
-	out[j++] = outN[idxN[k]++];
-}
-
-#define MAGIC 8
-
-/*
- * Order 0 histogram construction.  8-way unrolled to avoid cache collisions.
- */
-static inline
-void hist8(unsigned char *in, unsigned int in_size, uint32_t F0[256]) {
-    uint32_t F1[256+MAGIC] = {0}, F2[256+MAGIC] = {0}, F3[256+MAGIC] = {0};
-    uint32_t F4[256+MAGIC] = {0}, F5[256+MAGIC] = {0}, F6[256+MAGIC] = {0};
-    uint32_t F7[256+MAGIC] = {0};
-
-    unsigned int i, i8 = in_size & ~7;
-    for (i = 0; i < i8; i+=8) {
-	F0[in[i+0]]++;
-	F1[in[i+1]]++;
-	F2[in[i+2]]++;
-	F3[in[i+3]]++;
-	F4[in[i+4]]++;
-	F5[in[i+5]]++;
-	F6[in[i+6]]++;
-	F7[in[i+7]]++;
-    }
-    while (i < in_size)
-	F0[in[i++]]++;
-
-    for (i = 0; i < 256; i++)
-	F0[i] += F1[i] + F2[i] + F3[i] + F4[i] + F5[i] + F6[i] + F7[i];
-}
-
-/*
- * A variant of hist8 that simply marks the presence of a symbol rather
- * than its frequency.
- */
-static inline
-void present8(unsigned char *in, unsigned int in_size,
-	      uint32_t F0[256]) {
-    uint32_t F1[256+MAGIC] = {0}, F2[256+MAGIC] = {0}, F3[256+MAGIC] = {0};
-    uint32_t F4[256+MAGIC] = {0}, F5[256+MAGIC] = {0}, F6[256+MAGIC] = {0};
-    uint32_t F7[256+MAGIC] = {0};
-
-    unsigned int i, i8 = in_size & ~7;
-    for (i = 0; i < i8; i+=8) {
-	F0[in[i+0]]=1;
-	F1[in[i+1]]=1;
-	F2[in[i+2]]=1;
-	F3[in[i+3]]=1;
-	F4[in[i+4]]=1;
-	F5[in[i+5]]=1;
-	F6[in[i+6]]=1;
-	F7[in[i+7]]=1;
-    }
-    while (i < in_size)
-	F0[in[i++]]=1;
-
-    for (i = 0; i < 256; i++)
-	F0[i] += F1[i] + F2[i] + F3[i] + F4[i] + F5[i] + F6[i] + F7[i];
-}
-
-/*
- * Order 1 histogram construction.  4-way unrolled to avoid cache collisions.
- */
-static inline
-void hist1_4(unsigned char *in, unsigned int in_size,
-	     uint32_t F0[256][256], uint32_t *T0) {
-    uint32_t T1[256+MAGIC] = {0}, T2[256+MAGIC] = {0}, T3[256+MAGIC] = {0};
-
-    unsigned char l = 0, c;
-    unsigned char *in_end = in + in_size;
-
-    unsigned char cc[5] = {0};
-    if (in_size > 500000) {
-	uint32_t F1[256][259] = {{0}};
-	while (in < in_end-8) {
-	    memcpy(cc, in, 4); in += 4;
-	    T0[cc[4]]++; F0[cc[4]][cc[0]]++;
-	    T1[cc[0]]++; F1[cc[0]][cc[1]]++;
-	    T2[cc[1]]++; F0[cc[1]][cc[2]]++;
-	    T3[cc[2]]++; F1[cc[2]][cc[3]]++;
-	    cc[4] = cc[3];
-
-	    memcpy(cc, in, 4); in += 4;
-	    T0[cc[4]]++; F0[cc[4]][cc[0]]++;
-	    T1[cc[0]]++; F1[cc[0]][cc[1]]++;
-	    T2[cc[1]]++; F0[cc[1]][cc[2]]++;
-	    T3[cc[2]]++; F1[cc[2]][cc[3]]++;
-	    cc[4] = cc[3];
-	}
-	l = cc[3];
-
-	while (in < in_end) {
-	    F0[l][c = *in++]++;
-	    T0[l]++;
-	    l = c;
-	}
-
-	int i, j;
-	for (i = 0; i < 256; i++)
-	    for (j = 0; j < 256; j++)
-		F0[i][j] += F1[i][j];
-    } else {
-	while (in < in_end-8) {
-	    memcpy(cc, in, 4); in += 4;
-	    T0[cc[4]]++; F0[cc[4]][cc[0]]++;
-	    T1[cc[0]]++; F0[cc[0]][cc[1]]++;
-	    T2[cc[1]]++; F0[cc[1]][cc[2]]++;
-	    T3[cc[2]]++; F0[cc[2]][cc[3]]++;
-	    cc[4] = cc[3];
-
-	    memcpy(cc, in, 4); in += 4;
-	    T0[cc[4]]++; F0[cc[4]][cc[0]]++;
-	    T1[cc[0]]++; F0[cc[0]][cc[1]]++;
-	    T2[cc[1]]++; F0[cc[1]][cc[2]]++;
-	    T3[cc[2]]++; F0[cc[2]][cc[3]]++;
-	    cc[4] = cc[3];
-	}
-	l = cc[3];
-
-	while (in < in_end) {
-	    F0[l][c = *in++]++;
-	    T0[l]++;
-	    l = c;
-	}
-    }
-
-    int i;
-    for (i = 0; i < 256; i++)
-	T0[i]+=T1[i]+T2[i]+T3[i];
-}
diff -ruN stringtie.orig/htslib/htscodecs/htscodecs/varint2.h stringtie/htslib/htscodecs/htscodecs/varint2.h
--- stringtie.orig/htslib/htscodecs/htscodecs/varint2.h	2024-02-28 13:57:39.704579460 +0100
+++ stringtie/htslib/htscodecs/htscodecs/varint2.h	1970-01-01 01:00:00.000000000 +0100
@@ -1,318 +0,0 @@
-//#include <stdio.h>
-
-// FIXME: make get functions const uint8_t *
-
-/*
- * Copyright (c) 2019 Genome Research Ltd.
- * Author(s): James Bonfield
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions are met:
- *
- *    1. Redistributions of source code must retain the above copyright notice,
- *       this list of conditions and the following disclaimer.
- *
- *    2. Redistributions in binary form must reproduce the above
- *       copyright notice, this list of conditions and the following
- *       disclaimer in the documentation and/or other materials provided
- *       with the distribution.
- *
- *    3. Neither the names Genome Research Ltd and Wellcome Trust Sanger
- *       Institute nor the names of its contributors may be used to endorse
- *       or promote products derived from this software without specific
- *       prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY GENOME RESEARCH LTD AND CONTRIBUTORS "AS
- * IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
- * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
- * PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL GENOME RESEARCH
- * LTD OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
- * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
- * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
- * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
- * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
- * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
- * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- */
-
-#ifndef VARINT2_H
-#define VARINT2_H
-
-#include <stdint.h>
-
-// General API scheme is var_{get,put}_{s,u}{32,64}
-// s/u for signed/unsigned;  32/64 for integer size.
-
-// The ideas here are taken from the vbenc code in TurboPFor
-// (https://github.com/powturbo/TurboPFor) with analysis at
-// https://github.com/stoklund/varint.
-
-// Unlike the ITF8 and standard 7-bit at a time encodings, this
-// tries to ensure a larger portion of small numbers still fit in 1 byte.
-// This trades more space for long integers with less space for short ones,
-// which seems like a good tradeoff given the typical distribution curves.
-//
-// Like ITF8 and LTF8, the first byte also indicates the total number of
-// bytes we need to decode, but unlike those it uses the same format for
-// both meaning changing data type doesn't change encoding.
-//
-// Size comparison examples.
-//
-//              Max value
-// Bytes        ITF8/7bit               This
-// 1                  127                176
-// 2               16,383             16,560
-// 3            2,097,151            540,848
-// 4          268,435,455         16,777,215
-// 5       34,359,738,368      4,294,967,296
-// 6    4,398,046,511,104  1,099,511,627,776
-// ...
-//
-// The format is as follows:
-// 0-176                     1 byte:  0 + 8 bit
-// 177-16560 (14 bit range)  2 bytes: 177 + 6bit, 0 + 8bit, for x-177
-// 16561-540848 (19 bits)    3 bytes: 241 + 3bit, 0+8, 0+8, for x-16561
-// 540849-16777215 (~24 bit) 4 bytes: 249, 0+8, 0+8, 0+8, for x
-// 2^24 - 2^32-1             5 bytes: 250, 0+8 x4
-// 2^32 - 2^40-1             6 bytes: 251, 0+8 x5
-// 2^40 - 2^48-1             7 bytes: 252, 0+8 x6
-// 2^48 - 2^56-1             8 bytes: 253, 0+8 x7
-// 2^56 - 2^64-1             9 bytes: 254, 0+8 x8
-//
-// Hence first byte value 255 is not possible and permits future
-// escape code.
-
-
-// FIXME: consider returning the value and having nbytes passed in by
-// reference instead of vice-versa.
-//
-// ie uint64_t var_get_u64(uint8_t *cp, int *nbytes)
-// vs int      var_get_u64(uint8_t *cp, uint64_t *val)
-//
-// The return value can then be assigned to 32-bit or 64-bit type
-// without need of a new function name.  The cost is we can't then
-// do "cp += var_get_u32(cp, endp, &u_freq_sz);".  Maybe we can't do
-// overflow detection with former? (Want 32-bit but got, say, 40 bit)
-
-
-// static inline char *var_dump(const uint8_t *cp, int n) {
-//     static char buf[1000];
-//     int i, o = 0;
-//     for (i = 0; i < n; i++)
-// 	o += sprintf(&buf[o], " %d", cp[i]);
-//     return buf;
-// }
-
-static inline int var_put_u64(uint8_t *cp, const uint8_t *endp, uint64_t x) {
-    uint8_t *op = cp;
-
-    if (x < 177) {
-	if (endp && endp - cp < 1) return 0;
-	// 0 to 176 in single byte as-is
-	*cp++ = x;
-    } else if (x < 16561) {
-	if (endp && endp - cp < 2) return 0;
-	*cp++ = ((x-177)>>8)+177;
-	*cp++ = x-177;
-    } else if (x < 540849) {
-	if (endp && endp - cp < 3) return 0;
-	*cp++ = ((x-16561)>>16)+241;
-	*cp++ = (x-16561)>>8;
-	*cp++ = x-16561;
-    } else if (x < (1<<24)) {
-	if (endp && endp - cp < 4) return 0;
-	*cp++ = 249;
-	*cp++ = x>>16;
-	*cp++ = x>>8;
-	*cp++ = x;
-    } else if (x < (1LL<<32)) {
-	if (endp && endp - cp < 5) return 0;
-	*cp++ = 250;
-	*cp++ = x>>24;
-	*cp++ = x>>16;
-	*cp++ = x>>8;
-	*cp++ = x;
-    } else if (x < (1LL<<40)) {
-	if (endp && endp - cp < 6) return 0;
-	*cp++ = 251;
-	*cp++ = x>>32;
-	*cp++ = x>>24;
-	*cp++ = x>>16;
-	*cp++ = x>>8;
-	*cp++ = x;
-    } else if (x < (1LL<<48)) {
-	if (endp && endp - cp < 7) return 0;
-	*cp++ = 252;
-	*cp++ = x>>40;
-	*cp++ = x>>32;
-	*cp++ = x>>24;
-	*cp++ = x>>16;
-	*cp++ = x>>8;
-	*cp++ = x;
-    } else if (x < (1LL<<56)) {
-	if (endp && endp - cp < 8) return 0;
-	*cp++ = 253;
-	*cp++ = x>>48;
-	*cp++ = x>>40;
-	*cp++ = x>>32;
-	*cp++ = x>>24;
-	*cp++ = x>>16;
-	*cp++ = x>>8;
-	*cp++ = x;
-    } else {
-	if (endp && endp - cp < 9) return 0;
-	*cp++ = 254;
-	*cp++ = x>>56;
-	*cp++ = x>>48;
-	*cp++ = x>>40;
-	*cp++ = x>>32;
-	*cp++ = x>>24;
-	*cp++ = x>>16;
-	*cp++ = x>>8;
-	*cp++ = x;
-    }
-
-//    fprintf(stderr, "Put64 %d (%s)\n", x, var_dump(op, cp-op));
-
-    return cp-op;
-}
-
-static inline int var_put_u32(uint8_t *cp, const uint8_t *endp, uint32_t x) {
-    uint8_t *op = cp;
-
-    if (x < 177) {
-	if (endp && endp - cp < 1) abort();//return 0;
-	// 0 to 176 in single byte as-is
-	*cp++ = x;
-    } else if (x < 16561) {
-	if (endp && endp - cp < 2) abort();//return 0;
-	*cp++ = ((x-177)>>8)+177;
-	*cp++ = x-177;
-    } else if (x < 540849) {
-	if (endp && endp - cp < 3) abort();//return 0;
-	*cp++ = ((x-16561)>>16)+241;
-	*cp++ = (x-16561)>>8;
-	*cp++ = x-16561;
-    } else if (x < (1<<24)) {
-	if (endp && endp - cp < 4) abort();//return 0;
-	*cp++ = 249;
-	*cp++ = x>>16;
-	*cp++ = x>>8;
-	*cp++ = x;
-    } else {
-	if (endp && endp - cp < 5) abort();//return 0;
-	*cp++ = 250;
-	*cp++ = x>>24;
-	*cp++ = x>>16;
-	*cp++ = x>>8;
-	*cp++ = x;
-    }
-
-//    fprintf(stderr, "Put32 %d (%s)\n", x, var_dump(op, cp-op));
-
-    return cp-op;
-}
-
-static inline int var_get_u64(uint8_t *cp, const uint8_t *endp, uint64_t *i) {
-    uint8_t *op = cp;
-    uint64_t j = 0;
-
-    if (endp && cp >= endp) {
-	*i = 0;
-	return 0;
-    }
-    if (*cp < 177) {
-	j = *cp++;
-    } else if (*cp < 241) {
-	j = ((cp[0] - 177)<<8) + cp[1] + 177;
-	cp += 2;
-    } else if (*cp < 249) {
-	j = ((cp[0] - 241)<<16) + (cp[1]<<8) + cp[2] + 16561;
-	cp += 3;
-    } else {
-	int n = *cp++ - 249 + 3;
-	while (n--)
-	    j = (j<<8) + *cp++;
-    }
-
-//    fprintf(stderr, "Get64 %ld (%s)\n", j, var_dump(op, cp-op));
-
-    *i = j;
-    return cp-op;
-}
-
-static inline int var_get_u32(uint8_t *cp, const uint8_t *endp, uint32_t *i) {
-    uint8_t *op = cp;
-    uint32_t j = 0;
-
-    if (endp && cp >= endp) {
-	*i = 0;
-	return 0;
-    }
-    if (*cp < 177) {
-	j = *cp++;
-    } else if (*cp < 241) {
-	j = ((cp[0] - 177)<<8) + cp[1] + 177;
-	cp += 2;
-    } else if (*cp < 249) {
-	j = ((cp[0] - 241)<<16) + (cp[1]<<8) + cp[2] + 16561;
-	cp += 3;
-    } else {
-	int n = *cp++ - 249 + 3;
-	while (n--)
-	    j = (j<<8) + *cp++;
-    }
-
-//    fprintf(stderr, "Get32 %d (%s)\n", j, var_dump(op, cp-op));
-
-    *i = j;
-    return cp-op;
-}
-
-// Signed versions of the above using zig-zag integer encoding.
-// This folds the sign bit into the bottom bit so we iterate
-// 0, -1, +1, -2, +2, etc.
-static inline int var_put_s32(uint8_t *cp, const uint8_t *endp, int32_t i) {
-    return var_put_u32(cp, endp, (i << 1) ^ (i >> 31));
-}
-static inline int var_put_s64(uint8_t *cp, const uint8_t *endp, int64_t i) {
-    return var_put_u64(cp, endp, (i << 1) ^ (i >> 63));
-}
-
-static inline int var_get_s32(uint8_t *cp, const uint8_t *endp, int32_t *i) {
-    int b = var_get_u32(cp, endp, (uint32_t *)i);
-    *i = (*i >> 1) ^ -(*i & 1);
-    return b;
-}
-static inline int var_get_s64(uint8_t *cp, const uint8_t *endp, int64_t *i) {
-    int b = var_get_u64(cp, endp, (uint64_t *)i);
-    *i = (*i >> 1) ^ -(*i & 1);
-    return b;
-}
-
-static inline int var_size_u64(uint64_t v) {
-    if (v < 177)
-	return 1;
-    else if (v < 16561)
-	return 2;
-    else if (v < 540849)
-	return 3;
-
-    int i = 0;
-    do {
-	v >>= 8;
-	i++;
-    } while (v);
-
-//    fprintf(stderr, "Size %ld (%d)\n", v, i+1);
-
-    return i+1;
-}
-#define var_size_u32 var_size_u64
-
-static inline int var_size_s64(int64_t v) {
-    return var_size_u64((v >> 63) ^ (v << 1));
-}
-#define var_size_s32 var_size_s64
-
-#endif /* VARINT2_H */
diff -ruN stringtie.orig/htslib/htscodecs/htscodecs/varint.h stringtie/htslib/htscodecs/htscodecs/varint.h
--- stringtie.orig/htslib/htscodecs/htscodecs/varint.h	2024-02-28 13:57:39.704579460 +0100
+++ stringtie/htslib/htscodecs/htscodecs/varint.h	1970-01-01 01:00:00.000000000 +0100
@@ -1,304 +0,0 @@
-// FIXME: make get functions const uint8_t *
-
-/*
- * Copyright (c) 2019,2020 Genome Research Ltd.
- * Author(s): James Bonfield
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions are met:
- *
- *    1. Redistributions of source code must retain the above copyright notice,
- *       this list of conditions and the following disclaimer.
- *
- *    2. Redistributions in binary form must reproduce the above
- *       copyright notice, this list of conditions and the following
- *       disclaimer in the documentation and/or other materials provided
- *       with the distribution.
- *
- *    3. Neither the names Genome Research Ltd and Wellcome Trust Sanger
- *       Institute nor the names of its contributors may be used to endorse
- *       or promote products derived from this software without specific
- *       prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY GENOME RESEARCH LTD AND CONTRIBUTORS "AS
- * IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
- * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
- * PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL GENOME RESEARCH
- * LTD OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
- * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
- * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
- * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
- * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
- * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
- * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- */
-
-#ifndef VARINT_H
-#define VARINT_H
-
-#include <stdint.h>
-
-#ifdef VARINT2
-#include "varint2.h"
-#else
-
-// General API scheme is var_{get,put}_{s,u}{32,64}
-// s/u for signed/unsigned;  32/64 for integer size.
-
-// FIXME: consider returning the value and having nbytes passed in by
-// reference instead of vice-versa.
-//
-// ie uint64_t var_get_u64(uint8_t *cp, int *nbytes)
-// vs int      var_get_u64(uint8_t *cp, uint64_t *val)
-//
-// The return value can then be assigned to 32-bit or 64-bit type
-// without need of a new function name.  The cost is we can't then
-// do "cp += var_get_u32(cp, endp, &u_freq_sz);".  Maybe we can't do
-// overflow detection with former? (Want 32-bit but got, say, 40 bit)
-
-
-// Big endian.
-// Harder for encoding, but a simpler and faster decoder.
-#define BIG_END
-#ifdef BIG_END
-static inline int var_put_u64(uint8_t *cp, const uint8_t *endp, uint64_t i) {
-    uint8_t *op = cp;
-    int s = 0;
-    uint64_t X = i;
-
-    do {
-	s += 7;
-	X >>= 7;
-    } while (X);
-
-    if (endp && (endp-cp)*7 < s)
-	return 0;
-
-    do {
-	s -= 7;
-	*cp++ = ((i>>s) & 0x7f) + (s?128:0);
-    } while (s);
-
-    return cp-op;
-}
-
-static inline int var_put_u32(uint8_t *cp, const uint8_t *endp, uint32_t i) {
-    uint8_t *op = cp;
-    int s = 0;
-    uint32_t X = i;
-
-    do {
-	s += 7;
-	X >>= 7;
-    } while (X);
-
-    if (endp && (endp-cp)*7 < s)
-	return 0;
-
-    do {
-	s -= 7;
-	*cp++ = ((i>>s) & 0x7f) + (s?128:0);
-    } while (s);
-
-    return cp-op;
-}
-
-static inline int var_get_u64(uint8_t *cp, const uint8_t *endp, uint64_t *i) {
-    uint8_t *op = cp, c;
-    uint64_t j = 0;
-
-    if (endp) {
-	if (cp >= endp) {
-	    *i = 0;
-	    return 0;
-	}
-
-	do {
-	    c = *cp++;
-	    j = (j<<7) | (c & 0x7f);
-	} while ((c & 0x80) && cp < endp);
-    } else {
-	// unsafe variant
-	do {
-	    c = *cp++;
-	    j = (j<<7) | (c & 0x7f);
-	} while ((c & 0x80));
-    }
-    *i = j;
-    return cp-op;
-}
-
-static inline int var_get_u32(uint8_t *cp, const uint8_t *endp, uint32_t *i) {
-    uint8_t *op = cp, c;
-    uint32_t j = 0;
-
-    if (endp) {
-	if (cp >= endp) {
-	    *i = 0;
-	    return 0;
-	}
-
-	if (*cp < 128) {
-	    *i = *cp;
-	    return 1;
-	}
-
-	do {
-	    c = *cp++;
-	    j = (j<<7) | (c & 0x7f);
-	} while ((c & 0x80) && cp < endp);
-    } else {
-	// unsafe variant
-	do {
-	    c = *cp++;
-	    j = (j<<7) | (c & 0x7f);
-	} while ((c & 0x80));
-    }
-
-    *i = j;
-    return cp-op;
-}
-#else
-
-// Little endian 7-bit variable sized integer encoding.
-// The unsigned value is equivalent to LEB128 encoding.
-// For signed, see below.
-// This is also the Google Protocol Buffer and WebAssembly format.
-static inline int var_put_u64(uint8_t *cp, const uint8_t *endp, uint64_t i) {
-    uint8_t *op = cp;
-
-    if (!endp || (endp-cp)*7 >= 10) {
-	// Unsafe or big-enough anyway
-	do {
-	    *cp++ = (i&0x7f) + ((i>=0x80)<<7);
-	    i >>= 7;
-	} while (i);
-    } else if (cp < endp) {
-	// End checked variant
-	do {
-	    *cp++ = (i&0x7f) + ((i>=0x80)<<7);
-	    i >>= 7;
-	} while (i && cp < endp);
-    }
-
-    return cp-op;
-}
-
-static inline int var_put_u32(uint8_t *cp, const uint8_t *endp, uint32_t i) {
-    uint8_t *op = cp;
-
-    if (!endp || (endp-cp)*7 >= 5) {
-	// Unsafe or big-enough anyway
-	do {
-	    *cp++ = (i&0x7f) + ((i>=0x80)<<7);
-	    i >>= 7;
-	} while (i);
-    } else if (cp < endp) {
-	// End checked variant
-	do {
-	    *cp++ = (i&0x7f) + ((i>=0x80)<<7);
-	    i >>= 7;
-	} while (i && cp < endp);
-    }
-
-    return cp-op;
-}
-
-static inline int var_get_u64(uint8_t *cp, const uint8_t *endp, uint64_t *i) {
-    uint8_t *op = cp, c;
-    uint64_t j = 0, s = 0;
-
-    if (endp) {
-	// Safe variant
-	if (cp >= endp) {
-	    *i = 0;
-	    return 0;
-	}
-
-	do {
-	    c = *cp++;
-	    j |= (c & 0x7f) << s;
-	    s += 7;
-	} while ((c & 0x80) && cp < endp);
-    } else {
-	// Unsafe variant
-	do {
-	    c = *cp++;
-	    j |= (c & 0x7f) << s;
-	    s += 7;
-	} while ((c & 0x80));
-    }
-
-    *i = j;
-    return cp-op;
-}
-
-static inline int var_get_u32(uint8_t *cp, const uint8_t *endp, uint32_t *i) {
-    uint8_t *op = cp, c;
-    uint32_t j = 0, s = 0;
-
-    if (endp) {
-	// Safe variant
-	if (cp >= endp) {
-	    *i = 0;
-	    return 0;
-	}
-
-	do {
-	    c = *cp++;
-	    j |= (c & 0x7f) << s;
-	    s += 7;
-	} while ((c & 0x80) && cp < endp);
-    } else {
-	// Unsafe variant
-	do {
-	    c = *cp++;
-	    j |= (c & 0x7f) << s;
-	    s += 7;
-	} while ((c & 0x80));
-    }
-
-    *i = j;
-    return cp-op;
-}
-#endif
-
-// Signed versions of the above using zig-zag integer encoding.
-// This folds the sign bit into the bottom bit so we iterate
-// 0, -1, +1, -2, +2, etc.
-static inline int var_put_s32(uint8_t *cp, const uint8_t *endp, int32_t i) {
-    return var_put_u32(cp, endp, ((uint32_t)i << 1) ^ (i >> 31));
-}
-static inline int var_put_s64(uint8_t *cp, const uint8_t *endp, int64_t i) {
-    return var_put_u64(cp, endp, ((uint64_t)i << 1) ^ (i >> 63));
-}
-
-static inline int var_get_s32(uint8_t *cp, const uint8_t *endp, int32_t *i) {
-    int b = var_get_u32(cp, endp, (uint32_t *)i);
-    *i = ((uint32_t)*i >> 1) ^ -(int32_t)(*i & 1);
-    return b;
-}
-static inline int var_get_s64(uint8_t *cp, const uint8_t *endp, int64_t *i) {
-    int b = var_get_u64(cp, endp, (uint64_t *)i);
-    *i = ((uint64_t)*i >> 1) ^ -(int64_t)(*i & 1);
-    return b;
-}
-
-static inline int var_size_u64(uint64_t v) {
-    int i = 0;
-    do {
-	i++;
-	v >>= 7;
-    } while (v);
-    return i;
-}
-#define var_size_u32 var_size_u64
-
-static inline int var_size_s64(int64_t v) {
-    return var_size_u64(((uint64_t)v << 1) ^ (v >> 63));
-}
-#define var_size_s32 var_size_s64
-
-#endif /* VARINT2 */
-
-#endif /* VARINT_H */
diff -ruN stringtie.orig/htslib/htscodecs/htscodecs/version.h stringtie/htslib/htscodecs/htscodecs/version.h
--- stringtie.orig/htslib/htscodecs/htscodecs/version.h	2024-02-28 13:57:39.704579460 +0100
+++ stringtie/htslib/htscodecs/htscodecs/version.h	1970-01-01 01:00:00.000000000 +0100
@@ -1 +0,0 @@
-#define HTSCODECS_VERSION_TEXT "1.0"
diff -ruN stringtie.orig/htslib/htscodecs_bundled.mk stringtie/htslib/htscodecs_bundled.mk
--- stringtie.orig/htslib/htscodecs_bundled.mk	2024-02-28 13:57:39.701246126 +0100
+++ stringtie/htslib/htscodecs_bundled.mk	1970-01-01 01:00:00.000000000 +0100
@@ -1,62 +0,0 @@
-# Makefile fragment to add settings needed when bundling htscodecs functions
-#
-#    Copyright (C) 2021 Genome Research Ltd.
-#
-#    Author: Rob Davies <rmd@sanger.ac.uk>
-#
-# Permission is hereby granted, free of charge, to any person obtaining a copy
-# of this software and associated documentation files (the "Software"), to deal
-# in the Software without restriction, including without limitation the rights
-# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
-# copies of the Software, and to permit persons to whom the Software is
-# furnished to do so, subject to the following conditions:
-#
-# The above copyright notice and this permission notice shall be included in
-# all copies or substantial portions of the Software.
-#
-# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
-# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
-# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
-# THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
-# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
-# FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
-# DEALINGS IN THE SOFTWARE.
-
-
-HTSCODECS_SOURCES = $(HTSPREFIX)htscodecs/htscodecs/arith_dynamic.c \
-        $(HTSPREFIX)htscodecs/htscodecs/fqzcomp_qual.c \
-        $(HTSPREFIX)htscodecs/htscodecs/htscodecs.c \
-        $(HTSPREFIX)htscodecs/htscodecs/pack.c \
-        $(HTSPREFIX)htscodecs/htscodecs/rANS_static4x16pr.c \
-        $(HTSPREFIX)htscodecs/htscodecs/rANS_static.c \
-        $(HTSPREFIX)htscodecs/htscodecs/rle.c \
-        $(HTSPREFIX)htscodecs/htscodecs/tokenise_name3.c
-
-HTSCODECS_OBJS = $(HTSCODECS_SOURCES:.c=.o)
-
-# htscodecs public headers
-htscodecs_arith_dynamic_h = htscodecs/htscodecs/arith_dynamic.h
-htscodecs_fqzcomp_qual_h = htscodecs/htscodecs/fqzcomp_qual.h
-htscodecs_htscodecs_h = htscodecs/htscodecs/htscodecs.h $(htscodecs_version_h)
-htscodecs_pack_h = htscodecs/htscodecs/pack.h
-htscodecs_rANS_static_h = htscodecs/htscodecs/rANS_static.h
-htscodecs_rANS_static4x16_h = htscodecs/htscodecs/rANS_static4x16.h
-htscodecs_rle_h = htscodecs/htscodecs/rle.h
-htscodecs_tokenise_name3_h = htscodecs/htscodecs/tokenise_name3.h
-htscodecs_varint_h = htscodecs/htscodecs/varint.h
-
-# htscodecs internal headers
-htscodecs_htscodecs_endian_h = htscodecs/htscodecs/htscodecs_endian.h
-htscodecs_c_range_coder_h = htscodecs/htscodecs/c_range_coder.h
-htscodecs_c_simple_model_h = htscodecs/htscodecs/c_simple_model.h $(htscodecs_c_range_coder_h)
-htscodecs_pooled_alloc_h = htscodecs/htscodecs/pooled_alloc.h
-htscodecs_rANS_byte_h = htscodecs/htscodecs/rANS_byte.h
-htscodecs_rANS_word_h = htscodecs/htscodecs/rANS_word.h $(htscodecs_htscodecs_endian_h)
-htscodecs_utils_h = htscodecs/htscodecs/utils.h
-htscodecs_version_h = htscodecs/htscodecs/version.h
-
-# Add htscodecs tests into the HTSlib test framework
-
-#HTSCODECS_TEST_TARGETS = test_htscodecs_rans4x8 \
-#    test_htscodecs_rans4x16 test_htscodecs_arith test_htscodecs_tok3 \
-#    test_htscodecs_fqzcomp test_htscodecs_varint
diff -ruN stringtie.orig/htslib/htscodecs_external.mk stringtie/htslib/htscodecs_external.mk
--- stringtie.orig/htslib/htscodecs_external.mk	2024-02-28 13:57:39.701246126 +0100
+++ stringtie/htslib/htscodecs_external.mk	1970-01-01 01:00:00.000000000 +0100
@@ -1,46 +0,0 @@
-# Makefile fragment for use when linking to an external libhtscodecs
-#
-#    Copyright (C) 2021 Genome Research Ltd.
-#
-#    Author: Rob Davies <rmd@sanger.ac.uk>
-#
-# Permission is hereby granted, free of charge, to any person obtaining a copy
-# of this software and associated documentation files (the "Software"), to deal
-# in the Software without restriction, including without limitation the rights
-# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
-# copies of the Software, and to permit persons to whom the Software is
-# furnished to do so, subject to the following conditions:
-#
-# The above copyright notice and this permission notice shall be included in
-# all copies or substantial portions of the Software.
-#
-# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
-# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
-# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
-# THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
-# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
-# FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
-# DEALINGS IN THE SOFTWARE.
-
-HTSCODECS_SOURCES =
-HTSCODECS_OBJS =
-HTSCODECS_TEST_TARGETS =
-
-htscodecs_arith_dynamic_h =
-htscodecs_fqzcomp_qual_h =
-htscodecs_htscodecs_h =
-htscodecs_pack_h =
-htscodecs_rANS_static_h =
-htscodecs_rANS_static4x16_h =
-htscodecs_rle_h =
-htscodecs_tokenise_name3_h =
-htscodecs_varint_h =
-
-htscodecs_htscodecs_endian_h =
-htscodecs_c_range_coder_h =
-htscodecs_c_simple_model_h =
-htscodecs_pooled_alloc_h =
-htscodecs_rANS_byte_h =
-htscodecs_rANS_word_h =
-htscodecs_utils_h =
-htscodecs_version_h =
diff -ruN stringtie.orig/htslib/htscodecs.mk stringtie/htslib/htscodecs.mk
--- stringtie.orig/htslib/htscodecs.mk	2024-02-28 13:57:39.701246126 +0100
+++ stringtie/htslib/htscodecs.mk	1970-01-01 01:00:00.000000000 +0100
@@ -1,2 +0,0 @@
-# Default htscodecs.mk generated by Makefile
-include $(HTSPREFIX)htscodecs_bundled.mk
diff -ruN stringtie.orig/htslib/htscodecs.mk.in stringtie/htslib/htscodecs.mk.in
--- stringtie.orig/htslib/htscodecs.mk.in	2024-02-28 13:57:39.701246126 +0100
+++ stringtie/htslib/htscodecs.mk.in	1970-01-01 01:00:00.000000000 +0100
@@ -1,5 +0,0 @@
-# This is @configure_input@
-
-# This file selects Makefile rules for htscodecs
-
-include $(HTSPREFIX)@selected_htscodecs_mk@
diff -ruN stringtie.orig/htslib/hts_expr.c stringtie/htslib/hts_expr.c
--- stringtie.orig/htslib/hts_expr.c	2024-02-28 13:57:39.701246126 +0100
+++ stringtie/htslib/hts_expr.c	1970-01-01 01:00:00.000000000 +0100
@@ -1,705 +0,0 @@
-/*  hts_expr.c -- filter expression parsing and processing.
-
-    Copyright (C) 2020-2021 Genome Research Ltd.
-
-    Author: James Bonfield <jkb@sanger.ac.uk>
-
-Permission is hereby granted, free of charge, to any person obtaining a copy
-of this software and associated documentation files (the "Software"), to deal
-in the Software without restriction, including without limitation the rights
-to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
-copies of the Software, and to permit persons to whom the Software is
-furnished to do so, subject to the following conditions:
-
-The above copyright notices and this permission notice shall be included in
-all copies or substantial portions of the Software.
-
-THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
-IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
-FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
-THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
-LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
-FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
-DEALINGS IN THE SOFTWARE.  */
-
-// TODO:
-// - add maths functions.  pow, sqrt, log, ?
-// - ?: operator for conditionals?
-
-#define HTS_BUILDING_LIBRARY // Enables HTSLIB_EXPORT, see htslib/hts_defs.h
-#include <config.h>
-
-#include <stdio.h>
-#include <string.h>
-#include <ctype.h>
-#include <stdlib.h>
-#include <stdint.h>
-#include <float.h>
-#include <regex.h>
-#include <math.h>
-
-#include "htslib/hts_expr.h"
-#include "textutils_internal.h"
-
-// Could also cache hts_expr_val_t stack here for kstring reuse?
-#define MAX_REGEX 10
-struct hts_filter_t {
-    char *str;
-    int parsed;
-    int curr_regex, max_regex;
-    regex_t preg[MAX_REGEX];
-};
-
-/*
- * This is designed to be mostly C like with mostly same the precedence rules,
- * with the exception of bit operators (widely considered as a mistake in C).
- * It's not full C (eg no bit-shifting), but good enough for our purposes.
- *
- * Supported syntax, in order of precedence:
- *
- * Grouping:      (, ),   eg "(1+2)*3"
- * Values:        integers, floats, strings or variables
- * Unary ops:     +, -, !, ~  eg -10 +10, !10 (0), ~5 (bitwise not)
- * Math ops:      *, /, %  [TODO: add // for floor division?]
- * Math ops:      +, -
- * Bit-wise:      &, ^, |  [NB as 3 precedence levels, in that order]
- * Conditionals:  >, >=, <, <=,
- * Equality:      ==, !=, =~, !~
- * Boolean:       &&, ||
- */
-
-// Skip to start of term
-static char *ws(char *str) {
-    while (*str && (*str == ' ' || *str == '\t'))
-        str++;
-    return str;
-}
-
-static int expression(hts_filter_t *filt, void *data, hts_expr_sym_func *fn,
-                      char *str, char **end, hts_expr_val_t *res);
-
-/*
- * Simple functions operating on strings only.
- * length, min, max, avg.
- *
- * All return 0 on success,
- *           -1 on failure
- */
-static int expr_func_length(hts_expr_val_t *res) {
-    if (!res->is_str)
-        return -1;
-
-    res->is_str = 0;
-    res->d = res->s.l;
-    return 0;
-}
-
-static int expr_func_min(hts_expr_val_t *res) {
-    if (!res->is_str)
-        return -1;
-
-    size_t l = res->s.l;
-    int v = INT_MAX;
-    const uint8_t *x = (uint8_t *)res->s.s;
-    for (l = 0; l < res->s.l; l++)
-        if (v > x[l])
-            v = x[l];
-
-    res->is_str = 0;
-    res->d = v == INT_MAX ? NAN : v;
-
-    return 0;
-}
-
-static int expr_func_max(hts_expr_val_t *res) {
-    if (!res->is_str)
-        return -1;
-
-    size_t l = res->s.l;
-    int v = INT_MIN;
-    const uint8_t *x = (uint8_t *)res->s.s;
-    for (l = 0; l < res->s.l; l++)
-        if (v < x[l])
-            v = x[l];
-
-    res->is_str = 0;
-    res->d = v == INT_MIN ? NAN : v;
-
-    return 0;
-}
-
-static int expr_func_avg(hts_expr_val_t *res) {
-    if (!res->is_str)
-        return -1;
-
-    size_t l = res->s.l;
-    double v = 0;
-    const uint8_t *x = (uint8_t *)res->s.s;
-    for (l = 0; l < res->s.l; l++)
-        v += x[l];
-    if (l)
-        v /= l;
-
-    res->is_str = 0;
-    res->d = v;
-
-    return 0;
-}
-
-/*
- * functions:  FUNC(expr).
- * Note for simplicity of parsing, the "(" must immediately follow FUNC,
- * so "FUNC (x)" is invalid.
- */
-static int func_expr(hts_filter_t *filt, void *data, hts_expr_sym_func *fn,
-                     char *str, char **end, hts_expr_val_t *res) {
-    int func_ok = -1;
-    switch (*str) {
-    case 'a':
-        if (strncmp(str, "avg(", 4) == 0) {
-            if (expression(filt, data, fn, str+4, end, res)) return -1;
-            func_ok = expr_func_avg(res);
-        }
-        break;
-
-    case 'l':
-        if (strncmp(str, "length(", 7) == 0) {
-            if (expression(filt, data, fn, str+7, end, res)) return -1;
-            func_ok = expr_func_length(res);
-        }
-        break;
-
-    case 'm':
-        if (strncmp(str, "min(", 4) == 0) {
-            if (expression(filt, data, fn, str+4, end, res)) return -1;
-            func_ok = expr_func_min(res);
-        } else if (strncmp(str, "max(", 4) == 0) {
-            if (expression(filt, data, fn, str+4, end, res)) return -1;
-            func_ok = expr_func_max(res);
-        }
-        break;
-    }
-
-    if (func_ok < 0)
-        return -1;
-
-    str = ws(*end);
-    if (*str != ')') {
-        fprintf(stderr, "Missing ')'\n");
-        return -1;
-    }
-    *end = str+1;
-
-    return 0;
-}
-
-/*
- * simple_expr
- *     : identifier
- *     | constant
- *     | string
- *     | func_expr
- *     | '(' expression ')'
-*/
-static int simple_expr(hts_filter_t *filt, void *data, hts_expr_sym_func *fn,
-                       char *str, char **end, hts_expr_val_t *res) {
-    // Main recursion step
-    str = ws(str);
-    if (*str == '(') {
-        if (expression(filt, data, fn, str+1, end, res)) return -1;
-        str = ws(*end);
-        if (*str != ')') {
-            fprintf(stderr, "Missing ')'\n");
-            return -1;
-        }
-        *end = str+1;
-
-        return 0;
-    }
-
-    // Otherwise a basic element.
-    int fail = 0;
-    double d = hts_str2dbl(str, end, &fail);
-    if (str != *end) {
-        res->is_str = 0;
-        res->d = d;
-    } else {
-        // Not valid floating point syntax.
-        // TODO: add function call names in here; len(), sqrt(), pow(), etc
-        if (*str == '"') {
-            res->is_str = 1;
-            char *e = str+1;
-            int backslash = 0;
-            while (*e && *e != '"') {
-                if (*e == '\\')
-                    backslash=1, e+=1+(e[1]!='\0');
-                else
-                    e++;
-            }
-
-            kputsn(str+1, e-(str+1), ks_clear(&res->s));
-            if (backslash) {
-                size_t i, j;
-                for (i = j = 0; i < res->s.l; i++) {
-                    res->s.s[j++] = res->s.s[i];
-                    if (res->s.s[i] == '\\') {
-                        switch (res->s.s[++i]) {
-                        case '"': res->s.s[j-1] = '"'; break;
-                        case '\\':res->s.s[j-1] = '\\'; break;
-                        case 't': res->s.s[j-1] = '\t'; break;
-                        case 'n': res->s.s[j-1] = '\n'; break;
-                        case 'r': res->s.s[j-1] = '\r'; break;
-                        default:  res->s.s[j++] = res->s.s[i];
-                        }
-                    }
-                }
-                res->s.s[j] = 0;
-                res->s.l = j;
-            }
-            if (*e != '"')
-                return -1;
-            *end = e+1;
-        } else if (fn) {
-            // Try lookup as variable, if not as function
-            if (fn(data, str, end, res) == 0)
-                return 0;
-            else
-                return func_expr(filt, data, fn, str, end, res);
-        } else {
-            return -1;
-        }
-    }
-
-    return 0;
-}
-
-/*
- * unary_expr
- *     : simple_expr
- *     | '+' simple_expr
- *     | '-' simple_expr
- *     | '!' unary_expr // higher precedence
- *     | '~' unary_expr // higher precedence
- */
-static int unary_expr(hts_filter_t *filt, void *data, hts_expr_sym_func *fn,
-                      char *str, char **end, hts_expr_val_t *res) {
-    int err;
-    str = ws(str);
-    if (*str == '+') {
-        err = simple_expr(filt, data, fn, str+1, end, res);
-        err |= res->is_str;
-        res->is_true = res->d != 0;
-    } else if (*str == '-') {
-        err = simple_expr(filt, data, fn, str+1, end, res);
-        err |= res->is_str;
-        res->d = -res->d;
-        res->is_true = res->d != 0;
-    } else if (*str == '!') {
-        err = unary_expr(filt, data, fn, str+1, end, res);
-        if (res->is_str) {
-            res->is_str = 0;
-            res->d = 0;
-            res->is_true = !res->is_true;
-        } else {
-            res->d = !(int64_t)res->d;
-            res->is_true = res->d != 0;
-        }
-    } else if (*str == '~') {
-        err = unary_expr(filt, data, fn, str+1, end, res);
-        err |= res->is_str;
-        res->d = ~(int64_t)res->d;
-        res->is_true = res->d != 0;
-    } else {
-        err = simple_expr(filt, data, fn, str, end, res);
-    }
-    return err ? -1 : 0;
-}
-
-
-/*
- * mul_expr
- *     : unary_expr (
- *           '*' unary_expr
- *         | '/' unary_expr
- *         | '%' unary_expr
- *       )*
- */
-static int mul_expr(hts_filter_t *filt, void *data, hts_expr_sym_func *fn,
-                    char *str, char **end, hts_expr_val_t *res) {
-    if (unary_expr(filt, data, fn, str, end, res))
-        return -1;
-
-    str = *end;
-    hts_expr_val_t val = HTS_EXPR_VAL_INIT;
-    while (*str) {
-        str = ws(str);
-        if (*str == '*' || *str == '/' || *str == '%') {
-            if (unary_expr(filt, data, fn, str+1, end, &val)) return -1;
-            if (val.is_str || res->is_str) {
-                hts_expr_val_free(&val);
-                return -1; // arith on strings
-            }
-        }
-
-        if (*str == '*')
-            res->d *= val.d;
-        else if (*str == '/')
-            res->d /= val.d;
-        else if (*str == '%')
-            res->d = (int64_t)res->d % (int64_t)val.d;
-        else
-            break;
-
-        str = *end;
-    }
-    hts_expr_val_free(&val);
-
-    return 0;
-}
-
-/*
- * add_expr
- *     : mul_expr (
- *           '+' mul_expr
- *         | '-' mul_expr
- *       )*
- */
-static int add_expr(hts_filter_t *filt, void *data, hts_expr_sym_func *fn,
-                    char *str, char **end, hts_expr_val_t *res) {
-    if (mul_expr(filt, data, fn, str, end, res))
-        return -1;
-
-    str = *end;
-    hts_expr_val_t val = HTS_EXPR_VAL_INIT;
-    while (*str) {
-        str = ws(str);
-        if (*str == '+' || *str == '-') {
-            if (mul_expr(filt, data, fn, str+1, end, &val)) return -1;
-            if (val.is_str || res->is_str) {
-                hts_expr_val_free(&val);
-                return -1; // arith on strings
-            }
-        }
-
-        if (*str == '+')
-            res->d += val.d;
-        else if (*str == '-')
-            res->d -= val.d;
-        else
-            break;
-
-        str = *end;
-    }
-    hts_expr_val_free(&val);
-
-    return 0;
-}
-
-/*
- * bitand_expr
- *     : add_expr
- *     | bitand_expr '&' add_expr
- */
-static int bitand_expr(hts_filter_t *filt, void *data, hts_expr_sym_func *fn,
-                       char *str, char **end, hts_expr_val_t *res) {
-    if (add_expr(filt, data, fn, str, end, res)) return -1;
-
-    hts_expr_val_t val = HTS_EXPR_VAL_INIT;
-    for (;;) {
-        str = ws(*end);
-        if (*str == '&' && str[1] != '&') {
-            if (add_expr(filt, data, fn, str+1, end, &val)) return -1;
-            if (res->is_str || val.is_str) {
-                hts_expr_val_free(&val);
-                return -1;
-            }
-            res->is_true = (res->d = ((int64_t)res->d & (int64_t)val.d)) != 0;
-        } else {
-            break;
-        }
-    }
-    hts_expr_val_free(&val);
-
-    return 0;
-}
-
-/*
- * bitxor_expr
- *     : bitand_expr
- *     | bitxor_expr '^' bitand_expr
- */
-static int bitxor_expr(hts_filter_t *filt, void *data, hts_expr_sym_func *fn,
-                       char *str, char **end, hts_expr_val_t *res) {
-    if (bitand_expr(filt, data, fn, str, end, res)) return -1;
-
-    hts_expr_val_t val = HTS_EXPR_VAL_INIT;
-    for (;;) {
-        str = ws(*end);
-        if (*str == '^') {
-            if (bitand_expr(filt, data, fn, str+1, end, &val)) return -1;
-            if (res->is_str || val.is_str) {
-                hts_expr_val_free(&val);
-                return -1;
-            }
-            res->is_true = (res->d = ((int64_t)res->d ^ (int64_t)val.d)) != 0;
-        } else {
-            break;
-        }
-    }
-    hts_expr_val_free(&val);
-
-    return 0;
-}
-
-/*
- * bitor_expr
- *     : bitxor_expr
- *     | bitor_expr '|' bitxor_expr
- */
-static int bitor_expr(hts_filter_t *filt, void *data, hts_expr_sym_func *fn,
-                      char *str, char **end, hts_expr_val_t *res) {
-    if (bitxor_expr(filt, data, fn, str, end, res)) return -1;
-
-    hts_expr_val_t val = HTS_EXPR_VAL_INIT;
-    for (;;) {
-        str = ws(*end);
-        if (*str == '|' && str[1] != '|') {
-            if (bitxor_expr(filt, data, fn, str+1, end, &val)) return -1;
-            if (res->is_str || val.is_str) {
-                hts_expr_val_free(&val);
-                return -1;
-            }
-            res->is_true = (res->d = ((int64_t)res->d | (int64_t)val.d)) != 0;
-        } else {
-            break;
-        }
-    }
-    hts_expr_val_free(&val);
-
-    return 0;
-}
-
-/*
- * cmp_expr
- *     : bitor_expr
- *     | cmp_expr '<=' bitor_expr
- *     | cmp_expr '<'  bitor_expr
- *     | cmp_expr '>=' bitor_expr
- *     | cmp_expr '>'  bitor_expr
- */
-static int cmp_expr(hts_filter_t *filt, void *data, hts_expr_sym_func *fn,
-                    char *str, char **end, hts_expr_val_t *res) {
-    if (bitor_expr(filt, data, fn, str, end, res)) return -1;
-
-    str = ws(*end);
-    hts_expr_val_t val = HTS_EXPR_VAL_INIT;
-    int err = 0;
-
-    if (*str == '>' && str[1] == '=') {
-        err = cmp_expr(filt, data, fn, str+2, end, &val);
-        res->is_true=res->d = res->is_str && res->s.s && val.is_str && val.s.s
-            ? strcmp(res->s.s, val.s.s) >= 0
-            : !res->is_str && !val.is_str && res->d >= val.d;
-        res->is_str = 0;
-    } else if (*str == '>') {
-        err = cmp_expr(filt, data, fn, str+1, end, &val);
-        res->is_true=res->d = res->is_str && res->s.s && val.is_str && val.s.s
-            ? strcmp(res->s.s, val.s.s) > 0
-            : !res->is_str && !val.is_str && res->d > val.d;
-        res->is_str = 0;
-    } else if (*str == '<' && str[1] == '=') {
-        err = cmp_expr(filt, data, fn, str+2, end, &val);
-        res->is_true=res->d = res->is_str && res->s.s && val.is_str && val.s.s
-            ? strcmp(res->s.s, val.s.s) <= 0
-            : !res->is_str && !val.is_str && res->d <= val.d;
-        res->is_str = 0;
-    } else if (*str == '<') {
-        err = cmp_expr(filt, data, fn, str+1, end, &val);
-        res->is_true=res->d = res->is_str && res->s.s && val.is_str && val.s.s
-            ? strcmp(res->s.s, val.s.s) < 0
-            : !res->is_str && !val.is_str && res->d < val.d;
-        res->is_str = 0;
-    }
-    hts_expr_val_free(&val);
-
-    return err ? -1 : 0;
-}
-
-/*
- * eq_expr
- *     : cmp_expr
- *     | eq_expr '==' cmp_expr
- *     | eq_expr '!=' cmp_expr
- *     | eq_expr '=~' cmp_expr
- *     | eq_expr '!~' cmp_expr
- */
-static int eq_expr(hts_filter_t *filt, void *data, hts_expr_sym_func *fn,
-                   char *str, char **end, hts_expr_val_t *res) {
-    if (cmp_expr(filt, data, fn, str, end, res)) return -1;
-
-    str = ws(*end);
-
-    int err = 0;
-    hts_expr_val_t val = HTS_EXPR_VAL_INIT;
-
-    // numeric vs numeric comparison is as expected
-    // string vs string comparison is as expected
-    // numeric vs string is false
-    if (str[0] == '=' && str[1] == '=') {
-        if ((err = eq_expr(filt, data, fn, str+2, end, &val))) {
-            res->is_true = res->d = 0;
-        } else {
-            res->is_true = res->d = res->is_str
-                ? (res->s.s && val.s.s ? strcmp(res->s.s, val.s.s)==0 : 0)
-                : !res->is_str && !val.is_str && res->d == val.d;
-        }
-        res->is_str = 0;
-
-    } else if (str[0] == '!' && str[1] == '=') {
-        if ((err = eq_expr(filt, data, fn, str+2, end, &val))) {
-            res->is_true = res->d = 0;
-        } else {
-            res->is_true = res->d = res->is_str
-                ? (res->s.s && val.s.s ? strcmp(res->s.s, val.s.s) != 0 : 1)
-                : res->is_str != val.is_str || res->d != val.d;
-        }
-        res->is_str = 0;
-
-    } else if ((str[0] == '=' && str[1] == '~') ||
-               (str[0] == '!' && str[1] == '~')) {
-        err = eq_expr(filt, data, fn, str+2, end, &val);
-        if (!val.is_str || !res->is_str) {
-            hts_expr_val_free(&val);
-            return -1;
-        }
-        if (val.s.s && res->s.s && val.is_true >= 0 && res->is_true >= 0) {
-            regex_t preg_, *preg;
-            if (filt->curr_regex >= filt->max_regex) {
-                // Compile regex if not seen before
-                if (filt->curr_regex >= MAX_REGEX) {
-                    preg = &preg_;
-                } else {
-                    preg = &filt->preg[filt->curr_regex];
-                    filt->max_regex++;
-                }
-
-                int ec = regcomp(preg, val.s.s, REG_EXTENDED | REG_NOSUB);
-                if (ec != 0) {
-                    char errbuf[1024];
-                    regerror(ec, preg, errbuf, 1024);
-                    fprintf(stderr, "Failed regex: %.1024s\n", errbuf);
-                    hts_expr_val_free(&val);
-                    return -1;
-                }
-            } else {
-                preg = &filt->preg[filt->curr_regex];
-            }
-            res->is_true = res->d = regexec(preg, res->s.s, 0, NULL, 0) == 0
-                ? *str == '='  // matcn
-                : *str == '!'; // no-match
-            if (preg == &preg_)
-                regfree(preg);
-
-            filt->curr_regex++;
-        } else {
-            // nul regexp or input is considered false
-            res->is_true = 0;
-        }
-        res->is_str = 0;
-    }
-    hts_expr_val_free(&val);
-
-    return err ? -1 : 0;
-}
-
-/*
- * and_expr
- *     : eq_expr
- *     | and_expr 'and' eq_expr
- *     | and_expr 'or'  eq_expr
- */
-static int and_expr(hts_filter_t *filt, void *data, hts_expr_sym_func *fn,
-                    char *str, char **end, hts_expr_val_t *res) {
-    if (eq_expr(filt, data, fn, str, end, res)) return -1;
-
-    hts_expr_val_t val = HTS_EXPR_VAL_INIT;
-    for (;;) {
-        str = ws(*end);
-        if (str[0] == '&' && str[1] == '&') {
-            if (eq_expr(filt, data, fn, str+2, end, &val)) return -1;
-            res->is_true = res->d =
-                (res->is_true || (res->is_str && res->s.s) || res->d) &&
-                (val.is_true  || (val.is_str && val.s.s) || val.d);
-            res->is_str = 0;
-        } else if (str[0] == '|' && str[1] == '|') {
-            if (eq_expr(filt, data, fn, str+2, end, &val)) return -1;
-            res->is_true = res->d =
-                res->is_true || (res->is_str && res->s.s) || res->d ||
-                val.is_true  || (val.is_str  && val.s.s ) || val.d;
-            res->is_str = 0;
-        } else {
-            break;
-        }
-    }
-    hts_expr_val_free(&val);
-
-    return 0;
-}
-
-static int expression(hts_filter_t *filt, void *data, hts_expr_sym_func *fn,
-                      char *str, char **end, hts_expr_val_t *res) {
-    return and_expr(filt, data, fn, str, end, res);
-}
-
-hts_filter_t *hts_filter_init(const char *str) {
-    hts_filter_t *f = calloc(1, sizeof(*f));
-    if (!f) return NULL;
-
-    // Oversize to permit faster comparisons with memcmp over strcmp
-    size_t len = strlen(str)+100;
-    if (!(f->str = malloc(len))) {
-        free(f);
-        return NULL;
-    }
-    strcpy(f->str, str);
-    return f;
-}
-
-void hts_filter_free(hts_filter_t *filt) {
-    if (!filt)
-        return;
-
-    int i;
-    for (i = 0; i < filt->max_regex; i++)
-        regfree(&filt->preg[i]);
-
-    free(filt->str);
-    free(filt);
-}
-
-int hts_filter_eval(hts_filter_t *filt,
-                    void *data, hts_expr_sym_func *fn,
-                    hts_expr_val_t *res) {
-    char *end = NULL;
-
-    memset(res, 0, sizeof(*res));
-
-    filt->curr_regex = 0;
-    if (expression(filt, data, fn, filt->str, &end, res))
-        return -1;
-
-    if (end && *ws(end)) {
-        fprintf(stderr, "Unable to parse expression at %s\n", filt->str);
-        return -1;
-    }
-
-    // Strings evaluate to true.  An empty string is also true, but an
-    // absent (null) string is false.  An empty string has kstring length
-    // of zero, but a pointer as it's nul-terminated.
-    if (res->is_str)
-        res->is_true = res->d = res->s.s != NULL;
-    else
-        res->is_true |= res->d != 0;
-
-    return 0;
-}
diff -ruN stringtie.orig/htslib/hts_internal.h stringtie/htslib/hts_internal.h
--- stringtie.orig/htslib/hts_internal.h	2024-02-28 13:57:39.701246126 +0100
+++ stringtie/htslib/hts_internal.h	1970-01-01 01:00:00.000000000 +0100
@@ -1,152 +0,0 @@
-/*  hts_internal.h -- internal functions; not part of the public API.
-
-    Copyright (C) 2015-2016, 2018-2020 Genome Research Ltd.
-
-Permission is hereby granted, free of charge, to any person obtaining a copy
-of this software and associated documentation files (the "Software"), to deal
-in the Software without restriction, including without limitation the rights
-to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
-copies of the Software, and to permit persons to whom the Software is
-furnished to do so, subject to the following conditions:
-
-The above copyright notice and this permission notice shall be included in
-all copies or substantial portions of the Software.
-
-THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
-IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
-FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
-THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
-LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
-FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
-DEALINGS IN THE SOFTWARE.  */
-
-#ifndef HTSLIB_HTS_INTERNAL_H
-#define HTSLIB_HTS_INTERNAL_H
-
-#include <stddef.h>
-#include <ctype.h>
-
-#include "htslib/hts.h"
-#include "textutils_internal.h"
-
-#define HTS_MAX_EXT_LEN 8
-
-#ifdef __cplusplus
-extern "C" {
-#endif
-
-struct hFILE;
-
-struct hts_json_token {
-    char type;    ///< Token type
-    char *str;    ///< Value as a C string (filled in for all token types)
-    // TODO Add other fields to fill in for particular data types, e.g.
-    // int inum;
-    // float fnum;
-};
-
-struct cram_fd;
-
-/*
- * Check the existence of a local index file using part of the alignment file name.
- * The order is alignment.bam.csi, alignment.csi, alignment.bam.bai, alignment.bai
- * @param fn    - pointer to the file name
- * @param fnidx - pointer to the index file name placeholder
- * @return        1 for success, 0 for failure
- */
-int hts_idx_check_local(const char *fn, int fmt, char **fnidx);
-
-// Retrieve the name of the index file and also download it, if it is remote
-char *hts_idx_getfn(const char *fn, const char *ext);
-
-// Retrieve the name of the index file, but do not download it, if it is remote
-char *hts_idx_locatefn(const char *fn, const char *ext);
-
-// Used for on-the-fly indexing.  See the comments in hts.c.
-void hts_idx_amend_last(hts_idx_t *idx, uint64_t offset);
-
-int hts_idx_fmt(hts_idx_t *idx);
-
-// Construct a unique filename based on fname and open it.
-struct hFILE *hts_open_tmpfile(const char *fname, const char *mode, kstring_t *tmpname);
-
-// Check that index is capable of storing items in range beg..end
-int hts_idx_check_range(hts_idx_t *idx, int tid, hts_pos_t beg, hts_pos_t end);
-
-// The CRAM implementation stores the loaded index within the cram_fd rather
-// than separately as is done elsewhere in htslib.  So if p is a pointer to
-// an hts_idx_t with p->fmt == HTS_FMT_CRAI, then it actually points to an
-// hts_cram_idx_t and should be cast accordingly.
-typedef struct hts_cram_idx_t {
-    int fmt;
-    struct cram_fd *cram;
-} hts_cram_idx_t;
-
-
-// Entry point to hFILE_multipart backend.
-struct hFILE *hopen_htsget_redirect(struct hFILE *hfile, const char *mode);
-
-struct hts_path_itr {
-    kstring_t path, entry;
-    void *dirv;  // DIR * privately
-    const char *pathdir, *prefix, *suffix;
-    size_t prefix_len, suffix_len, entry_dir_l;
-};
-
-void hts_path_itr_setup(struct hts_path_itr *itr, const char *path,
-    const char *builtin_path, const char *prefix, size_t prefix_len,
-    const char *suffix, size_t suffix_len);
-
-const char *hts_path_itr_next(struct hts_path_itr *itr);
-
-typedef void plugin_void_func(void);
-plugin_void_func *load_plugin(void **pluginp, const char *filename, const char *symbol);
-void *plugin_sym(void *plugin, const char *name, const char **errmsg);
-plugin_void_func *plugin_func(void *plugin, const char *name, const char **errmsg);
-void close_plugin(void *plugin);
-const char *hts_plugin_path(void);
-
-/*
- * Buffers up arguments to hts_idx_push for later use, once we've written all bar
- * this block.  This is necessary when multiple blocks are in flight (threading).
- *
- * Returns 0 on success,
- *        -1 on failure
- */
-int bgzf_idx_push(BGZF *fp, hts_idx_t *hidx, int tid, hts_pos_t beg, hts_pos_t end, uint64_t offset, int is_mapped);
-
-/*
- * bgzf analogue to hts_idx_amend_last.
- *
- * This is needed when multi-threading and writing indices on the fly.
- * At the point of writing a record we know the virtual offset for start
- * and end, but that end virtual offset may be the end of the current
- * block.  In standard indexing our end virtual offset becomes the start
- * of the next block.  Thus to ensure bit for bit compatibility we
- * detect this boundary case and fix it up here.
- */
-void bgzf_idx_amend_last(BGZF *fp, hts_idx_t *hidx, uint64_t offset);
-
-static inline int find_file_extension(const char *fn, char ext_out[static HTS_MAX_EXT_LEN])
-{
-    const char *delim = fn ? strstr(fn, HTS_IDX_DELIM) : NULL, *ext;
-    if (!fn) return -1;
-    if (!delim) delim = fn + strlen(fn);
-    for (ext = delim; ext > fn && *ext != '.' && *ext != '/'; --ext) {}
-    if (*ext == '.' &&
-        ((delim - ext == 3 && ext[1] == 'g' && ext[2] == 'z') || // permit .sam.gz as a valid file extension
-        (delim - ext == 4 && ext[1] == 'b' && ext[2] == 'g' && ext[3] == 'z'))) // permit .vcf.bgz as a valid file extension
-    {
-        for (ext--; ext > fn && *ext != '.' && *ext != '/'; --ext) {}
-    }
-    if (*ext != '.' || delim - ext > HTS_MAX_EXT_LEN || delim - ext < 4) return -1;
-    memcpy(ext_out, ext + 1, delim - ext - 1);
-    ext_out[delim - ext - 1] = '\0';
-    return 0;
-}
-
-#ifdef __cplusplus
-}
-#endif
-
-#endif
diff -ruN stringtie.orig/htslib/htslib/bgzf.h stringtie/htslib/htslib/bgzf.h
--- stringtie.orig/htslib/htslib/bgzf.h	2024-02-28 13:57:39.704579460 +0100
+++ stringtie/htslib/htslib/bgzf.h	1970-01-01 01:00:00.000000000 +0100
@@ -1,453 +0,0 @@
-/// @file htslib/bgzf.h
-/// Low-level routines for direct BGZF operations.
-/*
-   Copyright (c) 2008 Broad Institute / Massachusetts Institute of Technology
-                 2011, 2012 Attractive Chaos <attractor@live.co.uk>
-   Copyright (C) 2009, 2013, 2014, 2017, 2018-2019 Genome Research Ltd
-
-   Permission is hereby granted, free of charge, to any person obtaining a copy
-   of this software and associated documentation files (the "Software"), to deal
-   in the Software without restriction, including without limitation the rights
-   to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
-   copies of the Software, and to permit persons to whom the Software is
-   furnished to do so, subject to the following conditions:
-
-   The above copyright notice and this permission notice shall be included in
-   all copies or substantial portions of the Software.
-
-   THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
-   IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
-   FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
-   AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
-   LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
-   OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
-   THE SOFTWARE.
-*/
-
-/* The BGZF library was originally written by Bob Handsaker from the Broad
- * Institute. It was later improved by the SAMtools developers. */
-
-#ifndef HTSLIB_BGZF_H
-#define HTSLIB_BGZF_H
-
-#include <stdint.h>
-#include <sys/types.h>
-
-#include "hts_defs.h"
-
-#ifdef __cplusplus
-extern "C" {
-#endif
-
-#define BGZF_BLOCK_SIZE     0xff00 // make sure compressBound(BGZF_BLOCK_SIZE) < BGZF_MAX_BLOCK_SIZE
-#define BGZF_MAX_BLOCK_SIZE 0x10000
-
-#define BGZF_ERR_ZLIB   1
-#define BGZF_ERR_HEADER 2
-#define BGZF_ERR_IO     4
-#define BGZF_ERR_MISUSE 8
-#define BGZF_ERR_MT     16 // stream cannot be multi-threaded
-#define BGZF_ERR_CRC    32
-
-struct hFILE;
-struct hts_tpool;
-struct kstring_t;
-struct bgzf_mtaux_t;
-typedef struct bgzidx_t bgzidx_t;
-typedef struct bgzf_cache_t bgzf_cache_t;
-struct z_stream_s;
-
-struct BGZF {
-    // Reserved bits should be written as 0; read as "don't care"
-    unsigned errcode:16, reserved:1, is_write:1, no_eof_block:1, is_be:1;
-    signed compress_level:9;
-    unsigned last_block_eof:1, is_compressed:1, is_gzip:1;
-    int cache_size;
-    int block_length, block_clength, block_offset;
-    int64_t block_address, uncompressed_address;
-    void *uncompressed_block, *compressed_block;
-    bgzf_cache_t *cache;
-    struct hFILE *fp; // actual file handle
-    struct bgzf_mtaux_t *mt; // only used for multi-threading
-    bgzidx_t *idx;      // BGZF index
-    int idx_build_otf;  // build index on the fly, set by bgzf_index_build_init()
-    struct z_stream_s *gz_stream; // for gzip-compressed files
-    int64_t seeked;     // virtual offset of last seek
-};
-#ifndef HTS_BGZF_TYPEDEF
-typedef struct BGZF BGZF;
-#define HTS_BGZF_TYPEDEF
-#endif
-
-    /******************
-     * Basic routines *
-     ******************/
-
-    /**
-     * Open an existing file descriptor for reading or writing.
-     *
-     * @param fd    file descriptor
-     *              Note that the file must be opened in binary mode, or else
-     *              there will be problems on platforms that make a difference
-     *              between text and binary mode.
-     * @param mode  mode matching /[rwag][u0-9]+/: 'r' for reading, 'w' for
-     *              writing, 'a' for appending, 'g' for gzip rather than BGZF
-     *              compression (with 'w' only), and digit specifies the zlib
-     *              compression level.
-     *              Note that there is a distinction between 'u' and '0': the
-     *              first yields plain uncompressed output whereas the latter
-     *              outputs uncompressed data wrapped in the zlib format.
-     * @return      BGZF file handler; 0 on error
-     */
-    HTSLIB_EXPORT
-    BGZF* bgzf_dopen(int fd, const char *mode);
-
-    #define bgzf_fdopen(fd, mode) bgzf_dopen((fd), (mode)) // for backward compatibility
-
-    /**
-     * Open the specified file for reading or writing.
-     */
-    HTSLIB_EXPORT
-    BGZF* bgzf_open(const char* path, const char *mode);
-
-    /**
-     * Open an existing hFILE stream for reading or writing.
-     */
-    HTSLIB_EXPORT
-    BGZF* bgzf_hopen(struct hFILE *fp, const char *mode);
-
-    /**
-     * Close the BGZF and free all associated resources.
-     *
-     * @param fp    BGZF file handler
-     * @return      0 on success and -1 on error
-     */
-    HTSLIB_EXPORT
-    int bgzf_close(BGZF *fp);
-
-    /**
-     * Read up to _length_ bytes from the file storing into _data_.
-     *
-     * @param fp     BGZF file handler
-     * @param data   data array to read into
-     * @param length size of data to read
-     * @return       number of bytes actually read; 0 on end-of-file and -1 on error
-     */
-    HTSLIB_EXPORT
-    ssize_t bgzf_read(BGZF *fp, void *data, size_t length) HTS_RESULT_USED;
-
-    /**
-     * Write _length_ bytes from _data_ to the file.  If no I/O errors occur,
-     * the complete _length_ bytes will be written (or queued for writing).
-     *
-     * @param fp     BGZF file handler
-     * @param data   data array to write
-     * @param length size of data to write
-     * @return       number of bytes written (i.e., _length_); negative on error
-     */
-    HTSLIB_EXPORT
-    ssize_t bgzf_write(BGZF *fp, const void *data, size_t length) HTS_RESULT_USED;
-
-    /**
-     * Write _length_ bytes from _data_ to the file, the index will be used to
-     * decide the amount of uncompressed data to be written to each bgzip block.
-     * If no I/O errors occur, the complete _length_ bytes will be written (or
-     * queued for writing).
-     * @param fp     BGZF file handler
-     * @param data   data array to write
-     * @param length size of data to write
-     * @return       number of bytes written (i.e., _length_); negative on error
-     */
-    HTSLIB_EXPORT
-    ssize_t bgzf_block_write(BGZF *fp, const void *data, size_t length);
-
-    /**
-     * Returns the next byte in the file without consuming it.
-     * @param fp     BGZF file handler
-     * @return       -1 on EOF,
-     *               -2 on error,
-     *               otherwise the unsigned byte value.
-     */
-    HTSLIB_EXPORT
-    int bgzf_peek(BGZF *fp);
-
-    /**
-     * Read up to _length_ bytes directly from the underlying stream without
-     * decompressing.  Bypasses BGZF blocking, so must be used with care in
-     * specialised circumstances only.
-     *
-     * @param fp     BGZF file handler
-     * @param data   data array to read into
-     * @param length number of raw bytes to read
-     * @return       number of bytes actually read; 0 on end-of-file and -1 on error
-     */
-    HTSLIB_EXPORT
-    ssize_t bgzf_raw_read(BGZF *fp, void *data, size_t length) HTS_RESULT_USED;
-
-    /**
-     * Write _length_ bytes directly to the underlying stream without
-     * compressing.  Bypasses BGZF blocking, so must be used with care
-     * in specialised circumstances only.
-     *
-     * @param fp     BGZF file handler
-     * @param data   data array to write
-     * @param length number of raw bytes to write
-     * @return       number of bytes actually written; -1 on error
-     */
-    HTSLIB_EXPORT
-    ssize_t bgzf_raw_write(BGZF *fp, const void *data, size_t length) HTS_RESULT_USED;
-
-    /**
-     * Write the data in the buffer to the file.
-     *
-     * @param fp     BGZF file handle
-     * @return       0 on success and -1 on error
-     */
-    HTSLIB_EXPORT
-    int bgzf_flush(BGZF *fp) HTS_RESULT_USED;
-
-    /**
-     * Return a virtual file pointer to the current location in the file.
-     * No interpretation of the value should be made, other than a subsequent
-     * call to bgzf_seek can be used to position the file at the same point.
-     * Return value is non-negative on success.
-     */
-    #define bgzf_tell(fp) (((fp)->block_address << 16) | ((fp)->block_offset & 0xFFFF))
-
-    /**
-     * Set the file to read from the location specified by _pos_.
-     *
-     * @param fp     BGZF file handler
-     * @param pos    virtual file offset returned by bgzf_tell()
-     * @param whence must be SEEK_SET
-     * @return       0 on success and -1 on error
-     *
-     * @note It is not permitted to seek on files open for writing,
-     * or files compressed with gzip (as opposed to bgzip).
-     */
-    HTSLIB_EXPORT
-    int64_t bgzf_seek(BGZF *fp, int64_t pos, int whence) HTS_RESULT_USED;
-
-    /**
-     * Check if the BGZF end-of-file (EOF) marker is present
-     *
-     * @param fp    BGZF file handler opened for reading
-     * @return      1 if the EOF marker is present and correct;
-     *              2 if it can't be checked, e.g., because fp isn't seekable;
-     *              0 if the EOF marker is absent;
-     *              -1 (with errno set) on error
-     */
-    HTSLIB_EXPORT
-    int bgzf_check_EOF(BGZF *fp);
-
-    /** Return the file's compression format
-     *
-     * @param fp  BGZF file handle
-     * @return    A small integer matching the corresponding
-     *            `enum htsCompression` value:
-     *   - 0 / `no_compression` if the file is uncompressed
-     *   - 1 / `gzip` if the file is plain GZIP-compressed
-     *   - 2 / `bgzf` if the file is BGZF-compressed
-     * @since 1.4
-     */
-    HTSLIB_EXPORT
-    int bgzf_compression(BGZF *fp);
-
-    /**
-     * Check if a file is in the BGZF format
-     *
-     * @param fn    file name
-     * @return      1 if _fn_ is BGZF; 0 if not or on I/O error
-     */
-    HTSLIB_EXPORT
-    int bgzf_is_bgzf(const char *fn) HTS_DEPRECATED("Use bgzf_compression() or hts_detect_format() instead");
-
-    /*********************
-     * Advanced routines *
-     *********************/
-
-    /**
-     * Set the cache size. Only effective when compiled with -DBGZF_CACHE.
-     *
-     * @param fp    BGZF file handler
-     * @param size  size of cache in bytes; 0 to disable caching (default)
-     */
-    HTSLIB_EXPORT
-    void bgzf_set_cache_size(BGZF *fp, int size);
-
-    /**
-     * Flush the file if the remaining buffer size is smaller than _size_
-     * @return      0 if flushing succeeded or was not needed; negative on error
-     */
-    HTSLIB_EXPORT
-    int bgzf_flush_try(BGZF *fp, ssize_t size) HTS_RESULT_USED;
-
-    /**
-     * Read one byte from a BGZF file. It is faster than bgzf_read()
-     * @param fp     BGZF file handler
-     * @return       byte read; -1 on end-of-file or error
-     */
-    HTSLIB_EXPORT
-    int bgzf_getc(BGZF *fp);
-
-    /**
-     * Read one line from a BGZF file. It is faster than bgzf_getc()
-     *
-     * @param fp     BGZF file handler
-     * @param delim  delimiter
-     * @param str    string to write to; must be initialized
-     * @return       length of the string; -1 on end-of-file; <= -2 on error
-     */
-    HTSLIB_EXPORT
-    int bgzf_getline(BGZF *fp, int delim, struct kstring_t *str);
-
-    /**
-     * Read the next BGZF block.
-     */
-    HTSLIB_EXPORT
-    int bgzf_read_block(BGZF *fp) HTS_RESULT_USED;
-
-    /**
-     * Enable multi-threading (when compiled with -DBGZF_MT) via a shared
-     * thread pool.  This means both encoder and decoder can balance
-     * usage across a single pool of worker jobs.
-     *
-     * @param fp          BGZF file handler; must be opened for writing
-     * @param pool        The thread pool (see hts_create_threads)
-     */
-    HTSLIB_EXPORT
-    int bgzf_thread_pool(BGZF *fp, struct hts_tpool *pool, int qsize);
-
-    /**
-     * Enable multi-threading (only effective when the library was compiled
-     * with -DBGZF_MT)
-     *
-     * @param fp          BGZF file handler; must be opened for writing
-     * @param n_threads   #threads used for writing
-     * @param n_sub_blks  #blocks processed by each thread; a value 64-256 is recommended
-     */
-    HTSLIB_EXPORT
-    int bgzf_mt(BGZF *fp, int n_threads, int n_sub_blks);
-
-    /**
-     * Compress a single BGZF block.
-     *
-     * @param dst    output buffer (must have size >= BGZF_MAX_BLOCK_SIZE)
-     * @param dlen   size of output buffer; updated on return to the number
-     *               of bytes actually written to dst
-     * @param src    buffer to be compressed
-     * @param slen   size of data to compress (must be <= BGZF_BLOCK_SIZE)
-     * @param level  compression level
-     * @return       0 on success and negative on error
-     */
-    HTSLIB_EXPORT
-    int bgzf_compress(void *dst, size_t *dlen, const void *src, size_t slen, int level);
-
-    /*******************
-     * bgzidx routines *
-     *******************/
-
-    /**
-     *  Position BGZF at the uncompressed offset
-     *
-     *  @param fp           BGZF file handler; must be opened for reading
-     *  @param uoffset      file offset in the uncompressed data
-     *  @param where        must be SEEK_SET
-     *
-     *  Returns 0 on success and -1 on error.
-     *
-     *  @note It is not permitted to seek on files open for writing,
-     *  or files compressed with gzip (as opposed to bgzip).
-     */
-    HTSLIB_EXPORT
-    int bgzf_useek(BGZF *fp, off_t uoffset, int where) HTS_RESULT_USED;
-
-    /**
-     *  Position in uncompressed BGZF
-     *
-     *  @param fp           BGZF file handler; must be opened for reading
-     *
-     *  Returns the current offset on success and -1 on error.
-     */
-    HTSLIB_EXPORT
-    off_t bgzf_utell(BGZF *fp);
-
-    /**
-     * Tell BGZF to build index while compressing.
-     *
-     * @param fp          BGZF file handler; can be opened for reading or writing.
-     *
-     * Returns 0 on success and -1 on error.
-     *
-     * @note This function must be called before any data has been read or
-     * written, and in particular before calling bgzf_mt() on the same
-     * file handle (as threads may start reading data before the index
-     * has been set up).
-     */
-    HTSLIB_EXPORT
-    int bgzf_index_build_init(BGZF *fp);
-
-    /// Load BGZF index
-    /**
-     * @param fp          BGZF file handler
-     * @param bname       base name
-     * @param suffix      suffix to add to bname (can be NULL)
-     * @return 0 on success and -1 on error.
-     */
-    HTSLIB_EXPORT
-    int bgzf_index_load(BGZF *fp,
-                        const char *bname, const char *suffix) HTS_RESULT_USED;
-
-    /// Load BGZF index from an hFILE
-    /**
-     * @param fp   BGZF file handle
-     * @param idx  hFILE to read from
-     * @param name file name (for error reporting only; can be NULL)
-     * @return 0 on success and -1 on error.
-     *
-     * Populates @p fp with index data read from the hFILE handle @p idx.
-     * The file pointer to @idx should point to the start of the index
-     * data when this function is called.
-     *
-     * The file name can optionally be passed in the @p name parameter.  This
-     * is only used for printing error messages; if NULL the word "index" is
-     * used instead.
-     */
-    HTSLIB_EXPORT
-    int bgzf_index_load_hfile(BGZF *fp, struct hFILE *idx,
-                              const char *name) HTS_RESULT_USED;
-
-    /// Save BGZF index
-    /**
-     * @param fp          BGZF file handler
-     * @param bname       base name
-     * @param suffix      suffix to add to bname (can be NULL)
-     * @return 0 on success and -1 on error.
-     */
-    HTSLIB_EXPORT
-    int bgzf_index_dump(BGZF *fp,
-                        const char *bname, const char *suffix) HTS_RESULT_USED;
-
-    /// Write a BGZF index to an hFILE
-    /**
-     * @param fp     BGZF file handle
-     * @param idx    hFILE to write to
-     * @param name   file name (for error reporting only, can be NULL)
-     * @return 0 on success and -1 on error.
-     *
-     * Write index data from @p fp to the file @p idx.
-     *
-     * The file name can optionally be passed in the @p name parameter.  This
-     * is only used for printing error messages; if NULL the word "index" is
-     * used instead.
-     */
-
-    HTSLIB_EXPORT
-    int bgzf_index_dump_hfile(BGZF *fp, struct hFILE *idx,
-                              const char *name) HTS_RESULT_USED;
-
-#ifdef __cplusplus
-}
-#endif
-
-#endif
diff -ruN stringtie.orig/htslib/htslib/cram.h stringtie/htslib/htslib/cram.h
--- stringtie.orig/htslib/htslib/cram.h	2024-02-28 13:57:39.704579460 +0100
+++ stringtie/htslib/htslib/cram.h	1970-01-01 01:00:00.000000000 +0100
@@ -1,571 +0,0 @@
-/// @file htslib/cram.h
-/// CRAM format-specific API functions.
-/*
-    Copyright (C) 2015, 2016, 2018-2020 Genome Research Ltd.
-
-    Author: James Bonfield <jkb@sanger.ac.uk>
-
-Permission is hereby granted, free of charge, to any person obtaining a copy
-of this software and associated documentation files (the "Software"), to deal
-in the Software without restriction, including without limitation the rights
-to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
-copies of the Software, and to permit persons to whom the Software is
-furnished to do so, subject to the following conditions:
-
-The above copyright notice and this permission notice shall be included in
-all copies or substantial portions of the Software.
-
-THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
-IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
-FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
-THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
-LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
-FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
-DEALINGS IN THE SOFTWARE.  */
-
-/** @file
- * Consider using the higher level hts_*() API for programs that wish to
- * be file format agnostic (see htslib/hts.h).
- *
- * This API should be used for CRAM specific code. The specifics of the
- * public API are implemented in cram_io.h, cram_encode.h and cram_decode.h
- * although these should not be included directly (use this file instead).
- */
-
-#ifndef HTSLIB_CRAM_H
-#define HTSLIB_CRAM_H
-
-#include <stdarg.h>
-#include <stdint.h>
-#include <sys/types.h>
-
-#include "hts_defs.h"
-#include "hts.h"
-#include "sam.h"
-
-#ifdef __cplusplus
-extern "C" {
-#endif
-
-// see cram/cram_structs.h for an internal more complete copy of this enum
-
-// Htslib 1.11 had these listed without any hts prefix, and included
-// some internal values such as RANS1 and GZIP_RLE (which shouldn't have ever
-// been public).
-//
-// We can't find evidence of these being used and the data type occurs
-// nowhere in functions or structures meaning using it would be pointless.
-// However for safety, if you absolute need the API to not change then
-// define HTS_COMPAT to 101100 (XYYYZZ for X.Y[.Z], meaning 1.11).
-#if defined(HTS_COMPAT) && HTS_COMPAT <= 101100
-enum cram_block_method {
-    // Public methods as defined in the CRAM spec.
-    BM_ERROR = -1,
-
-    // CRAM 2.x and 3.0
-    RAW      = 0,
-    GZIP     = 1,
-    BZIP2    = 2,
-    LZMA     = 3,
-    RANS     = 4,
-
-    // NB: the subsequent numbers may change.  They're simply here for
-    // compatibility with the old API, but may have no bearing on the
-    // internal way htslib works.  DO NOT USE
-    RANS0    = 4,
-    RANS1    = 10,
-    GZIP_RLE = 11,
-};
-#endif
-
-enum cram_content_type {
-    CT_ERROR           = -1,
-    FILE_HEADER        = 0,
-    COMPRESSION_HEADER = 1,
-    MAPPED_SLICE       = 2,
-    UNMAPPED_SLICE     = 3, // CRAM V1.0 only
-    EXTERNAL           = 4,
-    CORE               = 5,
-};
-
-// Opaque data types, see cram_structs for the fully fledged versions.
-typedef struct cram_file_def cram_file_def;
-typedef struct cram_fd cram_fd;
-typedef struct cram_container cram_container;
-typedef struct cram_block cram_block;
-typedef struct cram_slice cram_slice;
-typedef struct cram_metrics cram_metrics;
-typedef struct cram_block_slice_hdr cram_block_slice_hdr;
-typedef struct cram_block_compression_hdr cram_block_compression_hdr;
-typedef struct refs_t refs_t;
-
-struct hFILE;
-
-// Accessor functions
-
-/*
- *-----------------------------------------------------------------------------
- * cram_fd
- */
-HTSLIB_EXPORT
-sam_hdr_t *cram_fd_get_header(cram_fd *fd);
-
-HTSLIB_EXPORT
-void cram_fd_set_header(cram_fd *fd, sam_hdr_t *hdr);
-
-HTSLIB_EXPORT
-int cram_fd_get_version(cram_fd *fd);
-
-HTSLIB_EXPORT
-void cram_fd_set_version(cram_fd *fd, int vers);
-
-HTSLIB_EXPORT
-int cram_major_vers(cram_fd *fd);
-HTSLIB_EXPORT
-int cram_minor_vers(cram_fd *fd);
-
-HTSLIB_EXPORT
-struct hFILE *cram_fd_get_fp(cram_fd *fd);
-HTSLIB_EXPORT
-void cram_fd_set_fp(cram_fd *fd, struct hFILE *fp);
-
-
-/*
- *-----------------------------------------------------------------------------
- * cram_container
- */
-HTSLIB_EXPORT
-int32_t cram_container_get_length(cram_container *c);
-HTSLIB_EXPORT
-void cram_container_set_length(cram_container *c, int32_t length);
-HTSLIB_EXPORT
-int32_t cram_container_get_num_blocks(cram_container *c);
-HTSLIB_EXPORT
-void cram_container_set_num_blocks(cram_container *c, int32_t num_blocks);
-HTSLIB_EXPORT
-int32_t *cram_container_get_landmarks(cram_container *c, int32_t *num_landmarks);
-HTSLIB_EXPORT
-void cram_container_set_landmarks(cram_container *c, int32_t num_landmarks,
-                                  int32_t *landmarks);
-
-/* Returns true if the container is empty (EOF marker) */
-HTSLIB_EXPORT
-int cram_container_is_empty(cram_fd *fd);
-
-
-/*
- *-----------------------------------------------------------------------------
- * cram_block
- */
-HTSLIB_EXPORT
-int32_t cram_block_get_content_id(cram_block *b);
-HTSLIB_EXPORT
-int32_t cram_block_get_comp_size(cram_block *b);
-HTSLIB_EXPORT
-int32_t cram_block_get_uncomp_size(cram_block *b);
-HTSLIB_EXPORT
-int32_t cram_block_get_crc32(cram_block *b);
-HTSLIB_EXPORT
-void *  cram_block_get_data(cram_block *b);
-
-HTSLIB_EXPORT
-enum cram_content_type cram_block_get_content_type(cram_block *b);
-
-HTSLIB_EXPORT
-void cram_block_set_content_id(cram_block *b, int32_t id);
-HTSLIB_EXPORT
-void cram_block_set_comp_size(cram_block *b, int32_t size);
-HTSLIB_EXPORT
-void cram_block_set_uncomp_size(cram_block *b, int32_t size);
-HTSLIB_EXPORT
-void cram_block_set_crc32(cram_block *b, int32_t crc);
-HTSLIB_EXPORT
-void cram_block_set_data(cram_block *b, void *data);
-
-HTSLIB_EXPORT
-int cram_block_append(cram_block *b, const void *data, int size);
-HTSLIB_EXPORT
-void cram_block_update_size(cram_block *b);
-
-// Offset is known as "size" internally, but it can be confusing.
-HTSLIB_EXPORT
-size_t cram_block_get_offset(cram_block *b);
-HTSLIB_EXPORT
-void cram_block_set_offset(cram_block *b, size_t offset);
-
-/*
- * Computes the size of a cram block, including the block
- * header itself.
- */
-HTSLIB_EXPORT
-uint32_t cram_block_size(cram_block *b);
-
-/*
- * Renumbers RG numbers in a cram compression header.
- *
- * CRAM stores RG as the Nth number in the header, rather than a
- * string holding the ID: tag.  This is smaller in space, but means
- * "samtools cat" to join files together that contain single but
- * different RG lines needs a way of renumbering them.
- *
- * The file descriptor is expected to be immediately after the
- * cram_container structure (ie before the cram compression header).
- * Due to the nature of the CRAM format, this needs to read and write
- * the blocks itself.  Note that there may be multiple slices within
- * the container, meaning multiple compression headers to manipulate.
- * Changing RG may change the size of the compression header and
- * therefore the length field in the container.  Hence we rewrite all
- * blocks just in case and also emit the adjusted container.
- *
- * The current implementation can only cope with renumbering a single
- * RG (and only then if it is using HUFFMAN or BETA codecs).  In
- * theory it *may* be possible to renumber multiple RGs if they use
- * HUFFMAN to the CORE block or use an external block unshared by any
- * other data series.  So we have an API that can be upgraded to
- * support this, but do not implement it for now.  An example
- * implementation of RG as an EXTERNAL block would be to find that
- * block and rewrite it, returning the number of blocks consumed.
- *
- * Returns 0 on success;
- *        -1 if unable to edit;
- *        -2 on other errors (eg I/O).
- */
-HTSLIB_EXPORT
-int cram_transcode_rg(cram_fd *in, cram_fd *out,
-                      cram_container *c,
-                      int nrg, int *in_rg, int *out_rg);
-
-/*
- * Copies the blocks representing the next num_slice slices from a
- * container from 'in' to 'out'.  It is expected that the file pointer
- * is just after the read of the cram_container and cram compression
- * header.
- *
- * Returns 0 on success
- *        -1 on failure
- */
-HTSLIB_EXPORT
-int cram_copy_slice(cram_fd *in, cram_fd *out, int32_t num_slice);
-
-/*
- *-----------------------------------------------------------------------------
- * cram_io basics
- */
-
-/**@{ ----------------------------------------------------------------------
- * CRAM blocks - the dynamically growable data block. We have code to
- * create, update, (un)compress and read/write.
- *
- * These are derived from the deflate_interlaced.c blocks, but with the
- * CRAM extension of content types and IDs.
- */
-
-/*! Allocates a new cram_block structure with a specified content_type and
- * id.
- *
- * @return
- * Returns block pointer on success;
- *         NULL on failure
- *
- * The cram_block struct returned by a successful call should be freed
- * via cram_free_block() when it is no longer needed.
- */
-HTSLIB_EXPORT
-cram_block *cram_new_block(enum cram_content_type content_type,
-                           int content_id);
-
-/*! Reads a block from a cram file.
- *
- * @return
- * Returns cram_block pointer on success;
- *         NULL on failure
- *
- * The cram_block struct returned by a successful call should be freed
- * via cram_free_block() when it is no longer needed.
- */
-HTSLIB_EXPORT
-cram_block *cram_read_block(cram_fd *fd);
-
-/*! Writes a CRAM block.
- *
- * @return
- * Returns 0 on success;
- *        -1 on failure
- */
-HTSLIB_EXPORT
-int cram_write_block(cram_fd *fd, cram_block *b);
-
-/*! Frees a CRAM block, deallocating internal data too.
- */
-HTSLIB_EXPORT
-void cram_free_block(cram_block *b);
-
-/*! Uncompresses a CRAM block, if compressed.
- *
- * @return
- * Returns 0 on success;
- *        -1 on failure
- */
-HTSLIB_EXPORT
-int cram_uncompress_block(cram_block *b);
-
-/*! Compresses a block.
- *
- * Compresses a block using one of two different zlib strategies. If we only
- * want one choice set strat2 to be -1.
- *
- * The logic here is that sometimes Z_RLE does a better job than Z_FILTERED
- * or Z_DEFAULT_STRATEGY on quality data. If so, we'd rather use it as it is
- * significantly faster.
- *
- * @return
- * Returns 0 on success;
- *        -1 on failure
- */
-HTSLIB_EXPORT
-int cram_compress_block(cram_fd *fd, cram_block *b, cram_metrics *metrics,
-                        int method, int level);
-int cram_compress_block2(cram_fd *fd, cram_slice *s,
-                         cram_block *b, cram_metrics *metrics,
-                         int method, int level);
-
-/**@}*/
-/**@{ ----------------------------------------------------------------------
- * Containers
- */
-
-/*! Creates a new container, specifying the maximum number of slices
- * and records permitted.
- *
- * @return
- * Returns cram_container ptr on success;
- *         NULL on failure
- *
- * The cram_container struct returned by a successful call should be freed
- * via cram_free_container() when it is no longer needed.
- */
-HTSLIB_EXPORT
-cram_container *cram_new_container(int nrec, int nslice);
-HTSLIB_EXPORT
-void cram_free_container(cram_container *c);
-
-/*! Reads a container header.
- *
- * @return
- * Returns cram_container on success;
- *         NULL on failure or no container left (fd->err == 0).
- *
- * The cram_container struct returned by a successful call should be freed
- * via cram_free_container() when it is no longer needed.
- */
-HTSLIB_EXPORT
-cram_container *cram_read_container(cram_fd *fd);
-
-/*! Writes a container structure.
- *
- * @return
- * Returns 0 on success;
- *        -1 on failure
- */
-HTSLIB_EXPORT
-int cram_write_container(cram_fd *fd, cram_container *h);
-
-/*
- * Stores the container structure in dat and returns *size as the
- * number of bytes written to dat[].  The input size of dat is also
- * held in *size and should be initialised to cram_container_size(c).
- *
- * Returns 0 on success;
- *        -1 on failure
- */
-HTSLIB_EXPORT
-int cram_store_container(cram_fd *fd, cram_container *c, char *dat, int *size);
-
-HTSLIB_EXPORT
-int cram_container_size(cram_container *c);
-
-/**@}*/
-/**@{ ----------------------------------------------------------------------
- * The top-level cram opening, closing and option handling
- */
-
-/*! Opens a CRAM file for read (mode "rb") or write ("wb").
- *
- * The filename may be "-" to indicate stdin or stdout.
- *
- * @return
- * Returns file handle on success;
- *         NULL on failure.
- */
-HTSLIB_EXPORT
-cram_fd *cram_open(const char *filename, const char *mode);
-
-/*! Opens an existing stream for reading or writing.
- *
- * @return
- * Returns file handle on success;
- *         NULL on failure.
- */
-HTSLIB_EXPORT
-cram_fd *cram_dopen(struct hFILE *fp, const char *filename, const char *mode);
-
-/*! Closes a CRAM file.
- *
- * @return
- * Returns 0 on success;
- *        -1 on failure
- */
-HTSLIB_EXPORT
-int cram_close(cram_fd *fd);
-
-/*
- * Seek within a CRAM file.
- *
- * Returns 0 on success
- *        -1 on failure
- */
-HTSLIB_EXPORT
-int cram_seek(cram_fd *fd, off_t offset, int whence);
-
-/*
- * Flushes a CRAM file.
- * Useful for when writing to stdout without wishing to close the stream.
- *
- * Returns 0 on success
- *        -1 on failure
- */
-HTSLIB_EXPORT
-int cram_flush(cram_fd *fd);
-
-/*! Checks for end of file on a cram_fd stream.
- *
- * @return
- * Returns 0 if not at end of file
- *         1 if we hit an expected EOF (end of range or EOF block)
- *         2 for other EOF (end of stream without EOF block)
- */
-HTSLIB_EXPORT
-int cram_eof(cram_fd *fd);
-
-/*! Sets options on the cram_fd.
- *
- * See CRAM_OPT_* definitions in hts.h.
- * Use this immediately after opening.
- *
- * @return
- * Returns 0 on success;
- *        -1 on failure
- */
-HTSLIB_EXPORT
-int cram_set_option(cram_fd *fd, enum hts_fmt_option opt, ...);
-
-/*! Sets options on the cram_fd.
- *
- * See CRAM_OPT_* definitions in hts.h.
- * Use this immediately after opening.
- *
- * @return
- * Returns 0 on success;
- *        -1 on failure
- */
-HTSLIB_EXPORT
-int cram_set_voption(cram_fd *fd, enum hts_fmt_option opt, va_list args);
-
-/*!
- * Attaches a header to a cram_fd.
- *
- * This should be used when creating a new cram_fd for writing where
- * we have an SAM_hdr already constructed (eg from a file we've read
- * in).
- *
- * @return
- * Returns 0 on success;
- *        -1 on failure
- */
-HTSLIB_EXPORT
-int cram_set_header(cram_fd *fd, sam_hdr_t *hdr);
-
-/*! Check if this file has a proper EOF block
- *
- * @return
- * Returns 3 if the file is a version of CRAM that does not contain EOF blocks
- *         2 if the file is a stream and thus unseekable
- *         1 if the file contains an EOF block
- *         0 if the file does not contain an EOF block
- *        -1 if an error occurred whilst reading the file or we could not seek back to where we were
- *
- */
-HTSLIB_EXPORT
-int cram_check_EOF(cram_fd *fd);
-
-/* As int32_decoded/encode, but from/to blocks instead of cram_fd */
-HTSLIB_EXPORT
-int int32_put_blk(cram_block *b, int32_t val);
-
-/**@}*/
-/**@{ -------------------------------------------------------------------
- * Old typedef and function names for compatibility with existing code.
- * Header functionality is now provided by sam.h's sam_hdr_t functions.
- */
-
-typedef sam_hdr_t SAM_hdr;
-
-/*! Tokenises a SAM header into a hash table.
- *
- * Also extracts a few bits on specific data types, such as @RG lines.
- *
- * @return
- * Returns a SAM_hdr struct on success (free with sam_hdr_free());
- *         NULL on failure
- */
-static inline SAM_hdr *sam_hdr_parse_(const char *hdr, size_t len) { return sam_hdr_parse(len, hdr); }
-
-/*! Deallocates all storage used by a SAM_hdr struct.
- *
- * This also decrements the header reference count. If after decrementing
- * it is still non-zero then the header is assumed to be in use by another
- * caller and the free is not done.
- */
-static inline void sam_hdr_free(SAM_hdr *hdr) { sam_hdr_destroy(hdr); }
-
-/* sam_hdr_length() and sam_hdr_str() are now provided by sam.h. */
-
-/*! Add an @PG line.
- *
- * If we wish complete control over this use sam_hdr_add_line() directly. This
- * function uses that, but attempts to do a lot of tedious house work for
- * you too.
- *
- * - It will generate a suitable ID if the supplied one clashes.
- * - It will generate multiple @PG records if we have multiple PG chains.
- *
- * Call it as per sam_hdr_add_line() with a series of key,value pairs ending
- * in NULL.
- *
- * @return
- * Returns 0 on success;
- *        -1 on failure
- */
-#define sam_hdr_add_PG sam_hdr_add_pg
-
-/**@{ -------------------------------------------------------------------*/
-
-/*!
- * Returns the refs_t structure used by a cram file handle.
- *
- * This may be used in conjunction with option CRAM_OPT_SHARED_REF to
- * share reference memory between multiple file handles.
- *
- * @return
- * Returns NULL if none exists or the file handle is not a CRAM file.
- */
-HTSLIB_EXPORT
-refs_t *cram_get_refs(htsFile *fd);
-
-/**@}*/
-
-#ifdef __cplusplus
-}
-#endif
-
-#endif
diff -ruN stringtie.orig/htslib/htslib/faidx.h stringtie/htslib/htslib/faidx.h
--- stringtie.orig/htslib/htslib/faidx.h	2024-02-28 13:57:39.704579460 +0100
+++ stringtie/htslib/htslib/faidx.h	1970-01-01 01:00:00.000000000 +0100
@@ -1,334 +0,0 @@
-/// @file htslib/faidx.h
-/// FASTA random access.
-/*
-   Copyright (C) 2008, 2009, 2013, 2014, 2016, 2017-2020 Genome Research Ltd.
-
-   Author: Heng Li <lh3@sanger.ac.uk>
-
-   Permission is hereby granted, free of charge, to any person obtaining
-   a copy of this software and associated documentation files (the
-   "Software"), to deal in the Software without restriction, including
-   without limitation the rights to use, copy, modify, merge, publish,
-   distribute, sublicense, and/or sell copies of the Software, and to
-   permit persons to whom the Software is furnished to do so, subject to
-   the following conditions:
-
-   The above copyright notice and this permission notice shall be
-   included in all copies or substantial portions of the Software.
-
-   THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
-   EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
-   MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
-   NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS
-   BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
-   ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
-   CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
-   SOFTWARE.
-*/
-
-#ifndef HTSLIB_FAIDX_H
-#define HTSLIB_FAIDX_H
-
-#include <stdint.h>
-#include "hts_defs.h"
-#include "hts.h"
-
-#ifdef __cplusplus
-extern "C" {
-#endif
-
-/** @file
-
-  Index FASTA or FASTQ files and extract subsequence.
-
-  The fai file index columns for FASTA are:
-    - chromosome name
-    - chromosome length: number of bases
-    - offset: number of bytes to skip to get to the first base
-        from the beginning of the file, including the length
-        of the sequence description string (`>chr ..\n`)
-    - line length: number of bases per line (excluding `\n`)
-    - binary line length: number of bytes, including `\n`
-
-   The index for FASTQ is similar to above:
-    - chromosome name
-    - chromosome length: number of bases
-    - sequence offset: number of bytes to skip to get to the first base
-        from the beginning of the file, including the length
-        of the sequence description string (`@chr ..\n`)
-    - line length: number of bases per line (excluding `\n`)
-    - binary line length: number of bytes, including `\n`
-    - quality offset: number of bytes to skip from the beginning of the file
-        to get to the first quality value in the indexed entry.
-
-    The FASTQ version of the index uses line length and binary line length
-    for both the sequence and the quality values, so they must be line
-    wrapped in the same way.
- */
-
-struct faidx_t;
-/// Opaque structure representing FASTA index
-typedef struct faidx_t faidx_t;
-
-/// File format to be dealing with.
-enum fai_format_options {
-    FAI_NONE,
-    FAI_FASTA,
-    FAI_FASTQ
-};
-
-/// Build index for a FASTA or FASTQ or bgzip-compressed FASTA or FASTQ file.
-/**  @param  fn  FASTA/FASTQ file name
-     @param  fnfai Name of .fai file to build.
-     @param  fngzi Name of .gzi file to build (if fn is bgzip-compressed).
-     @return     0 on success; or -1 on failure
-
-If fnfai is NULL, ".fai" will be appended to fn to make the FAI file name.
-If fngzi is NULL, ".gzi" will be appended to fn for the GZI file.  The GZI
-file will only be built if fn is bgzip-compressed.
-*/
-HTSLIB_EXPORT
-int fai_build3(const char *fn, const char *fnfai, const char *fngzi) HTS_RESULT_USED;
-
-/// Build index for a FASTA or FASTQ or bgzip-compressed FASTA or FASTQ file.
-/** @param  fn  FASTA/FASTQ file name
-    @return     0 on success; or -1 on failure
-
-File "fn.fai" will be generated.  This function is equivalent to
-fai_build3(fn, NULL, NULL);
-*/
-HTSLIB_EXPORT
-int fai_build(const char *fn) HTS_RESULT_USED;
-
-/// Destroy a faidx_t struct
-HTSLIB_EXPORT
-void fai_destroy(faidx_t *fai);
-
-enum fai_load_options {
-    FAI_CREATE = 0x01,
-};
-
-/// Load FASTA indexes.
-/** @param  fn  File name of the FASTA file (can be compressed with bgzip).
-    @param  fnfai File name of the FASTA index.
-    @param  fngzi File name of the bgzip index.
-    @param  flags Option flags to control index file caching and creation.
-    @return Pointer to a faidx_t struct on success, NULL on failure.
-
-If fnfai is NULL, ".fai" will be appended to fn to make the FAI file name.
-If fngzi is NULL, ".gzi" will be appended to fn for the bgzip index name.
-The bgzip index is only needed if fn is compressed.
-
-If (flags & FAI_CREATE) is true, the index files will be built using
-fai_build3() if they are not already present.
-
-The struct returned by a successful call should be freed via fai_destroy()
-when it is no longer needed.
-*/
-HTSLIB_EXPORT
-faidx_t *fai_load3(const char *fn, const char *fnfai, const char *fngzi,
-                   int flags);
-
-/// Load index from "fn.fai".
-/** @param  fn  File name of the FASTA file
-    @return Pointer to a faidx_t struct on success, NULL on failure.
-
-This function is equivalent to fai_load3(fn, NULL, NULL, FAI_CREATE|FAI_CACHE);
-*/
-HTSLIB_EXPORT
-faidx_t *fai_load(const char *fn);
-
-/// Load FASTA or FASTQ indexes.
-/** @param  fn  File name of the FASTA/FASTQ file (can be compressed with bgzip).
-    @param  fnfai File name of the FASTA/FASTQ index.
-    @param  fngzi File name of the bgzip index.
-    @param  flags Option flags to control index file caching and creation.
-    @param  format FASTA or FASTQ file format
-    @return Pointer to a faidx_t struct on success, NULL on failure.
-
-If fnfai is NULL, ".fai" will be appended to fn to make the FAI file name.
-If fngzi is NULL, ".gzi" will be appended to fn for the bgzip index name.
-The bgzip index is only needed if fn is compressed.
-
-If (flags & FAI_CREATE) is true, the index files will be built using
-fai_build3() if they are not already present.
-
-The struct returned by a successful call should be freed via fai_destroy()
-when it is no longer needed.
-*/
-HTSLIB_EXPORT
-faidx_t *fai_load3_format(const char *fn, const char *fnfai, const char *fngzi,
-                   int flags, enum fai_format_options format);
-
-/// Load index from "fn.fai".
-/** @param  fn  File name of the FASTA/FASTQ file
-    @param  format FASTA or FASTQ file format
-    @return Pointer to a faidx_t struct on success, NULL on failure.
-
-This function is equivalent to fai_load3_format(fn, NULL, NULL, FAI_CREATE|FAI_CACHE, format);
-*/
-HTSLIB_EXPORT
-faidx_t *fai_load_format(const char *fn, enum fai_format_options format);
-
-/// Fetch the sequence in a region
-/** @param  fai  Pointer to the faidx_t struct
-    @param  reg  Region in the format "chr2:20,000-30,000"
-    @param  len  Length of the region; -2 if seq not present, -1 general error
-    @return      Pointer to the sequence; `NULL` on failure
-
-The returned sequence is allocated by `malloc()` family and should be destroyed
-by end users by calling `free()` on it.
-
-To work around ambiguous parsing issues, eg both "chr1" and "chr1:100-200"
-are reference names, quote using curly braces.
-Thus "{chr1}:100-200" and "{chr1:100-200}" disambiguate the above example.
-*/
-HTSLIB_EXPORT
-char *fai_fetch(const faidx_t *fai, const char *reg, int *len);
-HTSLIB_EXPORT
-char *fai_fetch64(const faidx_t *fai, const char *reg, hts_pos_t *len);
-
-/// Fetch the quality string for a region for FASTQ files
-/** @param  fai  Pointer to the faidx_t struct
-    @param  reg  Region in the format "chr2:20,000-30,000"
-    @param  len  Length of the region; -2 if seq not present, -1 general error
-    @return      Pointer to the quality string; null on failure
-
-The returned quality string is allocated by `malloc()` family and should be
-destroyed by end users by calling `free()` on it.
-
-Region names can be quoted with curly braces, as for fai_fetch().
-*/
-HTSLIB_EXPORT
-char *fai_fetchqual(const faidx_t *fai, const char *reg, int *len);
-HTSLIB_EXPORT
-char *fai_fetchqual64(const faidx_t *fai, const char *reg, hts_pos_t *len);
-
-/// Fetch the number of sequences
-/** @param  fai  Pointer to the faidx_t struct
-    @return      The number of sequences
-*/
-HTSLIB_EXPORT
-int faidx_fetch_nseq(const faidx_t *fai) HTS_DEPRECATED("Please use faidx_nseq instead");
-
-/// Fetch the sequence in a region
-/** @param  fai  Pointer to the faidx_t struct
-    @param  c_name Region name
-    @param  p_beg_i  Beginning position number (zero-based)
-    @param  p_end_i  End position number (zero-based)
-    @param  len  Length of the region; -2 if c_name not present, -1 general error
-    @return      Pointer to the sequence; null on failure
-
-The returned sequence is allocated by `malloc()` family and should be destroyed
-by end users by calling `free()` on it.
-*/
-HTSLIB_EXPORT
-char *faidx_fetch_seq(const faidx_t *fai, const char *c_name, int p_beg_i, int p_end_i, int *len);
-
-/// Fetch the sequence in a region
-/** @param  fai  Pointer to the faidx_t struct
-    @param  c_name Region name
-    @param  p_beg_i  Beginning position number (zero-based)
-    @param  p_end_i  End position number (zero-based)
-    @param  len  Length of the region; -2 if c_name not present, -1 general error
-    @return      Pointer to the sequence; null on failure
-
-The returned sequence is allocated by `malloc()` family and should be destroyed
-by end users by calling `free()` on it.
-*/
-HTSLIB_EXPORT
-char *faidx_fetch_seq64(const faidx_t *fai, const char *c_name, hts_pos_t p_beg_i, hts_pos_t p_end_i, hts_pos_t *len);
-
-/// Fetch the quality string in a region for FASTQ files
-/** @param  fai  Pointer to the faidx_t struct
-    @param  c_name Region name
-    @param  p_beg_i  Beginning position number (zero-based)
-    @param  p_end_i  End position number (zero-based)
-    @param  len  Length of the region; -2 if c_name not present, -1 general error
-    @return      Pointer to the sequence; null on failure
-
-The returned sequence is allocated by `malloc()` family and should be destroyed
-by end users by calling `free()` on it.
-*/
-HTSLIB_EXPORT
-char *faidx_fetch_qual(const faidx_t *fai, const char *c_name, int p_beg_i, int p_end_i, int *len);
-
-/// Fetch the quality string in a region for FASTQ files
-/** @param  fai  Pointer to the faidx_t struct
-    @param  c_name Region name
-    @param  p_beg_i  Beginning position number (zero-based)
-    @param  p_end_i  End position number (zero-based)
-    @param  len  Length of the region; -2 if c_name not present, -1 general error
-    @return      Pointer to the sequence; null on failure
-
-The returned sequence is allocated by `malloc()` family and should be destroyed
-by end users by calling `free()` on it.
-*/
-HTSLIB_EXPORT
-char *faidx_fetch_qual64(const faidx_t *fai, const char *c_name, hts_pos_t p_beg_i, hts_pos_t p_end_i, hts_pos_t *len);
-
-/// Query if sequence is present
-/**   @param  fai  Pointer to the faidx_t struct
-      @param  seq  Sequence name
-      @return      1 if present or 0 if absent
-*/
-HTSLIB_EXPORT
-int faidx_has_seq(const faidx_t *fai, const char *seq);
-
-/// Return number of sequences in fai index
-HTSLIB_EXPORT
-int faidx_nseq(const faidx_t *fai);
-
-/// Return name of i-th sequence
-HTSLIB_EXPORT
-const char *faidx_iseq(const faidx_t *fai, int i);
-
-/// Return sequence length, -1 if not present
-HTSLIB_EXPORT
-int faidx_seq_len(const faidx_t *fai, const char *seq);
-
-/// Parses a region string.
-/** @param  fai   Pointer to the faidx_t struct
-    @param  s     Region string
-    @param  tid   Returns which i-th sequence is described in the region.
-    @param  beg   Returns the start of the region (0 based)
-    @param  end   Returns the one past last of the region (0 based)
-    @param  flags Parsing method, see HTS_PARSE_* in hts.h.
-    @return       Pointer to end of parsed s if successful, NULL if not.
-
-    To work around ambiguous parsing issues, eg both "chr1" and "chr1:100-200"
-    are reference names, quote using curly braces.
-    Thus "{chr1}:100-200" and "{chr1:100-200}" disambiguate the above example.
-*/
-HTSLIB_EXPORT
-const char *fai_parse_region(const faidx_t *fai, const char *s,
-                             int *tid, hts_pos_t *beg, hts_pos_t *end,
-                             int flags);
-
-/// Sets the cache size of the underlying BGZF compressed file
-/** @param  fai         Pointer to the faidx_t struct
- *  @param  cache_size  Selected cache size in bytes
- */
-HTSLIB_EXPORT
-void fai_set_cache_size(faidx_t *fai, int cache_size);
-
-/// Determines the path to the reference index file
-/** @param  fa    String with the path to the reference file
- *  @return       String with the path to the reference index file, or NULL on failure
-
-    If the reference path has the format reference.fa##idx##index.fa.fai,
-    the index path is taken directly from it as index.fa.fai.
-    If the reference file is local and the index file cannot be found, it
-    will be created alongside the reference file.
-    If the reference file is remote and the index file cannot be found,
-    the method returns NULL.
-
-    The returned string has to be freed by the user at the end of its scope.
- */
-HTSLIB_EXPORT
-char *fai_path(const char *fa);
-#ifdef __cplusplus
-}
-#endif
-
-#endif
diff -ruN stringtie.orig/htslib/htslib/hfile.h stringtie/htslib/htslib/hfile.h
--- stringtie.orig/htslib/htslib/hfile.h	2024-02-28 13:57:39.704579460 +0100
+++ stringtie/htslib/htslib/hfile.h	1970-01-01 01:00:00.000000000 +0100
@@ -1,371 +0,0 @@
-/// @file htslib/hfile.h
-/// Buffered low-level input/output streams.
-/*
-    Copyright (C) 2013-2020 Genome Research Ltd.
-
-    Author: John Marshall <jm18@sanger.ac.uk>
-
-Permission is hereby granted, free of charge, to any person obtaining a copy
-of this software and associated documentation files (the "Software"), to deal
-in the Software without restriction, including without limitation the rights
-to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
-copies of the Software, and to permit persons to whom the Software is
-furnished to do so, subject to the following conditions:
-
-The above copyright notice and this permission notice shall be included in
-all copies or substantial portions of the Software.
-
-THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
-IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
-FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
-THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
-LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
-FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
-DEALINGS IN THE SOFTWARE.  */
-
-#ifndef HTSLIB_HFILE_H
-#define HTSLIB_HFILE_H
-
-#include <string.h>
-
-#include <sys/types.h>
-
-#include "hts_defs.h"
-
-#ifdef __cplusplus
-extern "C" {
-#endif
-
-struct hFILE_backend;
-struct kstring_t;
-
-/// Low-level input/output stream handle
-/** The fields of this structure are declared here solely for the benefit
-of the hFILE-related inline functions.  They may change in future releases.
-User code should not use them directly; you should imagine that hFILE is an
-opaque incomplete type.
-*/
-typedef struct hFILE {
-    // @cond internal
-    char *buffer, *begin, *end, *limit;
-    const struct hFILE_backend *backend;
-    off_t offset;
-    unsigned at_eof:1, mobile:1, readonly:1;
-    int has_errno;
-    // @endcond
-} hFILE;
-
-/// Open the named file or URL as a stream
-/** @return An hFILE pointer, or `NULL` (with _errno_ set) if an error occurred.
-
-The usual `fopen(3)` _mode_ letters are supported: one of
-`r` (read), `w` (write), `a` (append), optionally followed by any of
-`+` (update), `e` (close on `exec(2)`), `x` (create exclusively),
-`:` (indicates scheme-specific variable arguments follow).
-*/
-HTSLIB_EXPORT
-hFILE *hopen(const char *filename, const char *mode, ...) HTS_RESULT_USED;
-
-/// Associate a stream with an existing open file descriptor
-/** @return An hFILE pointer, or `NULL` (with _errno_ set) if an error occurred.
-
-Note that the file must be opened in binary mode, or else
-there will be problems on platforms that make a difference
-between text and binary mode.
-
-For socket descriptors (on Windows), _mode_ should contain `s`.
-*/
-HTSLIB_EXPORT
-hFILE *hdopen(int fd, const char *mode) HTS_RESULT_USED;
-
-/// Report whether the file name or URL denotes remote storage
-/** @return  0 if local, 1 if remote.
-
-"Remote" means involving e.g. explicit network access, with the implication
-that callers may wish to cache such files' contents locally.
-*/
-HTSLIB_EXPORT
-int hisremote(const char *filename) HTS_RESULT_USED;
-
-/// Append an extension or replace an existing extension
-/** @param buffer     The kstring to be used to store the modified filename
-    @param filename   The filename to be (copied and) adjusted
-    @param replace    If non-zero, one extension (if any) is removed first
-    @param extension  The extension to be added (e.g. ".csi")
-    @return  The modified filename (i.e., `buffer->s`), or NULL on error.
-    @since   1.10
-
-If _filename_ is an URL, alters extensions at the end of the `hier-part`,
-leaving any trailing `?query` or `#fragment` unchanged.
-*/
-HTSLIB_EXPORT
-char *haddextension(struct kstring_t *buffer, const char *filename,
-                    int replace, const char *extension) HTS_RESULT_USED;
-
-/// Flush (for output streams) and close the stream
-/** @return  0 if successful, or `EOF` (with _errno_ set) if an error occurred.
-*/
-HTSLIB_EXPORT
-int hclose(hFILE *fp) HTS_RESULT_USED;
-
-/// Close the stream, without flushing or propagating errors
-/** For use while cleaning up after an error only.  Preserves _errno_.
-*/
-HTSLIB_EXPORT
-void hclose_abruptly(hFILE *fp);
-
-/// Return the stream's error indicator
-/** @return  Non-zero (in fact, an _errno_ value) if an error has occurred.
-
-This would be called `herror()` and return true/false to parallel `ferror(3)`,
-but a networking-related `herror(3)` function already exists.
-*/
-static inline int herrno(hFILE *fp)
-{
-    return fp->has_errno;
-}
-
-/// Clear the stream's error indicator
-static inline void hclearerr(hFILE *fp)
-{
-    fp->has_errno = 0;
-}
-
-/// Reposition the read/write stream offset
-/** @return  The resulting offset within the stream (as per `lseek(2)`),
-    or negative if an error occurred.
-*/
-HTSLIB_EXPORT
-off_t hseek(hFILE *fp, off_t offset, int whence) HTS_RESULT_USED;
-
-/// Report the current stream offset
-/** @return  The offset within the stream, starting from zero.
-*/
-static inline off_t htell(hFILE *fp)
-{
-    return fp->offset + (fp->begin - fp->buffer);
-}
-
-/// Read one character from the stream
-/** @return  The character read, or `EOF` on end-of-file or error.
-*/
-static inline int hgetc(hFILE *fp)
-{
-    extern int hgetc2(hFILE *);
-    return (fp->end > fp->begin)? (unsigned char) *(fp->begin++) : hgetc2(fp);
-}
-
-/// Read from the stream until the delimiter, up to a maximum length
-/** @param buffer  The buffer into which bytes will be written
-    @param size    The size of the buffer
-    @param delim   The delimiter (interpreted as an `unsigned char`)
-    @param fp      The file stream
-    @return  The number of bytes read, or negative on error.
-    @since   1.4
-
-Bytes will be read into the buffer up to and including a delimiter, until
-EOF is reached, or _size-1_ bytes have been written, whichever comes first.
-The string will then be terminated with a NUL byte (`\0`).
-*/
-HTSLIB_EXPORT
-ssize_t hgetdelim(char *buffer, size_t size, int delim, hFILE *fp)
-    HTS_RESULT_USED;
-
-/// Read a line from the stream, up to a maximum length
-/** @param buffer  The buffer into which bytes will be written
-    @param size    The size of the buffer
-    @param fp      The file stream
-    @return  The number of bytes read, or negative on error.
-    @since   1.4
-
-Specialization of hgetdelim() for a `\n` delimiter.
-*/
-static inline ssize_t HTS_RESULT_USED
-hgetln(char *buffer, size_t size, hFILE *fp)
-{
-    return hgetdelim(buffer, size, '\n', fp);
-}
-
-/// Read a line from the stream, up to a maximum length
-/** @param buffer  The buffer into which bytes will be written
-    @param size    The size of the buffer (must be > 1 to be useful)
-    @param fp      The file stream
-    @return  _buffer_ on success, or `NULL` if an error occurred.
-    @since   1.4
-
-This function can be used as a replacement for `fgets(3)`, or together with
-kstring's `kgetline()` to read arbitrarily-long lines into a _kstring_t_.
-*/
-HTSLIB_EXPORT
-char *hgets(char *buffer, int size, hFILE *fp) HTS_RESULT_USED;
-
-/// Peek at characters to be read without removing them from buffers
-/** @param fp      The file stream
-    @param buffer  The buffer to which the peeked bytes will be written
-    @param nbytes  The number of bytes to peek at; limited by the size of the
-                   internal buffer, which could be as small as 4K.
-    @return  The number of bytes peeked, which may be less than _nbytes_
-             if EOF is encountered; or negative, if there was an I/O error.
-
-The characters peeked at remain in the stream's internal buffer, and will be
-returned by later hread() etc calls.
-*/
-HTSLIB_EXPORT
-ssize_t hpeek(hFILE *fp, void *buffer, size_t nbytes) HTS_RESULT_USED;
-
-/// Read a block of characters from the file
-/** @return  The number of bytes read, or negative if an error occurred.
-
-The full _nbytes_ requested will be returned, except as limited by EOF
-or I/O errors.
-*/
-static inline ssize_t HTS_RESULT_USED
-hread(hFILE *fp, void *buffer, size_t nbytes)
-{
-    extern ssize_t hread2(hFILE *, void *, size_t, size_t);
-
-    size_t n = fp->end - fp->begin;
-    if (n > nbytes) n = nbytes;
-    memcpy(buffer, fp->begin, n);
-    fp->begin += n;
-    return (n == nbytes || !fp->mobile)? (ssize_t) n : hread2(fp, buffer, nbytes, n);
-}
-
-/// Write a character to the stream
-/** @return  The character written, or `EOF` if an error occurred.
-*/
-static inline int hputc(int c, hFILE *fp)
-{
-    extern int hputc2(int, hFILE *);
-    if (fp->begin < fp->limit) *(fp->begin++) = c;
-    else c = hputc2(c, fp);
-    return c;
-}
-
-/// Write a string to the stream
-/** @return  0 if successful, or `EOF` if an error occurred.
-*/
-static inline int hputs(const char *text, hFILE *fp)
-{
-    extern int hputs2(const char *, size_t, size_t, hFILE *);
-
-    size_t nbytes = strlen(text), n = fp->limit - fp->begin;
-    if (n > nbytes) n = nbytes;
-    memcpy(fp->begin, text, n);
-    fp->begin += n;
-    return (n == nbytes)? 0 : hputs2(text, nbytes, n, fp);
-}
-
-/// Write a block of characters to the file
-/** @return  Either _nbytes_, or negative if an error occurred.
-
-In the absence of I/O errors, the full _nbytes_ will be written.
-*/
-static inline ssize_t HTS_RESULT_USED
-hwrite(hFILE *fp, const void *buffer, size_t nbytes)
-{
-    extern ssize_t hwrite2(hFILE *, const void *, size_t, size_t);
-    extern int hfile_set_blksize(hFILE *fp, size_t bufsiz);
-
-    if (!fp->mobile) {
-        size_t n = fp->limit - fp->begin;
-        if (n < nbytes) {
-            hfile_set_blksize(fp, fp->limit - fp->buffer + nbytes);
-            fp->end = fp->limit;
-        }
-    }
-
-    size_t n = fp->limit - fp->begin;
-    if (nbytes >= n && fp->begin == fp->buffer) {
-        // Go straight to hwrite2 if the buffer is empty and the request
-        // won't fit.
-        return hwrite2(fp, buffer, nbytes, 0);
-    }
-
-    if (n > nbytes) n = nbytes;
-    memcpy(fp->begin, buffer, n);
-    fp->begin += n;
-    return (n==nbytes)? (ssize_t) n : hwrite2(fp, buffer, nbytes, n);
-}
-
-/// For writing streams, flush buffered output to the underlying stream
-/** @return  0 if successful, or `EOF` if an error occurred.
-
-This includes low-level flushing such as via `fdatasync(2)`.
-*/
-HTSLIB_EXPORT
-int hflush(hFILE *fp) HTS_RESULT_USED;
-
-/// For hfile_mem: get the internal buffer and it's size from a hfile
-/** @return  buffer if successful, or NULL if an error occurred
-
-The buffer returned should not be freed as this will happen when the
-hFILE is closed.
-*/
-HTSLIB_EXPORT
-char *hfile_mem_get_buffer(hFILE *file, size_t *length);
-
-/// For hfile_mem: get the internal buffer and it's size from a hfile.
-/** @return  buffer if successful, or NULL if an error occurred
-
-This is similar to hfile_mem_get_buffer except that ownership of the
-buffer is granted to the caller, who now has responsibility for freeing
-it.  From this point onwards, the hFILE should not be used for any
-purpose other than closing.
-*/
-HTSLIB_EXPORT
-char *hfile_mem_steal_buffer(hFILE *file, size_t *length);
-
-/// Fills out sc_list[] with the list of known URL schemes.
-/**
- * @param plugin   [in]     Restricts schemes to only those from 'plugin.
- * @param sc_list  [out]    Filled out with the scheme names
- * @param nschemes [in/out] Size of sc_list (in) and number returned (out)
- *
- * Plugin may be passed in as NULL in which case all schemes are returned.
- * Use plugin "built-in" to list the built in schemes.
- * The size of sc_list is determined by the input value of *nschemes.
- * This is updated to return the output size.  It is up to the caller to
- * determine whether to call again with a larger number if this is too small.
- *
- * The return value represents the total number found matching plugin, which
- * may be larger than *nschemes if too small a value was specified.
- *
- * @return the number of schemes found on success.
- *         -1 on failure
- */
-HTSLIB_EXPORT
-int hfile_list_schemes(const char *plugin, const char *sc_list[], int *nschemes);
-
-/// Fills out plist[] with the list of known hFILE plugins.
-/*
- * @param plist    [out]    Filled out with the plugin names
- * @param nplugins [in/out] Size of plist (in) and number returned (out)
- *
- * The size of plist is determined by the input value of *nplugins.
- * This is updated to return the output size.  It is up to the caller to
- * determine whether to call again with a larger number if this is too small.
- *
- * The return value represents the total number found, which may be
- * larger than *nplugins if too small a value was specified.
- *
- * @return the number of plugins found on success.
- *         -1 on failure
- */
-HTSLIB_EXPORT
-int hfile_list_plugins(const char *plist[], int *nplugins);
-
-/// Tests for the presence of a specific hFILE plugin.
-/*
- * @param name     The name of the plugin to query.
- *
- * @return 1 if found, 0 otherwise.
- */
-HTSLIB_EXPORT
-int hfile_has_plugin(const char *name);
-
-#ifdef __cplusplus
-}
-#endif
-
-#endif
diff -ruN stringtie.orig/htslib/htslib/hts_defs.h stringtie/htslib/htslib/hts_defs.h
--- stringtie.orig/htslib/htslib/hts_defs.h	2024-02-28 13:57:39.704579460 +0100
+++ stringtie/htslib/htslib/hts_defs.h	1970-01-01 01:00:00.000000000 +0100
@@ -1,120 +0,0 @@
-/*  hts_defs.h -- Miscellaneous definitions.
-
-    Copyright (C) 2013-2015,2017, 2019-2020 Genome Research Ltd.
-
-    Author: John Marshall <jm18@sanger.ac.uk>
-
-Permission is hereby granted, free of charge, to any person obtaining a copy
-of this software and associated documentation files (the "Software"), to deal
-in the Software without restriction, including without limitation the rights
-to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
-copies of the Software, and to permit persons to whom the Software is
-furnished to do so, subject to the following conditions:
-
-The above copyright notice and this permission notice shall be included in
-all copies or substantial portions of the Software.
-
-THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
-IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
-FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
-THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
-LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
-FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
-DEALINGS IN THE SOFTWARE.  */
-
-#ifndef HTSLIB_HTS_DEFS_H
-#define HTSLIB_HTS_DEFS_H
-
-#if defined __MINGW32__
-#include <stdio.h>     // For __MINGW_PRINTF_FORMAT macro
-#endif
-
-#ifdef __clang__
-#ifdef __has_attribute
-#define HTS_COMPILER_HAS(attribute) __has_attribute(attribute)
-#endif
-
-#elif defined __GNUC__
-#define HTS_GCC_AT_LEAST(major, minor) \
-    (__GNUC__ > (major) || (__GNUC__ == (major) && __GNUC_MINOR__ >= (minor)))
-#endif
-
-#ifndef HTS_COMPILER_HAS
-#define HTS_COMPILER_HAS(attribute) 0
-#endif
-#ifndef HTS_GCC_AT_LEAST
-#define HTS_GCC_AT_LEAST(major, minor) 0
-#endif
-
-#if HTS_COMPILER_HAS(__nonstring__) || HTS_GCC_AT_LEAST(8,1)
-#define HTS_NONSTRING __attribute__ ((__nonstring__))
-#else
-#define HTS_NONSTRING
-#endif
-
-#if HTS_COMPILER_HAS(__noreturn__) || HTS_GCC_AT_LEAST(3,0)
-#define HTS_NORETURN __attribute__ ((__noreturn__))
-#else
-#define HTS_NORETURN
-#endif
-
-// GCC introduced warn_unused_result in 3.4 but added -Wno-unused-result later
-#if HTS_COMPILER_HAS(__warn_unused_result__) || HTS_GCC_AT_LEAST(4,5)
-#define HTS_RESULT_USED __attribute__ ((__warn_unused_result__))
-#else
-#define HTS_RESULT_USED
-#endif
-
-#if HTS_COMPILER_HAS(__unused__) || HTS_GCC_AT_LEAST(3,0)
-#define HTS_UNUSED __attribute__ ((__unused__))
-#else
-#define HTS_UNUSED
-#endif
-
-#if HTS_COMPILER_HAS(__deprecated__) || HTS_GCC_AT_LEAST(4,5)
-#define HTS_DEPRECATED(message) __attribute__ ((__deprecated__ (message)))
-#elif HTS_GCC_AT_LEAST(3,1)
-#define HTS_DEPRECATED(message) __attribute__ ((__deprecated__))
-#else
-#define HTS_DEPRECATED(message)
-#endif
-
-#if HTS_COMPILER_HAS(__deprecated__) || HTS_GCC_AT_LEAST(6,4)
-#define HTS_DEPRECATED_ENUM(message) __attribute__ ((__deprecated__ (message)))
-#else
-#define HTS_DEPRECATED_ENUM(message)
-#endif
-
-// On mingw the "printf" format type doesn't work.  It needs "gnu_printf"
-// in order to check %lld and %z, otherwise it defaults to checking against
-// the Microsoft library printf format options despite linking against the
-// GNU posix implementation of printf.  The __MINGW_PRINTF_FORMAT macro
-// expands to printf or gnu_printf as required, but obviously may not
-// exist
-#ifdef __MINGW_PRINTF_FORMAT
-#define HTS_PRINTF_FMT __MINGW_PRINTF_FORMAT
-#else
-#define HTS_PRINTF_FMT printf
-#endif
-
-#if HTS_COMPILER_HAS(__format__) || HTS_GCC_AT_LEAST(3,0)
-#define HTS_FORMAT(type, idx, first) __attribute__((__format__ (type, idx, first)))
-#else
-#define HTS_FORMAT(type, idx, first)
-#endif
-
-#if defined(_WIN32) || defined(__CYGWIN__)
-#if defined(HTS_BUILDING_LIBRARY)
-#define HTSLIB_EXPORT __declspec(dllexport)
-#else
-#define HTSLIB_EXPORT
-#endif
-#elif HTS_COMPILER_HAS(__visibility__) || HTS_GCC_AT_LEAST(4,0)
-#define HTSLIB_EXPORT __attribute__((__visibility__("default")))
-#elif defined(__SUNPRO_C) && __SUNPRO_C >= 0x550
-#define HTSLIB_EXPORT __global
-#else
-#define HTSLIB_EXPORT
-#endif
-
-#endif
diff -ruN stringtie.orig/htslib/htslib/hts_endian.h stringtie/htslib/htslib/hts_endian.h
--- stringtie.orig/htslib/htslib/hts_endian.h	2024-02-28 13:57:39.704579460 +0100
+++ stringtie/htslib/htslib/hts_endian.h	1970-01-01 01:00:00.000000000 +0100
@@ -1,354 +0,0 @@
-/// @file hts_endian.h
-/// Byte swapping and unaligned access functions.
-/*
-   Copyright (C) 2017 Genome Research Ltd.
-
-    Author: Rob Davies <rmd@sanger.ac.uk>
-
-Permission is hereby granted, free of charge, to any person obtaining a copy
-of this software and associated documentation files (the "Software"), to deal
-in the Software without restriction, including without limitation the rights
-to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
-copies of the Software, and to permit persons to whom the Software is
-furnished to do so, subject to the following conditions:
-
-The above copyright notice and this permission notice shall be included in
-all copies or substantial portions of the Software.
-
-THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
-IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
-FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
-THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
-LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
-FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
-DEALINGS IN THE SOFTWARE.  */
-
-#ifndef HTS_ENDIAN_H
-#define HTS_ENDIAN_H
-
-#include <stdint.h>
-
-/*
- * Compile-time endianness tests.
- *
- * Note that these tests may fail.  They should only be used to enable
- * faster versions of endian-neutral implementations.  The endian-neutral
- * version should always be available as a fall-back.
- *
- * See https://sourceforge.net/p/predef/wiki/Endianness/
- */
-
-/* Save typing as both endian and unaligned tests want to know about x86 */
-#if (defined(__i386__) || defined(__i386) || defined(__amd64__) || defined(__amd64) || defined(__x86_64__) || defined(__x86_64) || defined(__i686__) || defined(__i686)) && !defined(HTS_x86)
-#    define HTS_x86  /* x86 and x86_64 platform */
-#endif
-
-/** @def HTS_LITTLE_ENDIAN
- *  @brief Defined if platform is known to be little-endian
- */
-
-#ifndef HTS_LITTLE_ENDIAN
-#    if (defined(__BYTE_ORDER__) && __BYTE_ORDER__ == __ORDER_LITTLE_ENDIAN__) \
-      || defined(__LITTLE_ENDIAN__) \
-      || defined(HTS_x86) \
-      || defined(__ARMEL__) || defined(__THUMBEL__) || defined(__AARCH64EL__) \
-      || defined(_MIPSEL) || defined(__MIPSEL) || defined(__MIPSEL__)
-#        define HTS_LITTLE_ENDIAN
-#    endif
-#endif
-
-/** @def HTS_BIG_ENDIAN
- *  @brief Defined if platform is known to be big-endian
- */
-
-#ifndef HTS_BIG_ENDIAN
-#    if (defined(__BYTE_ORDER__) && __BYTE_ORDER__ == __ORDER_BIG_ENDIAN__) \
-      || defined(__BIG_ENDIAN__) \
-      || defined(__ARMEB__) || defined(__THUMBEB__) || defined(__AAARCHEB__) \
-      || defined(_MIPSEB) || defined(__MIPSEB) || defined(__MIPSEB__)
-#        define HTS_BIG_ENDIAN
-#    endif
-#endif
-
-/** @def HTS_ENDIAN_NEUTRAL
- *  @brief Define this to disable any endian-specific optimizations
- */
-
-#if defined(HTS_ENDIAN_NEUTRAL) || (defined(HTS_LITTLE_ENDIAN) && defined(HTS_BIG_ENDIAN))
-/* Disable all endian-specific code. */
-#    undef HTS_LITTLE_ENDIAN
-#    undef HTS_BIG_ENDIAN
-#endif
-
-/** @def HTS_ALLOW_UNALIGNED
- *  @brief Control use of unaligned memory access.
- *
- * Defining HTS_ALLOW_UNALIGNED=1 converts shift-and-or to simple casts on
- * little-endian platforms that can tolerate unaligned access (notably Intel
- * x86).
- *
- * Defining HTS_ALLOW_UNALIGNED=0 forces shift-and-or.
- */
-
-// Consider using AX_CHECK_ALIGNED_ACCESS_REQUIRED in autoconf.
-#ifndef HTS_ALLOW_UNALIGNED
-#    if defined(HTS_x86)
-#        define HTS_ALLOW_UNALIGNED 1
-#    else
-#        define HTS_ALLOW_UNALIGNED 0
-#    endif
-#endif
-
-#if HTS_ALLOW_UNALIGNED != 0
-#    if defined (__GNUC__) && (__GNUC__ > 4 || (__GNUC__ == 4 && __GNUC_MINOR__ >= 3))
-// This prevents problems with gcc's vectoriser generating the wrong
-// instructions for unaligned data.
-typedef uint16_t uint16_u __attribute__ ((__aligned__ (1)));
-typedef uint32_t uint32_u __attribute__ ((__aligned__ (1)));
-typedef uint64_t uint64_u __attribute__ ((__aligned__ (1)));
-#else
-typedef uint16_t uint16_u;
-typedef uint32_t uint32_u;
-typedef uint64_t uint64_u;
-#    endif
-#endif
-
-/// Get a uint16_t value from an unsigned byte array
-/** @param buf Pointer to source byte, may be unaligned
- *  @return A 16 bit unsigned integer
- *  The input is read in little-endian byte order.
- */
-static inline uint16_t le_to_u16(const uint8_t *buf) {
-#if defined(HTS_LITTLE_ENDIAN) && HTS_ALLOW_UNALIGNED != 0
-    return *((uint16_u *) buf);
-#else
-    return (uint16_t) buf[0] | ((uint16_t) buf[1] << 8);
-#endif
-}
-
-/// Get a uint32_t value from an unsigned byte array
-/** @param buf Pointer to source byte array, may be unaligned
- *  @return A 32 bit unsigned integer
- *  The input is read in little-endian byte order.
- */
-static inline uint32_t le_to_u32(const uint8_t *buf) {
-#if defined(HTS_LITTLE_ENDIAN) && HTS_ALLOW_UNALIGNED != 0
-    return *((uint32_u *) buf);
-#else
-    return ((uint32_t) buf[0] |
-            ((uint32_t) buf[1] << 8) |
-            ((uint32_t) buf[2] << 16) |
-            ((uint32_t) buf[3] << 24));
-#endif
-}
-
-/// Get a uint64_t value from an unsigned byte array
-/** @param buf Pointer to source byte array, may be unaligned
- *  @return A 64 bit unsigned integer
- *  The input is read in little-endian byte order.
- */
-static inline uint64_t le_to_u64(const uint8_t *buf) {
-#if defined(HTS_LITTLE_ENDIAN) && HTS_ALLOW_UNALIGNED != 0
-    return *((uint64_u *) buf);
-#else
-    return ((uint64_t) buf[0] |
-            ((uint64_t) buf[1] << 8) |
-            ((uint64_t) buf[2] << 16) |
-            ((uint64_t) buf[3] << 24) |
-            ((uint64_t) buf[4] << 32) |
-            ((uint64_t) buf[5] << 40) |
-            ((uint64_t) buf[6] << 48) |
-            ((uint64_t) buf[7] << 56));
-#endif
-}
-
-/// Store a uint16_t value in little-endian byte order
-/** @param val The value to store
- *  @param buf Where to store it (may be unaligned)
- */
-static inline void u16_to_le(uint16_t val, uint8_t *buf) {
-#if defined(HTS_LITTLE_ENDIAN) && HTS_ALLOW_UNALIGNED != 0
-    *((uint16_u *) buf) = val;
-#else
-    buf[0] = val & 0xff;
-    buf[1] = (val >> 8) & 0xff;
-#endif
-}
-
-/// Store a uint32_t value in little-endian byte order
-/** @param val The value to store
- *  @param buf Where to store it (may be unaligned)
- */
-static inline void u32_to_le(uint32_t val, uint8_t *buf) {
-#if defined(HTS_LITTLE_ENDIAN) && HTS_ALLOW_UNALIGNED != 0
-    *((uint32_u *) buf) = val;
-#else
-    buf[0] = val & 0xff;
-    buf[1] = (val >> 8) & 0xff;
-    buf[2] = (val >> 16) & 0xff;
-    buf[3] = (val >> 24) & 0xff;
-#endif
-}
-
-/// Store a uint64_t value in little-endian byte order
-/** @param val The value to store
- *  @param buf Where to store it (may be unaligned)
- */
-static inline void u64_to_le(uint64_t val, uint8_t *buf) {
-#if defined(HTS_LITTLE_ENDIAN) && HTS_ALLOW_UNALIGNED != 0
-    *((uint64_u *) buf) = val;
-#else
-    buf[0] = val & 0xff;
-    buf[1] = (val >> 8) & 0xff;
-    buf[2] = (val >> 16) & 0xff;
-    buf[3] = (val >> 24) & 0xff;
-    buf[4] = (val >> 32) & 0xff;
-    buf[5] = (val >> 40) & 0xff;
-    buf[6] = (val >> 48) & 0xff;
-    buf[7] = (val >> 56) & 0xff;
-#endif
-}
-
-/* Signed values.  Grab the data as unsigned, then convert to signed without
- * triggering undefined behaviour.  On any sensible platform, the conversion
- * should optimise away to nothing.
- */
-
-/// Get an int8_t value from an unsigned byte array
-/** @param buf Pointer to source byte array, may be unaligned
- *  @return A 8 bit signed integer
- *  The input data is interpreted as 2's complement representation.
- */
-static inline int8_t le_to_i8(const uint8_t *buf) {
-    return *buf < 0x80 ? (int8_t) *buf : -((int8_t) (0xff - *buf)) - 1;
-}
-
-/// Get an int16_t value from an unsigned byte array
-/** @param buf Pointer to source byte array, may be unaligned
- *  @return A 16 bit signed integer
- *  The input data is interpreted as 2's complement representation in
- *  little-endian byte order.
- */
-static inline int16_t le_to_i16(const uint8_t *buf) {
-    uint16_t v = le_to_u16(buf);
-    return v < 0x8000 ? (int16_t) v : -((int16_t) (0xffff - v)) - 1;
-}
-
-/// Get an int32_t value from an unsigned byte array
-/** @param buf Pointer to source byte array, may be unaligned
- *  @return A 32 bit signed integer
- *  The input data is interpreted as 2's complement representation in
- *  little-endian byte order.
- */
-static inline int32_t le_to_i32(const uint8_t *buf) {
-    uint32_t v = le_to_u32(buf);
-    return v < 0x80000000U ? (int32_t) v : -((int32_t) (0xffffffffU - v)) - 1;
-}
-
-/// Get an int64_t value from an unsigned byte array
-/** @param buf Pointer to source byte array, may be unaligned
- *  @return A 64 bit signed integer
- *  The input data is interpreted as 2's complement representation in
- *  little-endian byte order.
- */
-static inline int64_t le_to_i64(const uint8_t *buf) {
-    uint64_t v = le_to_u64(buf);
-    return (v < 0x8000000000000000ULL
-            ? (int64_t) v : -((int64_t) (0xffffffffffffffffULL - v)) - 1);
-}
-
-// Converting the other way is easier as signed -> unsigned is well defined.
-
-/// Store a uint16_t value in little-endian byte order
-/** @param val The value to store
- *  @param buf Where to store it (may be unaligned)
- */
-static inline void i16_to_le(int16_t val, uint8_t *buf) {
-    u16_to_le(val, buf);
-}
-
-/// Store a uint32_t value in little-endian byte order
-/** @param val The value to store
- *  @param buf Where to store it (may be unaligned)
- */
-static inline void i32_to_le(int32_t val, uint8_t *buf) {
-    u32_to_le(val, buf);
-}
-
-/// Store a uint64_t value in little-endian byte order
-/** @param val The value to store
- *  @param buf Where to store it (may be unaligned)
- */
-static inline void i64_to_le(int64_t val, uint8_t *buf) {
-    u64_to_le(val, buf);
-}
-
-/* Floating point.  Assumptions:
- *  Platform uses IEEE 754 format
- *  sizeof(float) == sizeof(uint32_t)
- *  sizeof(double) == sizeof(uint64_t)
- *  Endian-ness is the same for both floating point and integer
- *  Type-punning via a union is allowed
- */
-
-/// Get a float value from an unsigned byte array
-/** @param buf Pointer to source byte array, may be unaligned
- *  @return A 32 bit floating point value
- *  The input is interpreted as an IEEE 754 format float in little-endian
- *  byte order.
- */
-static inline float le_to_float(const uint8_t *buf) {
-    union {
-        uint32_t u;
-        float   f;
-    } convert;
-
-    convert.u = le_to_u32(buf);
-    return convert.f;
-}
-
-/// Get a double value from an unsigned byte array
-/** @param buf Pointer to source byte array, may be unaligned
- *  @return A 64 bit floating point value
- *  The input is interpreted as an IEEE 754 format double in little-endian
- *  byte order.
- */
-static inline double le_to_double(const uint8_t *buf) {
-    union {
-        uint64_t u;
-        double   f;
-    } convert;
-
-    convert.u = le_to_u64(buf);
-    return convert.f;
-}
-
-/// Store a float value in little-endian byte order
-/** @param val The value to store
- *  @param buf Where to store it (may be unaligned)
- */
-static inline void float_to_le(float val, uint8_t *buf) {
-    union {
-        uint32_t u;
-        float f;
-    } convert;
-
-    convert.f = val;
-    u32_to_le(convert.u, buf);
-}
-
-/// Store a double value in little-endian byte order
-/** @param val The value to store
- *  @param buf Where to store it (may be unaligned)
- */
-static inline void double_to_le(double val, uint8_t *buf) {
-    union {
-        uint64_t u;
-        double f;
-    } convert;
-
-    convert.f = val;
-    u64_to_le(convert.u, buf);
-}
-
-#endif /* HTS_ENDIAN_H */
diff -ruN stringtie.orig/htslib/htslib/hts_expr.h stringtie/htslib/htslib/hts_expr.h
--- stringtie.orig/htslib/htslib/hts_expr.h	2024-02-28 13:57:39.704579460 +0100
+++ stringtie/htslib/htslib/hts_expr.h	1970-01-01 01:00:00.000000000 +0100
@@ -1,97 +0,0 @@
-/*  expr.c -- filter expression parsing and processing.
-
-    Copyright (C) 2020 Genome Research Ltd.
-
-    Author: James Bonfield <jkb@sanger.ac.uk>
-
-Permission is hereby granted, free of charge, to any person obtaining a copy
-of this software and associated documentation files (the "Software"), to deal
-in the Software without restriction, including without limitation the rights
-to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
-copies of the Software, and to permit persons to whom the Software is
-furnished to do so, subject to the following conditions:
-
-The above copyright notices and this permission notice shall be included in
-all copies or substantial portions of the Software.
-
-THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
-IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
-FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
-THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
-LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
-FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
-DEALINGS IN THE SOFTWARE.  */
-
-#ifndef HTS_EXPR_H
-#define HTS_EXPR_H
-
-#include "kstring.h"
-#include "hts_defs.h"
-
-/// Holds a filter variable.  This is also used to return the results.
-/**
- * Note we cope with zero-but-true in order to implement a basic
- * "exists(something)" check where "something" may even be zero.
- *
- * Eg in the aux tag searching syntax, "[NM]" should return true if
- * NM tag exists even if zero.
- * Take care when negating this. "[NM] != 0" will be true when
- * [NM] is absent, thus consider "[NM] && [NM] != 0".
- */
-typedef struct hts_expr_val_t {
-    char is_str;  // Use .s vs .d
-    char is_true; // Force true if even zero
-    kstring_t s;  // is_str and empty s permitted (eval as false)
-    double d;     // otherwise this
-} hts_expr_val_t;
-
-/// Frees a hts_expr_val_t type.
-static inline void hts_expr_val_free(hts_expr_val_t *f) {
-    ks_free(&f->s);
-}
-
-/// Opaque hts_filter_t type.  Definition in hts_expr.c
-typedef struct hts_filter_t hts_filter_t;
-
-/// For static initialisation of hts_expr_val_t values
-#define HTS_EXPR_VAL_INIT {0, 0, KS_INITIALIZE, 0}
-
-/// Creates a filter for expression "str".
-/** @param str    The filter expression
- *  @return       A pointer on success, NULL on failure
- */
-HTSLIB_EXPORT
-hts_filter_t *hts_filter_init(const char *str);
-
-/// Frees an hts_filter_t created via hts_filter_init
-/** @param filt    The filter pointer.
- */
-HTSLIB_EXPORT
-void hts_filter_free(hts_filter_t *filt);
-
-/// Type for expression symbol lookups; name -> value.
-typedef int (hts_expr_sym_func)(void *data, char *str, char **end,
-                                hts_expr_val_t *res);
-
-/// Evaluates a filter expression and returns the value
-/** @param filt      The filter, produced by hts_filter_init
- *  @param data      Arbitrary caller data, passed into sym_func
- *  @param sym_func  Callback function to lookup variables.
- *  @param res       Filled out with the result of the filter evaluation
- *  @return          Returns 0 on success, -1 on failure
- *
- *  sym_func and data may be NULL if the caller does not need its own data
- *  pointer or if it has no variables to lookup.
- *
- *  The type of the returned result may be numeric of string, as defined by
- *  the is_str member.  It can also be explicitly defined to be true even
- *  for a null value.  This may be used to check for the existence of
- *  something, irrespective of whether that something evaluates to zero.
- */
-HTSLIB_EXPORT
-int hts_filter_eval(hts_filter_t *filt,
-                    void *data, hts_expr_sym_func *sym_func,
-                    hts_expr_val_t *res);
-
-
-#endif /* HTS_EXPR_H */
diff -ruN stringtie.orig/htslib/htslib/hts.h stringtie/htslib/htslib/hts.h
--- stringtie.orig/htslib/htslib/hts.h	2024-02-28 13:57:39.704579460 +0100
+++ stringtie/htslib/htslib/hts.h	1970-01-01 01:00:00.000000000 +0100
@@ -1,1468 +0,0 @@
-/// @file htslib/hts.h
-/// Format-neutral I/O, indexing, and iterator API functions.
-/*
-    Copyright (C) 2012-2020 Genome Research Ltd.
-    Copyright (C) 2010, 2012 Broad Institute.
-    Portions copyright (C) 2003-2006, 2008-2010 by Heng Li <lh3@live.co.uk>
-
-    Author: Heng Li <lh3@sanger.ac.uk>
-
-Permission is hereby granted, free of charge, to any person obtaining a copy
-of this software and associated documentation files (the "Software"), to deal
-in the Software without restriction, including without limitation the rights
-to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
-copies of the Software, and to permit persons to whom the Software is
-furnished to do so, subject to the following conditions:
-
-The above copyright notice and this permission notice shall be included in
-all copies or substantial portions of the Software.
-
-THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
-IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
-FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
-THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
-LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
-FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
-DEALINGS IN THE SOFTWARE.  */
-
-#ifndef HTSLIB_HTS_H
-#define HTSLIB_HTS_H
-
-#include <stddef.h>
-#include <stdint.h>
-#include <inttypes.h>
-
-#include "hts_defs.h"
-#include "hts_log.h"
-#include "kstring.h"
-#include "kroundup.h"
-
-#ifdef __cplusplus
-extern "C" {
-#endif
-
-// Separator used to split HTS_PATH (for plugins); REF_PATH (cram references)
-#if defined(_WIN32) || defined(__MSYS__)
-#define HTS_PATH_SEPARATOR_CHAR ';'
-#define HTS_PATH_SEPARATOR_STR  ";"
-#else
-#define HTS_PATH_SEPARATOR_CHAR ':'
-#define HTS_PATH_SEPARATOR_STR  ":"
-#endif
-
-#ifndef HTS_BGZF_TYPEDEF
-typedef struct BGZF BGZF;
-#define HTS_BGZF_TYPEDEF
-#endif
-struct cram_fd;
-struct hFILE;
-struct hts_tpool;
-struct sam_hdr_t;
-
-/**
- * @hideinitializer
- * Deprecated macro to expand a dynamic array of a given type
- *
- * @param         type_t The type of the array elements
- * @param[in]     n      Requested number of elements of type type_t
- * @param[in,out] m      Size of memory allocated
- * @param[in,out] ptr    Pointer to the array
- *
- * @discussion
- * Do not use this macro.  Use hts_resize() instead as allows allocation
- * failures to be handled more gracefully.
- *
- * The array *ptr will be expanded if necessary so that it can hold @p n
- * or more elements.  If the array is expanded then the new size will be
- * written to @p m and the value in @p ptr may change.
- *
- * It must be possible to take the address of @p ptr and @p m must be usable
- * as an lvalue.
- *
- * @bug
- * If the memory allocation fails, this will call exit(1).  This is
- * not ideal behaviour in a library.
- */
-#define hts_expand(type_t, n, m, ptr) do {                              \
-        if ((n) > (m)) {                                                \
-            size_t hts_realloc_or_die(size_t, size_t, size_t, size_t,   \
-                                      int, void **, const char *);      \
-            (m) = hts_realloc_or_die((n) >= 1 ? (n) : 1, (m), sizeof(m), \
-                                     sizeof(type_t),  0,                \
-                                     (void **)&(ptr), __func__);        \
-        }                                                               \
-    } while (0)
-
-/**
- * @hideinitializer
- * Macro to expand a dynamic array, zeroing any newly-allocated memory
- *
- * @param         type_t The type of the array elements
- * @param[in]     n      Requested number of elements of type type_t
- * @param[in,out] m      Size of memory allocated
- * @param[in,out] ptr    Pointer to the array
- *
- * @discussion
- * Do not use this macro.  Use hts_resize() instead as allows allocation
- * failures to be handled more gracefully.
- *
- * As for hts_expand(), except the bytes that make up the array elements
- * between the old and new values of @p m are set to zero using memset().
- *
- * @bug
- * If the memory allocation fails, this will call exit(1).  This is
- * not ideal behaviour in a library.
- */
-
-
-#define hts_expand0(type_t, n, m, ptr) do {                             \
-        if ((n) > (m)) {                                                \
-            size_t hts_realloc_or_die(size_t, size_t, size_t, size_t,   \
-                                      int, void **, const char *);      \
-            (m) = hts_realloc_or_die((n) >= 1 ? (n) : 1, (m), sizeof(m), \
-                                     sizeof(type_t), 1,                 \
-                                     (void **)&(ptr), __func__);        \
-        }                                                               \
-    } while (0)
-
-// For internal use (by hts_resize()) only
-HTSLIB_EXPORT
-int hts_resize_array_(size_t, size_t, size_t, void *, void **, int,
-                      const char *);
-
-#define HTS_RESIZE_CLEAR 1
-
-/**
- * @hideinitializer
- * Macro to expand a dynamic array of a given type
- *
- * @param         type_t    The type of the array elements
- * @param[in]     num       Requested number of elements of type type_t
- * @param[in,out] size_ptr  Pointer to where the size (in elements) of the
-                            array is stored.
- * @param[in,out] ptr       Location of the pointer to the array
- * @param[in]     flags     Option flags
- *
- * @return        0 for success, or negative if an error occurred.
- *
- * @discussion
- * The array *ptr will be expanded if necessary so that it can hold @p num
- * or more elements.  If the array is expanded then the new size will be
- * written to @p *size_ptr and the value in @p *ptr may change.
- *
- * If ( @p flags & HTS_RESIZE_CLEAR ) is set, any newly allocated memory will
- * be cleared.
- */
-
-#define hts_resize(type_t, num, size_ptr, ptr, flags)       \
-    ((num) > (*(size_ptr))                                  \
-     ? hts_resize_array_(sizeof(type_t), (num),             \
-                         sizeof(*(size_ptr)), (size_ptr),   \
-                         (void **)(ptr), (flags), __func__) \
-     : 0)
-
-/// Release resources when dlclosing a dynamically loaded HTSlib
-/** @discussion
- *  Normally HTSlib cleans up automatically when your program exits,
- *  whether that is via exit(3) or returning from main(). However if you
- *  have dlopen(3)ed HTSlib and wish to close it before your main program
- *  exits, you must call hts_lib_shutdown() before dlclose(3).
-*/
-HTSLIB_EXPORT
-void hts_lib_shutdown(void);
-
-/**
- * Wrapper function for free(). Enables memory deallocation across DLL
- * boundary. Should be used by all applications, which are compiled
- * with a different standard library than htslib and call htslib
- * methods that return dynamically allocated data.
- */
-HTSLIB_EXPORT
-void hts_free(void *ptr);
-
-/************
- * File I/O *
- ************/
-
-// Add new entries only at the end (but before the *_maximum entry)
-// of these enums, as their numbering is part of the htslib ABI.
-
-enum htsFormatCategory {
-    unknown_category,
-    sequence_data,    // Sequence data -- SAM, BAM, CRAM, etc
-    variant_data,     // Variant calling data -- VCF, BCF, etc
-    index_file,       // Index file associated with some data file
-    region_list,      // Coordinate intervals or regions -- BED, etc
-    category_maximum = 32767
-};
-
-enum htsExactFormat {
-    unknown_format,
-    binary_format, text_format,
-    sam, bam, bai, cram, crai, vcf, bcf, csi, gzi, tbi, bed,
-    htsget,
-    json HTS_DEPRECATED_ENUM("Use htsExactFormat 'htsget' instead") = htsget,
-    empty_format,  // File is empty (or empty after decompression)
-    fasta_format, fastq_format, fai_format, fqi_format,
-    hts_crypt4gh_format,
-    format_maximum = 32767
-};
-
-enum htsCompression {
-    no_compression, gzip, bgzf, custom, bzip2_compression, razf_compression,
-    compression_maximum = 32767
-};
-
-typedef struct htsFormat {
-    enum htsFormatCategory category;
-    enum htsExactFormat format;
-    struct { short major, minor; } version;
-    enum htsCompression compression;
-    short compression_level;  // currently unused
-    void *specific;  // format specific options; see struct hts_opt.
-} htsFormat;
-
-struct hts_idx_t;
-typedef struct hts_idx_t hts_idx_t;
-struct hts_filter_t;
-
-/**
- * @brief File handle returned by hts_open() etc.
- * This structure should be considered opaque by end users. There should be
- * no need to access most fields directly in user code, and in cases where
- * it is desirable accessor functions such as hts_get_format() are provided.
- */
-// Maintainers note htsFile cannot be an incomplete struct because some of its
-// fields are part of libhts.so's ABI (hence these fields must not be moved):
-//  - fp is used in the public sam_itr_next()/etc macros
-//  - is_bin is used directly in samtools <= 1.1 and bcftools <= 1.1
-//  - is_write and is_cram are used directly in samtools <= 1.1
-//  - fp is used directly in samtools (up to and including current develop)
-//  - line is used directly in bcftools (up to and including current develop)
-//  - is_bgzf and is_cram flags indicate which fp union member to use.
-//    Note is_bgzf being set does not indicate the flag is BGZF compressed,
-//    nor even whether it is compressed at all (eg on naked BAMs).
-typedef struct htsFile {
-    uint32_t is_bin:1, is_write:1, is_be:1, is_cram:1, is_bgzf:1, dummy:27;
-    int64_t lineno;
-    kstring_t line;
-    char *fn, *fn_aux;
-    union {
-        BGZF *bgzf;
-        struct cram_fd *cram;
-        struct hFILE *hfile;
-    } fp;
-    void *state;  // format specific state information
-    htsFormat format;
-    hts_idx_t *idx;
-    const char *fnidx;
-    struct sam_hdr_t *bam_header;
-    struct hts_filter_t *filter;
-} htsFile;
-
-// A combined thread pool and queue allocation size.
-// The pool should already be defined, but qsize may be zero to
-// indicate an appropriate queue size is taken from the pool.
-//
-// Reasons for explicitly setting it could be where many more file
-// descriptors are in use than threads, so keeping memory low is
-// important.
-typedef struct htsThreadPool {
-    struct hts_tpool *pool; // The shared thread pool itself
-    int qsize;    // Size of I/O queue to use for this fp
-} htsThreadPool;
-
-// REQUIRED_FIELDS
-enum sam_fields {
-    SAM_QNAME = 0x00000001,
-    SAM_FLAG  = 0x00000002,
-    SAM_RNAME = 0x00000004,
-    SAM_POS   = 0x00000008,
-    SAM_MAPQ  = 0x00000010,
-    SAM_CIGAR = 0x00000020,
-    SAM_RNEXT = 0x00000040,
-    SAM_PNEXT = 0x00000080,
-    SAM_TLEN  = 0x00000100,
-    SAM_SEQ   = 0x00000200,
-    SAM_QUAL  = 0x00000400,
-    SAM_AUX   = 0x00000800,
-    SAM_RGAUX = 0x00001000,
-};
-
-// Mostly CRAM only, but this could also include other format options
-enum hts_fmt_option {
-    // CRAM specific
-    CRAM_OPT_DECODE_MD,
-    CRAM_OPT_PREFIX,
-    CRAM_OPT_VERBOSITY,  // obsolete, use hts_set_log_level() instead
-    CRAM_OPT_SEQS_PER_SLICE,
-    CRAM_OPT_SLICES_PER_CONTAINER,
-    CRAM_OPT_RANGE,
-    CRAM_OPT_VERSION,    // rename to cram_version?
-    CRAM_OPT_EMBED_REF,
-    CRAM_OPT_IGNORE_MD5,
-    CRAM_OPT_REFERENCE,  // make general
-    CRAM_OPT_MULTI_SEQ_PER_SLICE,
-    CRAM_OPT_NO_REF,
-    CRAM_OPT_USE_BZIP2,
-    CRAM_OPT_SHARED_REF,
-    CRAM_OPT_NTHREADS,   // deprecated, use HTS_OPT_NTHREADS
-    CRAM_OPT_THREAD_POOL,// make general
-    CRAM_OPT_USE_LZMA,
-    CRAM_OPT_USE_RANS,
-    CRAM_OPT_REQUIRED_FIELDS,
-    CRAM_OPT_LOSSY_NAMES,
-    CRAM_OPT_BASES_PER_SLICE,
-    CRAM_OPT_STORE_MD,
-    CRAM_OPT_STORE_NM,
-    CRAM_OPT_RANGE_NOSEEK, // CRAM_OPT_RANGE minus the seek
-    CRAM_OPT_USE_TOK,
-    CRAM_OPT_USE_FQZ,
-    CRAM_OPT_USE_ARITH,
-    CRAM_OPT_POS_DELTA,  // force delta for AP, even on non-pos sorted data
-
-    // General purpose
-    HTS_OPT_COMPRESSION_LEVEL = 100,
-    HTS_OPT_NTHREADS,
-    HTS_OPT_THREAD_POOL,
-    HTS_OPT_CACHE_SIZE,
-    HTS_OPT_BLOCK_SIZE,
-    HTS_OPT_FILTER,
-    HTS_OPT_PROFILE,
-};
-
-// Profile options for encoding; primarily used at present in CRAM
-// but also usable in BAM as a synonym for deflate compression levels.
-enum hts_profile_option {
-    HTS_PROFILE_FAST,
-    HTS_PROFILE_NORMAL,
-    HTS_PROFILE_SMALL,
-    HTS_PROFILE_ARCHIVE,
-};
-
-// For backwards compatibility
-#define cram_option hts_fmt_option
-
-typedef struct hts_opt {
-    char *arg;                // string form, strdup()ed
-    enum hts_fmt_option opt;  // tokenised key
-    union {                   // ... and value
-        int i;
-        char *s;
-    } val;
-    struct hts_opt *next;
-} hts_opt;
-
-#define HTS_FILE_OPTS_INIT {{0},0}
-
-/*
- * Explicit index file name delimiter, see below
- */
-#define HTS_IDX_DELIM "##idx##"
-
-
-/**********************
- * Exported functions *
- **********************/
-
-/*
- * Parses arg and appends it to the option list.
- *
- * Returns 0 on success;
- *        -1 on failure.
- */
-HTSLIB_EXPORT
-int hts_opt_add(hts_opt **opts, const char *c_arg);
-
-/*
- * Applies an hts_opt option list to a given htsFile.
- *
- * Returns 0 on success
- *        -1 on failure
- */
-HTSLIB_EXPORT
-int hts_opt_apply(htsFile *fp, hts_opt *opts);
-
-/*
- * Frees an hts_opt list.
- */
-HTSLIB_EXPORT
-void hts_opt_free(hts_opt *opts);
-
-/*
- * Accepts a string file format (sam, bam, cram, vcf, bam) optionally
- * followed by a comma separated list of key=value options and splits
- * these up into the fields of htsFormat struct.
- *
- * Returns 0 on success
- *        -1 on failure.
- */
-HTSLIB_EXPORT
-int hts_parse_format(htsFormat *opt, const char *str);
-
-/*
- * Tokenise options as (key(=value)?,)*(key(=value)?)?
- * NB: No provision for ',' appearing in the value!
- * Add backslashing rules?
- *
- * This could be used as part of a general command line option parser or
- * as a string concatenated onto the file open mode.
- *
- * Returns 0 on success
- *        -1 on failure.
- */
-HTSLIB_EXPORT
-int hts_parse_opt_list(htsFormat *opt, const char *str);
-
-/*! @abstract Table for converting a nucleotide character to 4-bit encoding.
-The input character may be either an IUPAC ambiguity code, '=' for 0, or
-'0'/'1'/'2'/'3' for a result of 1/2/4/8.  The result is encoded as 1/2/4/8
-for A/C/G/T or combinations of these bits for ambiguous bases.
-*/
-extern const unsigned char seq_nt16_table[256];
-
-/*! @abstract Table for converting a 4-bit encoded nucleotide to an IUPAC
-ambiguity code letter (or '=' when given 0).
-*/
-extern const char seq_nt16_str[];
-
-/*! @abstract Table for converting a 4-bit encoded nucleotide to about 2 bits.
-Returns 0/1/2/3 for 1/2/4/8 (i.e., A/C/G/T), or 4 otherwise (0 or ambiguous).
-*/
-extern const int seq_nt16_int[];
-
-/*!
-  @abstract  Get the htslib version number
-  @return    For released versions, a string like "N.N[.N]"; or git describe
-  output if using a library built within a Git repository.
-*/
-HTSLIB_EXPORT
-const char *hts_version(void);
-
-/*!
-  @abstract  Compile-time HTSlib version number, for use in #if checks
-  @return    For released versions X.Y[.Z], an integer of the form XYYYZZ;
-  useful for preprocessor conditionals such as
-      #if HTS_VERSION >= 101000  // Check for v1.10 or later
-*/
-// Maintainers: Bump this in the final stage of preparing a new release.
-// Immediately after release, bump ZZ to 90 to distinguish in-development
-// Git repository builds from the release; you may wish to increment this
-// further when significant features are merged.
-#define HTS_VERSION 101200
-
-/*! @abstract Introspection on the features enabled in htslib
- *
- * @return a bitfield of HTS_FEATURE_* macros.
- */
-HTSLIB_EXPORT
-unsigned int hts_features(void);
-
-HTSLIB_EXPORT
-const char *hts_test_feature(unsigned int id);
-
-/*! @abstract Introspection on the features enabled in htslib, string form
- *
- * @return a string describing htslib build features
- */
-HTSLIB_EXPORT
-const char *hts_feature_string(void);
-
-// Whether ./configure was used or vanilla Makefile
-#define HTS_FEATURE_CONFIGURE    1
-
-// Whether --enable-plugins was used
-#define HTS_FEATURE_PLUGINS      2
-
-// Transport specific
-#define HTS_FEATURE_LIBCURL      (1u<<10)
-#define HTS_FEATURE_S3           (1u<<11)
-#define HTS_FEATURE_GCS          (1u<<12)
-
-// Compression options
-#define HTS_FEATURE_LIBDEFLATE   (1u<<20)
-#define HTS_FEATURE_LZMA         (1u<<21)
-#define HTS_FEATURE_BZIP2        (1u<<22)
-#define HTS_FEATURE_HTSCODECS    (1u<<23) // htscodecs library version
-
-// Build params
-#define HTS_FEATURE_CC           (1u<<27)
-#define HTS_FEATURE_CFLAGS       (1u<<28)
-#define HTS_FEATURE_CPPFLAGS     (1u<<29)
-#define HTS_FEATURE_LDFLAGS      (1u<<30)
-
-
-/*!
-  @abstract    Determine format by peeking at the start of a file
-  @param fp    File opened for reading, positioned at the beginning
-  @param fmt   Format structure that will be filled out on return
-  @return      0 for success, or negative if an error occurred.
-*/
-HTSLIB_EXPORT
-int hts_detect_format(struct hFILE *fp, htsFormat *fmt);
-
-/*!
-  @abstract    Get a human-readable description of the file format
-  @param fmt   Format structure holding type, version, compression, etc.
-  @return      Description string, to be freed by the caller after use.
-*/
-HTSLIB_EXPORT
-char *hts_format_description(const htsFormat *format);
-
-/*!
-  @abstract       Open a sequence data (SAM/BAM/CRAM) or variant data (VCF/BCF)
-                  or possibly-compressed textual line-orientated file
-  @param fn       The file name or "-" for stdin/stdout. For indexed files
-                  with a non-standard naming, the file name can include the
-                  name of the index file delimited with HTS_IDX_DELIM
-  @param mode     Mode matching / [rwa][bceguxz0-9]* /
-  @discussion
-      With 'r' opens for reading; any further format mode letters are ignored
-      as the format is detected by checking the first few bytes or BGZF blocks
-      of the file.  With 'w' or 'a' opens for writing or appending, with format
-      specifier letters:
-        b  binary format (BAM, BCF, etc) rather than text (SAM, VCF, etc)
-        c  CRAM format
-        g  gzip compressed
-        u  uncompressed
-        z  bgzf compressed
-        [0-9]  zlib compression level
-      and with non-format option letters (for any of 'r'/'w'/'a'):
-        e  close the file on exec(2) (opens with O_CLOEXEC, where supported)
-        x  create the file exclusively (opens with O_EXCL, where supported)
-      Note that there is a distinction between 'u' and '0': the first yields
-      plain uncompressed output whereas the latter outputs uncompressed data
-      wrapped in the zlib format.
-  @example
-      [rw]b  .. compressed BCF, BAM, FAI
-      [rw]bu .. uncompressed BCF
-      [rw]z  .. compressed VCF
-      [rw]   .. uncompressed VCF
-*/
-HTSLIB_EXPORT
-htsFile *hts_open(const char *fn, const char *mode);
-
-/*!
-  @abstract       Open a SAM/BAM/CRAM/VCF/BCF/etc file
-  @param fn       The file name or "-" for stdin/stdout
-  @param mode     Open mode, as per hts_open()
-  @param fmt      Optional format specific parameters
-  @discussion
-      See hts_open() for description of fn and mode.
-      // TODO Update documentation for s/opts/fmt/
-      Opts contains a format string (sam, bam, cram, vcf, bcf) which will,
-      if defined, override mode.  Opts also contains a linked list of hts_opt
-      structures to apply to the open file handle.  These can contain things
-      like pointers to the reference or information on compression levels,
-      block sizes, etc.
-*/
-HTSLIB_EXPORT
-htsFile *hts_open_format(const char *fn, const char *mode, const htsFormat *fmt);
-
-/*!
-  @abstract       Open an existing stream as a SAM/BAM/CRAM/VCF/BCF/etc file
-  @param fn       The already-open file handle
-  @param mode     Open mode, as per hts_open()
-*/
-HTSLIB_EXPORT
-htsFile *hts_hopen(struct hFILE *fp, const char *fn, const char *mode);
-
-/*!
-  @abstract  Close a file handle, flushing buffered data for output streams
-  @param fp  The file handle to be closed
-  @return    0 for success, or negative if an error occurred.
-*/
-HTSLIB_EXPORT
-int hts_close(htsFile *fp);
-
-/*!
-  @abstract  Returns the file's format information
-  @param fp  The file handle
-  @return    Read-only pointer to the file's htsFormat.
-*/
-HTSLIB_EXPORT
-const htsFormat *hts_get_format(htsFile *fp);
-
-/*!
-  @ abstract      Returns a string containing the file format extension.
-  @ param format  Format structure containing the file type.
-  @ return        A string ("sam", "bam", etc) or "?" for unknown formats.
- */
-HTSLIB_EXPORT
-const char *hts_format_file_extension(const htsFormat *format);
-
-/*!
-  @abstract  Sets a specified CRAM option on the open file handle.
-  @param fp  The file handle open the open file.
-  @param opt The CRAM_OPT_* option.
-  @param ... Optional arguments, dependent on the option used.
-  @return    0 for success, or negative if an error occurred.
-*/
-HTSLIB_EXPORT
-int hts_set_opt(htsFile *fp, enum hts_fmt_option opt, ...);
-
-/*!
-  @abstract         Read a line (and its \n or \r\n terminator) from a file
-  @param fp         The file handle
-  @param delimiter  Unused, but must be '\n' (or KS_SEP_LINE)
-  @param str        The line (not including the terminator) is written here
-  @return           Length of the string read;
-                    -1 on end-of-file; <= -2 on error
-*/
-HTSLIB_EXPORT
-int hts_getline(htsFile *fp, int delimiter, kstring_t *str);
-
-HTSLIB_EXPORT
-char **hts_readlines(const char *fn, int *_n);
-/*!
-    @abstract       Parse comma-separated list or read list from a file
-    @param list     File name or comma-separated list
-    @param is_file
-    @param _n       Size of the output array (number of items read)
-    @return         NULL on failure or pointer to newly allocated array of
-                    strings
-*/
-HTSLIB_EXPORT
-char **hts_readlist(const char *fn, int is_file, int *_n);
-
-/*!
-  @abstract  Create extra threads to aid compress/decompression for this file
-  @param fp  The file handle
-  @param n   The number of worker threads to create
-  @return    0 for success, or negative if an error occurred.
-  @notes     This function creates non-shared threads for use solely by fp.
-             The hts_set_thread_pool function is the recommended alternative.
-*/
-HTSLIB_EXPORT
-int hts_set_threads(htsFile *fp, int n);
-
-/*!
-  @abstract  Create extra threads to aid compress/decompression for this file
-  @param fp  The file handle
-  @param p   A pool of worker threads, previously allocated by hts_create_threads().
-  @return    0 for success, or negative if an error occurred.
-*/
-HTSLIB_EXPORT
-int hts_set_thread_pool(htsFile *fp, htsThreadPool *p);
-
-/*!
-  @abstract  Adds a cache of decompressed blocks, potentially speeding up seeks.
-             This may not work for all file types (currently it is bgzf only).
-  @param fp  The file handle
-  @param n   The size of cache, in bytes
-*/
-HTSLIB_EXPORT
-void hts_set_cache_size(htsFile *fp, int n);
-
-/*!
-  @abstract  Set .fai filename for a file opened for reading
-  @return    0 for success, negative on failure
-  @discussion
-      Called before *_hdr_read(), this provides the name of a .fai file
-      used to provide a reference list if the htsFile contains no @SQ headers.
-*/
-HTSLIB_EXPORT
-int hts_set_fai_filename(htsFile *fp, const char *fn_aux);
-
-
-/*!
-  @abstract  Sets a filter expression
-  @return    0 for success, negative on failure
-  @discussion
-      To clear an existing filter, specifying expr as NULL.
-*/
-HTSLIB_EXPORT
-int hts_set_filter_expression(htsFile *fp, const char *expr);
-
-/*!
-  @abstract  Determine whether a given htsFile contains a valid EOF block
-  @return    3 for a non-EOF checkable filetype;
-             2 for an unseekable file type where EOF cannot be checked;
-             1 for a valid EOF block;
-             0 for if the EOF marker is absent when it should be present;
-            -1 (with errno set) on failure
-  @discussion
-      Check if the BGZF end-of-file (EOF) marker is present
-*/
-HTSLIB_EXPORT
-int hts_check_EOF(htsFile *fp);
-
-/************
- * Indexing *
- ************/
-
-/*!
-These HTS_IDX_* macros are used as special tid values for hts_itr_query()/etc,
-producing iterators operating as follows:
- - HTS_IDX_NOCOOR iterates over unmapped reads sorted at the end of the file
- - HTS_IDX_START  iterates over the entire file
- - HTS_IDX_REST   iterates from the current position to the end of the file
- - HTS_IDX_NONE   always returns "no more alignment records"
-When one of these special tid values is used, beg and end are ignored.
-When REST or NONE is used, idx is also ignored and may be NULL.
-*/
-#define HTS_IDX_NOCOOR (-2)
-#define HTS_IDX_START  (-3)
-#define HTS_IDX_REST   (-4)
-#define HTS_IDX_NONE   (-5)
-
-#define HTS_FMT_CSI 0
-#define HTS_FMT_BAI 1
-#define HTS_FMT_TBI 2
-#define HTS_FMT_CRAI 3
-#define HTS_FMT_FAI 4
-
-// Almost INT64_MAX, but when cast into a 32-bit int it's
-// also INT_MAX instead of -1.  This avoids bugs with old code
-// using the new hts_pos_t data type.
-#define HTS_POS_MAX ((((int64_t)INT_MAX)<<32)|INT_MAX)
-#define HTS_POS_MIN INT64_MIN
-#define PRIhts_pos PRId64
-typedef int64_t hts_pos_t;
-
-// For comparison with previous release:
-//
-// #define HTS_POS_MAX INT_MAX
-// #define HTS_POS_MIN INT_MIN
-// #define PRIhts_pos PRId32
-// typedef int32_t hts_pos_t;
-
-typedef struct hts_pair_pos_t {
-   hts_pos_t beg, end;
-} hts_pair_pos_t;
-
-typedef hts_pair_pos_t hts_pair32_t;  // For backwards compatibility
-
-typedef struct hts_pair64_t {
-    uint64_t u, v;
-} hts_pair64_t;
-
-typedef struct hts_pair64_max_t {
-    uint64_t u, v;
-    uint64_t max;
-} hts_pair64_max_t;
-
-typedef struct hts_reglist_t {
-    const char *reg;
-    hts_pair_pos_t *intervals;
-    int tid;
-    uint32_t count;
-    hts_pos_t min_beg, max_end;
-} hts_reglist_t;
-
-typedef int hts_readrec_func(BGZF *fp, void *data, void *r, int *tid, hts_pos_t *beg, hts_pos_t *end);
-typedef int hts_seek_func(void *fp, int64_t offset, int where);
-typedef int64_t hts_tell_func(void *fp);
-
-/**
- * @brief File iterator that can handle multiple target regions.
- * This structure should be considered opaque by end users.
- * It does both the stepping inside the file and the filtering of alignments.
- * It can operate in single or multi-region mode, and depending on this,
- * it uses different fields.
- *
- * read_rest (1) - read everything from the current offset, without filtering
- * finished  (1) - no more iterations
- * is_cram   (1) - current file has CRAM format
- * nocoor    (1) - read all unmapped reads
- *
- * multi     (1) - multi-region moode
- * reg_list  - List of target regions
- * n_reg     - Size of the above list
- * curr_reg  - List index of the current region of search
- * curr_intv - Interval index inside the current region; points to a (beg, end)
- * end       - Used for CRAM files, to preserve the max end coordinate
- *
- * multi     (0) - single-region mode
- * tid       - Reference id of the target region
- * beg       - Start position of the target region
- * end       - End position of the target region
- *
- * Common fields:
- * off        - List of file offsets computed from the index
- * n_off      - Size of the above list
- * i          - List index of the current file offset
- * curr_off   - File offset for the next file read
- * curr_tid   - Reference id of the current alignment
- * curr_beg   - Start position of the current alignment
- * curr_end   - End position of the current alignment
- * nocoor_off - File offset where the unmapped reads start
- *
- * readrec    - File specific function that reads an alignment
- * seek       - File specific function for changing the file offset
- * tell       - File specific function for indicating the file offset
- */
-
-typedef struct hts_itr_t {
-    uint32_t read_rest:1, finished:1, is_cram:1, nocoor:1, multi:1, dummy:27;
-    int tid, n_off, i, n_reg;
-    hts_pos_t beg, end;
-    hts_reglist_t *reg_list;
-    int curr_tid, curr_reg, curr_intv;
-    hts_pos_t curr_beg, curr_end;
-    uint64_t curr_off, nocoor_off;
-    hts_pair64_max_t *off;
-    hts_readrec_func *readrec;
-    hts_seek_func *seek;
-    hts_tell_func *tell;
-    struct {
-        int n, m;
-        int *a;
-    } bins;
-} hts_itr_t;
-
-typedef hts_itr_t hts_itr_multi_t;
-
-    #define hts_bin_first(l) (((1<<(((l)<<1) + (l))) - 1) / 7)
-    #define hts_bin_parent(l) (((l) - 1) >> 3)
-
-///////////////////////////////////////////////////////////
-// Low-level API for building indexes.
-
-/// Create a BAI/CSI/TBI type index structure
-/** @param n          Initial number of targets
-    @param fmt        Format, one of HTS_FMT_CSI, HTS_FMT_BAI or HTS_FMT_TBI
-    @param offset0    Initial file offset
-    @param min_shift  Number of bits for the minimal interval
-    @param n_lvls     Number of levels in the binning index
-    @return An initialised hts_idx_t struct on success; NULL on failure
-
-The struct returned by a successful call should be freed via hts_idx_destroy()
-when it is no longer needed.
-*/
-HTSLIB_EXPORT
-hts_idx_t *hts_idx_init(int n, int fmt, uint64_t offset0, int min_shift, int n_lvls);
-
-/// Free a BAI/CSI/TBI type index
-/** @param idx   Index structure to free
- */
-HTSLIB_EXPORT
-void hts_idx_destroy(hts_idx_t *idx);
-
-/// Push an index entry
-/** @param idx        Index
-    @param tid        Target id
-    @param beg        Range start (zero-based)
-    @param end        Range end (zero-based, half-open)
-    @param offset     File offset
-    @param is_mapped  Range corresponds to a mapped read
-    @return 0 on success; -1 on failure
-
-The @p is_mapped parameter is used to update the n_mapped / n_unmapped counts
-stored in the meta-data bin.
- */
-HTSLIB_EXPORT
-int hts_idx_push(hts_idx_t *idx, int tid, hts_pos_t beg, hts_pos_t end, uint64_t offset, int is_mapped);
-
-/// Finish building an index
-/** @param idx          Index
-    @param final_offset Last file offset
-    @return 0 on success; non-zero on failure.
-*/
-HTSLIB_EXPORT
-int hts_idx_finish(hts_idx_t *idx, uint64_t final_offset);
-
-/// Returns index format
-/** @param idx   Index
-    @return One of HTS_FMT_CSI, HTS_FMT_BAI or HTS_FMT_TBI
-*/
-HTSLIB_EXPORT
-int hts_idx_fmt(hts_idx_t *idx);
-
-/// Add name to TBI index meta-data
-/** @param idx   Index
-    @param tid   Target identifier
-    @param name  Target name
-    @return Index number of name in names list on success; -1 on failure.
-*/
-HTSLIB_EXPORT
-int hts_idx_tbi_name(hts_idx_t *idx, int tid, const char *name);
-
-// Index loading and saving
-
-/// Save an index to a file
-/** @param idx  Index to be written
-    @param fn   Input BAM/BCF/etc filename, to which .bai/.csi/etc will be added
-    @param fmt  One of the HTS_FMT_* index formats
-    @return  0 if successful, or negative if an error occurred.
-*/
-HTSLIB_EXPORT
-int hts_idx_save(const hts_idx_t *idx, const char *fn, int fmt) HTS_RESULT_USED;
-
-/// Save an index to a specific file
-/** @param idx    Index to be written
-    @param fn     Input BAM/BCF/etc filename
-    @param fnidx  Output filename, or NULL to add .bai/.csi/etc to @a fn
-    @param fmt    One of the HTS_FMT_* index formats
-    @return  0 if successful, or negative if an error occurred.
-*/
-HTSLIB_EXPORT
-int hts_idx_save_as(const hts_idx_t *idx, const char *fn, const char *fnidx, int fmt) HTS_RESULT_USED;
-
-/// Load an index file
-/** @param fn   BAM/BCF/etc filename, to which .bai/.csi/etc will be added or
-                the extension substituted, to search for an existing index file.
-                In case of a non-standard naming, the file name can include the
-                name of the index file delimited with HTS_IDX_DELIM.
-    @param fmt  One of the HTS_FMT_* index formats
-    @return  The index, or NULL if an error occurred.
-
-If @p fn contains the string "##idx##" (HTS_IDX_DELIM), the part before
-the delimiter will be used as the name of the data file and the part after
-it will be used as the name of the index.
-
-Otherwise, this function tries to work out the index name as follows:
-
-  It will try appending ".csi" to @p fn
-  It will try substituting an existing suffix (e.g. .bam, .vcf) with ".csi"
-  Then, if @p fmt is HTS_FMT_BAI:
-    It will try appending ".bai" to @p fn
-    To will substituting the existing suffix (e.g. .bam) with ".bai"
-  else if @p fmt is HTS_FMT_TBI:
-    It will try appending ".tbi" to @p fn
-    To will substituting the existing suffix (e.g. .vcf) with ".tbi"
-
-If the index file is remote (served over a protocol like https), first a check
-is made to see is a locally cached copy is available.  This is done for all
-of the possible names listed above.  If a cached copy is not available then
-the index will be downloaded and stored in the current working directory,
-with the same name as the remote index.
-
-    Equivalent to hts_idx_load3(fn, NULL, fmt, HTS_IDX_SAVE_REMOTE);
-*/
-HTSLIB_EXPORT
-hts_idx_t *hts_idx_load(const char *fn, int fmt);
-
-/// Load a specific index file
-/** @param fn     Input BAM/BCF/etc filename
-    @param fnidx  The input index filename
-    @return  The index, or NULL if an error occurred.
-
-    Equivalent to hts_idx_load3(fn, fnidx, 0, 0);
-
-    This function will not attempt to save index files locally.
-*/
-HTSLIB_EXPORT
-hts_idx_t *hts_idx_load2(const char *fn, const char *fnidx);
-
-/// Load a specific index file
-/** @param fn     Input BAM/BCF/etc filename
-    @param fnidx  The input index filename
-    @param fmt    One of the HTS_FMT_* index formats
-    @param flags  Flags to alter behaviour (see description)
-    @return  The index, or NULL if an error occurred.
-
-    If @p fnidx is NULL, the index name will be derived from @p fn in the
-    same way as hts_idx_load().
-
-    If @p fnidx is not NULL, @p fmt is ignored.
-
-    The @p flags parameter can be set to a combination of the following
-    values:
-
-        HTS_IDX_SAVE_REMOTE   Save a local copy of any remote indexes
-        HTS_IDX_SILENT_FAIL   Fail silently if the index is not present
-
-    The index struct returned by a successful call should be freed
-    via hts_idx_destroy() when it is no longer needed.
-*/
-HTSLIB_EXPORT
-hts_idx_t *hts_idx_load3(const char *fn, const char *fnidx, int fmt, int flags);
-
-/// Flags for hts_idx_load3() ( and also sam_idx_load3(), tbx_idx_load3() )
-#define HTS_IDX_SAVE_REMOTE 1
-#define HTS_IDX_SILENT_FAIL 2
-
-///////////////////////////////////////////////////////////
-// Functions for accessing meta-data stored in indexes
-
-/// Get extra index meta-data
-/** @param idx    The index
-    @param l_meta Pointer to where the length of the extra data is stored
-    @return Pointer to the extra data if present; NULL otherwise
-
-    Indexes (both .tbi and .csi) made by tabix include extra data about
-    the indexed file.  The returns a pointer to this data.  Note that the
-    data is stored exactly as it is in the index.  Callers need to interpret
-    the results themselves, including knowing what sort of data to expect;
-    byte swapping etc.
-*/
-HTSLIB_EXPORT
-uint8_t *hts_idx_get_meta(hts_idx_t *idx, uint32_t *l_meta);
-
-/// Set extra index meta-data
-/** @param idx     The index
-    @param l_meta  Length of data
-    @param meta    Pointer to the extra data
-    @param is_copy If not zero, a copy of the data is taken
-    @return 0 on success; -1 on failure (out of memory).
-
-    Sets the data that is returned by hts_idx_get_meta().
-
-    If is_copy != 0, a copy of the input data is taken.  If not, ownership of
-    the data pointed to by *meta passes to the index.
-*/
-HTSLIB_EXPORT
-int hts_idx_set_meta(hts_idx_t *idx, uint32_t l_meta, uint8_t *meta, int is_copy);
-
-/// Get number of mapped and unmapped reads from an index
-/** @param      idx      Index
-    @param      tid      Target ID
-    @param[out] mapped   Location to store number of mapped reads
-    @param[out] unmapped Location to store number of unmapped reads
-    @return 0 on success; -1 on failure (data not available)
-
-    BAI and CSI indexes store information on the number of reads for each
-    target that were mapped or unmapped (unmapped reads will generally have
-    a paired read that is mapped to the target).  This function returns this
-    information if it is available.
-
-    @note Cram CRAI indexes do not include this information.
-*/
-HTSLIB_EXPORT
-int hts_idx_get_stat(const hts_idx_t* idx, int tid, uint64_t* mapped, uint64_t* unmapped);
-
-/// Return the number of unplaced reads from an index
-/** @param idx    Index
-    @return Unplaced reads count
-
-    Unplaced reads are not linked to any reference (e.g. RNAME is '*' in SAM
-    files).
-*/
-HTSLIB_EXPORT
-uint64_t hts_idx_get_n_no_coor(const hts_idx_t* idx);
-
-///////////////////////////////////////////////////////////
-// Region parsing
-
-#define HTS_PARSE_THOUSANDS_SEP 1  ///< Ignore ',' separators within numbers
-#define HTS_PARSE_ONE_COORD     2  ///< chr:pos means chr:pos-pos and not chr:pos-end
-#define HTS_PARSE_LIST          4  ///< Expect a comma separated list of regions. (Disables HTS_PARSE_THOUSANDS_SEP)
-
-/// Parse a numeric string
-/** The number may be expressed in scientific notation, and optionally may
-    contain commas in the integer part (before any decimal point or E notation).
-    @param str     String to be parsed
-    @param strend  If non-NULL, set on return to point to the first character
-                   in @a str after those forming the parsed number
-    @param flags   Or'ed-together combination of HTS_PARSE_* flags
-    @return  Converted value of the parsed number.
-
-    When @a strend is NULL, a warning will be printed (if hts_verbose is HTS_LOG_WARNING
-    or more) if there are any trailing characters after the number.
-*/
-HTSLIB_EXPORT
-long long hts_parse_decimal(const char *str, char **strend, int flags);
-
-typedef int (*hts_name2id_f)(void*, const char*);
-typedef const char *(*hts_id2name_f)(void*, int);
-
-/// Parse a "CHR:START-END"-style region string
-/** @param str  String to be parsed
-    @param beg  Set on return to the 0-based start of the region
-    @param end  Set on return to the 1-based end of the region
-    @return  Pointer to the colon or '\0' after the reference sequence name,
-             or NULL if @a str could not be parsed.
-
-    NOTE: For compatibility with hts_parse_reg only.
-    Please use hts_parse_region instead.
-*/
-HTSLIB_EXPORT
-const char *hts_parse_reg64(const char *str, hts_pos_t *beg, hts_pos_t *end);
-
-/// Parse a "CHR:START-END"-style region string
-/** @param str  String to be parsed
-    @param beg  Set on return to the 0-based start of the region
-    @param end  Set on return to the 1-based end of the region
-    @return  Pointer to the colon or '\0' after the reference sequence name,
-             or NULL if @a str could not be parsed.
-*/
-HTSLIB_EXPORT
-const char *hts_parse_reg(const char *str, int *beg, int *end);
-
-/// Parse a "CHR:START-END"-style region string
-/** @param str   String to be parsed
-    @param tid   Set on return (if not NULL) to be reference index (-1 if invalid)
-    @param beg   Set on return to the 0-based start of the region
-    @param end   Set on return to the 1-based end of the region
-    @param getid Function pointer.  Called if not NULL to set tid.
-    @param hdr   Caller data passed to getid.
-    @param flags Bitwise HTS_PARSE_* flags listed above.
-    @return      Pointer to the byte after the end of the entire region
-                 specifier (including any trailing comma) on success,
-                 or NULL if @a str could not be parsed.
-
-    A variant of hts_parse_reg which is reference-id aware.  It uses
-    the iterator name2id callbacks to validate the region tokenisation works.
-
-    This is necessary due to GRCh38 HLA additions which have reference names
-    like "HLA-DRB1*12:17".
-
-    To work around ambiguous parsing issues, eg both "chr1" and "chr1:100-200"
-    are reference names, quote using curly braces.
-    Thus "{chr1}:100-200" and "{chr1:100-200}" disambiguate the above example.
-
-    Flags are used to control how parsing works, and can be one of the below.
-
-    HTS_PARSE_THOUSANDS_SEP:
-        Ignore commas in numbers.  For example with this flag 1,234,567
-        is interpreted as 1234567.
-
-    HTS_PARSE_LIST:
-        If present, the region is assmed to be a comma separated list and
-        position parsing will not contain commas (this implicitly
-        clears HTS_PARSE_THOUSANDS_SEP in the call to hts_parse_decimal).
-        On success the return pointer will be the start of the next region, ie
-        the character after the comma.  (If *ret != '\0' then the caller can
-        assume another region is present in the list.)
-
-        If not set then positions may contain commas.  In this case the return
-        value should point to the end of the string, or NULL on failure.
-
-    HTS_PARSE_ONE_COORD:
-        If present, X:100 is treated as the single base pair region X:100-100.
-        In this case X:-100 is shorthand for X:1-100 and X:100- is X:100-<end>.
-        (This is the standard bcftools region convention.)
-
-        When not set X:100 is considered to be X:100-<end> where <end> is
-        the end of chromosome X (set to INT_MAX here).  X:100- and X:-100 are
-        invalid.
-        (This is the standard samtools region convention.)
-
-    Note the supplied string expects 1 based inclusive coordinates, but the
-    returned coordinates start from 0 and are half open, so pos0 is valid
-    for use in e.g. "for (pos0 = beg; pos0 < end; pos0++) {...}"
-
-    If NULL is returned, the value in tid mat give additional information
-    about the error:
-
-        -2   Failed to parse @p hdr; or out of memory
-        -1   The reference in @p str has mismatched braces, or does not
-             exist in @p hdr
-        >= 0 The specified range in @p str could not be parsed
-*/
-HTSLIB_EXPORT
-const char *hts_parse_region(const char *s, int *tid, hts_pos_t *beg,
-                             hts_pos_t *end, hts_name2id_f getid, void *hdr,
-                             int flags);
-
-
-///////////////////////////////////////////////////////////
-// Generic iterators
-//
-// These functions provide the low-level infrastructure for iterators.
-// Wrappers around these are used to make iterators for specific file types.
-// See:
-//     htslib/sam.h  for SAM/BAM/CRAM iterators
-//     htslib/vcf.h  for VCF/BCF iterators
-//     htslib/tbx.h  for files indexed by tabix
-
-/// Create a single-region iterator
-/** @param idx      Index
-    @param tid      Target ID
-    @param beg      Start of region
-    @param end      End of region
-    @param readrec  Callback to read a record from the input file
-    @return An iterator on success; NULL on failure
-
-    The iterator struct returned by a successful call should be freed
-    via hts_itr_destroy() when it is no longer needed.
- */
-HTSLIB_EXPORT
-hts_itr_t *hts_itr_query(const hts_idx_t *idx, int tid, hts_pos_t beg, hts_pos_t end, hts_readrec_func *readrec);
-
-/// Free an iterator
-/** @param iter   Iterator to free
- */
-HTSLIB_EXPORT
-void hts_itr_destroy(hts_itr_t *iter);
-
-typedef hts_itr_t *hts_itr_query_func(const hts_idx_t *idx, int tid, hts_pos_t beg, hts_pos_t end, hts_readrec_func *readrec);
-
-/// Create a single-region iterator from a text region specification
-/** @param idx       Index
-    @param reg       Region specifier
-    @param getid     Callback function to return the target ID for a name
-    @param hdr       Input file header
-    @param itr_query Callback function returning an iterator for a numeric tid,
-                     start and end position
-    @param readrec   Callback to read a record from the input file
-    @return An iterator on success; NULL on error
-
-    The iterator struct returned by a successful call should be freed
-    via hts_itr_destroy() when it is no longer needed.
- */
-HTSLIB_EXPORT
-hts_itr_t *hts_itr_querys(const hts_idx_t *idx, const char *reg, hts_name2id_f getid, void *hdr, hts_itr_query_func *itr_query, hts_readrec_func *readrec);
-
-/// Return the next record from an iterator
-/** @param fp      Input file handle
-    @param iter    Iterator
-    @param r       Pointer to record placeholder
-    @param data    Data passed to the readrec callback
-    @return >= 0 on success, -1 when there is no more data, < -1 on error
- */
-HTSLIB_EXPORT
-int hts_itr_next(BGZF *fp, hts_itr_t *iter, void *r, void *data) HTS_RESULT_USED;
-
-/// Return a list of target names from an index
-/** @param      idx    Index
-    @param[out] n      Location to store the number of targets
-    @param      getid  Callback function to get the name for a target ID
-    @param      hdr    Header from indexed file
-    @return An array of pointers to the names on success; NULL on failure
-
-    @note The names are pointers into the header data structure.  When cleaning
-    up, only the array should be freed, not the names.
- */
-HTSLIB_EXPORT
-const char **hts_idx_seqnames(const hts_idx_t *idx, int *n, hts_id2name_f getid, void *hdr); // free only the array, not the values
-
-/**********************************
- * Iterator with multiple regions *
- **********************************/
-
-typedef int hts_itr_multi_query_func(const hts_idx_t *idx, hts_itr_t *itr);
-HTSLIB_EXPORT
-int hts_itr_multi_bam(const hts_idx_t *idx, hts_itr_t *iter);
-HTSLIB_EXPORT
-int hts_itr_multi_cram(const hts_idx_t *idx, hts_itr_t *iter);
-
-/// Create a multi-region iterator from a region list
-/** @param idx          Index
-    @param reglist      Region list
-    @param count        Number of items in region list
-    @param getid        Callback to convert names to target IDs
-    @param hdr          Indexed file header (passed to getid)
-    @param itr_specific Filetype-specific callback function
-    @param readrec      Callback to read an input file record
-    @param seek         Callback to seek in the input file
-    @param tell         Callback to return current input file location
-    @return An iterator on success; NULL on failure
-
-    The iterator struct returned by a successful call should be freed
-    via hts_itr_destroy() when it is no longer needed.
- */
-HTSLIB_EXPORT
-hts_itr_t *hts_itr_regions(const hts_idx_t *idx, hts_reglist_t *reglist, int count, hts_name2id_f getid, void *hdr, hts_itr_multi_query_func *itr_specific, hts_readrec_func *readrec, hts_seek_func *seek, hts_tell_func *tell);
-
-/// Return the next record from an iterator
-/** @param fp      Input file handle
-    @param iter    Iterator
-    @param r       Pointer to record placeholder
-    @return >= 0 on success, -1 when there is no more data, < -1 on error
- */
-HTSLIB_EXPORT
-int hts_itr_multi_next(htsFile *fd, hts_itr_t *iter, void *r);
-
-/// Create a region list from a char array
-/** @param argv      Char array of target:interval elements, e.g. chr1:2500-3600, chr1:5100, chr2
-    @param argc      Number of items in the array
-    @param r_count   Pointer to the number of items in the resulting region list
-    @param hdr       Header for the sam/bam/cram file
-    @param getid     Callback to convert target names to target ids.
-    @return  A region list on success, NULL on failure
-
-    The hts_reglist_t struct returned by a successful call should be freed
-    via hts_reglist_free() when it is no longer needed.
- */
-HTSLIB_EXPORT
-hts_reglist_t *hts_reglist_create(char **argv, int argc, int *r_count, void *hdr,  hts_name2id_f getid);
-
-/// Free a region list
-/** @param reglist    Region list
-    @param count      Number of items in the list
- */
-HTSLIB_EXPORT
-void hts_reglist_free(hts_reglist_t *reglist, int count);
-
-/// Free a multi-region iterator
-/** @param iter   Iterator to free
- */
-#define hts_itr_multi_destroy(iter) hts_itr_destroy(iter)
-
-
-    /**
-     * hts_file_type() - Convenience function to determine file type
-     * DEPRECATED:  This function has been replaced by hts_detect_format().
-     * It and these FT_* macros will be removed in a future HTSlib release.
-     */
-    #define FT_UNKN   0
-    #define FT_GZ     1
-    #define FT_VCF    2
-    #define FT_VCF_GZ (FT_GZ|FT_VCF)
-    #define FT_BCF    (1<<2)
-    #define FT_BCF_GZ (FT_GZ|FT_BCF)
-    #define FT_STDIN  (1<<3)
-    HTSLIB_EXPORT
-    int hts_file_type(const char *fname);
-
-
-/***************************
- * Revised MAQ error model *
- ***************************/
-
-struct errmod_t;
-typedef struct errmod_t errmod_t;
-
-HTSLIB_EXPORT
-errmod_t *errmod_init(double depcorr);
-HTSLIB_EXPORT
-void errmod_destroy(errmod_t *em);
-
-/*
-    n: number of bases
-    m: maximum base
-    bases[i]: qual:6, strand:1, base:4
-    q[i*m+j]: phred-scaled likelihood of (i,j)
- */
-HTSLIB_EXPORT
-int errmod_cal(const errmod_t *em, int n, int m, uint16_t *bases, float *q);
-
-
-/*****************************************************
- * Probabilistic banded glocal alignment             *
- * See https://doi.org/10.1093/bioinformatics/btr076 *
- *****************************************************/
-
-typedef struct probaln_par_t {
-    float d, e;
-    int bw;
-} probaln_par_t;
-
-/// Perform probabilistic banded glocal alignment
-/** @param      ref     Reference sequence
-    @param      l_ref   Length of reference
-    @param      query   Query sequence
-    @param      l_query Length of query sequence
-    @param      iqual   Query base qualities
-    @param      c       Alignment parameters
-    @param[out] state   Output alignment
-    @param[out] q    Phred scaled posterior probability of state[i] being wrong
-    @return     Phred-scaled likelihood score, or INT_MIN on failure.
-
-The reference and query sequences are coded using integers 0,1,2,3,4 for
-bases A,C,G,T,N respectively (N here is for any ambiguity code).
-
-On output, state and q are arrays of length l_query. The higher 30
-bits give the reference position the query base is matched to and the
-lower two bits can be 0 (an alignment match) or 1 (an
-insertion). q[i] gives the phred scaled posterior probability of
-state[i] being wrong.
-
-On failure, errno will be set to EINVAL if the values of l_ref or l_query
-were invalid; or ENOMEM if a memory allocation failed.
-*/
-
-HTSLIB_EXPORT
-int probaln_glocal(const uint8_t *ref, int l_ref, const uint8_t *query, int l_query, const uint8_t *iqual, const probaln_par_t *c, int *state, uint8_t *q);
-
-
-    /**********************
-     * MD5 implementation *
-     **********************/
-
-    struct hts_md5_context;
-    typedef struct hts_md5_context hts_md5_context;
-
-    /*! @abstract   Initialises an MD5 context.
-     *  @discussion
-     *    The expected use is to allocate an hts_md5_context using
-     *    hts_md5_init().  This pointer is then passed into one or more calls
-     *    of hts_md5_update() to compute successive internal portions of the
-     *    MD5 sum, which can then be externalised as a full 16-byte MD5sum
-     *    calculation by calling hts_md5_final().  This can then be turned
-     *    into ASCII via hts_md5_hex().
-     *
-     *    To dealloate any resources created by hts_md5_init() call the
-     *    hts_md5_destroy() function.
-     *
-     *  @return     hts_md5_context pointer on success, NULL otherwise.
-     */
-    HTSLIB_EXPORT
-    hts_md5_context *hts_md5_init(void);
-
-    /*! @abstract Updates the context with the MD5 of the data. */
-    HTSLIB_EXPORT
-    void hts_md5_update(hts_md5_context *ctx, const void *data, unsigned long size);
-
-    /*! @abstract Computes the final 128-bit MD5 hash from the given context */
-    HTSLIB_EXPORT
-    void hts_md5_final(unsigned char *digest, hts_md5_context *ctx);
-
-    /*! @abstract Resets an md5_context to the initial state, as returned
-     *            by hts_md5_init().
-     */
-    HTSLIB_EXPORT
-    void hts_md5_reset(hts_md5_context *ctx);
-
-    /*! @abstract Converts a 128-bit MD5 hash into a 33-byte nul-termninated
-     *            hex string.
-     */
-    HTSLIB_EXPORT
-    void hts_md5_hex(char *hex, const unsigned char *digest);
-
-    /*! @abstract Deallocates any memory allocated by hts_md5_init. */
-    HTSLIB_EXPORT
-    void hts_md5_destroy(hts_md5_context *ctx);
-
-static inline int hts_reg2bin(hts_pos_t beg, hts_pos_t end, int min_shift, int n_lvls)
-{
-    int l, s = min_shift, t = ((1<<((n_lvls<<1) + n_lvls)) - 1) / 7;
-    for (--end, l = n_lvls; l > 0; --l, s += 3, t -= 1<<((l<<1)+l))
-        if (beg>>s == end>>s) return t + (beg>>s);
-    return 0;
-}
-
-static inline int hts_bin_bot(int bin, int n_lvls)
-{
-    int l, b;
-    for (l = 0, b = bin; b; ++l, b = hts_bin_parent(b)); // compute the level of bin
-    return (bin - hts_bin_first(l)) << (n_lvls - l) * 3;
-}
-
-/**************
- * Endianness *
- **************/
-
-static inline int ed_is_big(void)
-{
-    long one= 1;
-    return !(*((char *)(&one)));
-}
-static inline uint16_t ed_swap_2(uint16_t v)
-{
-    return (uint16_t)(((v & 0x00FF00FFU) << 8) | ((v & 0xFF00FF00U) >> 8));
-}
-static inline void *ed_swap_2p(void *x)
-{
-    *(uint16_t*)x = ed_swap_2(*(uint16_t*)x);
-    return x;
-}
-static inline uint32_t ed_swap_4(uint32_t v)
-{
-    v = ((v & 0x0000FFFFU) << 16) | (v >> 16);
-    return ((v & 0x00FF00FFU) << 8) | ((v & 0xFF00FF00U) >> 8);
-}
-static inline void *ed_swap_4p(void *x)
-{
-    *(uint32_t*)x = ed_swap_4(*(uint32_t*)x);
-    return x;
-}
-static inline uint64_t ed_swap_8(uint64_t v)
-{
-    v = ((v & 0x00000000FFFFFFFFLLU) << 32) | (v >> 32);
-    v = ((v & 0x0000FFFF0000FFFFLLU) << 16) | ((v & 0xFFFF0000FFFF0000LLU) >> 16);
-    return ((v & 0x00FF00FF00FF00FFLLU) << 8) | ((v & 0xFF00FF00FF00FF00LLU) >> 8);
-}
-static inline void *ed_swap_8p(void *x)
-{
-    *(uint64_t*)x = ed_swap_8(*(uint64_t*)x);
-    return x;
-}
-
-#ifdef __cplusplus
-}
-#endif
-
-#endif
diff -ruN stringtie.orig/htslib/htslib/hts_log.h stringtie/htslib/htslib/hts_log.h
--- stringtie.orig/htslib/htslib/hts_log.h	2024-02-28 13:57:39.704579460 +0100
+++ stringtie/htslib/htslib/hts_log.h	1970-01-01 01:00:00.000000000 +0100
@@ -1,96 +0,0 @@
-/// \file htslib/hts_log.h
-/// Configuration of log levels.
-/* The MIT License
-Copyright (C) 2017 Genome Research Ltd.
-
-Author: Anders Kaplan
-
-Permission is hereby granted, free of charge, to any person obtaining
-a copy of this software and associated documentation files (the
-"Software"), to deal in the Software without restriction, including
-without limitation the rights to use, copy, modify, merge, publish,
-distribute, sublicense, and/or sell copies of the Software, and to
-permit persons to whom the Software is furnished to do so, subject to
-the following conditions:
-
-The above copyright notice and this permission notice shall be
-included in all copies or substantial portions of the Software.
-
-THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
-EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
-MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
-NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS
-BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
-ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
-CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
-SOFTWARE.
-*/
-
-#ifndef HTS_LOG_H
-#define HTS_LOG_H
-
-#include "hts_defs.h"
-
-#ifdef __cplusplus
-extern "C" {
-#endif
-
-/// Log levels.
-enum htsLogLevel {
-    HTS_LOG_OFF,            ///< All logging disabled.
-    HTS_LOG_ERROR,          ///< Logging of errors only.
-    HTS_LOG_WARNING = 3,    ///< Logging of errors and warnings.
-    HTS_LOG_INFO,           ///< Logging of errors, warnings, and normal but significant events.
-    HTS_LOG_DEBUG,          ///< Logging of all except the most detailed debug events.
-    HTS_LOG_TRACE           ///< All logging enabled.
-};
-
-/// Sets the selected log level.
-HTSLIB_EXPORT
-void hts_set_log_level(enum htsLogLevel level);
-
-/// Gets the selected log level.
-HTSLIB_EXPORT
-enum htsLogLevel hts_get_log_level(void);
-
-/// Selected log level.
-/*!
- * One of the HTS_LOG_* values. The default is HTS_LOG_WARNING.
- * \note Avoid direct use of this variable. Use hts_set_log_level and hts_get_log_level instead.
- */
-extern int hts_verbose;
-
-/*! Logs an event.
-* \param severity      Severity of the event:
-*                      - HTS_LOG_ERROR means that something went wrong so that a task could not be completed.
-*                      - HTS_LOG_WARNING means that something unexpected happened, but that execution can continue, perhaps in a degraded mode.
-*                      - HTS_LOG_INFO means that something normal but significant happened.
-*                      - HTS_LOG_DEBUG means that something normal and insignificant happened.
-*                      - HTS_LOG_TRACE means that something happened that might be of interest when troubleshooting.
-* \param context       Context where the event occurred. Typically set to "__func__".
-* \param format        Format string with placeholders, like printf.
-*/
-HTSLIB_EXPORT
-void hts_log(enum htsLogLevel severity, const char *context, const char *format, ...)
-HTS_FORMAT(HTS_PRINTF_FMT, 3, 4);
-
-/*! Logs an event with severity HTS_LOG_ERROR and default context. Parameters: format, ... */
-#define hts_log_error(...) hts_log(HTS_LOG_ERROR, __func__, __VA_ARGS__)
-
-/*! Logs an event with severity HTS_LOG_WARNING and default context. Parameters: format, ... */
-#define hts_log_warning(...) hts_log(HTS_LOG_WARNING, __func__, __VA_ARGS__)
-
-/*! Logs an event with severity HTS_LOG_INFO and default context. Parameters: format, ... */
-#define hts_log_info(...) hts_log(HTS_LOG_INFO, __func__, __VA_ARGS__)
-
-/*! Logs an event with severity HTS_LOG_DEBUG and default context. Parameters: format, ... */
-#define hts_log_debug(...) hts_log(HTS_LOG_DEBUG, __func__, __VA_ARGS__)
-
-/*! Logs an event with severity HTS_LOG_TRACE and default context. Parameters: format, ... */
-#define hts_log_trace(...) hts_log(HTS_LOG_TRACE, __func__, __VA_ARGS__)
-
-#ifdef __cplusplus
-}
-#endif
-
-#endif // #ifndef HTS_LOG_H
diff -ruN stringtie.orig/htslib/htslib/hts_os.h stringtie/htslib/htslib/hts_os.h
--- stringtie.orig/htslib/htslib/hts_os.h	2024-02-28 13:57:39.704579460 +0100
+++ stringtie/htslib/htslib/hts_os.h	1970-01-01 01:00:00.000000000 +0100
@@ -1,80 +0,0 @@
-/// @file hts_os.h
-/// Operating System specific tweaks, for compatibility with POSIX.
-/*
-   Copyright (C) 2017, 2019-2020 Genome Research Ltd.
-
-    Author: James Bonfield <jkb@sanger.ac.uk>
-
-Permission is hereby granted, free of charge, to any person obtaining a copy
-of this software and associated documentation files (the "Software"), to deal
-in the Software without restriction, including without limitation the rights
-to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
-copies of the Software, and to permit persons to whom the Software is
-furnished to do so, subject to the following conditions:
-
-The above copyright notice and this permission notice shall be included in
-all copies or substantial portions of the Software.
-
-THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
-IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
-FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
-THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
-LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
-FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
-DEALINGS IN THE SOFTWARE.  */
-
-#ifndef HTSLIB_HTS_OS_H
-#define HTSLIB_HTS_OS_H
-
-#include "hts_defs.h"
-
-#ifdef __cplusplus
-extern "C" {
-#endif
-
-/* This is srand48_deterministic() on platforms that provide it, or srand48()
-   otherwise (or our own POSIX srand48() on platforms that provide neither).
-   Hence calling hts_srand48() will always set up the same POSIX-determined
-   sequence of pseudo-random numbers on any platform, while calling srand48()
-   may (e.g., on OpenBSD) set up a different non-deterministic sequence. */
-HTSLIB_EXPORT
-void hts_srand48(long seed);
-
-HTSLIB_EXPORT
-double hts_erand48(unsigned short xseed[3]);
-
-HTSLIB_EXPORT
-double hts_drand48(void);
-
-HTSLIB_EXPORT
-long hts_lrand48(void);
-
-#if defined(_WIN32) && !defined(__CYGWIN__)
-// Windows usually lacks *rand48(), but cygwin provides them.
-#define srand48(S) hts_srand48((S))
-#define erand48(X) hts_erand48((X))
-#define drand48() hts_drand48()
-#define lrand48() hts_lrand48()
-#endif
-
-#if 0  /* def _WIN32 - disabled for now, not currently used */
-/* Check if the fd is a cygwin/msys's pty. */
-extern int is_cygpty(int fd);
-#endif
-
-#ifdef __cplusplus
-}
-#endif
-
-#if defined(__MINGW32__)
-#include <io.h>
-#define mkdir(filename,mode) mkdir((filename))
-#endif
-
-#ifdef _WIN32
-#include <stdlib.h>
-#define srandom srand
-#define random rand
-#endif
-
-#endif // HTSLIB_HTS_OS_H
diff -ruN stringtie.orig/htslib/htslib/kbitset.h stringtie/htslib/htslib/kbitset.h
--- stringtie.orig/htslib/htslib/kbitset.h	2024-02-28 13:57:39.704579460 +0100
+++ stringtie/htslib/htslib/kbitset.h	1970-01-01 01:00:00.000000000 +0100
@@ -1,203 +0,0 @@
-/* The MIT License
-
-   Copyright (C) 2015, 2018 Genome Research Ltd.
-
-   Permission is hereby granted, free of charge, to any person obtaining
-   a copy of this software and associated documentation files (the
-   "Software"), to deal in the Software without restriction, including
-   without limitation the rights to use, copy, modify, merge, publish,
-   distribute, sublicense, and/or sell copies of the Software, and to
-   permit persons to whom the Software is furnished to do so, subject to
-   the following conditions:
-
-   The above copyright notice and this permission notice shall be
-   included in all copies or substantial portions of the Software.
-
-   THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
-   EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
-   MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
-   NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS
-   BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
-   ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
-   CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
-   SOFTWARE.
-*/
-
-#ifndef KBITSET_H
-#define KBITSET_H
-
-/* Example of using kbitset_t, which represents a subset of {0,..., N-1},
-   where N is the size specified in kbs_init().
-
-	kbitset_t *bset = kbs_init(100);
-	kbs_insert(bset, 5);
-	kbs_insert(bset, 68);
-	kbs_delete(bset, 37);
-	// ...
-
-	if (kbs_exists(bset, 68)) printf("68 present\n");
-
-	kbitset_iter_t itr;
-	int i;
-	kbs_start(&itr);
-	while ((i = kbs_next(bset, &itr)) >= 0)
-		printf("%d present\n", i);
-
-	kbs_destroy(bset);
-
-   Example of declaring a kbitset_t-using function in a header file, so that
-   only source files that actually use process() need to include <kbitset.h>:
-
-	struct kbitset_t;
-	void process(struct kbitset_t *bset);
-*/
-
-#include <limits.h>
-#include <stdlib.h>
-#include <string.h>
-
-#define KBS_ELTBITS (CHAR_BIT * sizeof (unsigned long))
-#define KBS_ELT(i)  ((i) / KBS_ELTBITS)
-#define KBS_MASK(i) (1UL << ((i) % KBS_ELTBITS))
-
-typedef struct kbitset_t {
-	size_t n, n_max;
-	unsigned long b[1];
-} kbitset_t;
-
-// (For internal use only.) Returns a mask (like 00011111) showing
-// which bits are in use in the last slot (for the given ni) set.
-static inline unsigned long kbs_last_mask(size_t ni)
-{
-	unsigned long mask = KBS_MASK(ni) - 1;
-	return mask? mask : ~0UL;
-}
-
-// Initialise a bit set capable of holding ni integers, 0 <= i < ni.
-// The set returned is empty if fill == 0, or all of [0,ni) otherwise.
-static inline kbitset_t *kbs_init2(size_t ni, int fill)
-{
-	size_t n = (ni + KBS_ELTBITS-1) / KBS_ELTBITS;
-	kbitset_t *bs =
-		(kbitset_t *) malloc(sizeof(kbitset_t) + n * sizeof(unsigned long));
-	if (bs == NULL) return NULL;
-	bs->n = bs->n_max = n;
-	memset(bs->b, fill? ~0 : 0, n * sizeof (unsigned long));
-	// b[n] is always non-zero (a fact used by kbs_next()).
-	bs->b[n] = kbs_last_mask(ni);
-	if (fill) bs->b[n-1] &= bs->b[n];
-	return bs;
-}
-
-// Initialise an empty bit set capable of holding ni integers, 0 <= i < ni.
-static inline kbitset_t *kbs_init(size_t ni)
-{
-	return kbs_init2(ni, 0);
-}
-
-// Resize an existing bit set to be capable of holding ni_new integers.
-// Elements in [ni_old,ni_new) are added to the set if fill != 0.
-static inline int kbs_resize2(kbitset_t **bsp, size_t ni_new, int fill)
-{
-	kbitset_t *bs = *bsp;
-	size_t n = bs? bs->n : 0;
-	size_t n_new = (ni_new + KBS_ELTBITS-1) / KBS_ELTBITS;
-	if (bs == NULL || n_new > bs->n_max) {
-		bs = (kbitset_t *)
-			realloc(*bsp, sizeof(kbitset_t) + n_new * sizeof(unsigned long));
-		if (bs == NULL) return -1;
-
-		bs->n_max = n_new;
-		*bsp = bs;
-	}
-
-	bs->n = n_new;
-	if (n_new >= n)
-		memset(&bs->b[n], fill? ~0 : 0, (n_new - n) * sizeof (unsigned long));
-	bs->b[n_new] = kbs_last_mask(ni_new);
-	// Need to clear excess bits when fill!=0 or n_new<n; always is simpler.
-	bs->b[n_new-1] &= bs->b[n_new];
-	return 0;
-}
-
-// Resize an existing bit set to be capable of holding ni_new integers.
-// Returns negative on error.
-static inline int kbs_resize(kbitset_t **bsp, size_t ni_new)
-{
-	return kbs_resize2(bsp, ni_new, 0);
-}
-
-// Destroy a bit set.
-static inline void kbs_destroy(kbitset_t *bs)
-{
-	free(bs);
-}
-
-// Reset the bit set to empty.
-static inline void kbs_clear(kbitset_t *bs)
-{
-	memset(bs->b, 0, bs->n * sizeof (unsigned long));
-}
-
-// Reset the bit set to all of [0,ni).
-static inline void kbs_insert_all(kbitset_t *bs)
-{
-	memset(bs->b, ~0, bs->n * sizeof (unsigned long));
-	bs->b[bs->n-1] &= bs->b[bs->n];
-}
-
-// Insert an element into the bit set.
-static inline void kbs_insert(kbitset_t *bs, int i)
-{
-	bs->b[KBS_ELT(i)] |= KBS_MASK(i);
-}
-
-// Remove an element from the bit set.
-static inline void kbs_delete(kbitset_t *bs, int i)
-{
-	bs->b[KBS_ELT(i)] &= ~KBS_MASK(i);
-}
-
-// Test whether the bit set contains the element.
-static inline int kbs_exists(const kbitset_t *bs, int i)
-{
-	return (bs->b[KBS_ELT(i)] & KBS_MASK(i)) != 0;
-}
-
-typedef struct kbitset_iter_t {
-	unsigned long mask;
-	size_t elt;
-	int i;
-} kbitset_iter_t;
-
-// Initialise or reset a bit set iterator.
-static inline void kbs_start(kbitset_iter_t *itr)
-{
-	itr->mask = 1;
-	itr->elt = 0;
-	itr->i = 0;
-}
-
-// Return the next element contained in the bit set, or -1 if there are no more.
-static inline int kbs_next(const kbitset_t *bs, kbitset_iter_t *itr)
-{
-	unsigned long b = bs->b[itr->elt];
-
-	for (;;) {
-		if (itr->mask == 0) {
-			while ((b = bs->b[++itr->elt]) == 0) itr->i += KBS_ELTBITS;
-			if (itr->elt == bs->n) return -1;
-			itr->mask = 1;
-		}
-
-		if (b & itr->mask) break;
-
-		itr->i++;
-		itr->mask <<= 1;
-	}
-
-	itr->mask <<= 1;
-	return itr->i++;
-}
-
-#endif
diff -ruN stringtie.orig/htslib/htslib/kfunc.h stringtie/htslib/htslib/kfunc.h
--- stringtie.orig/htslib/htslib/kfunc.h	2024-02-28 13:57:39.704579460 +0100
+++ stringtie/htslib/htslib/kfunc.h	1970-01-01 01:00:00.000000000 +0100
@@ -1,91 +0,0 @@
-/* The MIT License
-
-   Copyright (C) 2010, 2013-2014 Genome Research Ltd.
-   Copyright (C) 2011 Attractive Chaos <attractor@live.co.uk>
-
-   Permission is hereby granted, free of charge, to any person obtaining
-   a copy of this software and associated documentation files (the
-   "Software"), to deal in the Software without restriction, including
-   without limitation the rights to use, copy, modify, merge, publish,
-   distribute, sublicense, and/or sell copies of the Software, and to
-   permit persons to whom the Software is furnished to do so, subject to
-   the following conditions:
-
-   The above copyright notice and this permission notice shall be
-   included in all copies or substantial portions of the Software.
-
-   THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
-   EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
-   MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
-   NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS
-   BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
-   ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
-   CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
-   SOFTWARE.
-*/
-
-#ifndef HTSLIB_KFUNC_H
-#define HTSLIB_KFUNC_H
-
-#include "hts_defs.h"
-
-#ifdef __cplusplus
-extern "C" {
-#endif
-
-/* Log gamma function
- * \log{\Gamma(z)}
- * AS245, 2nd algorithm, http://lib.stat.cmu.edu/apstat/245
- */
-HTSLIB_EXPORT
-double kf_lgamma(double z);
-
-/* complementary error function
- * \frac{2}{\sqrt{\pi}} \int_x^{\infty} e^{-t^2} dt
- * AS66, 2nd algorithm, http://lib.stat.cmu.edu/apstat/66
- */
-HTSLIB_EXPORT
-double kf_erfc(double x);
-
-/* The following computes regularized incomplete gamma functions.
- * Formulas are taken from Wiki, with additional input from Numerical
- * Recipes in C (for modified Lentz's algorithm) and AS245
- * (http://lib.stat.cmu.edu/apstat/245).
- *
- * A good online calculator is available at:
- *
- *   http://www.danielsoper.com/statcalc/calc23.aspx
- *
- * It calculates upper incomplete gamma function, which equals
- * kf_gammaq(s,z)*tgamma(s).
- */
-
-HTSLIB_EXPORT
-double kf_gammap(double s, double z);
-HTSLIB_EXPORT
-double kf_gammaq(double s, double z);
-
-/* Regularized incomplete beta function. The method is taken from
- * Numerical Recipe in C, 2nd edition, section 6.4. The following web
- * page calculates the incomplete beta function, which equals
- * kf_betai(a,b,x) * gamma(a) * gamma(b) / gamma(a+b):
- *
- *   http://www.danielsoper.com/statcalc/calc36.aspx
- */
-HTSLIB_EXPORT
-double kf_betai(double a, double b, double x);
-
-/*
- *    n11  n12  | n1_
- *    n21  n22  | n2_
- *   -----------+----
- *    n_1  n_2  | n
- */
-HTSLIB_EXPORT
-double kt_fisher_exact(int n11, int n12, int n21, int n22, double *_left, double *_right, double *two);
-
-#ifdef __cplusplus
-}
-#endif
-
-#endif
diff -ruN stringtie.orig/htslib/htslib/khash.h stringtie/htslib/htslib/khash.h
--- stringtie.orig/htslib/htslib/khash.h	2024-02-28 13:57:39.704579460 +0100
+++ stringtie/htslib/htslib/khash.h	1970-01-01 01:00:00.000000000 +0100
@@ -1,670 +0,0 @@
-/* The MIT License
-
-   Copyright (c) 2008, 2009, 2011 by Attractive Chaos <attractor@live.co.uk>
-   Copyright (C) 2014-2015, 2018 Genome Research Ltd.
-
-   Permission is hereby granted, free of charge, to any person obtaining
-   a copy of this software and associated documentation files (the
-   "Software"), to deal in the Software without restriction, including
-   without limitation the rights to use, copy, modify, merge, publish,
-   distribute, sublicense, and/or sell copies of the Software, and to
-   permit persons to whom the Software is furnished to do so, subject to
-   the following conditions:
-
-   The above copyright notice and this permission notice shall be
-   included in all copies or substantial portions of the Software.
-
-   THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
-   EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
-   MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
-   NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS
-   BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
-   ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
-   CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
-   SOFTWARE.
-*/
-
-/*
-  An example:
-
-#include "khash.h"
-KHASH_MAP_INIT_INT(32, char)
-int main() {
-	int ret, is_missing;
-	khiter_t k;
-	khash_t(32) *h = kh_init(32);
-	k = kh_put(32, h, 5, &ret);
-	kh_value(h, k) = 10;
-	k = kh_get(32, h, 10);
-	is_missing = (k == kh_end(h));
-	k = kh_get(32, h, 5);
-	kh_del(32, h, k);
-	for (k = kh_begin(h); k != kh_end(h); ++k)
-		if (kh_exist(h, k)) kh_value(h, k) = 1;
-	kh_destroy(32, h);
-	return 0;
-}
-*/
-
-/*
-  2013-05-02 (0.2.8):
-
-	* Use quadratic probing. When the capacity is power of 2, stepping function
-	  i*(i+1)/2 guarantees to traverse each bucket. It is better than double
-	  hashing on cache performance and is more robust than linear probing.
-
-	  In theory, double hashing should be more robust than quadratic probing.
-	  However, my implementation is probably not for large hash tables, because
-	  the second hash function is closely tied to the first hash function,
-	  which reduce the effectiveness of double hashing.
-
-	Reference: http://research.cs.vt.edu/AVresearch/hashing/quadratic.php
-
-  2011-12-29 (0.2.7):
-
-    * Minor code clean up; no actual effect.
-
-  2011-09-16 (0.2.6):
-
-	* The capacity is a power of 2. This seems to dramatically improve the
-	  speed for simple keys. Thank Zilong Tan for the suggestion. Reference:
-
-	   - http://code.google.com/p/ulib/
-	   - http://nothings.org/computer/judy/
-
-	* Allow to optionally use linear probing which usually has better
-	  performance for random input. Double hashing is still the default as it
-	  is more robust to certain non-random input.
-
-	* Added Wang's integer hash function (not used by default). This hash
-	  function is more robust to certain non-random input.
-
-  2011-02-14 (0.2.5):
-
-    * Allow to declare global functions.
-
-  2009-09-26 (0.2.4):
-
-    * Improve portability
-
-  2008-09-19 (0.2.3):
-
-	* Corrected the example
-	* Improved interfaces
-
-  2008-09-11 (0.2.2):
-
-	* Improved speed a little in kh_put()
-
-  2008-09-10 (0.2.1):
-
-	* Added kh_clear()
-	* Fixed a compiling error
-
-  2008-09-02 (0.2.0):
-
-	* Changed to token concatenation which increases flexibility.
-
-  2008-08-31 (0.1.2):
-
-	* Fixed a bug in kh_get(), which has not been tested previously.
-
-  2008-08-31 (0.1.1):
-
-	* Added destructor
-*/
-
-
-#ifndef __AC_KHASH_H
-#define __AC_KHASH_H
-
-/*!
-  @header
-
-  Generic hash table library.
- */
-
-#define AC_VERSION_KHASH_H "0.2.8"
-
-#include <stdlib.h>
-#include <string.h>
-#include <limits.h>
-
-#include "kstring.h"
-#include "kroundup.h"
-
-/* compiler specific configuration */
-
-#if UINT_MAX == 0xffffffffu
-typedef unsigned int khint32_t;
-#elif ULONG_MAX == 0xffffffffu
-typedef unsigned long khint32_t;
-#endif
-
-#if ULONG_MAX == ULLONG_MAX
-typedef unsigned long khint64_t;
-#else
-typedef unsigned long long khint64_t;
-#endif
-
-#ifndef kh_inline
-#ifdef _MSC_VER
-#define kh_inline __inline
-#else
-#define kh_inline inline
-#endif
-#endif /* kh_inline */
-
-#ifndef klib_unused
-#if (defined __clang__ && __clang_major__ >= 3) || (defined __GNUC__ && __GNUC__ >= 3)
-#define klib_unused __attribute__ ((__unused__))
-#else
-#define klib_unused
-#endif
-#endif /* klib_unused */
-
-typedef khint32_t khint_t;
-typedef khint_t khiter_t;
-
-#define __ac_isempty(flag, i) ((flag[i>>4]>>((i&0xfU)<<1))&2)
-#define __ac_isdel(flag, i) ((flag[i>>4]>>((i&0xfU)<<1))&1)
-#define __ac_iseither(flag, i) ((flag[i>>4]>>((i&0xfU)<<1))&3)
-#define __ac_set_isdel_false(flag, i) (flag[i>>4]&=~(1ul<<((i&0xfU)<<1)))
-#define __ac_set_isempty_false(flag, i) (flag[i>>4]&=~(2ul<<((i&0xfU)<<1)))
-#define __ac_set_isboth_false(flag, i) (flag[i>>4]&=~(3ul<<((i&0xfU)<<1)))
-#define __ac_set_isdel_true(flag, i) (flag[i>>4]|=1ul<<((i&0xfU)<<1))
-
-#define __ac_fsize(m) ((m) < 16? 1 : (m)>>4)
-
-#ifndef kroundup32
-#define kroundup32(x) (--(x), (x)|=(x)>>1, (x)|=(x)>>2, (x)|=(x)>>4, (x)|=(x)>>8, (x)|=(x)>>16, ++(x))
-#endif
-
-#ifndef kcalloc
-#define kcalloc(N,Z) calloc(N,Z)
-#endif
-#ifndef kmalloc
-#define kmalloc(Z) malloc(Z)
-#endif
-#ifndef krealloc
-#define krealloc(P,Z) realloc(P,Z)
-#endif
-#ifndef kfree
-#define kfree(P) free(P)
-#endif
-
-static const double __ac_HASH_UPPER = 0.77;
-
-#define __KHASH_TYPE(name, khkey_t, khval_t) \
-	typedef struct kh_##name##_s { \
-		khint_t n_buckets, size, n_occupied, upper_bound; \
-		khint32_t *flags; \
-		khkey_t *keys; \
-		khval_t *vals; \
-	} kh_##name##_t;
-
-#define __KHASH_PROTOTYPES(name, khkey_t, khval_t)	 					\
-	extern kh_##name##_t *kh_init_##name(void);							\
-	extern void kh_destroy_##name(kh_##name##_t *h);					\
-	extern void kh_clear_##name(kh_##name##_t *h);						\
-	extern khint_t kh_get_##name(const kh_##name##_t *h, khkey_t key); 	\
-	extern int kh_resize_##name(kh_##name##_t *h, khint_t new_n_buckets); \
-	extern khint_t kh_put_##name(kh_##name##_t *h, khkey_t key, int *ret); \
-	extern void kh_del_##name(kh_##name##_t *h, khint_t x);
-
-#define __KHASH_IMPL(name, SCOPE, khkey_t, khval_t, kh_is_map, __hash_func, __hash_equal) \
-	SCOPE kh_##name##_t *kh_init_##name(void) {							\
-		return (kh_##name##_t*)kcalloc(1, sizeof(kh_##name##_t));		\
-	}																	\
-	SCOPE void kh_destroy_##name(kh_##name##_t *h)						\
-	{																	\
-		if (h) {														\
-			kfree((void *)h->keys); kfree(h->flags);					\
-			kfree((void *)h->vals);										\
-			kfree(h);													\
-		}																\
-	}																	\
-	SCOPE void kh_clear_##name(kh_##name##_t *h)						\
-	{																	\
-		if (h && h->flags) {											\
-			memset(h->flags, 0xaa, __ac_fsize(h->n_buckets) * sizeof(khint32_t)); \
-			h->size = h->n_occupied = 0;								\
-		}																\
-	}																	\
-	SCOPE khint_t kh_get_##name(const kh_##name##_t *h, khkey_t key) 	\
-	{																	\
-		if (h->n_buckets) {												\
-			khint_t k, i, last, mask, step = 0; \
-			mask = h->n_buckets - 1;									\
-			k = __hash_func(key); i = k & mask;							\
-			last = i; \
-			while (!__ac_isempty(h->flags, i) && (__ac_isdel(h->flags, i) || !__hash_equal(h->keys[i], key))) { \
-				i = (i + (++step)) & mask; \
-				if (i == last) return h->n_buckets;						\
-			}															\
-			return __ac_iseither(h->flags, i)? h->n_buckets : i;		\
-		} else return 0;												\
-	}																	\
-	SCOPE int kh_resize_##name(kh_##name##_t *h, khint_t new_n_buckets) \
-	{ /* This function uses 0.25*n_buckets bytes of working space instead of [sizeof(key_t+val_t)+.25]*n_buckets. */ \
-		khint32_t *new_flags = 0;										\
-		khint_t j = 1;													\
-		{																\
-			kroundup32(new_n_buckets); 									\
-			if (new_n_buckets < 4) new_n_buckets = 4;					\
-			if (h->size >= (khint_t)(new_n_buckets * __ac_HASH_UPPER + 0.5)) j = 0;	/* requested size is too small */ \
-			else { /* hash table size to be changed (shrink or expand); rehash */ \
-				new_flags = (khint32_t*)kmalloc(__ac_fsize(new_n_buckets) * sizeof(khint32_t));	\
-				if (!new_flags) return -1;								\
-				memset(new_flags, 0xaa, __ac_fsize(new_n_buckets) * sizeof(khint32_t)); \
-				if (h->n_buckets < new_n_buckets) {	/* expand */		\
-					khkey_t *new_keys = (khkey_t*)krealloc((void *)h->keys, new_n_buckets * sizeof(khkey_t)); \
-					if (!new_keys) { kfree(new_flags); return -1; }		\
-					h->keys = new_keys;									\
-					if (kh_is_map) {									\
-						khval_t *new_vals = (khval_t*)krealloc((void *)h->vals, new_n_buckets * sizeof(khval_t)); \
-						if (!new_vals) { kfree(new_flags); return -1; }	\
-						h->vals = new_vals;								\
-					}													\
-				} /* otherwise shrink */								\
-			}															\
-		}																\
-		if (j) { /* rehashing is needed */								\
-			for (j = 0; j != h->n_buckets; ++j) {						\
-				if (__ac_iseither(h->flags, j) == 0) {					\
-					khkey_t key = h->keys[j];							\
-					khval_t val;										\
-					khint_t new_mask;									\
-					new_mask = new_n_buckets - 1; 						\
-					if (kh_is_map) val = h->vals[j];					\
-					__ac_set_isdel_true(h->flags, j);					\
-					while (1) { /* kick-out process; sort of like in Cuckoo hashing */ \
-						khint_t k, i, step = 0; \
-						k = __hash_func(key);							\
-						i = k & new_mask;								\
-						while (!__ac_isempty(new_flags, i)) i = (i + (++step)) & new_mask; \
-						__ac_set_isempty_false(new_flags, i);			\
-						if (i < h->n_buckets && __ac_iseither(h->flags, i) == 0) { /* kick out the existing element */ \
-							{ khkey_t tmp = h->keys[i]; h->keys[i] = key; key = tmp; } \
-							if (kh_is_map) { khval_t tmp = h->vals[i]; h->vals[i] = val; val = tmp; } \
-							__ac_set_isdel_true(h->flags, i); /* mark it as deleted in the old hash table */ \
-						} else { /* write the element and jump out of the loop */ \
-							h->keys[i] = key;							\
-							if (kh_is_map) h->vals[i] = val;			\
-							break;										\
-						}												\
-					}													\
-				}														\
-			}															\
-			if (h->n_buckets > new_n_buckets) { /* shrink the hash table */ \
-				h->keys = (khkey_t*)krealloc((void *)h->keys, new_n_buckets * sizeof(khkey_t)); \
-				if (kh_is_map) h->vals = (khval_t*)krealloc((void *)h->vals, new_n_buckets * sizeof(khval_t)); \
-			}															\
-			kfree(h->flags); /* free the working space */				\
-			h->flags = new_flags;										\
-			h->n_buckets = new_n_buckets;								\
-			h->n_occupied = h->size;									\
-			h->upper_bound = (khint_t)(h->n_buckets * __ac_HASH_UPPER + 0.5); \
-		}																\
-		return 0;														\
-	}																	\
-	SCOPE khint_t kh_put_##name(kh_##name##_t *h, khkey_t key, int *ret) \
-	{																	\
-		khint_t x;														\
-		if (h->n_occupied >= h->upper_bound) { /* update the hash table */ \
-			if (h->n_buckets > (h->size<<1)) {							\
-				if (kh_resize_##name(h, h->n_buckets - 1) < 0) { /* clear "deleted" elements */ \
-					*ret = -1; return h->n_buckets;						\
-				}														\
-			} else if (kh_resize_##name(h, h->n_buckets + 1) < 0) { /* expand the hash table */ \
-				*ret = -1; return h->n_buckets;							\
-			}															\
-		} /* TODO: to implement automatically shrinking; resize() already support shrinking */ \
-		{																\
-			khint_t k, i, site, last, mask = h->n_buckets - 1, step = 0; \
-			x = site = h->n_buckets; k = __hash_func(key); i = k & mask; \
-			if (__ac_isempty(h->flags, i)) x = i; /* for speed up */	\
-			else {														\
-				last = i; \
-				while (!__ac_isempty(h->flags, i) && (__ac_isdel(h->flags, i) || !__hash_equal(h->keys[i], key))) { \
-					if (__ac_isdel(h->flags, i)) site = i;				\
-					i = (i + (++step)) & mask; \
-					if (i == last) { x = site; break; }					\
-				}														\
-				if (x == h->n_buckets) {								\
-					if (__ac_isempty(h->flags, i) && site != h->n_buckets) x = site; \
-					else x = i;											\
-				}														\
-			}															\
-		}																\
-		if (__ac_isempty(h->flags, x)) { /* not present at all */		\
-			h->keys[x] = key;											\
-			__ac_set_isboth_false(h->flags, x);							\
-			++h->size; ++h->n_occupied;									\
-			*ret = 1;													\
-		} else if (__ac_isdel(h->flags, x)) { /* deleted */				\
-			h->keys[x] = key;											\
-			__ac_set_isboth_false(h->flags, x);							\
-			++h->size;													\
-			*ret = 2;													\
-		} else *ret = 0; /* Don't touch h->keys[x] if present and not deleted */ \
-		return x;														\
-	}																	\
-	SCOPE void kh_del_##name(kh_##name##_t *h, khint_t x)				\
-	{																	\
-		if (x != h->n_buckets && !__ac_iseither(h->flags, x)) {			\
-			__ac_set_isdel_true(h->flags, x);							\
-			--h->size;													\
-		}																\
-	}
-
-#define KHASH_DECLARE(name, khkey_t, khval_t)		 					\
-	__KHASH_TYPE(name, khkey_t, khval_t) 								\
-	__KHASH_PROTOTYPES(name, khkey_t, khval_t)
-
-#define KHASH_INIT2(name, SCOPE, khkey_t, khval_t, kh_is_map, __hash_func, __hash_equal) \
-	__KHASH_TYPE(name, khkey_t, khval_t) 								\
-	__KHASH_IMPL(name, SCOPE, khkey_t, khval_t, kh_is_map, __hash_func, __hash_equal)
-
-#define KHASH_INIT(name, khkey_t, khval_t, kh_is_map, __hash_func, __hash_equal) \
-	KHASH_INIT2(name, static kh_inline klib_unused, khkey_t, khval_t, kh_is_map, __hash_func, __hash_equal)
-
-/* --- BEGIN OF HASH FUNCTIONS --- */
-
-/*! @function
-  @abstract     Integer hash function
-  @param  key   The integer [khint32_t]
-  @return       The hash value [khint_t]
- */
-#define kh_int_hash_func(key) (khint32_t)(key)
-/*! @function
-  @abstract     Integer comparison function
- */
-#define kh_int_hash_equal(a, b) ((a) == (b))
-/*! @function
-  @abstract     64-bit integer hash function
-  @param  key   The integer [khint64_t]
-  @return       The hash value [khint_t]
- */
-#define kh_int64_hash_func(key) (khint32_t)((key)>>33^(key)^(key)<<11)
-/*! @function
-  @abstract     64-bit integer comparison function
- */
-#define kh_int64_hash_equal(a, b) ((a) == (b))
-/*! @function
-  @abstract     const char* hash function
-  @param  s     Pointer to a null terminated string
-  @return       The hash value
- */
-static kh_inline khint_t __ac_X31_hash_string(const char *s)
-{
-	khint_t h = (khint_t)*s;
-	if (h) for (++s ; *s; ++s) h = (h << 5) - h + (khint_t)*s;
-	return h;
-}
-/*! @function
-  @abstract     Another interface to const char* hash function
-  @param  key   Pointer to a nul terminated string [const char*]
-  @return       The hash value [khint_t]
- */
-#define kh_str_hash_func(key) __ac_X31_hash_string(key)
-/*! @function
-  @abstract     Const char* comparison function
- */
-#define kh_str_hash_equal(a, b) (strcmp(a, b) == 0)
-
-/*! @function
-  @abstract     Kstring hash function
-  @param  s     Pointer to a kstring
-  @return       The hash value
- */
-static kh_inline khint_t __ac_X31_hash_kstring(const kstring_t ks)
-{
-	khint_t h = 0;
-	size_t i;
-	for (i = 0; i < ks.l; i++)
-		h = (h << 5) - h + (khint_t)ks.s[i];
-	return h;
-}
-/*! @function
-  @abstract     Interface to kstring hash function.
-  @param  key   Pointer to a khash; permits hashing on non-nul terminated strings.
-  @return       The hash value [khint_t]
- */
-#define kh_kstr_hash_func(key) __ac_X31_hash_kstring(key)
-/*! @function
-  @abstract     kstring comparison function
- */
-#define kh_kstr_hash_equal(a, b) ((a).l == (b).l && strncmp((a).s, (b).s, (a).l) == 0)
-
-static kh_inline khint_t __ac_Wang_hash(khint_t key)
-{
-    key += ~(key << 15);
-    key ^=  (key >> 10);
-    key +=  (key << 3);
-    key ^=  (key >> 6);
-    key += ~(key << 11);
-    key ^=  (key >> 16);
-    return key;
-}
-#define kh_int_hash_func2(k) __ac_Wang_hash((khint_t)key)
-
-/* --- END OF HASH FUNCTIONS --- */
-
-/* Other convenient macros... */
-
-/*!
-  @abstract Type of the hash table.
-  @param  name  Name of the hash table [symbol]
- */
-#define khash_t(name) kh_##name##_t
-
-/*! @function
-  @abstract     Initiate a hash table.
-  @param  name  Name of the hash table [symbol]
-  @return       Pointer to the hash table [khash_t(name)*]
- */
-#define kh_init(name) kh_init_##name()
-
-/*! @function
-  @abstract     Destroy a hash table.
-  @param  name  Name of the hash table [symbol]
-  @param  h     Pointer to the hash table [khash_t(name)*]
- */
-#define kh_destroy(name, h) kh_destroy_##name(h)
-
-/*! @function
-  @abstract     Reset a hash table without deallocating memory.
-  @param  name  Name of the hash table [symbol]
-  @param  h     Pointer to the hash table [khash_t(name)*]
- */
-#define kh_clear(name, h) kh_clear_##name(h)
-
-/*! @function
-  @abstract     Resize a hash table.
-  @param  name  Name of the hash table [symbol]
-  @param  h     Pointer to the hash table [khash_t(name)*]
-  @param  s     New size [khint_t]
- */
-#define kh_resize(name, h, s) kh_resize_##name(h, s)
-
-/*! @function
-  @abstract     Insert a key to the hash table.
-  @param  name  Name of the hash table [symbol]
-  @param  h     Pointer to the hash table [khash_t(name)*]
-  @param  k     Key [type of keys]
-  @param  r     Extra return code: -1 if the operation failed;
-                0 if the key is present in the hash table;
-                1 if the bucket is empty (never used); 2 if the element in
-				the bucket has been deleted [int*]
-  @return       Iterator to the inserted element [khint_t]
- */
-#define kh_put(name, h, k, r) kh_put_##name(h, k, r)
-
-/*! @function
-  @abstract     Retrieve a key from the hash table.
-  @param  name  Name of the hash table [symbol]
-  @param  h     Pointer to the hash table [khash_t(name)*]
-  @param  k     Key [type of keys]
-  @return       Iterator to the found element, or kh_end(h) if the element is absent [khint_t]
- */
-#define kh_get(name, h, k) kh_get_##name(h, k)
-
-/*! @function
-  @abstract     Remove a key from the hash table.
-  @param  name  Name of the hash table [symbol]
-  @param  h     Pointer to the hash table [khash_t(name)*]
-  @param  k     Iterator to the element to be deleted [khint_t]
- */
-#define kh_del(name, h, k) kh_del_##name(h, k)
-
-/*! @function
-  @abstract     Test whether a bucket contains data.
-  @param  h     Pointer to the hash table [khash_t(name)*]
-  @param  x     Iterator to the bucket [khint_t]
-  @return       1 if containing data; 0 otherwise [int]
- */
-#define kh_exist(h, x) (!__ac_iseither((h)->flags, (x)))
-
-/*! @function
-  @abstract     Get key given an iterator
-  @param  h     Pointer to the hash table [khash_t(name)*]
-  @param  x     Iterator to the bucket [khint_t]
-  @return       Key [type of keys]
- */
-#define kh_key(h, x) ((h)->keys[x])
-
-/*! @function
-  @abstract     Get value given an iterator
-  @param  h     Pointer to the hash table [khash_t(name)*]
-  @param  x     Iterator to the bucket [khint_t]
-  @return       Value [type of values]
-  @discussion   For hash sets, calling this results in segfault.
- */
-#define kh_val(h, x) ((h)->vals[x])
-
-/*! @function
-  @abstract     Alias of kh_val()
- */
-#define kh_value(h, x) ((h)->vals[x])
-
-/*! @function
-  @abstract     Get the start iterator
-  @param  h     Pointer to the hash table [khash_t(name)*]
-  @return       The start iterator [khint_t]
- */
-#define kh_begin(h) (khint_t)(0)
-
-/*! @function
-  @abstract     Get the end iterator
-  @param  h     Pointer to the hash table [khash_t(name)*]
-  @return       The end iterator [khint_t]
- */
-#define kh_end(h) ((h)->n_buckets)
-
-/*! @function
-  @abstract     Get the number of elements in the hash table
-  @param  h     Pointer to the hash table [khash_t(name)*]
-  @return       Number of elements in the hash table [khint_t]
- */
-#define kh_size(h) ((h)->size)
-
-/*! @function
-  @abstract     Get the number of buckets in the hash table
-  @param  h     Pointer to the hash table [khash_t(name)*]
-  @return       Number of buckets in the hash table [khint_t]
- */
-#define kh_n_buckets(h) ((h)->n_buckets)
-
-/*! @function
-  @abstract     Iterate over the entries in the hash table
-  @param  h     Pointer to the hash table [khash_t(name)*]
-  @param  kvar  Variable to which key will be assigned
-  @param  vvar  Variable to which value will be assigned
-  @param  code  Block of code to execute
- */
-#define kh_foreach(h, kvar, vvar, code) { khint_t __i;		\
-	for (__i = kh_begin(h); __i != kh_end(h); ++__i) {		\
-		if (!kh_exist(h,__i)) continue;						\
-		(kvar) = kh_key(h,__i);								\
-		(vvar) = kh_val(h,__i);								\
-		code;												\
-	} }
-
-/*! @function
-  @abstract     Iterate over the values in the hash table
-  @param  h     Pointer to the hash table [khash_t(name)*]
-  @param  vvar  Variable to which value will be assigned
-  @param  code  Block of code to execute
- */
-#define kh_foreach_value(h, vvar, code) { khint_t __i;		\
-	for (__i = kh_begin(h); __i != kh_end(h); ++__i) {		\
-		if (!kh_exist(h,__i)) continue;						\
-		(vvar) = kh_val(h,__i);								\
-		code;												\
-	} }
-
-/* More convenient interfaces */
-
-/*! @function
-  @abstract     Instantiate a hash set containing integer keys
-  @param  name  Name of the hash table [symbol]
- */
-#define KHASH_SET_INIT_INT(name)										\
-	KHASH_INIT(name, khint32_t, char, 0, kh_int_hash_func, kh_int_hash_equal)
-
-/*! @function
-  @abstract     Instantiate a hash map containing integer keys
-  @param  name  Name of the hash table [symbol]
-  @param  khval_t  Type of values [type]
- */
-#define KHASH_MAP_INIT_INT(name, khval_t)								\
-	KHASH_INIT(name, khint32_t, khval_t, 1, kh_int_hash_func, kh_int_hash_equal)
-
-/*! @function
-  @abstract     Instantiate a hash set containing 64-bit integer keys
-  @param  name  Name of the hash table [symbol]
- */
-#define KHASH_SET_INIT_INT64(name)										\
-	KHASH_INIT(name, khint64_t, char, 0, kh_int64_hash_func, kh_int64_hash_equal)
-
-/*! @function
-  @abstract     Instantiate a hash map containing 64-bit integer keys
-  @param  name  Name of the hash table [symbol]
-  @param  khval_t  Type of values [type]
- */
-#define KHASH_MAP_INIT_INT64(name, khval_t)								\
-	KHASH_INIT(name, khint64_t, khval_t, 1, kh_int64_hash_func, kh_int64_hash_equal)
-
-typedef const char *kh_cstr_t;
-/*! @function
-  @abstract     Instantiate a hash set containing const char* keys
-  @param  name  Name of the hash table [symbol]
- */
-#define KHASH_SET_INIT_STR(name)										\
-	KHASH_INIT(name, kh_cstr_t, char, 0, kh_str_hash_func, kh_str_hash_equal)
-
-/*! @function
-  @abstract     Instantiate a hash map containing const char* keys
-  @param  name  Name of the hash table [symbol]
-  @param  khval_t  Type of values [type]
- */
-#define KHASH_MAP_INIT_STR(name, khval_t)								\
-	KHASH_INIT(name, kh_cstr_t, khval_t, 1, kh_str_hash_func, kh_str_hash_equal)
-
-/*! @function
-  @abstract     Instantiate a hash set containing kstring_t keys
-  @param  name  Name of the hash table [symbol]
- */
-#define KHASH_SET_INIT_KSTR(name)										\
-	KHASH_INIT(name, kstring_t, char, 0, kh_kstr_hash_func, kh_kstr_hash_equal)
-
-/*! @function
-  @abstract     Instantiate a hash map containing kstring_t keys
-  @param  name  Name of the hash table [symbol]
-  @param  khval_t  Type of values [type]
- */
-#define KHASH_MAP_INIT_KSTR(name, khval_t)								\
-	KHASH_INIT(name, kstring_t, khval_t, 1, kh_kstr_hash_func, kh_kstr_hash_equal)
-
-#endif /* __AC_KHASH_H */
diff -ruN stringtie.orig/htslib/htslib/khash_str2int.h stringtie/htslib/htslib/khash_str2int.h
--- stringtie.orig/htslib/htslib/khash_str2int.h	2024-02-28 13:57:39.704579460 +0100
+++ stringtie/htslib/htslib/khash_str2int.h	1970-01-01 01:00:00.000000000 +0100
@@ -1,135 +0,0 @@
-/*  khash_str2int.h -- C-string to integer hash table.
-
-    Copyright (C) 2013-2014,2020 Genome Research Ltd.
-
-    Author: Petr Danecek <pd3@sanger.ac.uk>
-
-Permission is hereby granted, free of charge, to any person obtaining a copy
-of this software and associated documentation files (the "Software"), to deal
-in the Software without restriction, including without limitation the rights
-to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
-copies of the Software, and to permit persons to whom the Software is
-furnished to do so, subject to the following conditions:
-
-The above copyright notice and this permission notice shall be included in
-all copies or substantial portions of the Software.
-
-THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
-IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
-FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
-THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
-LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
-FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
-DEALINGS IN THE SOFTWARE.  */
-
-#ifndef HTSLIB_KHASH_STR2INT_H
-#define HTSLIB_KHASH_STR2INT_H
-
-#include "khash.h"
-
-KHASH_MAP_INIT_STR(str2int, int)
-
-/*
- *  Wrappers for khash dictionaries used by mpileup.
- */
-
-static inline void *khash_str2int_init(void)
-{
-    return kh_init(str2int);
-}
-
-/*
- *  Destroy the hash structure, but not the keys
- */
-static inline void khash_str2int_destroy(void *_hash)
-{
-    khash_t(str2int) *hash = (khash_t(str2int)*)_hash;
-    if (hash) kh_destroy(str2int, hash); // Note that strings are not freed.
-}
-
-/*
- *  Destroys both the hash structure and the keys
- */
-static inline void khash_str2int_destroy_free(void *_hash)
-{
-    khash_t(str2int) *hash = (khash_t(str2int)*)_hash;
-    khint_t k;
-    if (hash == 0) return;
-    for (k = 0; k < kh_end(hash); ++k)
-        if (kh_exist(hash, k)) free((char*)kh_key(hash, k));
-    kh_destroy(str2int, hash);
-}
-
-/*
- *  Returns 1 if key exists or 0 if not
- */
-static inline int khash_str2int_has_key(void *_hash, const char *str)
-{
-    khash_t(str2int) *hash = (khash_t(str2int)*)_hash;
-    khint_t k = kh_get(str2int, hash, str);
-    if ( k == kh_end(hash) ) return 0;
-    return 1;
-}
-
-/*
- *  Returns 0 on success and -1 when the key is not present. On success,
- *  *value is set, unless NULL is passed.
- */
-static inline int khash_str2int_get(void *_hash, const char *str, int *value)
-{
-    khash_t(str2int) *hash = (khash_t(str2int)*)_hash;
-    khint_t k;
-    if ( !hash ) return -1;
-    k = kh_get(str2int, hash, str);
-    if ( k == kh_end(hash) ) return -1;
-    if ( !value ) return 0;
-    *value = kh_val(hash, k);
-    return 0;
-}
-
-/*
- *  Add a new string to the dictionary, auto-incrementing the value.
- *  On success returns the newly inserted integer id, on error -1
- *  is returned. Note that the key must continue to exist throughout
- *  the whole life of _hash.
- */
-static inline int khash_str2int_inc(void *_hash, const char *str)
-{
-    khint_t k;
-    int ret;
-    khash_t(str2int) *hash = (khash_t(str2int)*)_hash;
-    if ( !hash ) return -1;
-    k = kh_put(str2int, hash, str, &ret);
-    if (ret < 0) return -1;
-    if (ret == 0) return kh_val(hash, k);
-    kh_val(hash, k) = kh_size(hash) - 1;
-    return kh_val(hash, k);
-}
-
-/*
- *  Set a new key,value pair. On success returns the bin index, on
- *  error -1 is returned. Note that the key must continue to exist
- *  throughout the whole life of _hash.
- */
-static inline int khash_str2int_set(void *_hash, const char *str, int value)
-{
-    khint_t k;
-    int ret;
-    khash_t(str2int) *hash = (khash_t(str2int)*)_hash;
-    if ( !hash ) return -1;
-    k = kh_put(str2int, hash, str, &ret);
-    if (ret < 0) return -1;
-    kh_val(hash,k) = value;
-    return k;
-}
-
-/*
- *  Return the number of keys in the hash table.
- */
-static inline int khash_str2int_size(void *_hash)
-{
-    khash_t(str2int) *hash = (khash_t(str2int)*)_hash;
-    return kh_size(hash);
-}
-
-#endif
diff -ruN stringtie.orig/htslib/htslib/klist.h stringtie/htslib/htslib/klist.h
--- stringtie.orig/htslib/htslib/klist.h	2024-02-28 13:57:39.704579460 +0100
+++ stringtie/htslib/htslib/klist.h	1970-01-01 01:00:00.000000000 +0100
@@ -1,136 +0,0 @@
-/* The MIT License
-
-   Copyright (c) 2008-2009, by Attractive Chaos <attractor@live.co.uk>
-   Copyright (C) 2013, 2015 Genome Research Ltd.
-
-   Permission is hereby granted, free of charge, to any person obtaining
-   a copy of this software and associated documentation files (the
-   "Software"), to deal in the Software without restriction, including
-   without limitation the rights to use, copy, modify, merge, publish,
-   distribute, sublicense, and/or sell copies of the Software, and to
-   permit persons to whom the Software is furnished to do so, subject to
-   the following conditions:
-
-   The above copyright notice and this permission notice shall be
-   included in all copies or substantial portions of the Software.
-
-   THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
-   EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
-   MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
-   NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS
-   BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
-   ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
-   CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
-   SOFTWARE.
-*/
-
-#ifndef _AC_KLIST_H
-#define _AC_KLIST_H
-
-#include <stdlib.h>
-
-#ifndef klib_unused
-#if (defined __clang__ && __clang_major__ >= 3) || (defined __GNUC__ && __GNUC__ >= 3)
-#define klib_unused __attribute__ ((__unused__))
-#else
-#define klib_unused
-#endif
-#endif /* klib_unused */
-
-#define KMEMPOOL_INIT2(SCOPE, name, kmptype_t, kmpfree_f)				\
-	typedef struct {													\
-		size_t cnt, n, max;												\
-		kmptype_t **buf;												\
-	} kmp_##name##_t;													\
-	SCOPE kmp_##name##_t *kmp_init_##name(void) {						\
-		return calloc(1, sizeof(kmp_##name##_t));						\
-	}																	\
-	SCOPE void kmp_destroy_##name(kmp_##name##_t *mp) {					\
-		size_t k;														\
-		for (k = 0; k < mp->n; ++k) {									\
-			kmpfree_f(mp->buf[k]); free(mp->buf[k]);					\
-		}																\
-		free(mp->buf); free(mp);										\
-	}																	\
-	SCOPE kmptype_t *kmp_alloc_##name(kmp_##name##_t *mp) {				\
-		++mp->cnt;														\
-		if (mp->n == 0) return calloc(1, sizeof(kmptype_t));			\
-		return mp->buf[--mp->n];										\
-	}																	\
-	SCOPE void kmp_free_##name(kmp_##name##_t *mp, kmptype_t *p) {		\
-		--mp->cnt;														\
-		if (mp->n == mp->max) {											\
-			mp->max = mp->max? mp->max<<1 : 16;							\
-			mp->buf = realloc(mp->buf, sizeof(kmptype_t *) * mp->max);	\
-		}																\
-		mp->buf[mp->n++] = p;											\
-	}
-
-#define KMEMPOOL_INIT(name, kmptype_t, kmpfree_f)						\
-	KMEMPOOL_INIT2(static inline klib_unused, name, kmptype_t, kmpfree_f)
-
-#define kmempool_t(name) kmp_##name##_t
-#define kmp_init(name) kmp_init_##name()
-#define kmp_destroy(name, mp) kmp_destroy_##name(mp)
-#define kmp_alloc(name, mp) kmp_alloc_##name(mp)
-#define kmp_free(name, mp, p) kmp_free_##name(mp, p)
-
-#define KLIST_INIT2(SCOPE, name, kltype_t, kmpfree_t)					\
-	struct __kl1_##name {												\
-		kltype_t data;													\
-		struct __kl1_##name *next;										\
-	};																	\
-	typedef struct __kl1_##name kl1_##name;								\
-	KMEMPOOL_INIT2(SCOPE, name, kl1_##name, kmpfree_t)					\
-	typedef struct {													\
-		kl1_##name *head, *tail;										\
-		kmp_##name##_t *mp;												\
-		size_t size;													\
-	} kl_##name##_t;													\
-	SCOPE kl_##name##_t *kl_init_##name(void) {							\
-		kl_##name##_t *kl = calloc(1, sizeof(kl_##name##_t));			\
-		kl->mp = kmp_init(name);										\
-		kl->head = kl->tail = kmp_alloc(name, kl->mp);					\
-		kl->head->next = 0;												\
-		return kl;														\
-	}																	\
-	SCOPE void kl_destroy_##name(kl_##name##_t *kl) {					\
-		kl1_##name *p;													\
-		for (p = kl->head; p != kl->tail; p = p->next)					\
-			kmp_free(name, kl->mp, p);									\
-		kmp_free(name, kl->mp, p);										\
-		kmp_destroy(name, kl->mp);										\
-		free(kl);														\
-	}																	\
-	SCOPE kltype_t *kl_pushp_##name(kl_##name##_t *kl) {				\
-		kl1_##name *q, *p = kmp_alloc(name, kl->mp);					\
-		q = kl->tail; p->next = 0; kl->tail->next = p; kl->tail = p;	\
-		++kl->size;														\
-		return &q->data;												\
-	}																	\
-	SCOPE int kl_shift_##name(kl_##name##_t *kl, kltype_t *d) {			\
-		kl1_##name *p;													\
-		if (kl->head->next == 0) return -1;								\
-		--kl->size;														\
-		p = kl->head; kl->head = kl->head->next;						\
-		if (d) *d = p->data;											\
-		kmp_free(name, kl->mp, p);										\
-		return 0;														\
-	}
-
-#define KLIST_INIT(name, kltype_t, kmpfree_t)							\
-	KLIST_INIT2(static inline klib_unused, name, kltype_t, kmpfree_t)
-
-#define kliter_t(name) kl1_##name
-#define klist_t(name) kl_##name##_t
-#define kl_val(iter) ((iter)->data)
-#define kl_next(iter) ((iter)->next)
-#define kl_begin(kl) ((kl)->head)
-#define kl_end(kl) ((kl)->tail)
-
-#define kl_init(name) kl_init_##name()
-#define kl_destroy(name, kl) kl_destroy_##name(kl)
-#define kl_pushp(name, kl) kl_pushp_##name(kl)
-#define kl_shift(name, kl, d) kl_shift_##name(kl, d)
-
-#endif
diff -ruN stringtie.orig/htslib/htslib/knetfile.h stringtie/htslib/htslib/knetfile.h
--- stringtie.orig/htslib/htslib/knetfile.h	2024-02-28 13:57:39.704579460 +0100
+++ stringtie/htslib/htslib/knetfile.h	1970-01-01 01:00:00.000000000 +0100
@@ -1,105 +0,0 @@
-/* The MIT License
-
-   Copyright (c) 2008, 2012, 2014, 2021 Genome Research Ltd (GRL).
-                 2010 by Attractive Chaos <attractor@live.co.uk>
-
-   Permission is hereby granted, free of charge, to any person obtaining
-   a copy of this software and associated documentation files (the
-   "Software"), to deal in the Software without restriction, including
-   without limitation the rights to use, copy, modify, merge, publish,
-   distribute, sublicense, and/or sell copies of the Software, and to
-   permit persons to whom the Software is furnished to do so, subject to
-   the following conditions:
-
-   The above copyright notice and this permission notice shall be
-   included in all copies or substantial portions of the Software.
-
-   THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
-   EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
-   MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
-   NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS
-   BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
-   ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
-   CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
-   SOFTWARE.
-*/
-
-#ifndef KNETFILE_H
-#define KNETFILE_H
-
-#include <stdint.h>
-#include <fcntl.h>
-#include <sys/types.h>
-
-#include "hts_defs.h"
-
-#ifndef _WIN32
-#define netread(fd, ptr, len) read(fd, ptr, len)
-#define netwrite(fd, ptr, len) write(fd, ptr, len)
-#define netclose(fd) close(fd)
-#else
-#include <winsock2.h>
-#define netread(fd, ptr, len) recv(fd, ptr, len, 0)
-#define netwrite(fd, ptr, len) send(fd, ptr, len, 0)
-#define netclose(fd) closesocket(fd)
-#endif
-
-// FIXME: currently I/O is unbuffered
-
-#define KNF_TYPE_LOCAL 1
-#define KNF_TYPE_FTP   2
-#define KNF_TYPE_HTTP  3
-
-// Kept for API/ABI compatability only.  Do not use directly!
-typedef struct knetFile_s {
-        int type, fd;
-        int64_t offset;
-        char *host, *port;
-
-        // the following are for FTP only
-        int ctrl_fd, pasv_ip[4], pasv_port, max_response, no_reconnect, is_ready;
-        char *response, *retr, *size_cmd;
-        int64_t seek_offset; // for lazy seek
-        int64_t file_size;
-
-        // the following are for HTTP only
-        char *path, *http_host;
-} knetFile;
-
-#define knet_tell(fp) ((fp)->offset)
-#define knet_fileno(fp) ((fp)->fd)
-
-#ifdef __cplusplus
-extern "C" {
-#endif
-
-    HTSLIB_EXPORT
-        knetFile *knet_open(const char *fn, const char *mode) HTS_DEPRECATED("Please use hopen instead");
-
-        /*
-           This only works with local files.
-         */
-    HTSLIB_EXPORT
-        knetFile *knet_dopen(int fd, const char *mode) HTS_DEPRECATED("Please use hdopen instead");
-
-        /*
-          If ->is_ready==0, this routine updates ->fd; otherwise, it simply
-          reads from ->fd.
-         */
-    HTSLIB_EXPORT
-        ssize_t knet_read(knetFile *fp, void *buf, size_t len) HTS_DEPRECATED("Please use hread instead");
-
-        /*
-          This routine only sets ->offset and ->is_ready=0. It does not
-          communicate with the FTP server.
-         */
-    HTSLIB_EXPORT
-        off_t knet_seek(knetFile *fp, off_t off, int whence) HTS_DEPRECATED("Please use hseek instead");
-    HTSLIB_EXPORT
-        int knet_close(knetFile *fp) HTS_DEPRECATED("Please use hclose instead");
-
-#ifdef __cplusplus
-}
-#endif
-
-#endif
diff -ruN stringtie.orig/htslib/htslib/kroundup.h stringtie/htslib/htslib/kroundup.h
--- stringtie.orig/htslib/htslib/kroundup.h	2024-02-28 13:57:39.704579460 +0100
+++ stringtie/htslib/htslib/kroundup.h	1970-01-01 01:00:00.000000000 +0100
@@ -1,76 +0,0 @@
-/* The MIT License
-
-   Copyright (C) 2020 Genome Research Ltd.
-
-   Permission is hereby granted, free of charge, to any person obtaining
-   a copy of this software and associated documentation files (the
-   "Software"), to deal in the Software without restriction, including
-   without limitation the rights to use, copy, modify, merge, publish,
-   distribute, sublicense, and/or sell copies of the Software, and to
-   permit persons to whom the Software is furnished to do so, subject to
-   the following conditions:
-
-   The above copyright notice and this permission notice shall be
-   included in all copies or substantial portions of the Software.
-
-   THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
-   EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
-   MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
-   NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS
-   BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
-   ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
-   CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
-   SOFTWARE.
-*/
-
-#ifndef KROUNDUP_H
-#define KROUNDUP_H
-
-// Value of this macro is 1 if x is a signed type; 0 if unsigned
-#define k_signed_type(x) (!(-((x) * 0 + 1) > 0))
-
-/*
-  Macro with value 1 if the highest bit in x is set for any integer type
-
-  This is written avoiding conditionals (?: operator) to reduce the likelihood
-  of gcc attempting jump thread optimisations for code paths where (x) is
-  large.  These optimisations can cause gcc to issue warnings about excessively
-  large memory allocations when the kroundup64() macro below is used with
-  malloc().  Such warnings can be misleading as they imply only the large
-  allocation happens when it's actually working fine for normal values of (x).
-
-  See https://developers.redhat.com/blog/2019/03/13/understanding-gcc-warnings-part-2/
-*/
-#define k_high_bit_set(x) ((((x) >> (sizeof(x) * 8 - 1 - k_signed_type(x))) & 1))
-
-/*! @hideinitializer
-  @abstract  Round up to next power of two
-  @discussion
-  This macro will work for unsigned types up to uint64_t.
-
-  If the next power of two does not fit in the given type, it will set
-  the largest value that does.
- */
-#define kroundup64(x) ((x) > 0 ?                                        \
-                       (--(x),                                          \
-                        (x)|=(x)>>(sizeof(x)/8),                        \
-                        (x)|=(x)>>(sizeof(x)/4),                        \
-                        (x)|=(x)>>(sizeof(x)/2),                        \
-                        (x)|=(x)>>(sizeof(x)),                          \
-                        (x)|=(x)>>(sizeof(x)*2),                        \
-                        (x)|=(x)>>(sizeof(x)*4),                        \
-                        (x) += !k_high_bit_set(x),                      \
-                        (x))                                            \
-                       : 0)
-
-// Historic interfaces for 32-bit and size_t values.  The macro above
-// works for both (as long as size_t is no more than 64 bits).
-
-#ifndef kroundup32
-#define kroundup32(x) kroundup64(x)
-#endif
-#ifndef kroundup_size_t
-#define kroundup_size_t(x) kroundup64(x)
-#endif
-
-#endif
diff -ruN stringtie.orig/htslib/htslib/kseq.h stringtie/htslib/htslib/kseq.h
--- stringtie.orig/htslib/htslib/kseq.h	2024-02-28 13:57:39.704579460 +0100
+++ stringtie/htslib/htslib/kseq.h	1970-01-01 01:00:00.000000000 +0100
@@ -1,248 +0,0 @@
-/* The MIT License
-
-   Copyright (c) 2008, 2009, 2011 Attractive Chaos <attractor@live.co.uk>
-   Copyright (C) 2013, 2018, 2020 Genome Research Ltd.
-
-   Permission is hereby granted, free of charge, to any person obtaining
-   a copy of this software and associated documentation files (the
-   "Software"), to deal in the Software without restriction, including
-   without limitation the rights to use, copy, modify, merge, publish,
-   distribute, sublicense, and/or sell copies of the Software, and to
-   permit persons to whom the Software is furnished to do so, subject to
-   the following conditions:
-
-   The above copyright notice and this permission notice shall be
-   included in all copies or substantial portions of the Software.
-
-   THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
-   EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
-   MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
-   NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS
-   BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
-   ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
-   CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
-   SOFTWARE.
-*/
-
-/* Last Modified: 05MAR2012 */
-
-#ifndef AC_KSEQ_H
-#define AC_KSEQ_H
-
-#include <ctype.h>
-#include <string.h>
-#include <stdlib.h>
-
-#include "kstring.h"
-
-#ifndef klib_unused
-#if (defined __clang__ && __clang_major__ >= 3) || (defined __GNUC__ && __GNUC__ >= 3)
-#define klib_unused __attribute__ ((__unused__))
-#else
-#define klib_unused
-#endif
-#endif /* klib_unused */
-
-#define KS_SEP_SPACE 0 // isspace(): \t, \n, \v, \f, \r
-#define KS_SEP_TAB   1 // isspace() && !' '
-#define KS_SEP_LINE  2 // line separator: "\n" (Unix) or "\r\n" (Windows)
-#define KS_SEP_MAX   2
-
-#define __KS_TYPE(type_t) \
-	typedef struct __kstream_t { \
-		int begin, end; \
-		int is_eof:2, bufsize:30; \
-        uint64_t seek_pos; \
-		type_t f; \
-		unsigned char *buf; \
-	} kstream_t;
-
-#define ks_eof(ks) ((ks)->is_eof && (ks)->begin >= (ks)->end)
-#define ks_rewind(ks) ((ks)->is_eof = (ks)->begin = (ks)->end = 0)
-
-#define __KS_BASIC(SCOPE, type_t, __bufsize) \
-	SCOPE kstream_t *ks_init(type_t f) \
-	{ \
-		kstream_t *ks = (kstream_t*)calloc(1, sizeof(kstream_t)); \
-		ks->f = f; ks->bufsize = __bufsize; \
-		ks->buf = (unsigned char*)malloc(__bufsize); \
-		return ks; \
-	} \
-	SCOPE void ks_destroy(kstream_t *ks) \
-	{ \
-		if (!ks) return; \
-		free(ks->buf); \
-		free(ks); \
-	}
-
-#define __KS_INLINED(__read) \
-	static inline klib_unused int ks_getc(kstream_t *ks) \
-	{ \
-		if (ks->is_eof && ks->begin >= ks->end) return -1; \
-		if (ks->begin >= ks->end) { \
-			ks->begin = 0; \
-			ks->end = __read(ks->f, ks->buf, ks->bufsize); \
-			if (ks->end == 0) { ks->is_eof = 1; return -1; } \
-		} \
-        ks->seek_pos++; \
-		return (int)ks->buf[ks->begin++]; \
-	} \
-	static inline klib_unused int ks_getuntil(kstream_t *ks, int delimiter, kstring_t *str, int *dret) \
-	{ return ks_getuntil2(ks, delimiter, str, dret, 0); }
-
-#define __KS_GETUNTIL(SCOPE, __read) \
-	SCOPE int ks_getuntil2(kstream_t *ks, int delimiter, kstring_t *str, int *dret, int append)  \
-	{ \
-		int gotany = 0; \
-		if (dret) *dret = 0; \
-		str->l = append? str->l : 0; \
-        uint64_t seek_pos = str->l; \
-		for (;;) { \
-			int i; \
-			if (ks->begin >= ks->end) { \
-				if (!ks->is_eof) { \
-					ks->begin = 0; \
-					ks->end = __read(ks->f, ks->buf, ks->bufsize); \
-					if (ks->end == 0) { ks->is_eof = 1; break; } \
-				} else break; \
-			} \
-			if (delimiter == KS_SEP_LINE) {  \
-				for (i = ks->begin; i < ks->end; ++i)  \
-					if (ks->buf[i] == '\n') break; \
-			} else if (delimiter > KS_SEP_MAX) { \
-				for (i = ks->begin; i < ks->end; ++i) \
-					if (ks->buf[i] == delimiter) break; \
-			} else if (delimiter == KS_SEP_SPACE) { \
-				for (i = ks->begin; i < ks->end; ++i) \
-					if (isspace(ks->buf[i])) break; \
-			} else if (delimiter == KS_SEP_TAB) { \
-				for (i = ks->begin; i < ks->end; ++i) \
-					if (isspace(ks->buf[i]) && ks->buf[i] != ' ') break;  \
-			} else i = 0; /* never come to here! */ \
-			(void) ks_expand(str, i - ks->begin + 1); \
-            seek_pos += i - ks->begin; if ( i < ks->end ) seek_pos++; \
-			gotany = 1; \
-			memcpy(str->s + str->l, ks->buf + ks->begin, i - ks->begin);  \
-			str->l = str->l + (i - ks->begin); \
-			ks->begin = i + 1; \
-			if (i < ks->end) { \
-				if (dret) *dret = ks->buf[i]; \
-				break; \
-			} \
-		} \
-		if (!gotany && ks_eof(ks)) return -1; \
-        ks->seek_pos += seek_pos; \
-		if (str->s == 0) { \
-			str->m = 1; \
-			str->s = (char*)calloc(1, 1); \
-		} else if (delimiter == KS_SEP_LINE && str->l > 1 && str->s[str->l-1] == '\r') --str->l; \
-		str->s[str->l] = '\0';											\
-		return str->l; \
-	}
-
-#define KSTREAM_INIT2(SCOPE, type_t, __read, __bufsize) \
-	__KS_TYPE(type_t) \
-	__KS_BASIC(SCOPE, type_t, __bufsize) \
-	__KS_GETUNTIL(SCOPE, __read) \
-	__KS_INLINED(__read)
-
-#define KSTREAM_INIT(type_t, __read, __bufsize) KSTREAM_INIT2(static, type_t, __read, __bufsize)
-
-#define KSTREAM_DECLARE(type_t, __read) \
-	__KS_TYPE(type_t) \
-	extern int ks_getuntil2(kstream_t *ks, int delimiter, kstring_t *str, int *dret, int append); \
-	extern kstream_t *ks_init(type_t f); \
-	extern void ks_destroy(kstream_t *ks); \
-	__KS_INLINED(__read)
-
-/******************
- * FASTA/Q parser *
- ******************/
-
-#define kseq_rewind(ks) ((ks)->last_char = (ks)->f->is_eof = (ks)->f->begin = (ks)->f->end = 0)
-
-#define __KSEQ_BASIC(SCOPE, type_t)										\
-	SCOPE kseq_t *kseq_init(type_t fd)									\
-	{																	\
-		kseq_t *s = (kseq_t*)calloc(1, sizeof(kseq_t));					\
-		s->f = ks_init(fd);												\
-		return s;														\
-	}																	\
-	SCOPE void kseq_destroy(kseq_t *ks)									\
-	{																	\
-		if (!ks) return;												\
-		free(ks->name.s); free(ks->comment.s); free(ks->seq.s);	free(ks->qual.s); \
-		ks_destroy(ks->f);												\
-		free(ks);														\
-	}
-
-/* Return value:
-   >=0  length of the sequence (normal)
-   -1   end-of-file
-   -2   truncated quality string
- */
-#define __KSEQ_READ(SCOPE) \
-	SCOPE int kseq_read(kseq_t *seq) \
-	{ \
-		int c; \
-		kstream_t *ks = seq->f; \
-		if (seq->last_char == 0) { /* then jump to the next header line */ \
-			while ((c = ks_getc(ks)) != -1 && c != '>' && c != '@'); \
-			if (c == -1) return -1; /* end of file */ \
-			seq->last_char = c; \
-		} /* else: the first header char has been read in the previous call */ \
-		seq->comment.l = seq->seq.l = seq->qual.l = 0; /* reset all members */ \
-		if (ks_getuntil(ks, 0, &seq->name, &c) < 0) return -1; /* normal exit: EOF */ \
-		if (c != '\n') ks_getuntil(ks, KS_SEP_LINE, &seq->comment, 0); /* read FASTA/Q comment */ \
-		if (seq->seq.s == 0) { /* we can do this in the loop below, but that is slower */ \
-			seq->seq.m = 256; \
-			seq->seq.s = (char*)malloc(seq->seq.m); \
-		} \
-		while ((c = ks_getc(ks)) != -1 && c != '>' && c != '+' && c != '@') { \
-			if (c == '\n') continue; /* skip empty lines */ \
-			seq->seq.s[seq->seq.l++] = c; /* this is safe: we always have enough space for 1 char */ \
-			ks_getuntil2(ks, KS_SEP_LINE, &seq->seq, 0, 1); /* read the rest of the line */ \
-		} \
-		if (c == '>' || c == '@') seq->last_char = c; /* the first header char has been read */	\
-		if (seq->seq.l + 1 >= seq->seq.m) { /* seq->seq.s[seq->seq.l] below may be out of boundary */ \
-			seq->seq.m = seq->seq.l + 2; \
-			kroundup32(seq->seq.m); /* rounded to the next closest 2^k */ \
-			seq->seq.s = (char*)realloc(seq->seq.s, seq->seq.m); \
-		} \
-		seq->seq.s[seq->seq.l] = 0;	/* null terminated string */ \
-		if (c != '+') return seq->seq.l; /* FASTA */ \
-		if (seq->qual.m < seq->seq.m) {	/* allocate memory for qual in case insufficient */ \
-			seq->qual.m = seq->seq.m; \
-			seq->qual.s = (char*)realloc(seq->qual.s, seq->qual.m); \
-		} \
-		while ((c = ks_getc(ks)) != -1 && c != '\n'); /* skip the rest of '+' line */ \
-		if (c == -1) return -2; /* error: no quality string */ \
-		while (ks_getuntil2(ks, KS_SEP_LINE, &seq->qual, 0, 1) >= 0 && seq->qual.l < seq->seq.l); \
-		seq->last_char = 0;	/* we have not come to the next header line */ \
-		if (seq->seq.l != seq->qual.l) return -2; /* error: qual string is of a different length */ \
-		return seq->seq.l; \
-	}
-
-#define __KSEQ_TYPE(type_t)						\
-	typedef struct {							\
-		kstring_t name, comment, seq, qual;		\
-		int last_char;							\
-		kstream_t *f;							\
-	} kseq_t;
-
-#define KSEQ_INIT2(SCOPE, type_t, __read)		\
-	KSTREAM_INIT(type_t, __read, 16384)			\
-	__KSEQ_TYPE(type_t)							\
-	__KSEQ_BASIC(SCOPE, type_t)					\
-	__KSEQ_READ(SCOPE)
-
-#define KSEQ_INIT(type_t, __read) KSEQ_INIT2(static, type_t, __read)
-
-#define KSEQ_DECLARE(type_t) \
-	__KS_TYPE(type_t) \
-	__KSEQ_TYPE(type_t) \
-	extern kseq_t *kseq_init(type_t fd); \
-	void kseq_destroy(kseq_t *ks); \
-	int kseq_read(kseq_t *seq);
-
-#endif
diff -ruN stringtie.orig/htslib/htslib/ksort.h stringtie/htslib/htslib/ksort.h
--- stringtie.orig/htslib/htslib/ksort.h	2024-02-28 13:57:39.704579460 +0100
+++ stringtie/htslib/htslib/ksort.h	1970-01-01 01:00:00.000000000 +0100
@@ -1,320 +0,0 @@
-/* The MIT License
-
-   Copyright (c) 2008, 2012-2013, 2017-2019 Genome Research Ltd (GRL).
-
-   Permission is hereby granted, free of charge, to any person obtaining
-   a copy of this software and associated documentation files (the
-   "Software"), to deal in the Software without restriction, including
-   without limitation the rights to use, copy, modify, merge, publish,
-   distribute, sublicense, and/or sell copies of the Software, and to
-   permit persons to whom the Software is furnished to do so, subject to
-   the following conditions:
-
-   The above copyright notice and this permission notice shall be
-   included in all copies or substantial portions of the Software.
-
-   THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
-   EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
-   MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
-   NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS
-   BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
-   ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
-   CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
-   SOFTWARE.
-*/
-
-/* Contact: Heng Li <lh3@sanger.ac.uk> */
-
-/*
-  2012-12-11 (0.1.4):
-
-    * Defined __ks_insertsort_##name as static to compile with C99.
-
-  2008-11-16 (0.1.4):
-
-    * Fixed a bug in introsort() that happens in rare cases.
-
-  2008-11-05 (0.1.3):
-
-    * Fixed a bug in introsort() for complex comparisons.
-
-	* Fixed a bug in mergesort(). The previous version is not stable.
-
-  2008-09-15 (0.1.2):
-
-	* Accelerated introsort. On my Mac (not on another Linux machine),
-	  my implementation is as fast as the C++ standard library's sort()
-	  on random input.
-
-	* Added combsort and in introsort, switch to combsort if the
-	  recursion is too deep.
-
-  2008-09-13 (0.1.1):
-
-	* Added k-small algorithm
-
-  2008-09-05 (0.1.0):
-
-	* Initial version
-
-*/
-
-#ifndef AC_KSORT_H
-#define AC_KSORT_H
-
-#include <stdlib.h>
-#include <string.h>
-
-#ifndef klib_unused
-#if (defined __clang__ && __clang_major__ >= 3) || (defined __GNUC__ && __GNUC__ >= 3)
-#define klib_unused __attribute__ ((__unused__))
-#else
-#define klib_unused
-#endif
-#endif /* klib_unused */
-
-#ifdef __cplusplus
-extern "C" {
-#endif
-
-// Use our own drand48() symbol (used by ks_shuffle) to avoid portability
-// problems on Windows.  Don't include htslib/hts_os.h for this as it
-// may not get on with older attempts to fix this in code that includes
-// this file.
-extern double hts_drand48(void);
-
-typedef struct {
-	void *left, *right;
-	int depth;
-} ks_isort_stack_t;
-
-#define KSORT_SWAP(type_t, a, b) { register type_t t=(a); (a)=(b); (b)=t; }
-
-#define KSORT_INIT(name, type_t, __sort_lt)	KSORT_INIT_(_ ## name, , type_t, __sort_lt)
-#define KSORT_INIT_STATIC(name, type_t, __sort_lt)	KSORT_INIT_(_ ## name, static klib_unused, type_t, __sort_lt)
-#define KSORT_INIT2(name, SCOPE, type_t, __sort_lt)	KSORT_INIT_(_ ## name, SCOPE, type_t, __sort_lt)
-
-#define KSORT_INIT_(name, SCOPE, type_t, __sort_lt)						\
-	SCOPE int ks_mergesort##name(size_t n, type_t array[], type_t temp[]) \
-	{																	\
-		type_t *a2[2], *a, *b;											\
-		int curr, shift;												\
-																		\
-		a2[0] = array;													\
-		a2[1] = temp? temp : (type_t*)malloc(sizeof(type_t) * n);		\
-		for (curr = 0, shift = 0; (1ul<<shift) < n; ++shift) {			\
-			a = a2[curr]; b = a2[1-curr];								\
-			if (shift == 0) {											\
-				type_t *p = b, *i, *eb = a + n;							\
-				for (i = a; i < eb; i += 2) {							\
-					if (i == eb - 1) *p++ = *i;							\
-					else {												\
-						if (__sort_lt(*(i+1), *i)) {					\
-							*p++ = *(i+1); *p++ = *i;					\
-						} else {										\
-							*p++ = *i; *p++ = *(i+1);					\
-						}												\
-					}													\
-				}														\
-			} else {													\
-				size_t i, step = 1ul<<shift;							\
-				for (i = 0; i < n; i += step<<1) {						\
-					type_t *p, *j, *k, *ea, *eb;						\
-					if (n < i + step) {									\
-						ea = a + n; eb = a;								\
-					} else {											\
-						ea = a + i + step;								\
-						eb = a + (n < i + (step<<1)? n : i + (step<<1)); \
-					}													\
-					j = a + i; k = a + i + step; p = b + i;				\
-					while (j < ea && k < eb) {							\
-						if (__sort_lt(*k, *j)) *p++ = *k++;				\
-						else *p++ = *j++;								\
-					}													\
-					while (j < ea) *p++ = *j++;							\
-					while (k < eb) *p++ = *k++;							\
-				}														\
-			}															\
-			curr = 1 - curr;											\
-		}																\
-		if (curr == 1) {												\
-			type_t *p = a2[0], *i = a2[1], *eb = array + n;				\
-			for (; p < eb; ++i) *p++ = *i;								\
-		}																\
-		if (temp == 0) free(a2[1]);										\
-		return 0;															\
-	}																	\
-	SCOPE void ks_heapadjust##name(size_t i, size_t n, type_t l[])		\
-	{																	\
-		size_t k = i;													\
-		type_t tmp = l[i];												\
-		while ((k = (k << 1) + 1) < n) {								\
-			if (k != n - 1 && __sort_lt(l[k], l[k+1])) ++k;				\
-			if (__sort_lt(l[k], tmp)) break;							\
-			l[i] = l[k]; i = k;											\
-		}																\
-		l[i] = tmp;														\
-	}																	\
-	SCOPE void ks_heapmake##name(size_t lsize, type_t l[])				\
-	{																	\
-		size_t i;														\
-		for (i = (lsize >> 1) - 1; i != (size_t)(-1); --i)				\
-			ks_heapadjust##name(i, lsize, l);							\
-	}																	\
-	SCOPE void ks_heapsort##name(size_t lsize, type_t l[])				\
-	{																	\
-		size_t i;														\
-		for (i = lsize - 1; i > 0; --i) {								\
-			type_t tmp;													\
-			tmp = *l; *l = l[i]; l[i] = tmp; ks_heapadjust##name(0, i, l); \
-		}																\
-	}																	\
-	static inline void __ks_insertsort##name(type_t *s, type_t *t)		\
-	{																	\
-		type_t *i, *j, swap_tmp;										\
-		for (i = s + 1; i < t; ++i)										\
-			for (j = i; j > s && __sort_lt(*j, *(j-1)); --j) {			\
-				swap_tmp = *j; *j = *(j-1); *(j-1) = swap_tmp;			\
-			}															\
-	}																	\
-	SCOPE void ks_combsort##name(size_t n, type_t a[])					\
-	{																	\
-		const double shrink_factor = 1.2473309501039786540366528676643; \
-		int do_swap;													\
-		size_t gap = n;													\
-		type_t tmp, *i, *j;												\
-		do {															\
-			if (gap > 2) {												\
-				gap = (size_t)(gap / shrink_factor);					\
-				if (gap == 9 || gap == 10) gap = 11;					\
-			}															\
-			do_swap = 0;												\
-			for (i = a; i < a + n - gap; ++i) {							\
-				j = i + gap;											\
-				if (__sort_lt(*j, *i)) {								\
-					tmp = *i; *i = *j; *j = tmp;						\
-					do_swap = 1;										\
-				}														\
-			}															\
-		} while (do_swap || gap > 2);									\
-		if (gap != 1) __ks_insertsort##name(a, a + n);					\
-	}																	\
-	SCOPE int ks_introsort##name(size_t n, type_t a[])					\
-	{																	\
-		int d;															\
-		ks_isort_stack_t *top, *stack;									\
-		type_t rp, swap_tmp;											\
-		type_t *s, *t, *i, *j, *k;										\
-																		\
-		if (n < 1) return 0;												\
-		else if (n == 2) {												\
-			if (__sort_lt(a[1], a[0])) { swap_tmp = a[0]; a[0] = a[1]; a[1] = swap_tmp; } \
-			return 0;														\
-		}																\
-		for (d = 2; 1ul<<d < n; ++d);									\
-		stack = (ks_isort_stack_t*)malloc(sizeof(ks_isort_stack_t) * ((sizeof(size_t)*d)+2)); \
-		top = stack; s = a; t = a + (n-1); d <<= 1;						\
-		while (1) {														\
-			if (s < t) {												\
-				if (--d == 0) {											\
-					ks_combsort##name(t - s + 1, s);					\
-					t = s;												\
-					continue;											\
-				}														\
-				i = s; j = t; k = i + ((j-i)>>1) + 1;					\
-				if (__sort_lt(*k, *i)) {								\
-					if (__sort_lt(*k, *j)) k = j;						\
-				} else k = __sort_lt(*j, *i)? i : j;					\
-				rp = *k;												\
-				if (k != t) { swap_tmp = *k; *k = *t; *t = swap_tmp; }	\
-				for (;;) {												\
-					do ++i; while (__sort_lt(*i, rp));					\
-					do --j; while (i <= j && __sort_lt(rp, *j));		\
-					if (j <= i) break;									\
-					swap_tmp = *i; *i = *j; *j = swap_tmp;				\
-				}														\
-				swap_tmp = *i; *i = *t; *t = swap_tmp;					\
-				if (i-s > t-i) {										\
-					if (i-s > 16) { top->left = s; top->right = i-1; top->depth = d; ++top; } \
-					s = t-i > 16? i+1 : t;								\
-				} else {												\
-					if (t-i > 16) { top->left = i+1; top->right = t; top->depth = d; ++top; } \
-					t = i-s > 16? i-1 : s;								\
-				}														\
-			} else {													\
-				if (top == stack) {										\
-					free(stack);										\
-					__ks_insertsort##name(a, a+n);						\
-					return 0;												\
-				} else { --top; s = (type_t*)top->left; t = (type_t*)top->right; d = top->depth; } \
-			}															\
-		}																\
-		return 0;															\
-	}																	\
-	/* This function is adapted from: http://ndevilla.free.fr/median/ */ \
-	/* 0 <= kk < n */													\
-	SCOPE type_t ks_ksmall##name(size_t n, type_t arr[], size_t kk)		\
-	{																	\
-		type_t *low, *high, *k, *ll, *hh, *mid;							\
-		low = arr; high = arr + n - 1; k = arr + kk;					\
-		for (;;) {														\
-			if (high <= low) return *k;									\
-			if (high == low + 1) {										\
-				if (__sort_lt(*high, *low)) KSORT_SWAP(type_t, *low, *high); \
-				return *k;												\
-			}															\
-			mid = low + (high - low) / 2;								\
-			if (__sort_lt(*high, *mid)) KSORT_SWAP(type_t, *mid, *high); \
-			if (__sort_lt(*high, *low)) KSORT_SWAP(type_t, *low, *high); \
-			if (__sort_lt(*low, *mid)) KSORT_SWAP(type_t, *mid, *low);	\
-			KSORT_SWAP(type_t, *mid, *(low+1));							\
-			ll = low + 1; hh = high;									\
-			for (;;) {													\
-				do ++ll; while (__sort_lt(*ll, *low));					\
-				do --hh; while (__sort_lt(*low, *hh));					\
-				if (hh < ll) break;										\
-				KSORT_SWAP(type_t, *ll, *hh);							\
-			}															\
-			KSORT_SWAP(type_t, *low, *hh);								\
-			if (hh <= k) low = ll;										\
-			if (hh >= k) high = hh - 1;									\
-		}																\
-	}																	\
-	SCOPE void ks_shuffle##name(size_t n, type_t a[])					\
-	{																	\
-		int i, j;														\
-		for (i = n; i > 1; --i) {										\
-			type_t tmp;													\
-			j = (int)(hts_drand48() * i);								\
-			tmp = a[j]; a[j] = a[i-1]; a[i-1] = tmp;					\
-		}																\
-	}
-
-#define ks_mergesort(name, n, a, t) ks_mergesort_##name(n, a, t)
-#define ks_introsort(name, n, a) ks_introsort_##name(n, a)
-#define ks_combsort(name, n, a) ks_combsort_##name(n, a)
-#define ks_heapsort(name, n, a) ks_heapsort_##name(n, a)
-#define ks_heapmake(name, n, a) ks_heapmake_##name(n, a)
-#define ks_heapadjust(name, i, n, a) ks_heapadjust_##name(i, n, a)
-#define ks_ksmall(name, n, a, k) ks_ksmall_##name(n, a, k)
-#define ks_shuffle(name, n, a) ks_shuffle_##name(n, a)
-
-#define ks_lt_generic(a, b) ((a) < (b))
-#define ks_lt_str(a, b) (strcmp((a), (b)) < 0)
-
-typedef const char *ksstr_t;
-
-#define KSORT_INIT_GENERIC(type_t) KSORT_INIT_(_ ## type_t, , type_t, ks_lt_generic)
-#define KSORT_INIT_STR KSORT_INIT(str, ksstr_t, ks_lt_str)
-
-#define KSORT_INIT_STATIC_GENERIC(type_t) KSORT_INIT_(_ ## type_t, static klib_unused, type_t, ks_lt_generic)
-#define KSORT_INIT_STATIC_STR KSORT_INIT_STATIC(str, ksstr_t, ks_lt_str)
-
-#define KSORT_INIT2_GENERIC(type_t, SCOPE) KSORT_INIT_(_ ## type_t, SCOPE, type_t, ks_lt_generic)
-#define KSORT_INIT2_STR KSORT_INIT2(str, SCOPE, ksstr_t, ks_lt_str)
-
-#ifdef __cplusplus
-}
-#endif
-
-#endif
diff -ruN stringtie.orig/htslib/htslib/kstring.h stringtie/htslib/htslib/kstring.h
--- stringtie.orig/htslib/htslib/kstring.h	2024-02-28 13:57:39.704579460 +0100
+++ stringtie/htslib/htslib/kstring.h	1970-01-01 01:00:00.000000000 +0100
@@ -1,399 +0,0 @@
-/* The MIT License
-
-   Copyright (C) 2011 by Attractive Chaos <attractor@live.co.uk>
-   Copyright (C) 2013-2014, 2016, 2018-2020 Genome Research Ltd.
-
-   Permission is hereby granted, free of charge, to any person obtaining
-   a copy of this software and associated documentation files (the
-   "Software"), to deal in the Software without restriction, including
-   without limitation the rights to use, copy, modify, merge, publish,
-   distribute, sublicense, and/or sell copies of the Software, and to
-   permit persons to whom the Software is furnished to do so, subject to
-   the following conditions:
-
-   The above copyright notice and this permission notice shall be
-   included in all copies or substantial portions of the Software.
-
-   THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
-   EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
-   MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
-   NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS
-   BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
-   ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
-   CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
-   SOFTWARE.
-*/
-
-#ifndef KSTRING_H
-#define KSTRING_H
-
-#include <stdlib.h>
-#include <string.h>
-#include <stdarg.h>
-#include <stdint.h>
-#include <stdio.h>
-#include <limits.h>
-#include <errno.h>
-#include <sys/types.h>
-
-#include "hts_defs.h"
-#include "kroundup.h"
-
-#if defined __GNUC__ && (__GNUC__ > 2 || (__GNUC__ == 2 && __GNUC_MINOR__ > 4))
-#ifdef __MINGW_PRINTF_FORMAT
-#define KS_ATTR_PRINTF(fmt, arg) __attribute__((__format__ (__MINGW_PRINTF_FORMAT, fmt, arg)))
-#else
-#define KS_ATTR_PRINTF(fmt, arg) __attribute__((__format__ (__printf__, fmt, arg)))
-#endif // __MINGW_PRINTF_FORMAT
-#else
-#define KS_ATTR_PRINTF(fmt, arg)
-#endif
-
-#ifndef HAVE___BUILTIN_CLZ
-#if defined __GNUC__ && (__GNUC__ > 3 || (__GNUC__ == 3 && __GNUC_MINOR__ >= 4))
-#define HAVE___BUILTIN_CLZ 1
-#endif
-#endif
-
-/* kstring_t is a simple non-opaque type whose fields are likely to be
- * used directly by user code (but see also ks_str() and ks_len() below).
- * A kstring_t object is initialised by either of
- *       kstring_t str = KS_INITIALIZE;
- *       kstring_t str; ...; ks_initialize(&str);
- * and either ownership of the underlying buffer should be given away before
- * the object disappears (see ks_release() below) or the kstring_t should be
- * destroyed with  ks_free(&str) or free(str.s) */
-#ifndef KSTRING_T
-#define KSTRING_T kstring_t
-typedef struct kstring_t {
-	size_t l, m;
-	char *s;
-} kstring_t;
-#endif
-
-typedef struct ks_tokaux_t {
-	uint64_t tab[4];
-	int sep, finished;
-	const char *p; // end of the current token
-} ks_tokaux_t;
-
-#ifdef __cplusplus
-extern "C" {
-#endif
-
-    HTSLIB_EXPORT
-	int kvsprintf(kstring_t *s, const char *fmt, va_list ap) KS_ATTR_PRINTF(2,0);
-
-    HTSLIB_EXPORT
-	int ksprintf(kstring_t *s, const char *fmt, ...) KS_ATTR_PRINTF(2,3);
-
-    HTSLIB_EXPORT
-    int kputd(double d, kstring_t *s); // custom %g only handler
-
-    HTSLIB_EXPORT
-	int ksplit_core(char *s, int delimiter, int *_max, int **_offsets);
-
-    HTSLIB_EXPORT
-	char *kstrstr(const char *str, const char *pat, int **_prep);
-
-    HTSLIB_EXPORT
-	char *kstrnstr(const char *str, const char *pat, int n, int **_prep);
-
-    HTSLIB_EXPORT
-	void *kmemmem(const void *_str, int n, const void *_pat, int m, int **_prep);
-
-	/* kstrtok() is similar to strtok_r() except that str is not
-	 * modified and both str and sep can be NULL. For efficiency, it is
-	 * actually recommended to set both to NULL in the subsequent calls
-	 * if sep is not changed. */
-    HTSLIB_EXPORT
-	char *kstrtok(const char *str, const char *sep, ks_tokaux_t *aux);
-
-    /* kgetline() uses the supplied fgets()-like function to read a "\n"-
-     * or "\r\n"-terminated line from fp.  The line read is appended to the
-     * kstring without its terminator and 0 is returned; EOF is returned at
-     * EOF or on error (determined by querying fp, as per fgets()). */
-    typedef char *kgets_func(char *, int, void *);
-    HTSLIB_EXPORT
-    int kgetline(kstring_t *s, kgets_func *fgets_fn, void *fp);
-
-    /* kgetline2() uses the supplied hgetln()-like function to read a "\n"-
-     * or "\r\n"-terminated line from fp.  The line read is appended to the
-     * ksring without its terminator and 0 is returned; EOF is returned at
-     * EOF or on error (determined by querying fp, as per fgets()). */
-    typedef ssize_t kgets_func2(char *, size_t, void *);
-    HTSLIB_EXPORT
-    int kgetline2(kstring_t *s, kgets_func2 *fgets_fn, void *fp);
-
-#ifdef __cplusplus
-}
-#endif
-
-/// kstring initializer for structure assignment
-#define KS_INITIALIZE { 0, 0, NULL }
-
-/// kstring initializer for pointers
-/**
-   @note Not to be used if the buffer has been allocated.  Use ks_release()
-   or ks_clear() instead.
-*/
-
-static inline void ks_initialize(kstring_t *s)
-{
-    s->l = s->m = 0;
-    s->s = NULL;
-}
-
-/// Resize a kstring to a given capacity
-static inline int ks_resize(kstring_t *s, size_t size)
-{
-	if (s->m < size) {
-	    char *tmp;
-	    size = (size > (SIZE_MAX>>2)) ? size : size + (size >> 1);
-	    tmp = (char*)realloc(s->s, size);
-	    if (!tmp)
-	        return -1;
-	    s->s = tmp;
-	    s->m = size;
-	}
-	return 0;
-}
-
-/// Increase kstring capacity by a given number of bytes
-static inline int ks_expand(kstring_t *s, size_t expansion)
-{
-    size_t new_size = s->l + expansion;
-
-    if (new_size < s->l) // Overflow check
-        return -1;
-    return ks_resize(s, new_size);
-}
-
-/// Returns the kstring buffer
-static inline char *ks_str(kstring_t *s)
-{
-	return s->s;
-}
-
-/// Returns the kstring buffer, or an empty string if l == 0
-/**
- * Unlike ks_str(), this function will never return NULL.  If the kstring is
- * empty it will return a read-only empty string.  As the returned value
- * may be read-only, the caller should not attempt to modify it.
- */
-static inline const char *ks_c_str(kstring_t *s)
-{
-    return s->l && s->s ? s->s : "";
-}
-
-static inline size_t ks_len(kstring_t *s)
-{
-	return s->l;
-}
-
-/// Reset kstring length to zero
-/**
-   @return The kstring itself
-
-   Example use: kputsn(string, len, ks_clear(s))
-*/
-static inline kstring_t *ks_clear(kstring_t *s)
-{
-    s->l = 0;
-    return s;
-}
-
-// Give ownership of the underlying buffer away to something else (making
-// that something else responsible for freeing it), leaving the kstring_t
-// empty and ready to be used again, or ready to go out of scope without
-// needing  free(str.s)  to prevent a memory leak.
-static inline char *ks_release(kstring_t *s)
-{
-	char *ss = s->s;
-	s->l = s->m = 0;
-	s->s = NULL;
-	return ss;
-}
-
-/// Safely free the underlying buffer in a kstring.
-static inline void ks_free(kstring_t *s)
-{
-    if (s) {
-        free(s->s);
-        ks_initialize(s);
-    }
-}
-
-static inline int kputsn(const char *p, size_t l, kstring_t *s)
-{
-	size_t new_sz = s->l + l + 2;
-	if (new_sz <= s->l || ks_resize(s, new_sz) < 0)
-		return EOF;
-	memcpy(s->s + s->l, p, l);
-	s->l += l;
-	s->s[s->l] = 0;
-	return l;
-}
-
-static inline int kputs(const char *p, kstring_t *s)
-{
-	if (!p) { errno = EFAULT; return -1; }
-	return kputsn(p, strlen(p), s);
-}
-
-static inline int kputc(int c, kstring_t *s)
-{
-	if (ks_resize(s, s->l + 2) < 0)
-		return EOF;
-	s->s[s->l++] = c;
-	s->s[s->l] = 0;
-	return (unsigned char)c;
-}
-
-static inline int kputc_(int c, kstring_t *s)
-{
-	if (ks_resize(s, s->l + 1) < 0)
-		return EOF;
-	s->s[s->l++] = c;
-	return 1;
-}
-
-static inline int kputsn_(const void *p, size_t l, kstring_t *s)
-{
-	size_t new_sz = s->l + l;
-	if (new_sz < s->l || ks_resize(s, new_sz ? new_sz : 1) < 0)
-		return EOF;
-	memcpy(s->s + s->l, p, l);
-	s->l += l;
-	return l;
-}
-
-static inline int kputuw(unsigned x, kstring_t *s)
-{
-#if HAVE___BUILTIN_CLZ && UINT_MAX == 4294967295U
-    static const unsigned int kputuw_num_digits[32] = {
-        10, 10, 10,  9,  9,  9,  8,  8,
-        8,   7,  7,  7,  7,  6,  6,  6,
-        5,   5,  5,  4,  4,  4,  4,  3,
-        3,   3,  2,  2,  2,  1,  1,  1
-    };
-    static const unsigned int kputuw_thresholds[32] = {
-        0,        0, 1000000000U, 0,       0, 100000000U,   0,      0,
-        10000000, 0,          0,  0, 1000000,         0,    0, 100000,
-        0,        0,      10000,  0,       0,         0, 1000,      0,
-        0,      100,          0,  0,      10,         0,    0,      0
-    };
-#else
-    uint64_t m;
-#endif
-    static const char kputuw_dig2r[] =
-        "00010203040506070809"
-        "10111213141516171819"
-        "20212223242526272829"
-        "30313233343536373839"
-        "40414243444546474849"
-        "50515253545556575859"
-        "60616263646566676869"
-        "70717273747576777879"
-        "80818283848586878889"
-        "90919293949596979899";
-    unsigned int l, j;
-    char *cp;
-
-    // Trivial case - also prevents __builtin_clz(0), which is undefined
-    if (x < 10) {
-        if (ks_resize(s, s->l + 2) < 0)
-            return EOF;
-        s->s[s->l++] = '0'+x;
-        s->s[s->l] = 0;
-        return 0;
-    }
-
-    // Find out how many digits are to be printed.
-#if HAVE___BUILTIN_CLZ && UINT_MAX == 4294967295U
-    /*
-     * Table method - should be quick if clz can be done in hardware.
-     * Find the most significant bit of the value to print and look
-     * up in a table to find out how many decimal digits are needed.
-     * This number needs to be adjusted by 1 for cases where the decimal
-     * length could vary for a given number of bits (for example,
-     * a four bit number could be between 8 and 15).
-     */
-
-    l = __builtin_clz(x);
-    l = kputuw_num_digits[l] - (x < kputuw_thresholds[l]);
-#else
-    // Fallback for when clz is not available
-    m = 1;
-    l = 0;
-    do {
-        l++;
-        m *= 10;
-    } while (x >= m);
-#endif
-
-    if (ks_resize(s, s->l + l + 2) < 0)
-        return EOF;
-
-    // Add digits two at a time
-    j = l;
-    cp = s->s + s->l;
-    while (x >= 10) {
-        const char *d = &kputuw_dig2r[2*(x%100)];
-        x /= 100;
-        memcpy(&cp[j-=2], d, 2);
-    }
-
-    // Last one (if necessary).  We know that x < 10 by now.
-    if (j == 1)
-        cp[0] = x + '0';
-
-    s->l += l;
-    s->s[s->l] = 0;
-    return 0;
-}
-
-static inline int kputw(int c, kstring_t *s)
-{
-    unsigned int x = c;
-    if (c < 0) {
-        x = -x;
-        if (ks_resize(s, s->l + 3) < 0)
-            return EOF;
-        s->s[s->l++] = '-';
-    }
-
-    return kputuw(x, s);
-}
-
-static inline int kputll(long long c, kstring_t *s)
-{
-	char buf[32];
-	int i, l = 0;
-	unsigned long long x = c;
-	if (c < 0) x = -x;
-	do { buf[l++] = x%10 + '0'; x /= 10; } while (x > 0);
-	if (c < 0) buf[l++] = '-';
-	if (ks_resize(s, s->l + l + 2) < 0)
-		return EOF;
-	for (i = l - 1; i >= 0; --i) s->s[s->l++] = buf[i];
-	s->s[s->l] = 0;
-	return 0;
-}
-
-static inline int kputl(long c, kstring_t *s) {
-    return kputll(c, s);
-}
-
-/*
- * Returns 's' split by delimiter, with *n being the number of components;
- *         NULL on failure.
- */
-static inline int *ksplit(kstring_t *s, int delimiter, int *n)
-{
-	int max = 0, *offsets = 0;
-	*n = ksplit_core(s->s, delimiter, &max, &offsets);
-	return offsets;
-}
-
-#endif
diff -ruN stringtie.orig/htslib/htslib/regidx.h stringtie/htslib/htslib/regidx.h
--- stringtie.orig/htslib/htslib/regidx.h	2024-02-28 13:57:39.704579460 +0100
+++ stringtie/htslib/htslib/regidx.h	1970-01-01 01:00:00.000000000 +0100
@@ -1,242 +0,0 @@
-/// @file htslib/regidx.h
-/// Region indexing.
-/*
-    Copyright (C) 2014-2019 Genome Research Ltd.
-
-    Author: Petr Danecek <pd3@sanger.ac.uk>
-
-    Permission is hereby granted, free of charge, to any person obtaining a copy
-    of this software and associated documentation files (the "Software"), to deal
-    in the Software without restriction, including without limitation the rights
-    to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
-    copies of the Software, and to permit persons to whom the Software is
-    furnished to do so, subject to the following conditions:
-
-    The above copyright notice and this permission notice shall be included in
-    all copies or substantial portions of the Software.
-
-    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
-    IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
-    FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
-    AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
-    LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
-    OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
-    THE SOFTWARE.
-*/
-
-/*
-    Region indexing with an optional payload.
-
-    Example of usage:
-
-        // Init the parser and print regions. In this example the payload is a
-        // pointer to a string. For the description of parse_custom and
-        // free_custom functions, see regidx_parse_f and regidx_free_f below,
-        // and for working example see test/test-regidx.c.
-        regidx_t *idx = regidx_init(in_fname,parse_custom,free_custom,sizeof(char*),NULL);
-
-        // Query overlap with chr:beg-end (beg,end are 1-based coordinates)
-        regitr_t *itr = regitr_init(idx);
-        if ( regidx_overlap(idx, chr,beg-1,end-1, itr) ) printf("There is an overlap!\n");
-
-        while ( regitr_overlap(itr) )
-        {
-            printf("[%"PRIhts_pos",%"PRIhts_pos"] overlaps with [%"PRIhts_pos",%"PRIhts_pos"], payload=%s\n",
-                   beg, end, itr->beg+1, itr->end+1, regitr_payload(itr,char*));
-        }
-
-        regidx_destroy(idx);
-        regitr_destroy(itr);
-
-
-    Another example, loop over all regions:
-
-        regidx_t *idx = regidx_init(in_fname,NULL,NULL,0,NULL);
-        regitr_t *itr = regitr_init(idx);
-
-        while ( regitr_loop(itr) )
-            printf("chr=%s  beg=%d  end=%d\n", itr->seq, itr->beg+1, itr->end+1);
-
-        regidx_destroy(idx);
-        regitr_destroy(itr);
-*/
-
-#ifndef HTSLIB_REGIDX_H
-#define HTSLIB_REGIDX_H
-
-#include "hts.h"
-
-#ifdef __cplusplus
-extern "C" {
-#endif
-
-// maximum regidx position (0-based).  Used to represent the end point of
-// regions which do not explicitly set one.  regidx_push() also limits
-// positions passed to it to be no bigger than this.
-
-// Limit is set to ensure some internal values used by regidx keep within 32
-// bits and to stop the index from getting too big.
-
-#define REGIDX_MAX (1ULL << 35)
-
-typedef struct regidx_t regidx_t;
-typedef struct regitr_t
-{
-    hts_pos_t beg,end;
-    void *payload;
-    char *seq;
-    void *itr;
-}
-regitr_t;
-
-#define regitr_payload(itr,type_t) (*((type_t*)(itr)->payload))
-
-// Old API for backwards compatibility
-#define REGITR_START(itr) (itr).beg
-#define REGITR_END(itr)   (itr).end
-#define REGITR_PAYLOAD(itr,type_t) ((type_t*)(itr).payload)
-#define REGITR_OVERLAP(itr,from,to) regidx_overlap((itr));
-
-/*
- *  regidx_parse_f - Function to parse one input line, such as regidx_parse_bed
- *  or regidx_parse_tab below. The function is expected to set `chr_from` and
- *  `chr_to` to point to first and last character of chromosome name and set
- *  coordinates `beg` and `end` (0-based, inclusive). If regidx_init() was
- *  called with non-zero payload_size, the `payload` points to a memory
- *  location of the payload_size and `usr` is the data passed to regidx_init().
- *  Any memory allocated by the function will be freed by regidx_free_f called
- *  by regidx_destroy().
- *
- *  Return value: 0 on success, -1 to skip a record, -2 on fatal error.
- */
-typedef int  (*regidx_parse_f)(const char *line, char **chr_beg, char **chr_end, hts_pos_t *beg, hts_pos_t *end, void *payload, void *usr);
-typedef void (*regidx_free_f)(void *payload);
-
-/*
- *  A note about the parsers:
- *      - leading spaces are ignored
- *      - lines starting with "#" are ignored
- */
-HTSLIB_EXPORT
-int regidx_parse_bed(const char*,char**,char**,hts_pos_t*,hts_pos_t*,void*,void*);   // CHROM or whitespace-sepatated CHROM,FROM,TO (0-based,right-open)
-HTSLIB_EXPORT
-int regidx_parse_tab(const char*,char**,char**,hts_pos_t*,hts_pos_t*,void*,void*);   // CHROM or whitespace-separated CHROM,POS (1-based, inclusive)
-HTSLIB_EXPORT
-int regidx_parse_reg(const char*,char**,char**,hts_pos_t*,hts_pos_t*,void*,void*);   // CHROM, CHROM:POS, CHROM:FROM-TO, CHROM:FROM- (1-based, inclusive)
-HTSLIB_EXPORT
-int regidx_parse_vcf(const char*,char**,char**,hts_pos_t*,hts_pos_t*,void*,void*);
-
-/*
- *  regidx_init() - creates new index
- *  regidx_init_string() - creates new index, from a string rather than from a file
- *
- *  @param fname:  input file name or NULL if regions will be added one-by-one via regidx_insert()
- *  @param parsef: regidx_parse_bed, regidx_parse_tab or see description of regidx_parse_f. If NULL,
- *                 the format will be autodected, currently either regidx_parse_tab (the default) or
- *                 regidx_parse_bed (file must be named 'bed' or 'bed.gz') will be used. Note that
- *                 the exact autodetection algorithm will change.
- *  @param freef:  NULL or see description of regidx_parse_f
- *  @param payload_size: 0 with regidx_parse_bed, regidx_parse_tab or see regidx_parse_f
- *  @param usr:    optional user data passed to regidx_parse_f
- *
- *  Returns index on success or NULL on error.
- *
- *  The regidx_t index struct returned by a successful call should be freed
- *  via regidx_destroy() when it is no longer needed.
- */
-HTSLIB_EXPORT
-regidx_t *regidx_init(const char *fname, regidx_parse_f parsef, regidx_free_f freef, size_t payload_size, void *usr);
-HTSLIB_EXPORT
-regidx_t *regidx_init_string(const char *string, regidx_parse_f parsef, regidx_free_f freef, size_t payload_size, void *usr);
-
-/*
- *  regidx_destroy() - free memory allocated by regidx_init
- */
-HTSLIB_EXPORT
-void regidx_destroy(regidx_t *idx);
-
-/*
- *  regidx_overlap() - check overlap of the location chr:from-to with regions
- *  @param beg,end:     0-based start, end coordinate (inclusive)
- *  @param itr:         pointer to iterator, can be NULL if regidx_loop not needed
- *
- *  Returns 0 if there is no overlap or 1 if overlap is found. The overlapping
- *  regions can be iterated as shown in the example above.
- */
-HTSLIB_EXPORT
-int regidx_overlap(regidx_t *idx, const char *chr, hts_pos_t beg, hts_pos_t end, regitr_t *itr);
-
-/*
- *  regidx_insert() - add a new region.
- *  regidx_insert_list() - add new regions from a list
- *  regidx_push() - low level insertion of a new region
- *
- *  Returns 0 on success or -1 on error.
- */
-HTSLIB_EXPORT
-int regidx_insert(regidx_t *idx, char *line);
-HTSLIB_EXPORT
-int regidx_insert_list(regidx_t *idx, char *line, char delim);
-HTSLIB_EXPORT
-int regidx_push(regidx_t *idx, char *chr_beg, char *chr_end, hts_pos_t beg, hts_pos_t end, void *payload);
-
-/*
- *  regidx_seq_names() - return list of all sequence names
- */
-HTSLIB_EXPORT
-char **regidx_seq_names(regidx_t *idx, int *n);
-
-/*
- *  regidx_seq_nregs() - number of regions
- *  regidx_nregs()  - total number of regions
- */
-HTSLIB_EXPORT
-int regidx_seq_nregs(regidx_t *idx, const char *seq);
-
-HTSLIB_EXPORT
-int regidx_nregs(regidx_t *idx);
-
-/*
- *  regitr_init() - initialize an iterator. The idx parameter is required only
- *                  with regitr_loop. If only regitr_overlap is called, NULL
- *                  can be given.
- *
- *                  The regitr_t struct returned by a successful regitr_init()
- *                  call should be freed via regitr_destroy() when it is no
- *                  longer needed.
- *
- *  regitr_reset() - initialize an iterator for a repeated regitr_loop cycle.
- *                  Not required with regitr_overlap.
- */
-HTSLIB_EXPORT
-regitr_t *regitr_init(regidx_t *idx);
-HTSLIB_EXPORT
-void regitr_destroy(regitr_t *itr);
-HTSLIB_EXPORT
-void regitr_reset(regidx_t *idx, regitr_t *itr);
-
-/*
- *  regitr_overlap() - next overlapping region
- *  Returns 0 when done or 1 when itr is set to next region
- */
-HTSLIB_EXPORT
-int regitr_overlap(regitr_t *itr);
-
-/*
- *  regitr_loop() - loop over all regions
- *  Returns 0 when done or 1 when itr is set to next region
- */
-HTSLIB_EXPORT
-int regitr_loop(regitr_t *itr);
-
-/*
- *  regitr_copy() - create a copy of an iterator for a repeated iteration with regitr_loop
- */
-HTSLIB_EXPORT
-void regitr_copy(regitr_t *dst, regitr_t *src);
-
-#ifdef __cplusplus
-}
-#endif
-
-#endif
diff -ruN stringtie.orig/htslib/htslib/sam.h stringtie/htslib/htslib/sam.h
--- stringtie.orig/htslib/htslib/sam.h	2024-02-28 13:57:39.704579460 +0100
+++ stringtie/htslib/htslib/sam.h	1970-01-01 01:00:00.000000000 +0100
@@ -1,2081 +0,0 @@
-/// @file htslib/sam.h
-/// High-level SAM/BAM/CRAM sequence file operations.
-/*
-    Copyright (C) 2008, 2009, 2013-2020 Genome Research Ltd.
-    Copyright (C) 2010, 2012, 2013 Broad Institute.
-
-    Author: Heng Li <lh3@sanger.ac.uk>
-
-Permission is hereby granted, free of charge, to any person obtaining a copy
-of this software and associated documentation files (the "Software"), to deal
-in the Software without restriction, including without limitation the rights
-to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
-copies of the Software, and to permit persons to whom the Software is
-furnished to do so, subject to the following conditions:
-
-The above copyright notice and this permission notice shall be included in
-all copies or substantial portions of the Software.
-
-THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
-IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
-FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
-THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
-LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
-FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
-DEALINGS IN THE SOFTWARE.  */
-
-#ifndef HTSLIB_SAM_H
-#define HTSLIB_SAM_H
-
-#include <errno.h>
-#include <stdint.h>
-#include <sys/types.h>
-#include "hts.h"
-#include "hts_endian.h"
-
-#ifdef __cplusplus
-extern "C" {
-#endif
-
-/// Highest SAM format version supported by this library
-#define SAM_FORMAT_VERSION "1.6"
-
-/***************************
- *** SAM/BAM/CRAM header ***
- ***************************/
-
-/*! @typedef
- * @abstract Header extension structure, grouping a collection
- *  of hash tables that contain the parsed header data.
- */
-
-typedef struct sam_hrecs_t sam_hrecs_t;
-
-/*! @typedef
- @abstract Structure for the alignment header.
- @field n_targets   number of reference sequences
- @field l_text      length of the plain text in the header (may be zero if
-                    the header has been edited)
- @field target_len  lengths of the reference sequences
- @field target_name names of the reference sequences
- @field text        plain text (may be NULL if the header has been edited)
- @field sdict       header dictionary
- @field hrecs       pointer to the extended header struct (internal use only)
- @field ref_count   reference count
-
- @note The text and l_text fields are included for backwards compatibility.
- These fields may be set to NULL and zero respectively as a side-effect
- of calling some header API functions.  New code that needs to access the
- header text should use the sam_hdr_str() and sam_hdr_length() functions
- instead of these fields.
- */
-
-typedef struct sam_hdr_t {
-    int32_t n_targets, ignore_sam_err;
-    size_t l_text;
-    uint32_t *target_len;
-    const int8_t *cigar_tab HTS_DEPRECATED("Use bam_cigar_table[] instead");
-    char **target_name;
-    char *text;
-    void *sdict;
-    sam_hrecs_t *hrecs;
-    uint32_t ref_count;
-} sam_hdr_t;
-
-/*! @typedef
- * @abstract Old name for compatibility with existing code.
- */
-typedef sam_hdr_t bam_hdr_t;
-
-/****************************
- *** CIGAR related macros ***
- ****************************/
-
-#define BAM_CMATCH      0
-#define BAM_CINS        1
-#define BAM_CDEL        2
-#define BAM_CREF_SKIP   3
-#define BAM_CSOFT_CLIP  4
-#define BAM_CHARD_CLIP  5
-#define BAM_CPAD        6
-#define BAM_CEQUAL      7
-#define BAM_CDIFF       8
-#define BAM_CBACK       9
-
-#define BAM_CIGAR_STR   "MIDNSHP=XB"
-#define BAM_CIGAR_SHIFT 4
-#define BAM_CIGAR_MASK  0xf
-#define BAM_CIGAR_TYPE  0x3C1A7
-
-/*! @abstract Table for converting a CIGAR operator character to BAM_CMATCH etc.
-Result is operator code or -1. Be sure to cast the index if it is a plain char:
-    int op = bam_cigar_table[(unsigned char) ch];
-*/
-extern const int8_t bam_cigar_table[256];
-
-#define bam_cigar_op(c) ((c)&BAM_CIGAR_MASK)
-#define bam_cigar_oplen(c) ((c)>>BAM_CIGAR_SHIFT)
-// Note that BAM_CIGAR_STR is padded to length 16 bytes below so that
-// the array look-up will not fall off the end.  '?' is chosen as the
-// padding character so it's easy to spot if one is emitted, and will
-// result in a parsing failure (in sam_parse1(), at least) if read.
-#define bam_cigar_opchr(c) (BAM_CIGAR_STR "??????" [bam_cigar_op(c)])
-#define bam_cigar_gen(l, o) ((l)<<BAM_CIGAR_SHIFT|(o))
-
-/* bam_cigar_type returns a bit flag with:
- *   bit 1 set if the cigar operation consumes the query
- *   bit 2 set if the cigar operation consumes the reference
- *
- * For reference, the unobfuscated truth table for this function is:
- * BAM_CIGAR_TYPE  QUERY  REFERENCE
- * --------------------------------
- * BAM_CMATCH      1      1
- * BAM_CINS        1      0
- * BAM_CDEL        0      1
- * BAM_CREF_SKIP   0      1
- * BAM_CSOFT_CLIP  1      0
- * BAM_CHARD_CLIP  0      0
- * BAM_CPAD        0      0
- * BAM_CEQUAL      1      1
- * BAM_CDIFF       1      1
- * BAM_CBACK       0      0
- * --------------------------------
- */
-#define bam_cigar_type(o) (BAM_CIGAR_TYPE>>((o)<<1)&3) // bit 1: consume query; bit 2: consume reference
-
-/*! @abstract the read is paired in sequencing, no matter whether it is mapped in a pair */
-#define BAM_FPAIRED        1
-/*! @abstract the read is mapped in a proper pair */
-#define BAM_FPROPER_PAIR   2
-/*! @abstract the read itself is unmapped; conflictive with BAM_FPROPER_PAIR */
-#define BAM_FUNMAP         4
-/*! @abstract the mate is unmapped */
-#define BAM_FMUNMAP        8
-/*! @abstract the read is mapped to the reverse strand */
-#define BAM_FREVERSE      16
-/*! @abstract the mate is mapped to the reverse strand */
-#define BAM_FMREVERSE     32
-/*! @abstract this is read1 */
-#define BAM_FREAD1        64
-/*! @abstract this is read2 */
-#define BAM_FREAD2       128
-/*! @abstract not primary alignment */
-#define BAM_FSECONDARY   256
-/*! @abstract QC failure */
-#define BAM_FQCFAIL      512
-/*! @abstract optical or PCR duplicate */
-#define BAM_FDUP        1024
-/*! @abstract supplementary alignment */
-#define BAM_FSUPPLEMENTARY 2048
-
-/*************************
- *** Alignment records ***
- *************************/
-
-/*
- * Assumptions made here.  While pos can be 64-bit, no sequence
- * itself is that long, but due to ref skip CIGAR fields it
- * may span more than that.  (CIGAR itself is 28-bit len + 4 bit
- * type, but in theory we can combine multiples together.)
- *
- * Mate position and insert size also need to be 64-bit, but
- * we won't accept more than 32-bit for tid.
- *
- * The bam_core_t structure is the *in memory* layout and not
- * the same as the on-disk format.  64-bit changes here permit
- * SAM to work with very long chromosomes and permit BAM and CRAM
- * to seamlessly update in the future without further API/ABI
- * revisions.
- */
-
-/*! @typedef
- @abstract Structure for core alignment information.
- @field  pos     0-based leftmost coordinate
- @field  tid     chromosome ID, defined by sam_hdr_t
- @field  bin     bin calculated by bam_reg2bin()
- @field  qual    mapping quality
- @field  l_extranul length of extra NULs between qname & cigar (for alignment)
- @field  flag    bitwise flag
- @field  l_qname length of the query name
- @field  n_cigar number of CIGAR operations
- @field  l_qseq  length of the query sequence (read)
- @field  mtid    chromosome ID of next read in template, defined by sam_hdr_t
- @field  mpos    0-based leftmost coordinate of next read in template
- @field  isize   observed template length ("insert size")
- */
-typedef struct bam1_core_t {
-    hts_pos_t pos;
-    int32_t tid;
-    uint16_t bin; // NB: invalid on 64-bit pos
-    uint8_t qual;
-    uint8_t l_extranul;
-    uint16_t flag;
-    uint16_t l_qname;
-    uint32_t n_cigar;
-    int32_t l_qseq;
-    int32_t mtid;
-    hts_pos_t mpos;
-    hts_pos_t isize;
-} bam1_core_t;
-
-/*! @typedef
- @abstract Structure for one alignment.
- @field  core       core information about the alignment
- @field  id
- @field  data       all variable-length data, concatenated; structure: qname-cigar-seq-qual-aux
- @field  l_data     current length of bam1_t::data
- @field  m_data     maximum length of bam1_t::data
- @field  mempolicy  memory handling policy, see bam_set_mempolicy()
-
- @discussion Notes:
-
- 1. The data blob should be accessed using bam_get_qname, bam_get_cigar,
-    bam_get_seq, bam_get_qual and bam_get_aux macros.  These returns pointers
-    to the start of each type of data.
- 2. qname is terminated by one to four NULs, so that the following
-    cigar data is 32-bit aligned; core.l_qname includes these trailing NULs,
-    while core.l_extranul counts the excess NULs (so 0 <= l_extranul <= 3).
- 3. Cigar data is encoded 4 bytes per CIGAR operation.
-    See the bam_cigar_* macros for manipulation.
- 4. seq is nibble-encoded according to bam_nt16_table.
-    See the bam_seqi macro for retrieving individual bases.
- 5. Per base qualilties are stored in the Phred scale with no +33 offset.
-    Ie as per the BAM specification and not the SAM ASCII printable method.
- */
-typedef struct bam1_t {
-    bam1_core_t core;
-    uint64_t id;
-    uint8_t *data;
-    int l_data;
-    uint32_t m_data;
-    uint32_t mempolicy:2, :30 /* Reserved */;
-} bam1_t;
-
-/*! @function
- @abstract  Get whether the query is on the reverse strand
- @param  b  pointer to an alignment
- @return    boolean true if query is on the reverse strand
- */
-#define bam_is_rev(b) (((b)->core.flag&BAM_FREVERSE) != 0)
-/*! @function
- @abstract  Get whether the query's mate is on the reverse strand
- @param  b  pointer to an alignment
- @return    boolean true if query's mate on the reverse strand
- */
-#define bam_is_mrev(b) (((b)->core.flag&BAM_FMREVERSE) != 0)
-/*! @function
- @abstract  Get the name of the query
- @param  b  pointer to an alignment
- @return    pointer to the name string, null terminated
- */
-#define bam_get_qname(b) ((char*)(b)->data)
-/*! @function
- @abstract  Get the CIGAR array
- @param  b  pointer to an alignment
- @return    pointer to the CIGAR array
-
- @discussion In the CIGAR array, each element is a 32-bit integer. The
- lower 4 bits gives a CIGAR operation and the higher 28 bits keep the
- length of a CIGAR.
- */
-#define bam_get_cigar(b) ((uint32_t*)((b)->data + (b)->core.l_qname))
-/*! @function
- @abstract  Get query sequence
- @param  b  pointer to an alignment
- @return    pointer to sequence
-
- @discussion Each base is encoded in 4 bits: 1 for A, 2 for C, 4 for G,
- 8 for T and 15 for N. Two bases are packed in one byte with the base
- at the higher 4 bits having smaller coordinate on the read. It is
- recommended to use bam_seqi() macro to get the base.
- */
-#define bam_get_seq(b)   ((b)->data + ((b)->core.n_cigar<<2) + (b)->core.l_qname)
-/*! @function
- @abstract  Get query quality
- @param  b  pointer to an alignment
- @return    pointer to quality string
- */
-#define bam_get_qual(b)  ((b)->data + ((b)->core.n_cigar<<2) + (b)->core.l_qname + (((b)->core.l_qseq + 1)>>1))
-/*! @function
- @abstract  Get auxiliary data
- @param  b  pointer to an alignment
- @return    pointer to the concatenated auxiliary data
- */
-#define bam_get_aux(b)   ((b)->data + ((b)->core.n_cigar<<2) + (b)->core.l_qname + (((b)->core.l_qseq + 1)>>1) + (b)->core.l_qseq)
-/*! @function
- @abstract  Get length of auxiliary data
- @param  b  pointer to an alignment
- @return    length of the concatenated auxiliary data
- */
-#define bam_get_l_aux(b) ((b)->l_data - ((b)->core.n_cigar<<2) - (b)->core.l_qname - (b)->core.l_qseq - (((b)->core.l_qseq + 1)>>1))
-/*! @function
- @abstract  Get a base on read
- @param  s  Query sequence returned by bam_get_seq()
- @param  i  The i-th position, 0-based
- @return    4-bit integer representing the base.
- */
-#define bam_seqi(s, i) ((s)[(i)>>1] >> ((~(i)&1)<<2) & 0xf)
-/*!
- @abstract  Modifies a single base in the bam structure.
- @param s   Query sequence returned by bam_get_seq()
- @param i   The i-th position, 0-based
- @param b   Base in nt16 nomenclature (see seq_nt16_table)
-*/
-#define bam_set_seqi(s,i,b) ((s)[(i)>>1] = ((s)[(i)>>1] & (0xf0 >> ((~(i)&1)<<2))) | ((b)<<((~(i)&1)<<2)))
-
-/**************************
- *** Exported functions ***
- **************************/
-
-/***************
- *** BAM I/O ***
- ***************/
-
-/* Header */
-
-/// Generates a new unpopulated header structure.
-/*!
- *
- * @return  A valid pointer to new header on success, NULL on failure
- *
- * The sam_hdr_t struct returned by a successful call should be freed
- * via sam_hdr_destroy() when it is no longer needed.
- */
-HTSLIB_EXPORT
-sam_hdr_t *sam_hdr_init(void);
-
-/// Read the header from a BAM compressed file.
-/*!
- * @param fp  File pointer
- * @return    A valid pointer to new header on success, NULL on failure
- *
- * This function only works with BAM files.  It is usually better to use
- * sam_hdr_read(), which works on SAM, BAM and CRAM files.
- *
- * The sam_hdr_t struct returned by a successful call should be freed
- * via sam_hdr_destroy() when it is no longer needed.
- */
-HTSLIB_EXPORT
-sam_hdr_t *bam_hdr_read(BGZF *fp);
-
-/// Writes the header to a BAM file.
-/*!
- * @param fp  File pointer
- * @param h   Header pointer
- * @return    0 on success, -1 on failure
- *
- * This function only works with BAM files.  Use sam_hdr_write() to
- * write in any of the SAM, BAM or CRAM formats.
- */
-HTSLIB_EXPORT
-int bam_hdr_write(BGZF *fp, const sam_hdr_t *h) HTS_RESULT_USED;
-
-/*!
- * Frees the resources associated with a header.
- */
-HTSLIB_EXPORT
-void sam_hdr_destroy(sam_hdr_t *h);
-
-/// Duplicate a header structure.
-/*!
- * @return  A valid pointer to new header on success, NULL on failure
- *
- * The sam_hdr_t struct returned by a successful call should be freed
- * via sam_hdr_destroy() when it is no longer needed.
- */
-HTSLIB_EXPORT
-sam_hdr_t *sam_hdr_dup(const sam_hdr_t *h0);
-
-/*!
- * @abstract Old names for compatibility with existing code.
- */
-static inline sam_hdr_t *bam_hdr_init(void) { return sam_hdr_init(); }
-static inline void bam_hdr_destroy(sam_hdr_t *h) { sam_hdr_destroy(h); }
-static inline sam_hdr_t *bam_hdr_dup(const sam_hdr_t *h0) { return sam_hdr_dup(h0); }
-
-typedef htsFile samFile;
-
-/// Create a header from existing text.
-/*!
- * @param l_text    Length of text
- * @param text      Header text
- * @return A populated sam_hdr_t structure on success; NULL on failure.
- * @note The text field of the returned header will be NULL, and the l_text
- * field will be zero.
- *
- * The sam_hdr_t struct returned by a successful call should be freed
- * via sam_hdr_destroy() when it is no longer needed.
- */
-HTSLIB_EXPORT
-sam_hdr_t *sam_hdr_parse(size_t l_text, const char *text);
-
-/// Read a header from a SAM, BAM or CRAM file.
-/*!
- * @param fp    Pointer to a SAM, BAM or CRAM file handle
- * @return  A populated sam_hdr_t struct on success; NULL on failure.
- *
- * The sam_hdr_t struct returned by a successful call should be freed
- * via sam_hdr_destroy() when it is no longer needed.
- */
-HTSLIB_EXPORT
-sam_hdr_t *sam_hdr_read(samFile *fp);
-
-/// Write a header to a SAM, BAM or CRAM file.
-/*!
- * @param fp    SAM, BAM or CRAM file header
- * @param h     Header structure to write
- * @return  0 on success; -1 on failure
- */
-HTSLIB_EXPORT
-int sam_hdr_write(samFile *fp, const sam_hdr_t *h) HTS_RESULT_USED;
-
-/// Returns the current length of the header text.
-/*!
- * @return  >= 0 on success, SIZE_MAX on failure
- */
-HTSLIB_EXPORT
-size_t sam_hdr_length(sam_hdr_t *h);
-
-/// Returns the text representation of the header.
-/*!
- * @return  valid char pointer on success, NULL on failure
- *
- * The returned string is part of the header structure.  It will remain
- * valid until a call to a header API function causes the string to be
- * invalidated, or the header is destroyed.
- *
- * The caller should not attempt to free or realloc this pointer.
- */
-HTSLIB_EXPORT
-const char *sam_hdr_str(sam_hdr_t *h);
-
-/// Returns the number of references in the header.
-/*!
- * @return  >= 0 on success, -1 on failure
- */
-HTSLIB_EXPORT
-int sam_hdr_nref(const sam_hdr_t *h);
-
-/* ==== Line level methods ==== */
-
-/// Add formatted lines to an existing header.
-/*!
- * @param lines  Full SAM header record, eg "@SQ\tSN:foo\tLN:100", with
- *               optional new-line. If it contains more than 1 line then
- *               multiple lines will be added in order
- * @param len    The maximum length of lines (if an early NUL is not
- *               encountered). len may be 0 if unknown, in which case
- *               lines must be NUL-terminated
- * @return       0 on success, -1 on failure
- *
- * The lines will be appended to the end of the existing header
- * (apart from HD, which always comes first).
- */
-HTSLIB_EXPORT
-int sam_hdr_add_lines(sam_hdr_t *h, const char *lines, size_t len);
-
-/// Adds a single line to an existing header.
-/*!
- * Specify type and one or more key,value pairs, ending with the NULL key.
- * Eg. sam_hdr_add_line(h, "SQ", "ID", "foo", "LN", "100", NULL).
- *
- * @param type  Type of the added line. Eg. "SQ"
- * @return      0 on success, -1 on failure
- *
- * The new line will be added immediately after any others of the same
- * type, or at the end of the existing header if no lines of the
- * given type currently exist.  The exception is HD lines, which always
- * come first.  If an HD line already exists, it will be replaced.
- */
-HTSLIB_EXPORT
-int sam_hdr_add_line(sam_hdr_t *h, const char *type, ...);
-
-/// Returns a complete line of formatted text for a given type and ID.
-/*!
- * @param type      Type of the searched line. Eg. "SQ"
- * @param ID_key    Tag key defining the line. Eg. "SN"
- * @param ID_value  Tag value associated with the key above. Eg. "ref1"
- * @param ks        kstring to hold the result
- * @return          0 on success;
- *                 -1 if no matching line is found
- *                 -2 on other failures
- *
- * Puts a complete line of formatted text for a specific header type/ID
- * combination into @p ks. If ID_key is NULL then it returns the first line of
- * the specified type.
- *
- * Any existing content in @p ks will be overwritten.
- */
-HTSLIB_EXPORT
-int sam_hdr_find_line_id(sam_hdr_t *h, const char *type,
-                      const char *ID_key, const char *ID_val, kstring_t *ks);
-
-/// Returns a complete line of formatted text for a given type and index.
-/*!
- * @param type      Type of the searched line. Eg. "SQ"
- * @param position  Index in lines of this type (zero-based)
- * @param ks        kstring to hold the result
- * @return          0 on success;
- *                 -1 if no matching line is found
- *                 -2 on other failures
- *
- * Puts a complete line of formatted text for a specific line into @p ks.
- * The header line is selected using the @p type and @p position parameters.
- *
- * Any existing content in @p ks will be overwritten.
- */
-HTSLIB_EXPORT
-int sam_hdr_find_line_pos(sam_hdr_t *h, const char *type,
-                          int pos, kstring_t *ks);
-
-/// Remove a line with given type / id from a header
-/*!
- * @param type      Type of the searched line. Eg. "SQ"
- * @param ID_key    Tag key defining the line. Eg. "SN"
- * @param ID_value  Tag value associated with the key above. Eg. "ref1"
- * @return          0 on success, -1 on error
- *
- * Remove a line from the header by specifying a tag:value that uniquely
- * identifies the line, i.e. the @SQ line containing "SN:ref1".
- *
- * \@SQ line is uniquely identified by the SN tag.
- * \@RG line is uniquely identified by the ID tag.
- * \@PG line is uniquely identified by the ID tag.
- * Eg. sam_hdr_remove_line_id(h, "SQ", "SN", "ref1")
- *
- * If no key:value pair is specified, the type MUST be followed by a NULL argument and
- * the first line of the type will be removed, if any.
- * Eg. sam_hdr_remove_line_id(h, "SQ", NULL, NULL)
- *
- * @note Removing \@PG lines is currently unsupported.
- */
-HTSLIB_EXPORT
-int sam_hdr_remove_line_id(sam_hdr_t *h, const char *type, const char *ID_key, const char *ID_value);
-
-/// Remove nth line of a given type from a header
-/*!
- * @param type     Type of the searched line. Eg. "SQ"
- * @param position Index in lines of this type (zero-based). E.g. 3
- * @return         0 on success, -1 on error
- *
- * Remove a line from the header by specifying the position in the type
- * group, i.e. 3rd @SQ line.
- */
-HTSLIB_EXPORT
-int sam_hdr_remove_line_pos(sam_hdr_t *h, const char *type, int position);
-
-/// Add or update tag key,value pairs in a header line.
-/*!
- * @param type      Type of the searched line. Eg. "SQ"
- * @param ID_key    Tag key defining the line. Eg. "SN"
- * @param ID_value  Tag value associated with the key above. Eg. "ref1"
- * @return          0 on success, -1 on error
- *
- * Adds or updates tag key,value pairs in a header line.
- * Eg. for adding M5 tags to @SQ lines or updating sort order for the
- * @HD line.
- *
- * Specify multiple key,value pairs ending in NULL. Eg.
- * sam_hdr_update_line(h, "RG", "ID", "rg1", "DS", "description", "PG", "samtools", NULL)
- *
- * Attempting to update the record name (i.e. @SQ SN or @RG ID) will
- * work as long as the new name is not already in use, however doing this
- * on a file opened for reading may produce unexpected results.
- *
- * Renaming an @RG record in this way will only change the header.  Alignment
- * records written later will not be updated automatically even if they
- * reference the old read group name.
- *
- * Attempting to change an @PG ID tag is not permitted.
- */
-HTSLIB_EXPORT
-int sam_hdr_update_line(sam_hdr_t *h, const char *type,
-        const char *ID_key, const char *ID_value, ...);
-
-/// Remove all lines of a given type from a header, except the one matching an ID
-/*!
- * @param type      Type of the searched line. Eg. "SQ"
- * @param ID_key    Tag key defining the line. Eg. "SN"
- * @param ID_value  Tag value associated with the key above. Eg. "ref1"
- * @return          0 on success, -1 on failure
- *
- * Remove all lines of type <type> from the header, except the one
- * specified by tag:value, i.e. the @SQ line containing "SN:ref1".
- *
- * If no line matches the key:value ID, all lines of the given type are removed.
- * To remove all lines of a given type, use NULL for both ID_key and ID_value.
- */
-HTSLIB_EXPORT
-int sam_hdr_remove_except(sam_hdr_t *h, const char *type, const char *ID_key, const char *ID_value);
-
-/// Remove header lines of a given type, except those in a given ID set
-/*!
- * @param type  Type of the searched line. Eg. "RG"
- * @param id    Tag key defining the line. Eg. "ID"
- * @param rh    Hash set initialised by the caller with the values to be kept.
- *              See description for how to create this. If @p rh is NULL, all
- *              lines of this type will be removed.
- * @return      0 on success, -1 on failure
- *
- * Remove all lines of type @p type from the header, except the ones
- * specified in the hash set @p rh. If @p rh is NULL, all lines of
- * this type will be removed.
- * Declaration of @p rh is done using KHASH_SET_INIT_STR macro. Eg.
- * @code{.c}
- *              #include "htslib/khash.h"
- *              KHASH_SET_INIT_STR(keep)
- *              typedef khash_t(keep) *keephash_t;
- *
- *              void your_method() {
- *                  samFile *sf = sam_open("alignment.bam", "r");
- *                  sam_hdr_t *h = sam_hdr_read(sf);
- *                  keephash_t rh = kh_init(keep);
- *                  int ret = 0;
- *                  kh_put(keep, rh, strdup("chr2"), &ret);
- *                  kh_put(keep, rh, strdup("chr3"), &ret);
- *                  if (sam_hdr_remove_lines(h, "SQ", "SN", rh) == -1)
- *                      fprintf(stderr, "Error removing lines\n");
- *                  khint_t k;
- *                  for (k = 0; k < kh_end(rh); ++k)
- *                     if (kh_exist(rh, k)) free((char*)kh_key(rh, k));
- *                  kh_destroy(keep, rh);
- *                  sam_hdr_destroy(h);
- *                  sam_close(sf);
- *              }
- * @endcode
- *
- */
-HTSLIB_EXPORT
-int sam_hdr_remove_lines(sam_hdr_t *h, const char *type, const char *id, void *rh);
-
-/// Count the number of lines for a given header type
-/*!
- * @param h     BAM header
- * @param type  Header type to count. Eg. "RG"
- * @return  Number of lines of this type on success; -1 on failure
- */
-HTSLIB_EXPORT
-int sam_hdr_count_lines(sam_hdr_t *h, const char *type);
-
-/// Index of the line for the types that have dedicated look-up tables (SQ, RG, PG)
-/*!
- * @param h     BAM header
- * @param type  Type of the searched line. Eg. "RG"
- * @param key   The value of the identifying key. Eg. "rg1"
- * @return  0-based index on success; -1 if line does not exist; -2 on failure
- */
-HTSLIB_EXPORT
-int sam_hdr_line_index(sam_hdr_t *bh, const char *type, const char *key);
-
-/// Id key of the line for the types that have dedicated look-up tables (SQ, RG, PG)
-/*!
- * @param h     BAM header
- * @param type  Type of the searched line. Eg. "RG"
- * @param pos   Zero-based index inside the type group. Eg. 2 (for the third RG line)
- * @return  Valid key string on success; NULL on failure
- */
-HTSLIB_EXPORT
-const char *sam_hdr_line_name(sam_hdr_t *bh, const char *type, int pos);
-
-/* ==== Key:val level methods ==== */
-
-/// Return the value associated with a key for a header line identified by ID_key:ID_val
-/*!
- * @param type      Type of the line to which the tag belongs. Eg. "SQ"
- * @param ID_key    Tag key defining the line. Eg. "SN". Can be NULL, if looking for the first line.
- * @param ID_value  Tag value associated with the key above. Eg. "ref1". Can be NULL, if ID_key is NULL.
- * @param key       Key of the searched tag. Eg. "LN"
- * @param ks        kstring where the value will be written
- * @return          0 on success
- *                 -1 if the requested tag does not exist
- *                 -2 on other errors
- *
- * Looks for a specific key in a single SAM header line and writes the
- * associated value into @p ks.  The header line is selected using the ID_key
- * and ID_value parameters.  Any pre-existing content in @p ks will be
- * overwritten.
- */
-HTSLIB_EXPORT
-int sam_hdr_find_tag_id(sam_hdr_t *h, const char *type, const char *ID_key, const char *ID_value, const char *key, kstring_t *ks);
-
-/// Return the value associated with a key for a header line identified by position
-/*!
- * @param type      Type of the line to which the tag belongs. Eg. "SQ"
- * @param position  Index in lines of this type (zero-based). E.g. 3
- * @param key       Key of the searched tag. Eg. "LN"
- * @param ks        kstring where the value will be written
- * @return          0 on success
- *                 -1 if the requested tag does not exist
- *                 -2 on other errors
- *
- * Looks for a specific key in a single SAM header line and writes the
- * associated value into @p ks.  The header line is selected using the @p type
- * and @p position parameters.  Any pre-existing content in @p ks will be
- * overwritten.
- */
-HTSLIB_EXPORT
-int sam_hdr_find_tag_pos(sam_hdr_t *h, const char *type, int pos, const char *key, kstring_t *ks);
-
-/// Remove the key from the line identified by type, ID_key and ID_value.
-/*!
- * @param type      Type of the line to which the tag belongs. Eg. "SQ"
- * @param ID_key    Tag key defining the line. Eg. "SN"
- * @param ID_value  Tag value associated with the key above. Eg. "ref1"
- * @param key       Key of the targeted tag. Eg. "M5"
- * @return          1 if the key was removed; 0 if it was not present; -1 on error
- */
-HTSLIB_EXPORT
-int sam_hdr_remove_tag_id(sam_hdr_t *h, const char *type, const char *ID_key, const char *ID_value, const char *key);
-
-/// Get the target id for a given reference sequence name
-/*!
- * @param ref  Reference name
- * @return     Positive value on success,
- *             -1 if unknown reference,
- *             -2 if the header could not be parsed
- *
- * Looks up a reference sequence by name in the reference hash table
- * and returns the numerical target id.
- */
-HTSLIB_EXPORT
-int sam_hdr_name2tid(sam_hdr_t *h, const char *ref);
-
-/// Get the reference sequence name from a target index
-/*!
- * @param tid  Target index
- * @return     Valid reference name on success, NULL on failure
- *
- * Fetch the reference sequence name from the target name array,
- * using the numerical target id.
- */
-HTSLIB_EXPORT
-const char *sam_hdr_tid2name(const sam_hdr_t *h, int tid);
-
-/// Get the reference sequence length from a target index
-/*!
- * @param tid  Target index
- * @return     Strictly positive value on success, 0 on failure
- *
- * Fetch the reference sequence length from the target length array,
- * using the numerical target id.
- */
-HTSLIB_EXPORT
-hts_pos_t sam_hdr_tid2len(const sam_hdr_t *h, int tid);
-
-/// Alias of sam_hdr_name2tid(), for backwards compatibility.
-/*!
- * @param ref  Reference name
- * @return     Positive value on success,
- *             -1 if unknown reference,
- *             -2 if the header could not be parsed
- */
-static inline int bam_name2id(sam_hdr_t *h, const char *ref) { return sam_hdr_name2tid(h, ref); }
-
-/// Generate a unique \@PG ID: value
-/*!
- * @param name  Name of the program. Eg. samtools
- * @return      Valid ID on success, NULL on failure
- *
- * Returns a unique ID from a base name.  The string returned will remain
- * valid until the next call to this function, or the header is destroyed.
- * The caller should not attempt to free() or realloc() it.
- */
-HTSLIB_EXPORT
-const char *sam_hdr_pg_id(sam_hdr_t *h, const char *name);
-
-/// Add an \@PG line.
-/*!
- * @param name  Name of the program. Eg. samtools
- * @return      0 on success, -1 on failure
- *
- * If we wish complete control over this use sam_hdr_add_line() directly. This
- * function uses that, but attempts to do a lot of tedious house work for
- * you too.
- *
- * - It will generate a suitable ID if the supplied one clashes.
- * - It will generate multiple \@PG records if we have multiple PG chains.
- *
- * Call it as per sam_hdr_add_line() with a series of key,value pairs ending
- * in NULL.
- */
-HTSLIB_EXPORT
-int sam_hdr_add_pg(sam_hdr_t *h, const char *name, ...);
-
-/*!
- * A function to help with construction of CL tags in @PG records.
- * Takes an argc, argv pair and returns a single space-separated string.
- * This string should be deallocated by the calling function.
- *
- * @return
- * Returns malloced char * on success;
- *         NULL on failure
- */
-HTSLIB_EXPORT
-char *stringify_argv(int argc, char *argv[]);
-
-/// Increments the reference count on a header
-/*!
- * This permits multiple files to share the same header, all calling
- * sam_hdr_destroy when done, without causing errors for other open files.
- */
-HTSLIB_EXPORT
-void sam_hdr_incr_ref(sam_hdr_t *h);
-
-/*
- * Macros for changing the \@HD line. They eliminate the need to use NULL method arguments.
- */
-
-/// Returns the SAM formatted text of the \@HD header line
-#define sam_hdr_find_hd(h, ks) sam_hdr_find_line_id((h), "HD", NULL, NULL, (ks))
-/// Returns the value associated with a given \@HD line tag
-#define sam_hdr_find_tag_hd(h, key, ks) sam_hdr_find_tag_id((h), "HD", NULL, NULL, (key), (ks))
-/// Adds or updates tags on the header \@HD line
-#define sam_hdr_update_hd(h, ...) sam_hdr_update_line((h), "HD", NULL, NULL, __VA_ARGS__, NULL)
-/// Removes the \@HD line tag with the given key
-#define sam_hdr_remove_tag_hd(h, key) sam_hdr_remove_tag_id((h), "HD", NULL, NULL, (key))
-
-/* Alignment */
-
-/// Create a new bam1_t alignment structure
-/**
-   @return An empty bam1_t structure on success, NULL on failure
-
-   The bam1_t struct returned by a successful call should be freed
-   via bam_destroy1() when it is no longer needed.
- */
-HTSLIB_EXPORT
-bam1_t *bam_init1(void);
-
-/// Destroy a bam1_t structure
-/**
-   @param b  structure to destroy
-
-   Does nothing if @p b is NULL.  If not, all memory associated with @p b
-   will be freed, along with the structure itself.  @p b should not be
-   accessed after calling this function.
- */
-HTSLIB_EXPORT
-void bam_destroy1(bam1_t *b);
-
-#define BAM_USER_OWNS_STRUCT 1
-#define BAM_USER_OWNS_DATA   2
-
-/// Set alignment record memory policy
-/**
-   @param b       Alignment record
-   @param policy  Desired policy
-
-   Allows the way HTSlib reallocates and frees bam1_t data to be
-   changed.  @policy can be set to the bitwise-or of the following
-   values:
-
-   \li \c BAM_USER_OWNS_STRUCT
-   If this is set then bam_destroy1() will not try to free the bam1_t struct.
-
-   \li \c BAM_USER_OWNS_DATA
-   If this is set, bam_destroy1() will not free the bam1_t::data pointer.
-   Also, functions which need to expand bam1_t::data memory will change
-   behaviour.  Instead of calling realloc() on the pointer, they will
-   allocate a new data buffer and copy any existing content in to it.
-   The existing memory will \b not be freed.  bam1_t::data will be
-   set to point to the new memory and the BAM_USER_OWNS_DATA flag will be
-   cleared.
-
-   BAM_USER_OWNS_STRUCT allows bam_destroy1() to be called on bam1_t
-   structures that are members of an array.
-
-   BAM_USER_OWNS_DATA can be used by applications that want more control
-   over where the variable-length parts of the bam record will be stored.
-   By preventing calls to free() and realloc(), it allows bam1_t::data
-   to hold pointers to memory that cannot be passed to those functions.
-
-   Example:  Read a block of alignment records, storing the variable-length
-   data in a single buffer and the records in an array.  Stop when either
-   the array or the buffer is full.
-
-   \code{.c}
-   #define MAX_RECS 1000
-   #define REC_LENGTH 400  // Average length estimate, to get buffer size
-   size_t bufsz = MAX_RECS * REC_LENGTH, nrecs, buff_used = 0;
-   bam1_t *recs = calloc(MAX_RECS, sizeof(bam1_t));
-   uint8_t *buffer = malloc(bufsz);
-   int res = 0, result = EXIT_FAILURE;
-   uint32_t new_m_data;
-
-   if (!recs || !buffer) goto cleanup;
-   for (nrecs = 0; nrecs < MAX_RECS; nrecs++) {
-      bam_set_mempolicy(BAM_USER_OWNS_STRUCT|BAM_USER_OWNS_DATA);
-
-      // Set data pointer to unused part of buffer
-      recs[nrecs].data = &buffer[buff_used];
-
-      // Set m_data to size of unused part of buffer.  On 64-bit platforms it
-      // will be necessary to limit this to UINT32_MAX due to the size of
-      // bam1_t::m_data (not done here as our buffer is only 400K).
-      recs[nrecs].m_data = bufsz - buff_used;
-
-      // Read the record
-      res = sam_read1(file_handle, header, &recs[nrecs]);
-      if (res <= 0) break; // EOF or error
-
-      // Check if the record data didn't fit - if not, stop reading
-      if ((bam_get_mempolicy(&recs[nrecs]) & BAM_USER_OWNS_DATA) == 0) {
-         nrecs++; // Include last record in count
-         break;
-      }
-
-      // Adjust m_data to the space actually used.  If space is available,
-      // round up to eight bytes so the next record aligns nicely.
-      new_m_data = ((uint32_t) recs[nrecs].l_data + 7) & (~7U);
-      if (new_m_data < recs[nrecs].m_data) recs[nrecs].m_data = new_m_data;
-
-      buff_used += recs[nrecs].m_data;
-   }
-   if (res < 0) goto cleanup;
-   result = EXIT_SUCCESS;
-
-   // ... use data ...
-
- cleanup:
-   for (size_t i = 0; i < nrecs; i++)
-     bam_destroy1(i);
-   free(buffer);
-   free(recs);
-
-   \endcode
-*/
-static inline void bam_set_mempolicy(bam1_t *b, uint32_t policy) {
-    b->mempolicy = policy;
-}
-
-/// Get alignment record memory policy
-/** @param b    Alignment record
-
-    See bam_set_mempolicy()
- */
-static inline uint32_t bam_get_mempolicy(bam1_t *b) {
-    return b->mempolicy;
-}
-
-/// Read a BAM format alignment record
-/**
-   @param fp   BGZF file being read
-   @param b    Destination for the alignment data
-   @return number of bytes read on success
-           -1 at end of file
-           < -1 on failure
-
-   This function can only read BAM format files.  Most code should use
-   sam_read1() instead, which can be used with BAM, SAM and CRAM formats.
-*/
-HTSLIB_EXPORT
-int bam_read1(BGZF *fp, bam1_t *b) HTS_RESULT_USED;
-
-/// Write a BAM format alignment record
-/**
-   @param fp  BGZF file being written
-   @param b   Alignment record to write
-   @return number of bytes written on success
-           -1 on error
-
-   This function can only write BAM format files.  Most code should use
-   sam_write1() instead, which can be used with BAM, SAM and CRAM formats.
-*/
-HTSLIB_EXPORT
-int bam_write1(BGZF *fp, const bam1_t *b) HTS_RESULT_USED;
-
-/// Copy alignment record data
-/**
-   @param bdst  Destination alignment record
-   @param bsrc  Source alignment record
-   @return bdst on success; NULL on failure
- */
-HTSLIB_EXPORT
-bam1_t *bam_copy1(bam1_t *bdst, const bam1_t *bsrc) HTS_RESULT_USED;
-
-/// Create a duplicate alignment record
-/**
-   @param bsrc  Source alignment record
-   @return Pointer to a new alignment record on success; NULL on failure
-
-   The bam1_t struct returned by a successful call should be freed
-   via bam_destroy1() when it is no longer needed.
- */
-HTSLIB_EXPORT
-bam1_t *bam_dup1(const bam1_t *bsrc);
-
-/// Sets all components of an alignment structure
-/**
-   @param bam      Target alignment structure. Must be initialized by a call to bam_init1().
-                   The data field will be reallocated automatically as needed.
-   @param l_qname  Length of the query name. If set to 0, the placeholder query name "*" will be used.
-   @param qname    Query name, may be NULL if l_qname = 0
-   @param flag     Bitwise flag, a combination of the BAM_F* constants.
-   @param tid      Chromosome ID, defined by sam_hdr_t (a.k.a. RNAME).
-   @param pos      0-based leftmost coordinate.
-   @param mapq     Mapping quality.
-   @param n_cigar  Number of CIGAR operations.
-   @param cigar    CIGAR data, may be NULL if n_cigar = 0.
-   @param mtid     Chromosome ID of next read in template, defined by sam_hdr_t (a.k.a. RNEXT).
-   @param mpos     0-based leftmost coordinate of next read in template (a.k.a. PNEXT).
-   @param isize    Observed template length ("insert size") (a.k.a. TLEN).
-   @param l_seq    Length of the query sequence (read) and sequence quality string.
-   @param seq      Sequence, may be NULL if l_seq = 0.
-   @param qual     Sequence quality, may be NULL.
-   @param l_aux    Length to be reserved for auxiliary field data, may be 0.
-
-   @return >= 0 on success (number of bytes written to bam->data), negative (with errno set) on failure.
-*/
-HTSLIB_EXPORT
-int bam_set1(bam1_t *bam,
-             size_t l_qname, const char *qname,
-             uint16_t flag, int32_t tid, hts_pos_t pos, uint8_t mapq,
-             size_t n_cigar, const uint32_t *cigar,
-             int32_t mtid, hts_pos_t mpos, hts_pos_t isize,
-             size_t l_seq, const char *seq, const char *qual,
-             size_t l_aux);
-
-/// Calculate query length from CIGAR data
-/**
-   @param n_cigar   Number of items in @p cigar
-   @param cigar     CIGAR data
-   @return Query length
-
-   CIGAR data is stored as in the BAM format, i.e. (op_len << 4) | op
-   where op_len is the length in bases and op is a value between 0 and 8
-   representing one of the operations "MIDNSHP=X" (M = 0; X = 8)
-
-   This function returns the sum of the lengths of the M, I, S, = and X
-   operations in @p cigar (these are the operations that "consume" query
-   bases).  All other operations (including invalid ones) are ignored.
-
-   @note This return type of this function is hts_pos_t so that it can
-   correctly return the length of CIGAR sequences including many long
-   operations without overflow. However, other restrictions (notably the sizes
-   of bam1_core_t::l_qseq and bam1_t::data) limit the maximum query sequence
-   length supported by HTSlib to fewer than INT_MAX bases.
- */
-HTSLIB_EXPORT
-hts_pos_t bam_cigar2qlen(int n_cigar, const uint32_t *cigar);
-
-/// Calculate reference length from CIGAR data
-/**
-   @param n_cigar   Number of items in @p cigar
-   @param cigar     CIGAR data
-   @return Reference length
-
-   CIGAR data is stored as in the BAM format, i.e. (op_len << 4) | op
-   where op_len is the length in bases and op is a value between 0 and 8
-   representing one of the operations "MIDNSHP=X" (M = 0; X = 8)
-
-   This function returns the sum of the lengths of the M, D, N, = and X
-   operations in @p cigar (these are the operations that "consume" reference
-   bases).  All other operations (including invalid ones) are ignored.
- */
-HTSLIB_EXPORT
-hts_pos_t bam_cigar2rlen(int n_cigar, const uint32_t *cigar);
-
-/*!
-      @abstract Calculate the rightmost base position of an alignment on the
-      reference genome.
-
-      @param  b  pointer to an alignment
-      @return    the coordinate of the first base after the alignment, 0-based
-
-      @discussion For a mapped read, this is just b->core.pos + bam_cigar2rlen.
-      For an unmapped read (either according to its flags or if it has no cigar
-      string) or a read whose cigar string consumes no reference bases at all,
-      we return b->core.pos + 1 by convention.
- */
-HTSLIB_EXPORT
-hts_pos_t bam_endpos(const bam1_t *b);
-
-HTSLIB_EXPORT
-int   bam_str2flag(const char *str);    /** returns negative value on error */
-
-HTSLIB_EXPORT
-char *bam_flag2str(int flag);   /** The string must be freed by the user */
-
-/*! @function
- @abstract  Set the name of the query
- @param  b  pointer to an alignment
- @return    0 on success, -1 on failure
- */
-HTSLIB_EXPORT
-int bam_set_qname(bam1_t *b, const char *qname);
-
-/*! @function
- @abstract  Parse a CIGAR string into a uint32_t array
- @param  in      [in]  pointer to the source string
- @param  end     [out] address of the pointer to the new end of the input string
-                       can be NULL
- @param  a_cigar [in/out]  address of the destination uint32_t buffer
- @param  a_mem   [in/out]  address of the allocated number of buffer elements
- @return         number of processed CIGAR operators; -1 on error
- */
-HTSLIB_EXPORT
-ssize_t sam_parse_cigar(const char *in, char **end, uint32_t **a_cigar, size_t *a_mem);
-
-/*! @function
- @abstract  Parse a CIGAR string into a bam1_t struct
- @param  in      [in]  pointer to the source string
- @param  end     [out] address of the pointer to the new end of the input string
-                       can be NULL
- @param  b       [in/out]  address of the destination bam1_t struct
- @return         number of processed CIGAR operators; -1 on error
- */
-HTSLIB_EXPORT
-ssize_t bam_parse_cigar(const char *in, char **end, bam1_t *b);
-
-/*************************
- *** BAM/CRAM indexing ***
- *************************/
-
-// These BAM iterator functions work only on BAM files.  To work with either
-// BAM or CRAM files use the sam_index_load() & sam_itr_*() functions.
-#define bam_itr_destroy(iter) hts_itr_destroy(iter)
-#define bam_itr_queryi(idx, tid, beg, end) sam_itr_queryi(idx, tid, beg, end)
-#define bam_itr_querys(idx, hdr, region) sam_itr_querys(idx, hdr, region)
-#define bam_itr_next(htsfp, itr, r) sam_itr_next((htsfp), (itr), (r))
-
-// Load/build .csi or .bai BAM index file.  Does not work with CRAM.
-// It is recommended to use the sam_index_* functions below instead.
-#define bam_index_load(fn) hts_idx_load((fn), HTS_FMT_BAI)
-#define bam_index_build(fn, min_shift) (sam_index_build((fn), (min_shift)))
-
-/// Initialise fp->idx for the current format type for SAM, BAM and CRAM types .
-/** @param fp        File handle for the data file being written.
-    @param h         Bam header structured (needed for BAI and CSI).
-    @param min_shift 0 for BAI, or larger for CSI (CSI defaults to 14).
-    @param fnidx     Filename to write index to.  This pointer must remain valid
-                     until after sam_idx_save is called.
-    @return          0 on success, <0 on failure.
-
-    @note This must be called after the header has been written, but before
-          any other data.
-*/
-HTSLIB_EXPORT
-int sam_idx_init(htsFile *fp, sam_hdr_t *h, int min_shift, const char *fnidx);
-
-/// Writes the index initialised with sam_idx_init to disk.
-/** @param fp        File handle for the data file being written.
-    @return          0 on success, <0 on filaure.
-*/
-HTSLIB_EXPORT
-int sam_idx_save(htsFile *fp) HTS_RESULT_USED;
-
-/// Load a BAM (.csi or .bai) or CRAM (.crai) index file
-/** @param fp  File handle of the data file whose index is being opened
-    @param fn  BAM/CRAM/etc filename to search alongside for the index file
-    @return  The index, or NULL if an error occurred.
-
-Equivalent to sam_index_load3(fp, fn, NULL, HTS_IDX_SAVE_REMOTE);
-*/
-HTSLIB_EXPORT
-hts_idx_t *sam_index_load(htsFile *fp, const char *fn);
-
-/// Load a specific BAM (.csi or .bai) or CRAM (.crai) index file
-/** @param fp     File handle of the data file whose index is being opened
-    @param fn     BAM/CRAM/etc data file filename
-    @param fnidx  Index filename, or NULL to search alongside @a fn
-    @return  The index, or NULL if an error occurred.
-
-Equivalent to sam_index_load3(fp, fn, fnidx, HTS_IDX_SAVE_REMOTE);
-*/
-HTSLIB_EXPORT
-hts_idx_t *sam_index_load2(htsFile *fp, const char *fn, const char *fnidx);
-
-/// Load or stream a BAM (.csi or .bai) or CRAM (.crai) index file
-/** @param fp     File handle of the data file whose index is being opened
-    @param fn     BAM/CRAM/etc data file filename
-    @param fnidx  Index filename, or NULL to search alongside @a fn
-    @param flags  Flags to alter behaviour (see description)
-    @return  The index, or NULL if an error occurred.
-
-The @p flags parameter can be set to a combination of the following values:
-
-        HTS_IDX_SAVE_REMOTE   Save a local copy of any remote indexes
-        HTS_IDX_SILENT_FAIL   Fail silently if the index is not present
-
-Note that HTS_IDX_SAVE_REMOTE has no effect for remote CRAM indexes.  They
-are always downloaded and never cached locally.
-
-The index struct returned by a successful call should be freed
-via hts_idx_destroy() when it is no longer needed.
-*/
-HTSLIB_EXPORT
-hts_idx_t *sam_index_load3(htsFile *fp, const char *fn, const char *fnidx, int flags);
-
-/// Generate and save an index file
-/** @param fn        Input BAM/etc filename, to which .csi/etc will be added
-    @param min_shift Positive to generate CSI, or 0 to generate BAI
-    @return  0 if successful, or negative if an error occurred (usually -1; or
-             -2: opening fn failed; -3: format not indexable; -4:
-             failed to create and/or save the index)
-*/
-HTSLIB_EXPORT
-int sam_index_build(const char *fn, int min_shift) HTS_RESULT_USED;
-
-/// Generate and save an index to a specific file
-/** @param fn        Input BAM/CRAM/etc filename
-    @param fnidx     Output filename, or NULL to add .bai/.csi/etc to @a fn
-    @param min_shift Positive to generate CSI, or 0 to generate BAI
-    @return  0 if successful, or negative if an error occurred (see
-             sam_index_build for error codes)
-*/
-HTSLIB_EXPORT
-int sam_index_build2(const char *fn, const char *fnidx, int min_shift) HTS_RESULT_USED;
-
-/// Generate and save an index to a specific file
-/** @param fn        Input BAM/CRAM/etc filename
-    @param fnidx     Output filename, or NULL to add .bai/.csi/etc to @a fn
-    @param min_shift Positive to generate CSI, or 0 to generate BAI
-    @param nthreads  Number of threads to use when building the index
-    @return  0 if successful, or negative if an error occurred (see
-             sam_index_build for error codes)
-*/
-HTSLIB_EXPORT
-int sam_index_build3(const char *fn, const char *fnidx, int min_shift, int nthreads) HTS_RESULT_USED;
-
-/// Free a SAM iterator
-/// @param iter     Iterator to free
-#define sam_itr_destroy(iter) hts_itr_destroy(iter)
-
-/// Create a BAM/CRAM iterator
-/** @param idx     Index
-    @param tid     Target id
-    @param beg     Start position in target
-    @param end     End position in target
-    @return An iterator on success; NULL on failure
-
-The following special values (defined in htslib/hts.h)can be used for @p tid.
-When using one of these values, @p beg and @p end are ignored.
-
-  HTS_IDX_NOCOOR iterates over unmapped reads sorted at the end of the file
-  HTS_IDX_START  iterates over the entire file
-  HTS_IDX_REST   iterates from the current position to the end of the file
-  HTS_IDX_NONE   always returns "no more alignment records"
-
-When using HTS_IDX_REST or HTS_IDX_NONE, NULL can be passed in to @p idx.
- */
-HTSLIB_EXPORT
-hts_itr_t *sam_itr_queryi(const hts_idx_t *idx, int tid, hts_pos_t beg, hts_pos_t end);
-
-/// Create a SAM/BAM/CRAM iterator
-/** @param idx     Index
-    @param hdr     Header
-    @param region  Region specification
-    @return An iterator on success; NULL on failure
-
-Regions are parsed by hts_parse_reg(), and take one of the following forms:
-
-region          | Outputs
---------------- | -------------
-REF             | All reads with RNAME REF
-REF:            | All reads with RNAME REF
-REF:START       | Reads with RNAME REF overlapping START to end of REF
-REF:-END        | Reads with RNAME REF overlapping start of REF to END
-REF:START-END   | Reads with RNAME REF overlapping START to END
-.               | All reads from the start of the file
-*               | Unmapped reads at the end of the file (RNAME '*' in SAM)
-
-The form `REF:` should be used when the reference name itself contains a colon.
-
-Note that SAM files must be bgzf-compressed for iterators to work.
- */
-HTSLIB_EXPORT
-hts_itr_t *sam_itr_querys(const hts_idx_t *idx, sam_hdr_t *hdr, const char *region);
-
-/// Create a multi-region iterator
-/** @param idx       Index
-    @param hdr       Header
-    @param reglist   Array of regions to iterate over
-    @param regcount  Number of items in reglist
-
-Each @p reglist entry should have the reference name in the `reg` field, an
-array of regions for that reference in `intervals` and the number of items
-in `intervals` should be stored in `count`.  No other fields need to be filled
-in.
-
-The iterator will return all reads overlapping the given regions.  If a read
-overlaps more than one region, it will only be returned once.
- */
-HTSLIB_EXPORT
-hts_itr_t *sam_itr_regions(const hts_idx_t *idx, sam_hdr_t *hdr, hts_reglist_t *reglist, unsigned int regcount);
-
-/// Create a multi-region iterator
-/** @param idx       Index
-    @param hdr       Header
-    @param regarray  Array of ref:interval region specifiers
-    @param regcount  Number of items in regarray
-
-Each @p regarray entry is parsed by hts_parse_reg(), and takes one of the
-following forms:
-
-region          | Outputs
---------------- | -------------
-REF             | All reads with RNAME REF
-REF:            | All reads with RNAME REF
-REF:START       | Reads with RNAME REF overlapping START to end of REF
-REF:-END        | Reads with RNAME REF overlapping start of REF to END
-REF:START-END   | Reads with RNAME REF overlapping START to END
-.               | All reads from the start of the file
-*               | Unmapped reads at the end of the file (RNAME '*' in SAM)
-
-The form `REF:` should be used when the reference name itself contains a colon.
-
-The iterator will return all reads overlapping the given regions.  If a read
-overlaps more than one region, it will only be returned once.
- */
-HTSLIB_EXPORT
-hts_itr_t *sam_itr_regarray(const hts_idx_t *idx, sam_hdr_t *hdr, char **regarray, unsigned int regcount);
-
-/// Get the next read from a SAM/BAM/CRAM iterator
-/** @param htsfp       Htsfile pointer for the input file
-    @param itr         Iterator
-    @param r           Pointer to a bam1_t struct
-    @return >= 0 on success; -1 when there is no more data; < -1 on error
- */
-static inline int sam_itr_next(htsFile *htsfp, hts_itr_t *itr, bam1_t *r) {
-    if (!htsfp->is_bgzf && !htsfp->is_cram) {
-        hts_log_error("%s not BGZF compressed", htsfp->fn ? htsfp->fn : "File");
-        return -2;
-    }
-    if (!itr) {
-        hts_log_error("Null iterator");
-        return -2;
-    }
-
-    if (itr->multi)
-        return hts_itr_multi_next(htsfp, itr, r);
-    else
-        return hts_itr_next(htsfp->is_bgzf ? htsfp->fp.bgzf : NULL, itr, r, htsfp);
-}
-
-/// Get the next read from a BAM/CRAM multi-iterator
-/** @param htsfp       Htsfile pointer for the input file
-    @param itr         Iterator
-    @param r           Pointer to a bam1_t struct
-    @return >= 0 on success; -1 when there is no more data; < -1 on error
- */
-#define sam_itr_multi_next(htsfp, itr, r) sam_itr_next(htsfp, itr, r)
-
-HTSLIB_EXPORT
-const char *sam_parse_region(sam_hdr_t *h, const char *s, int *tid,
-                             hts_pos_t *beg, hts_pos_t *end, int flags);
-
-    /***************
-     *** SAM I/O ***
-     ***************/
-
-    #define sam_open(fn, mode) (hts_open((fn), (mode)))
-    #define sam_open_format(fn, mode, fmt) (hts_open_format((fn), (mode), (fmt)))
-    #define sam_close(fp) hts_close(fp)
-
-    HTSLIB_EXPORT
-    int sam_open_mode(char *mode, const char *fn, const char *format);
-
-    // A version of sam_open_mode that can handle ,key=value options.
-    // The format string is allocated and returned, to be freed by the caller.
-    // Prefix should be "r" or "w",
-    HTSLIB_EXPORT
-    char *sam_open_mode_opts(const char *fn,
-                             const char *mode,
-                             const char *format);
-
-    HTSLIB_EXPORT
-    int sam_hdr_change_HD(sam_hdr_t *h, const char *key, const char *val);
-
-    HTSLIB_EXPORT
-    int sam_parse1(kstring_t *s, sam_hdr_t *h, bam1_t *b) HTS_RESULT_USED;
-    HTSLIB_EXPORT
-    int sam_format1(const sam_hdr_t *h, const bam1_t *b, kstring_t *str) HTS_RESULT_USED;
-
-/// sam_read1 - Read a record from a file
-/** @param fp   Pointer to the source file
- *  @param h    Pointer to the header previously read (fully or partially)
- *  @param b    Pointer to the record placeholder
- *  @return >= 0 on successfully reading a new record, -1 on end of stream, < -1 on error
- */
-    HTSLIB_EXPORT
-    int sam_read1(samFile *fp, sam_hdr_t *h, bam1_t *b) HTS_RESULT_USED;
-/// sam_write1 - Write a record to a file
-/** @param fp    Pointer to the destination file
- *  @param h     Pointer to the header structure previously read
- *  @param b     Pointer to the record to be written
- *  @return >= 0 on successfully writing the record, -1 on error
- */
-    HTSLIB_EXPORT
-    int sam_write1(samFile *fp, const sam_hdr_t *h, const bam1_t *b) HTS_RESULT_USED;
-
-// Forward declaration, see hts_expr.h for full.
-struct hts_filter_t;
-
-/// sam_passes_filter - Checks whether a record passes an hts_filter.
-/** @param h      Pointer to the header structure previously read
- *  @param b      Pointer to the BAM record to be checked
- *  @param filt   Pointer to the filter, created from hts_filter_init.
- *  @return       1 if passes, 0 if not, and <0 on error.
- */
-HTSLIB_EXPORT
-int sam_passes_filter(const sam_hdr_t *h, const bam1_t *b,
-                      struct hts_filter_t *filt);
-
-    /*************************************
-     *** Manipulating auxiliary fields ***
-     *************************************/
-
-/// Converts a BAM aux tag to SAM format
-/*
- * @param b    Pointer to the bam record
- * @param key  Two letter tag key
- * @param type Single letter type code: ACcSsIifHZB.
- * @param tag  Tag data pointer, in BAM format
- * @param end  Pointer to end of bam record (largest extent of tag)
- * @param ks   Kstring to write the formatted tag to
- *
- * @return pointer to end of tag on success,
- *         NULL on failure.
- *
- * @discussion The three separate parameters key, type, tag may be
- * derived from a s=bam_aux_get() query as s-2, *s and s+1.  However
- * it is recommended to use bam_aux_get_str in this situation.
- * The desire to split these parameters up is for potential processing
- * of non-BAM formats that encode using a BAM type mechanism
- * (such as the internal CRAM representation).
- */
-static inline const uint8_t *sam_format_aux1(const uint8_t *key,
-                                             const uint8_t type,
-                                             const uint8_t *tag,
-                                             const uint8_t *end,
-                                             kstring_t *ks) {
-    int r = 0;
-    const uint8_t *s = tag; // brevity and consistency with other code.
-    r |= kputsn_((char*)key, 2, ks) < 0;
-    r |= kputc_(':', ks) < 0;
-    if (type == 'C') {
-        r |= kputsn_("i:", 2, ks) < 0;
-        r |= kputw(*s, ks) < 0;
-        ++s;
-    } else if (type == 'c') {
-        r |= kputsn_("i:", 2, ks) < 0;
-        r |= kputw(*(int8_t*)s, ks) < 0;
-        ++s;
-    } else if (type == 'S') {
-        if (end - s >= 2) {
-            r |= kputsn_("i:", 2, ks) < 0;
-            r |= kputuw(le_to_u16(s), ks) < 0;
-            s += 2;
-        } else goto bad_aux;
-    } else if (type == 's') {
-        if (end - s >= 2) {
-            r |= kputsn_("i:", 2, ks) < 0;
-            r |= kputw(le_to_i16(s), ks) < 0;
-            s += 2;
-        } else goto bad_aux;
-    } else if (type == 'I') {
-        if (end - s >= 4) {
-            r |= kputsn_("i:", 2, ks) < 0;
-            r |= kputuw(le_to_u32(s), ks) < 0;
-            s += 4;
-        } else goto bad_aux;
-    } else if (type == 'i') {
-        if (end - s >= 4) {
-            r |= kputsn_("i:", 2, ks) < 0;
-            r |= kputw(le_to_i32(s), ks) < 0;
-            s += 4;
-        } else goto bad_aux;
-    } else if (type == 'A') {
-        r |= kputsn_("A:", 2, ks) < 0;
-        r |= kputc_(*s, ks) < 0;
-        ++s;
-    } else if (type == 'f') {
-        if (end - s >= 4) {
-            ksprintf(ks, "f:%g", le_to_float(s));
-            s += 4;
-        } else goto bad_aux;
-
-    } else if (type == 'd') {
-        // NB: "d" is not an official type in the SAM spec.
-        // However for unknown reasons samtools has always supported this.
-        // We believe, HOPE, it is not in general usage and we do not
-        // encourage it.
-        if (end - s >= 8) {
-            ksprintf(ks, "d:%g", le_to_double(s));
-            s += 8;
-        } else goto bad_aux;
-    } else if (type == 'Z' || type == 'H') {
-        r |= kputc_(type, ks) < 0;
-        r |= kputc_(':', ks) < 0;
-        while (s < end && *s) r |= kputc_(*s++, ks) < 0;
-        if (s >= end)
-            goto bad_aux;
-        ++s;
-    } else if (type == 'B') {
-        uint8_t sub_type = *(s++);
-        int sub_type_size;
-
-        // or externalise sam.c's aux_type2size function?
-        switch (sub_type) {
-        case 'A': case 'c': case 'C':
-            sub_type_size = 1;
-            break;
-        case 's': case 'S':
-            sub_type_size = 2;
-            break;
-        case 'i': case 'I': case 'f':
-            sub_type_size = 4;
-            break;
-        default:
-            sub_type_size = 0;
-            break;
-        }
-
-        uint32_t i, n;
-        if (sub_type_size == 0 || end - s < 4)
-            goto bad_aux;
-        n = le_to_u32(s);
-        s += 4; // now points to the start of the array
-        if ((end - s) / sub_type_size < n)
-            goto bad_aux;
-        r |= kputsn_("B:", 2, ks) < 0;
-        r |= kputc(sub_type, ks) < 0; // write the type
-        switch (sub_type) {
-        case 'c':
-            if (ks_expand(ks, n*2) < 0) goto mem_err;
-            for (i = 0; i < n; ++i) {
-                ks->s[ks->l++] = ',';
-                r |= kputw(*(int8_t*)s, ks) < 0;
-                ++s;
-            }
-            break;
-        case 'C':
-            if (ks_expand(ks, n*2) < 0) goto mem_err;
-            for (i = 0; i < n; ++i) {
-                ks->s[ks->l++] = ',';
-                r |= kputuw(*(uint8_t*)s, ks) < 0;
-                ++s;
-            }
-            break;
-        case 's':
-            if (ks_expand(ks, n*4) < 0) goto mem_err;
-            for (i = 0; i < n; ++i) {
-                ks->s[ks->l++] = ',';
-                r |= kputw(le_to_i16(s), ks) < 0;
-                s += 2;
-            }
-            break;
-        case 'S':
-            if (ks_expand(ks, n*4) < 0) goto mem_err;
-            for (i = 0; i < n; ++i) {
-                ks->s[ks->l++] = ',';
-                r |= kputuw(le_to_u16(s), ks) < 0;
-                s += 2;
-            }
-            break;
-        case 'i':
-            if (ks_expand(ks, n*6) < 0) goto mem_err;
-            for (i = 0; i < n; ++i) {
-                ks->s[ks->l++] = ',';
-                r |= kputw(le_to_i32(s), ks) < 0;
-                s += 4;
-            }
-            break;
-        case 'I':
-            if (ks_expand(ks, n*6) < 0) goto mem_err;
-            for (i = 0; i < n; ++i) {
-                ks->s[ks->l++] = ',';
-                r |= kputuw(le_to_u32(s), ks) < 0;
-                s += 4;
-            }
-            break;
-        case 'f':
-            if (ks_expand(ks, n*8) < 0) goto mem_err;
-            for (i = 0; i < n; ++i) {
-                ks->s[ks->l++] = ',';
-                r |= kputd(le_to_float(s), ks) < 0;
-                s += 4;
-            }
-            break;
-        default:
-            goto bad_aux;
-        }
-    } else { // Unknown type
-        goto bad_aux;
-    }
-    return r ? NULL : s;
-
- bad_aux:
-    errno = EINVAL;
-    return NULL;
-
- mem_err:
-    hts_log_error("Out of memory");
-    errno = ENOMEM;
-    return NULL;
-}
-
-/// Return a pointer to an aux record
-/** @param b   Pointer to the bam record
-    @param tag Desired aux tag
-    @return Pointer to the tag data, or NULL if tag is not present or on error
-    If the tag is not present, this function returns NULL and sets errno to
-    ENOENT.  If the bam record's aux data is corrupt (either a tag has an
-    invalid type, or the last record is incomplete) then errno is set to
-    EINVAL and NULL is returned.
- */
-HTSLIB_EXPORT
-uint8_t *bam_aux_get(const bam1_t *b, const char tag[2]);
-
-/// Return a SAM formatting string containing a BAM tag
-/** @param b   Pointer to the bam record
-    @param tag Desired aux tag
-    @param s   The kstring to write to.
-
-    @return 1 on success,
-            0 on no tag found with errno = ENOENT,
-           -1 on error (errno will be either EINVAL or ENOMEM).
- */
-static inline int bam_aux_get_str(const bam1_t *b,
-                                  const char tag[2],
-                                  kstring_t *s) {
-    const uint8_t *t = bam_aux_get(b, tag);
-    if (!t)
-        return errno == ENOENT ? 0 : -1;
-
-    if (!sam_format_aux1(t-2, *t, t+1, b->data + b->l_data, s))
-        return -1;
-
-    return 1;
-}
-
-/// Get an integer aux value
-/** @param s Pointer to the tag data, as returned by bam_aux_get()
-    @return The value, or 0 if the tag was not an integer type
-    If the tag is not an integer type, errno is set to EINVAL.  This function
-    will not return the value of floating-point tags.
-*/
-HTSLIB_EXPORT
-int64_t bam_aux2i(const uint8_t *s);
-
-/// Get an integer aux value
-/** @param s Pointer to the tag data, as returned by bam_aux_get()
-    @return The value, or 0 if the tag was not an integer type
-    If the tag is not an numeric type, errno is set to EINVAL.  The value of
-    integer flags will be returned cast to a double.
-*/
-HTSLIB_EXPORT
-double bam_aux2f(const uint8_t *s);
-
-/// Get a character aux value
-/** @param s Pointer to the tag data, as returned by bam_aux_get().
-    @return The value, or 0 if the tag was not a character ('A') type
-    If the tag is not a character type, errno is set to EINVAL.
-*/
-HTSLIB_EXPORT
-char bam_aux2A(const uint8_t *s);
-
-/// Get a string aux value
-/** @param s Pointer to the tag data, as returned by bam_aux_get().
-    @return Pointer to the string, or NULL if the tag was not a string type
-    If the tag is not a string type ('Z' or 'H'), errno is set to EINVAL.
-*/
-HTSLIB_EXPORT
-char *bam_aux2Z(const uint8_t *s);
-
-/// Get the length of an array-type ('B') tag
-/** @param s Pointer to the tag data, as returned by bam_aux_get().
-    @return The length of the array, or 0 if the tag is not an array type.
-    If the tag is not an array type, errno is set to EINVAL.
- */
-HTSLIB_EXPORT
-uint32_t bam_auxB_len(const uint8_t *s);
-
-/// Get an integer value from an array-type tag
-/** @param s   Pointer to the tag data, as returned by bam_aux_get().
-    @param idx 0-based Index into the array
-    @return The idx'th value, or 0 on error.
-    If the array is not an integer type, errno is set to EINVAL.  If idx
-    is greater than or equal to  the value returned by bam_auxB_len(s),
-    errno is set to ERANGE.  In both cases, 0 will be returned.
- */
-HTSLIB_EXPORT
-int64_t bam_auxB2i(const uint8_t *s, uint32_t idx);
-
-/// Get a floating-point value from an array-type tag
-/** @param s   Pointer to the tag data, as returned by bam_aux_get().
-    @param idx 0-based Index into the array
-    @return The idx'th value, or 0.0 on error.
-    If the array is not a numeric type, errno is set to EINVAL.  This can
-    only actually happen if the input record has an invalid type field.  If
-    idx is greater than or equal to  the value returned by bam_auxB_len(s),
-    errno is set to ERANGE.  In both cases, 0.0 will be returned.
- */
-HTSLIB_EXPORT
-double bam_auxB2f(const uint8_t *s, uint32_t idx);
-
-/// Append tag data to a bam record
-/* @param b    The bam record to append to.
-   @param tag  Tag identifier
-   @param type Tag data type
-   @param len  Length of the data in bytes
-   @param data The data to append
-   @return 0 on success; -1 on failure.
-If there is not enough space to store the additional tag, errno is set to
-ENOMEM.  If the type is invalid, errno may be set to EINVAL.  errno is
-also set to EINVAL if the bam record's aux data is corrupt.
-*/
-HTSLIB_EXPORT
-int bam_aux_append(bam1_t *b, const char tag[2], char type, int len, const uint8_t *data);
-
-/// Delete tag data from a bam record
-/* @param b The bam record to update
-   @param s Pointer to the tag to delete, as returned by bam_aux_get().
-   @return 0 on success; -1 on failure
-   If the bam record's aux data is corrupt, errno is set to EINVAL and this
-   function returns -1;
-*/
-HTSLIB_EXPORT
-int bam_aux_del(bam1_t *b, uint8_t *s);
-
-/// Update or add a string-type tag
-/* @param b    The bam record to update
-   @param tag  Tag identifier
-   @param len  The length of the new string
-   @param data The new string
-   @return 0 on success, -1 on failure
-   This function will not change the ordering of tags in the bam record.
-   New tags will be appended to any existing aux records.
-
-   If @p len is less than zero, the length of the input string will be
-   calculated using strlen().  Otherwise exactly @p len bytes will be
-   copied from @p data to make the new tag.  If these bytes do not
-   include a terminating NUL character, one will be added.  (Note that
-   versions of HTSlib up to 1.10.2 had different behaviour here and
-   simply copied @p len bytes from data.  To generate a valid tag it
-   was necessary to ensure the last character was a NUL, and include
-   it in @p len.)
-
-   On failure, errno may be set to one of the following values:
-
-   EINVAL: The bam record's aux data is corrupt or an existing tag with the
-   given ID is not of type 'Z'.
-
-   ENOMEM: The bam data needs to be expanded and either the attempt to
-   reallocate the data buffer failed or the resulting buffer would be
-   longer than the maximum size allowed in a bam record (2Gbytes).
-*/
-HTSLIB_EXPORT
-int bam_aux_update_str(bam1_t *b, const char tag[2], int len, const char *data);
-
-/// Update or add an integer tag
-/* @param b    The bam record to update
-   @param tag  Tag identifier
-   @param val  The new value
-   @return 0 on success, -1 on failure
-   This function will not change the ordering of tags in the bam record.
-   New tags will be appended to any existing aux records.
-
-   On failure, errno may be set to one of the following values:
-
-   EINVAL: The bam record's aux data is corrupt or an existing tag with the
-   given ID is not of an integer type (c, C, s, S, i or I).
-
-   EOVERFLOW (or ERANGE on systems that do not have EOVERFLOW): val is
-   outside the range that can be stored in an integer bam tag (-2147483647
-   to 4294967295).
-
-   ENOMEM: The bam data needs to be expanded and either the attempt to
-   reallocate the data buffer failed or the resulting buffer would be
-   longer than the maximum size allowed in a bam record (2Gbytes).
-*/
-HTSLIB_EXPORT
-int bam_aux_update_int(bam1_t *b, const char tag[2], int64_t val);
-
-/// Update or add a floating-point tag
-/* @param b    The bam record to update
-   @param tag  Tag identifier
-   @param val  The new value
-   @return 0 on success, -1 on failure
-   This function will not change the ordering of tags in the bam record.
-   New tags will be appended to any existing aux records.
-
-   On failure, errno may be set to one of the following values:
-
-   EINVAL: The bam record's aux data is corrupt or an existing tag with the
-   given ID is not of a float type.
-
-   ENOMEM: The bam data needs to be expanded and either the attempt to
-   reallocate the data buffer failed or the resulting buffer would be
-   longer than the maximum size allowed in a bam record (2Gbytes).
-*/
-HTSLIB_EXPORT
-int bam_aux_update_float(bam1_t *b, const char tag[2], float val);
-
-/// Update or add an array tag
-/* @param b     The bam record to update
-   @param tag   Tag identifier
-   @param type  Data type (one of c, C, s, S, i, I or f)
-   @param items Number of items
-   @param data  Pointer to data
-   @return 0 on success, -1 on failure
-   The type parameter indicates the how the data is interpreted:
-
-   Letter code | Data type | Item Size (bytes)
-   ----------- | --------- | -----------------
-   c           | int8_t    | 1
-   C           | uint8_t   | 1
-   s           | int16_t   | 2
-   S           | uint16_t  | 2
-   i           | int32_t   | 4
-   I           | uint32_t  | 4
-   f           | float     | 4
-
-   This function will not change the ordering of tags in the bam record.
-   New tags will be appended to any existing aux records.  The bam record
-   will grow or shrink in order to accommodate the new data.
-
-   The data parameter must not point to any data in the bam record itself or
-   undefined behaviour may result.
-
-   On failure, errno may be set to one of the following values:
-
-   EINVAL: The bam record's aux data is corrupt, an existing tag with the
-   given ID is not of an array type or the type parameter is not one of
-   the values listed above.
-
-   ENOMEM: The bam data needs to be expanded and either the attempt to
-   reallocate the data buffer failed or the resulting buffer would be
-   longer than the maximum size allowed in a bam record (2Gbytes).
-*/
-HTSLIB_EXPORT
-int bam_aux_update_array(bam1_t *b, const char tag[2],
-                         uint8_t type, uint32_t items, void *data);
-
-/**************************
- *** Pileup and Mpileup ***
- **************************/
-
-#if !defined(BAM_NO_PILEUP)
-
-/*! @typedef
- @abstract Generic pileup 'client data'.
-
- @discussion The pileup iterator allows setting a constructor and
- destructor function, which will be called every time a sequence is
- fetched and discarded.  This permits caching of per-sequence data in
- a tidy manner during the pileup process.  This union is the cached
- data to be manipulated by the "client" (the caller of pileup).
-*/
-typedef union {
-    void *p;
-    int64_t i;
-    double f;
-} bam_pileup_cd;
-
-/*! @typedef
- @abstract Structure for one alignment covering the pileup position.
- @field  b          pointer to the alignment
- @field  qpos       position of the read base at the pileup site, 0-based
- @field  indel      indel length; 0 for no indel, positive for ins and negative for del
- @field  level      the level of the read in the "viewer" mode
- @field  is_del     1 iff the base on the padded read is a deletion
- @field  is_head    1 iff this is the first base in the query sequence
- @field  is_tail    1 iff this is the last base in the query sequence
- @field  is_refskip 1 iff the base on the padded read is part of CIGAR N op
- @field  aux        (used by bcf_call_gap_prep())
- @field  cigar_ind  index of the CIGAR operator that has just been processed
-
- @discussion See also bam_plbuf_push() and bam_lplbuf_push(). The
- difference between the two functions is that the former does not
- set bam_pileup1_t::level, while the later does. Level helps the
- implementation of alignment viewers, but calculating this has some
- overhead.
- */
-typedef struct bam_pileup1_t {
-    bam1_t *b;
-    int32_t qpos;
-    int indel, level;
-    uint32_t is_del:1, is_head:1, is_tail:1, is_refskip:1, /* reserved */ :1, aux:27;
-    bam_pileup_cd cd; // generic per-struct data, owned by caller.
-    int cigar_ind;
-} bam_pileup1_t;
-
-typedef int (*bam_plp_auto_f)(void *data, bam1_t *b);
-
-struct bam_plp_s;
-typedef struct bam_plp_s *bam_plp_t;
-
-struct bam_mplp_s;
-typedef struct bam_mplp_s *bam_mplp_t;
-
-    /**
-     *  bam_plp_init() - sets an iterator over multiple
-     *  @func:      see mplp_func in bam_plcmd.c in samtools for an example. Expected return
-     *              status: 0 on success, -1 on end, < -1 on non-recoverable errors
-     *  @data:      user data to pass to @func
-     *
-     *  The struct returned by a successful call should be freed
-     *  via bam_plp_destroy() when it is no longer needed.
-     */
-    HTSLIB_EXPORT
-    bam_plp_t bam_plp_init(bam_plp_auto_f func, void *data);
-
-    HTSLIB_EXPORT
-    void bam_plp_destroy(bam_plp_t iter);
-
-    HTSLIB_EXPORT
-    int bam_plp_push(bam_plp_t iter, const bam1_t *b);
-
-    HTSLIB_EXPORT
-    const bam_pileup1_t *bam_plp_next(bam_plp_t iter, int *_tid, int *_pos, int *_n_plp);
-
-    HTSLIB_EXPORT
-    const bam_pileup1_t *bam_plp_auto(bam_plp_t iter, int *_tid, int *_pos, int *_n_plp);
-
-    HTSLIB_EXPORT
-    const bam_pileup1_t *bam_plp64_next(bam_plp_t iter, int *_tid, hts_pos_t *_pos, int *_n_plp);
-
-    HTSLIB_EXPORT
-    const bam_pileup1_t *bam_plp64_auto(bam_plp_t iter, int *_tid, hts_pos_t *_pos, int *_n_plp);
-
-    HTSLIB_EXPORT
-    void bam_plp_set_maxcnt(bam_plp_t iter, int maxcnt);
-
-    HTSLIB_EXPORT
-    void bam_plp_reset(bam_plp_t iter);
-
-    /**
-     *  bam_plp_constructor() - sets a callback to initialise any per-pileup1_t fields.
-     *  @plp:       The bam_plp_t initialised using bam_plp_init.
-     *  @func:      The callback function itself.  When called, it is given the
-     *              data argument (specified in bam_plp_init), the bam structure and
-     *              a pointer to a locally allocated bam_pileup_cd union.  This union
-     *              will also be present in each bam_pileup1_t created.
-     */
-    HTSLIB_EXPORT
-    void bam_plp_constructor(bam_plp_t plp,
-                             int (*func)(void *data, const bam1_t *b, bam_pileup_cd *cd));
-    HTSLIB_EXPORT
-    void bam_plp_destructor(bam_plp_t plp,
-                            int (*func)(void *data, const bam1_t *b, bam_pileup_cd *cd));
-
-    /// Get pileup padded insertion sequence
-    /**
-     * @param p       pileup data
-     * @param ins     the kstring where the insertion sequence will be written
-     * @param del_len location for deletion length
-     * @return the length of insertion string on success; -1 on failure.
-     *
-     * Fills out the kstring with the padded insertion sequence for the current
-     * location in 'p'.  If this is not an insertion site, the string is blank.
-     *
-     * If del_len is not NULL, the location pointed to is set to the length of
-     * any deletion immediately following the insertion, or zero if none.
-     */
-    HTSLIB_EXPORT
-    int bam_plp_insertion(const bam_pileup1_t *p, kstring_t *ins, int *del_len) HTS_RESULT_USED;
-
-    /// Create a new bam_mplp_t structure
-    /** The struct returned by a successful call should be freed
-     *  via bam_mplp_destroy() when it is no longer needed.
-     */
-    HTSLIB_EXPORT
-    bam_mplp_t bam_mplp_init(int n, bam_plp_auto_f func, void **data);
-
-    /// Set up mpileup overlap detection
-    /**
-     * @param iter    mpileup iterator
-     * @return 0 on success; a negative value on error
-     *
-     *  If called, mpileup will detect overlapping
-     *  read pairs and for each base pair set the base quality of the
-     *  lower-quality base to zero, thus effectively discarding it from
-     *  calling. If the two bases are identical, the quality of the other base
-     *  is increased to the sum of their qualities (capped at 200), otherwise
-     *  it is multiplied by 0.8.
-     */
-    HTSLIB_EXPORT
-    int bam_mplp_init_overlaps(bam_mplp_t iter);
-
-    HTSLIB_EXPORT
-    void bam_mplp_destroy(bam_mplp_t iter);
-
-    HTSLIB_EXPORT
-    void bam_mplp_set_maxcnt(bam_mplp_t iter, int maxcnt);
-
-    HTSLIB_EXPORT
-    int bam_mplp_auto(bam_mplp_t iter, int *_tid, int *_pos, int *n_plp, const bam_pileup1_t **plp);
-
-    HTSLIB_EXPORT
-    int bam_mplp64_auto(bam_mplp_t iter, int *_tid, hts_pos_t *_pos, int *n_plp, const bam_pileup1_t **plp);
-
-    HTSLIB_EXPORT
-    void bam_mplp_reset(bam_mplp_t iter);
-
-    HTSLIB_EXPORT
-    void bam_mplp_constructor(bam_mplp_t iter,
-                              int (*func)(void *data, const bam1_t *b, bam_pileup_cd *cd));
-
-    HTSLIB_EXPORT
-    void bam_mplp_destructor(bam_mplp_t iter,
-                             int (*func)(void *data, const bam1_t *b, bam_pileup_cd *cd));
-
-#endif // ~!defined(BAM_NO_PILEUP)
-
-
-/***********************************
- * BAQ calculation and realignment *
- ***********************************/
-
-HTSLIB_EXPORT
-int sam_cap_mapq(bam1_t *b, const char *ref, hts_pos_t ref_len, int thres);
-
-/// Calculate BAQ scores
-/** @param b   BAM record
-    @param ref     Reference sequence
-    @param ref_len Reference sequence length
-    @param flag    Flags, see description
-    @return 0 on success \n
-           -1 if the read was unmapped, zero length, had no quality values, did not have at least one M, X or = CIGAR operator, or included a reference skip. \n
-           -3 if BAQ alignment has already been done and does not need to be applied, or has already been applied. \n
-           -4 if alignment failed (most likely due to running out of memory)
-
-This function calculates base alignment quality (BAQ) values using the method
-described in "Improving SNP discovery by base alignment quality", Heng Li,
-Bioinformatics, Volume 27, Issue 8 (https://doi.org/10.1093/bioinformatics/btr076).
-
-The following @param flag bits can be used:
-
-Bit 0: Adjust the quality values using the BAQ values
-
- If set, the data in the BQ:Z tag is used to adjust the quality values, and
- the BQ:Z tag is renamed to ZQ:Z.
-
- If clear, and a ZQ:Z tag is present, the quality values are reverted using
- the data in the tag, and the tag is renamed to BQ:Z.
-
-Bit 1: Use "extended" BAQ.
-
- Changes the BAQ calculation to increase sensitivity at the expense of
- reduced specificity.
-
-Bit 2: Recalculate BAQ, even if a BQ tag is present.
-
- Force BAQ to be recalculated.  Note that a ZQ:Z tag will always disable
- recalculation.
-
-@bug
-If the input read has both BQ:Z and ZQ:Z tags, the ZQ:Z one will be removed.
-Depending on what previous processing happened, this may or may not be the
-correct thing to do.  It would be wise to avoid this situation if possible.
-*/
-
-HTSLIB_EXPORT
-int sam_prob_realn(bam1_t *b, const char *ref, hts_pos_t ref_len, int flag);
-
-#ifdef __cplusplus
-}
-#endif
-
-#endif
diff -ruN stringtie.orig/htslib/htslib/synced_bcf_reader.h stringtie/htslib/htslib/synced_bcf_reader.h
--- stringtie.orig/htslib/htslib/synced_bcf_reader.h	2024-02-28 13:57:39.704579460 +0100
+++ stringtie/htslib/htslib/synced_bcf_reader.h	1970-01-01 01:00:00.000000000 +0100
@@ -1,386 +0,0 @@
-/// @file htslib/synced_bcf_reader.h
-/// Stream through multiple VCF files.
-/*
-    Copyright (C) 2012-2017, 2019-2020 Genome Research Ltd.
-
-    Author: Petr Danecek <pd3@sanger.ac.uk>
-
-Permission is hereby granted, free of charge, to any person obtaining a copy
-of this software and associated documentation files (the "Software"), to deal
-in the Software without restriction, including without limitation the rights
-to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
-copies of the Software, and to permit persons to whom the Software is
-furnished to do so, subject to the following conditions:
-
-The above copyright notice and this permission notice shall be included in
-all copies or substantial portions of the Software.
-
-THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
-IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
-FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
-THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
-LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
-FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
-DEALINGS IN THE SOFTWARE.  */
-
-/*
-    The synced_bcf_reader allows to keep multiple VCFs open and stream them
-    using the next_line iterator in a seamless matter without worrying about
-    chromosomes and synchronizing the sites. This is used by vcfcheck to
-    compare multiple VCFs simultaneously and is used also for merging,
-    creating intersections, etc.
-
-    The synced_bcf_reader also provides API for reading indexed BCF/VCF,
-    hiding differences in BCF/VCF opening, indexing and reading.
-
-
-    Example of usage:
-
-        bcf_srs_t *sr = bcf_sr_init();
-        bcf_sr_set_opt(sr, BCF_SR_PAIR_LOGIC, BCF_SR_PAIR_BOTH_REF);
-        bcf_sr_set_opt(sr, BCF_SR_REQUIRE_IDX);
-        for (i=0; i<nfiles; i++)
-            bcf_sr_add_reader(sr,files[i]);
-        while ( bcf_sr_next_line(sr) )
-        {
-            for (i=0; i<nfiles; i++)
-            {
-                bcf1_t *line = bcf_sr_get_line(sr,i);
-                ...
-            }
-        }
-        if ( sr->errnum ) error("Error: %s\n", bcf_sr_strerror(sr->errnum));
-        bcf_sr_destroy(sr);
-*/
-
-#ifndef HTSLIB_SYNCED_BCF_READER_H
-#define HTSLIB_SYNCED_BCF_READER_H
-
-#include "hts.h"
-#include "vcf.h"
-#include "tbx.h"
-
-#ifdef __cplusplus
-extern "C" {
-#endif
-
-/*
-    When reading multiple files in parallel, duplicate records within each
-    file will be reordered and offered in intuitive order. For example,
-    when reading two files, each with unsorted SNP and indel record, the
-    reader should return the SNP records together and the indel records
-    together. The logic of compatible records can vary depending on the
-    application and can be set using the PAIR_* defined below.
-
-    The COLLAPSE_* definitions will be deprecated in future versions, please
-    use the PAIR_* definitions instead.
-*/
-#define COLLAPSE_NONE   0   // require the exact same set of alleles in all files
-#define COLLAPSE_SNPS   1   // allow different alleles, as long as they all are SNPs
-#define COLLAPSE_INDELS 2   // the same as above, but with indels
-#define COLLAPSE_ANY    4   // any combination of alleles can be returned by bcf_sr_next_line()
-#define COLLAPSE_SOME   8   // at least some of the ALTs must match
-#define COLLAPSE_BOTH  (COLLAPSE_SNPS|COLLAPSE_INDELS)
-
-#define BCF_SR_PAIR_SNPS       (1<<0)  // allow different alleles, as long as they all are SNPs
-#define BCF_SR_PAIR_INDELS     (1<<1)  // the same as above, but with indels
-#define BCF_SR_PAIR_ANY        (1<<2)  // any combination of alleles can be returned by bcf_sr_next_line()
-#define BCF_SR_PAIR_SOME       (1<<3)  // at least some of multiallelic ALTs must match. Implied by all the others with the exception of EXACT
-#define BCF_SR_PAIR_SNP_REF    (1<<4)  // allow REF-only records with SNPs
-#define BCF_SR_PAIR_INDEL_REF  (1<<5)  // allow REF-only records with indels
-#define BCF_SR_PAIR_EXACT      (1<<6)  // require the exact same set of alleles in all files
-#define BCF_SR_PAIR_BOTH       (BCF_SR_PAIR_SNPS|BCF_SR_PAIR_INDELS)
-#define BCF_SR_PAIR_BOTH_REF   (BCF_SR_PAIR_SNPS|BCF_SR_PAIR_INDELS|BCF_SR_PAIR_SNP_REF|BCF_SR_PAIR_INDEL_REF)
-
-typedef enum
-{
-    BCF_SR_REQUIRE_IDX,
-    BCF_SR_PAIR_LOGIC,          // combination of the PAIR_* values above
-    BCF_SR_ALLOW_NO_IDX         // allow to proceed even if required index is not present (at the user's risk)
-}
-bcf_sr_opt_t;
-
-struct bcf_sr_region_t;
-
-typedef struct bcf_sr_regions_t
-{
-    // for reading from tabix-indexed file (big data)
-    tbx_t *tbx;             // tabix index
-    hts_itr_t *itr;         // tabix iterator
-    kstring_t line;         // holder of the current line, set only when reading from tabix-indexed files
-    htsFile *file;
-    char *fname;
-    int is_bin;             // is open in binary mode (tabix access)
-    char **als;             // parsed alleles if targets_als set and _regions_match_alleles called
-    kstring_t als_str;      // block of parsed alleles
-    int nals, mals;         // number of set alleles and the size of allocated array
-    int als_type;           // alleles type, currently VCF_SNP or VCF_INDEL
-
-    // user handler to deal with skipped regions without a counterpart in VCFs
-    void (*missed_reg_handler)(struct bcf_sr_regions_t *, void *);
-    void *missed_reg_data;
-
-    // for in-memory regions (small data)
-    struct bcf_sr_region_t *regs; // the regions
-
-    // shared by both tabix-index and in-memory regions
-    void *seq_hash;         // keys: sequence names, values: index to seqs
-    char **seq_names;       // sequence names
-    int nseqs;              // number of sequences (chromosomes) in the file
-    int iseq;               // current position: chr name, index to snames
-    hts_pos_t start, end;   // current position: start, end of the region (0-based)
-    int prev_seq;
-    hts_pos_t prev_start, prev_end;
-}
-bcf_sr_regions_t;
-
-typedef struct bcf_sr_t
-{
-    htsFile *file;
-    tbx_t *tbx_idx;
-    hts_idx_t *bcf_idx;
-    bcf_hdr_t *header;
-    hts_itr_t *itr;
-    char *fname;
-    bcf1_t **buffer;                // cached VCF records. First is the current record synced across the reader
-    int nbuffer, mbuffer;           // number of cached records (including the current record); number of allocated records
-    int nfilter_ids, *filter_ids;   // -1 for ".", otherwise filter id as returned by bcf_hdr_id2int
-    int *samples, n_smpl;   // list of columns in the order consistent with bcf_srs_t.samples
-}
-bcf_sr_t;
-
-typedef enum
-{
-    open_failed, not_bgzf, idx_load_failed, file_type_error, api_usage_error,
-    header_error, no_eof, no_memory, vcf_parse_error, bcf_read_error, noidx_error
-}
-bcf_sr_error;
-
-typedef struct bcf_srs_t
-{
-    // Parameters controlling the logic
-    int collapse;           // Do not access directly, use bcf_sr_set_pairing_logic() instead
-    char *apply_filters;    // If set, sites where none of the FILTER strings is listed
-                            // will be skipped. Active only at the time of
-                            // initialization, that is during the add_reader()
-                            // calls. Therefore, each reader can be initialized with different
-                            // filters.
-    int require_index;  // Some tools do not need random access
-    int max_unpack;     // When reading VCFs and knowing some fields will not be needed, boost performance of vcf_parse1
-    int *has_line;      // Corresponds to return value of bcf_sr_next_line but is not limited by sizeof(int). Use bcf_sr_has_line macro to query.
-    bcf_sr_error errnum;
-
-    // Auxiliary data
-    bcf_sr_t *readers;
-    int nreaders;
-    int streaming;      // reading mode: index-jumping or streaming
-    int explicit_regs;  // was the list of regions se by bcf_sr_set_regions or guessed from tabix index?
-    char **samples; // List of samples
-    bcf_sr_regions_t *regions, *targets;    // see bcf_sr_set_[targets|regions] for description
-    int targets_als;    // subset to targets not only by position but also by alleles?
-    int targets_exclude;
-    kstring_t tmps;
-    int n_smpl;
-
-    int n_threads;      // Simple multi-threaded decoding / encoding.
-    htsThreadPool *p;   // Our pool, but it can be used by others if needed.
-    void *aux;          // Opaque auxiliary data
-}
-bcf_srs_t;
-
-/** Allocate and initialize a bcf_srs_t struct.
- *
- *  The bcf_srs_t struct returned by a successful call should be freed
- *  via bcf_sr_destroy() when it is no longer needed.
- */
-HTSLIB_EXPORT
-bcf_srs_t *bcf_sr_init(void);
-
-/** Destroy a bcf_srs_t struct */
-HTSLIB_EXPORT
-void bcf_sr_destroy(bcf_srs_t *readers);
-
-HTSLIB_EXPORT
-char *bcf_sr_strerror(int errnum);
-
-HTSLIB_EXPORT
-int bcf_sr_set_opt(bcf_srs_t *readers, bcf_sr_opt_t opt, ...);
-
-
-/**
- * bcf_sr_set_threads() - allocates a thread-pool for use by the synced reader.
- * @n_threads: size of thread pool
- *
- * Returns 0 if the call succeeded, or <0 on error.
- */
-HTSLIB_EXPORT
-int bcf_sr_set_threads(bcf_srs_t *files, int n_threads);
-
-/** Deallocates thread memory, if owned by us. */
-HTSLIB_EXPORT
-void bcf_sr_destroy_threads(bcf_srs_t *files);
-
-/**
- *  bcf_sr_add_reader() - open new reader
- *  @readers: holder of the open readers
- *  @fname:   the VCF file
- *
- *  Returns 1 if the call succeeded, or 0 on error.
- *
- *  See also the bcf_srs_t data structure for parameters controlling
- *  the reader's logic.
- */
-HTSLIB_EXPORT
-int bcf_sr_add_reader(bcf_srs_t *readers, const char *fname);
-
-HTSLIB_EXPORT
-void bcf_sr_remove_reader(bcf_srs_t *files, int i);
-
-/**
- * bcf_sr_next_line() - the iterator
- * @readers:    holder of the open readers
- *
- * Returns the number of readers which have the current line
- * (bcf_sr_t.buffer[0]) set at this position. Use the bcf_sr_has_line macro to
- * determine which of the readers are set.
- */
-HTSLIB_EXPORT
-int bcf_sr_next_line(bcf_srs_t *readers);
-
-#define bcf_sr_has_line(readers, i) (readers)->has_line[i]
-#define bcf_sr_get_line(_readers, i) ((_readers)->has_line[i] ? ((_readers)->readers[i].buffer[0]) : (bcf1_t *) NULL)
-#define bcf_sr_swap_line(_readers, i, lieu) { bcf1_t *tmp = lieu; lieu = (_readers)->readers[i].buffer[0]; (_readers)->readers[i].buffer[0] = tmp; }
-#define bcf_sr_region_done(_readers,i) (!(_readers)->has_line[i] && !(_readers)->readers[i].nbuffer ? 1 : 0)
-#define bcf_sr_get_header(_readers, i) (_readers)->readers[i].header
-#define bcf_sr_get_reader(_readers, i) &((_readers)->readers[i])
-
-
-/**
- *  bcf_sr_seek() - set all readers to selected position
- *  @seq:  sequence name; NULL to seek to start
- *  @pos:  0-based coordinate
- */
-HTSLIB_EXPORT
-int bcf_sr_seek(bcf_srs_t *readers, const char *seq, hts_pos_t pos);
-
-/**
- * bcf_sr_set_samples() - sets active samples
- * @readers: holder of the open readers
- * @samples: this can be one of: file name with one sample per line;
- *           or column-separated list of samples; or '-' for a list of
- *           samples shared by all files. If first character is the
- *           exclamation mark, all but the listed samples are included.
- * @is_file: 0: list of samples; 1: file with sample names
- *
- * Returns 1 if the call succeeded, or 0 on error.
- */
-HTSLIB_EXPORT
-int bcf_sr_set_samples(bcf_srs_t *readers, const char *samples, int is_file);
-
-/**
- *  bcf_sr_set_targets(), bcf_sr_set_regions() - init targets/regions
- *  @readers:   holder of the open readers
- *  @targets:   list of regions, one-based and inclusive.
- *  @is_fname:  0: targets is a comma-separated list of regions (chr,chr:from-to)
- *              1: targets is a tabix indexed file with a list of regions
- *              (<chr,pos> or <chr,from,to>)
- *
- *  Returns 0 if the call succeeded, or -1 on error.
- *
- *  Both functions behave the same way, unlisted positions will be skipped by
- *  bcf_sr_next_line(). However, there is an important difference: regions use
- *  index to jump to desired positions while targets streams the whole files
- *  and merely skip unlisted positions.
- *
- *  Moreover, bcf_sr_set_targets() accepts an optional parameter $alleles which
- *  is interpreted as a 1-based column index in the tab-delimited file where
- *  alleles are listed. This in principle enables to perform the COLLAPSE_*
- *  logic also with tab-delimited files. However, the current implementation
- *  considers the alleles merely as a suggestion for prioritizing one of possibly
- *  duplicate VCF lines. It is up to the caller to examine targets->als if
- *  perfect match is sought after. Note that the duplicate positions in targets
- *  file are currently not supported.
- *  Targets (but not regions) can be prefixed with "^" to request logical complement,
- *  for example "^X,Y,MT" indicates that sequences X, Y and MT should be skipped.
- */
-HTSLIB_EXPORT
-int bcf_sr_set_targets(bcf_srs_t *readers, const char *targets, int is_file, int alleles);
-
-HTSLIB_EXPORT
-int bcf_sr_set_regions(bcf_srs_t *readers, const char *regions, int is_file);
-
-
-
-/*
- *  bcf_sr_regions_init()
- *  @regions:   regions can be either a comma-separated list of regions
- *              (chr|chr:pos|chr:from-to|chr:from-) or VCF, BED, or
- *              tab-delimited file (the default). Uncompressed files
- *              are stored in memory while bgzip-compressed and tabix-indexed
- *              region files are streamed.
- *  @is_file:   0: regions is a comma-separated list of regions
- *                  (chr|chr:pos|chr:from-to|chr:from-)
- *              1: VCF, BED or tab-delimited file
- *  @chr, from, to:
- *              Column indexes of chromosome, start position and end position
- *              in the tab-delimited file. The positions are 1-based and
- *              inclusive.
- *              These parameters are ignored when reading from VCF, BED or
- *              tabix-indexed files. When end position column is not present,
- *              supply 'from' in place of 'to'. When 'to' is negative, first
- *              abs(to) will be attempted and if that fails, 'from' will be used
- *              instead.
- *
- *  The bcf_sr_regions_t struct returned by a successful call should be freed
- *  via bcf_sr_regions_destroy() when it is no longer needed.
- */
-HTSLIB_EXPORT
-bcf_sr_regions_t *bcf_sr_regions_init(const char *regions, int is_file, int chr, int from, int to);
-
-HTSLIB_EXPORT
-void bcf_sr_regions_destroy(bcf_sr_regions_t *regions);
-
-/*
- *  bcf_sr_regions_seek() - seek to the chromosome block
- *
- *  Returns 0 on success or -1 on failure. Sets reg->seq appropriately and
- *  reg->start,reg->end to -1.
- */
-HTSLIB_EXPORT
-int bcf_sr_regions_seek(bcf_sr_regions_t *regions, const char *chr);
-
-/*
- *  bcf_sr_regions_next() - retrieves next region. Returns 0 on success and -1
- *  when all regions have been read. The fields reg->seq, reg->start and
- *  reg->end are filled with the genomic coordinates on success or with
- *  NULL,-1,-1 when no region is available. The coordinates are 0-based,
- *  inclusive.
- */
-HTSLIB_EXPORT
-int bcf_sr_regions_next(bcf_sr_regions_t *reg);
-
-/*
- *  bcf_sr_regions_overlap() - checks if the interval <start,end> overlaps any of
- *  the regions, the coordinates are 0-based, inclusive. The coordinate queries
- *  must come in ascending order.
- *
- *  Returns 0 if the position is in regions; -1 if the position is not in the
- *  regions and more regions exist; -2 if not in the regions and there are no more
- *  regions left.
- */
-HTSLIB_EXPORT
-int bcf_sr_regions_overlap(bcf_sr_regions_t *reg, const char *seq, hts_pos_t start, hts_pos_t end);
-
-/*
- *  bcf_sr_regions_flush() - calls repeatedly regs->missed_reg_handler() until
- *  all remaining records are processed.
- *  Returns 0 on success, <0 on error.
- */
-HTSLIB_EXPORT
-int bcf_sr_regions_flush(bcf_sr_regions_t *regs);
-
-#ifdef __cplusplus
-}
-#endif
-
-#endif
diff -ruN stringtie.orig/htslib/htslib/tbx.h stringtie/htslib/htslib/tbx.h
--- stringtie.orig/htslib/htslib/tbx.h	2024-02-28 13:57:39.704579460 +0100
+++ stringtie/htslib/htslib/tbx.h	1970-01-01 01:00:00.000000000 +0100
@@ -1,142 +0,0 @@
-/// @file htslib/tbx.h
-/// Tabix API functions.
-/*
-    Copyright (C) 2009, 2012-2015, 2019 Genome Research Ltd.
-    Copyright (C) 2010, 2012 Broad Institute.
-
-    Author: Heng Li <lh3@sanger.ac.uk>
-
-Permission is hereby granted, free of charge, to any person obtaining a copy
-of this software and associated documentation files (the "Software"), to deal
-in the Software without restriction, including without limitation the rights
-to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
-copies of the Software, and to permit persons to whom the Software is
-furnished to do so, subject to the following conditions:
-
-The above copyright notice and this permission notice shall be included in
-all copies or substantial portions of the Software.
-
-THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
-IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
-FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
-THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
-LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
-FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
-DEALINGS IN THE SOFTWARE.  */
-
-#ifndef HTSLIB_TBX_H
-#define HTSLIB_TBX_H
-
-#include "hts.h"
-
-#ifdef __cplusplus
-extern "C" {
-#endif
-
-#define TBX_MAX_SHIFT 31
-
-#define TBX_GENERIC 0
-#define TBX_SAM     1
-#define TBX_VCF     2
-#define TBX_UCSC    0x10000
-
-typedef struct tbx_conf_t {
-    int32_t preset;
-    int32_t sc, bc, ec; // seq col., beg col. and end col.
-    int32_t meta_char, line_skip;
-} tbx_conf_t;
-
-typedef struct tbx_t {
-    tbx_conf_t conf;
-    hts_idx_t *idx;
-    void *dict;
-} tbx_t;
-
-extern const tbx_conf_t tbx_conf_gff, tbx_conf_bed, tbx_conf_psltbl, tbx_conf_sam, tbx_conf_vcf;
-
-    #define tbx_itr_destroy(iter) hts_itr_destroy(iter)
-    #define tbx_itr_queryi(tbx, tid, beg, end) hts_itr_query((tbx)->idx, (tid), (beg), (end), tbx_readrec)
-    #define tbx_itr_querys(tbx, s) hts_itr_querys((tbx)->idx, (s), (hts_name2id_f)(tbx_name2id), (tbx), hts_itr_query, tbx_readrec)
-    #define tbx_itr_next(htsfp, tbx, itr, r) hts_itr_next(hts_get_bgzfp(htsfp), (itr), (r), (tbx))
-    #define tbx_bgzf_itr_next(bgzfp, tbx, itr, r) hts_itr_next((bgzfp), (itr), (r), (tbx))
-
-    HTSLIB_EXPORT
-    int tbx_name2id(tbx_t *tbx, const char *ss);
-
-    /* Internal helper function used by tbx_itr_next() */
-    HTSLIB_EXPORT
-    BGZF *hts_get_bgzfp(htsFile *fp);
-
-    HTSLIB_EXPORT
-    int tbx_readrec(BGZF *fp, void *tbxv, void *sv, int *tid, hts_pos_t *beg, hts_pos_t *end);
-
-/// Build an index of the lines in a BGZF-compressed file
-/** The index struct returned by a successful call should be freed
-    via tbx_destroy() when it is no longer needed.
-*/
-    HTSLIB_EXPORT
-    tbx_t *tbx_index(BGZF *fp, int min_shift, const tbx_conf_t *conf);
-/*
- * All tbx_index_build* methods return: 0 (success), -1 (general failure) or -2 (compression not BGZF)
- */
-    HTSLIB_EXPORT
-    int tbx_index_build(const char *fn, int min_shift, const tbx_conf_t *conf);
-
-    HTSLIB_EXPORT
-    int tbx_index_build2(const char *fn, const char *fnidx, int min_shift, const tbx_conf_t *conf);
-
-    HTSLIB_EXPORT
-    int tbx_index_build3(const char *fn, const char *fnidx, int min_shift, int n_threads, const tbx_conf_t *conf);
-
-
-/// Load or stream a .tbi or .csi index
-/** @param fn     Name of the data file corresponding to the index
-
-    Equivalent to tbx_index_load3(fn, NULL, HTS_IDX_SAVE_REMOTE);
-*/
-    HTSLIB_EXPORT
-    tbx_t *tbx_index_load(const char *fn);
-
-/// Load or stream a .tbi or .csi index
-/** @param fn     Name of the data file corresponding to the index
-    @param fnidx  Name of the indexed file
-    @return The index, or NULL if an error occurred
-
-    If @p fnidx is NULL, the index name will be derived from @p fn.
-
-    Equivalent to tbx_index_load3(fn, fnidx, HTS_IDX_SAVE_REMOTE);
-*/
-    HTSLIB_EXPORT
-    tbx_t *tbx_index_load2(const char *fn, const char *fnidx);
-
-/// Load or stream a .tbi or .csi index
-/** @param fn     Name of the data file corresponding to the index
-    @param fnidx  Name of the indexed file
-    @param flags  Flags to alter behaviour (see description)
-    @return The index, or NULL if an error occurred
-
-    If @p fnidx is NULL, the index name will be derived from @p fn.
-
-    The @p flags parameter can be set to a combination of the following
-    values:
-
-        HTS_IDX_SAVE_REMOTE   Save a local copy of any remote indexes
-        HTS_IDX_SILENT_FAIL   Fail silently if the index is not present
-
-    The index struct returned by a successful call should be freed
-    via tbx_destroy() when it is no longer needed.
-*/
-    HTSLIB_EXPORT
-    tbx_t *tbx_index_load3(const char *fn, const char *fnidx, int flags);
-
-    HTSLIB_EXPORT
-    const char **tbx_seqnames(tbx_t *tbx, int *n);  // free the array but not the values
-
-    HTSLIB_EXPORT
-    void tbx_destroy(tbx_t *tbx);
-
-#ifdef __cplusplus
-}
-#endif
-
-#endif
diff -ruN stringtie.orig/htslib/htslib/thread_pool.h stringtie/htslib/htslib/thread_pool.h
--- stringtie.orig/htslib/htslib/thread_pool.h	2024-02-28 13:57:39.704579460 +0100
+++ stringtie/htslib/htslib/thread_pool.h	1970-01-01 01:00:00.000000000 +0100
@@ -1,385 +0,0 @@
-/// @file htslib/thread_pool.h
-/// Thread pool for multi-threading applications.
-/*
-    Copyright (c) 2013-2017, 2019, 2020 Genome Research Ltd.
-
-    Author: James Bonfield <jkb@sanger.ac.uk>
-
-Permission is hereby granted, free of charge, to any person obtaining a copy
-of this software and associated documentation files (the "Software"), to deal
-in the Software without restriction, including without limitation the rights
-to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
-copies of the Software, and to permit persons to whom the Software is
-furnished to do so, subject to the following conditions:
-
-The above copyright notice and this permission notice shall be included in
-all copies or substantial portions of the Software.
-
-THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
-IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
-FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
-THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
-LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
-FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
-DEALINGS IN THE SOFTWARE.  */
-
-/*
- * This file implements a thread pool for multi-threading applications.  It
- * consists of two distinct interfaces: thread pools and thread process
- * queues (a queue of both jobs to-do and of the results of completed jobs).
- * Do not confuse "process" here with a unix PID; rather it is analogous to a
- * program reading a stream of data blocks, processing them in some manner,
- * and outputting a stream of new data blocks.
- *
- * The pool of threads is given a function pointer and void* data to pass in.
- * This means the pool can run jobs of multiple types, albeit first come
- * first served with no job scheduling except to pick tasks for the
- * processes that have room to store the result.
- *
- * Upon completion, the return value from the function pointer is
- * added to back to the process result queue if required.  We may have
- * multiple "processes" in use for the one pool.
- *
- * To see example usage, please look at the #ifdef TEST_MAIN code in
- * thread_pool.c.
- */
-
-#ifndef HTSLIB_THREAD_POOL_H
-#define HTSLIB_THREAD_POOL_H
-
-#include "hts_defs.h"
-
-#ifdef __cplusplus
-extern "C" {
-#endif
-
-/*-----------------------------------------------------------------------------
- * Opaque data types.
- *
- * Actual definitions are in thread_pool_internal.h, but these should only
- * be used by thread_pool.c itself.
- */
-
-/*
- * An hts_tpool_process implements a queue of input jobs to process and a
- * queue of resulting output  post-processing.  Internally it consists of two
- * buffered queues, analogous to the pipes in a unix pipeline:
- *    ...input | process |  output...
- *
- * Both input and output queues have size limits to prevent either queue from
- * growing too large and serial numbers to ensure sequential consumption of
- * the output.
- *
- * The thread pool may have many heterogeneous tasks, each using its own
- * process mixed into the same thread pool.
- */
-typedef struct hts_tpool_process hts_tpool_process;
-
-/*
- * The single pool structure itself.
- *
- * This knows nothing about the nature of the jobs or where their output is
- * going, but it maintains a list of process-queues associated with this pool
- * from which the jobs are taken.
- */
-typedef struct hts_tpool hts_tpool;
-
-/*
- * An output, after job has executed.
- */
-typedef struct hts_tpool_result hts_tpool_result;
-
-
-/*-----------------------------------------------------------------------------
- * Thread pool external functions
- */
-
-
-/*
- * Creates a worker pool with n worker threads.
- *
- * Returns pool pointer on success;
- *         NULL on failure
- *
- * The hts_tpool struct returned by a successful call should be freed
- * via hts_tpool_destroy() when it is no longer needed.
- */
-HTSLIB_EXPORT
-hts_tpool *hts_tpool_init(int n);
-
-
-/*
- * Returns the number of requested threads for a pool.
- */
-HTSLIB_EXPORT
-int hts_tpool_size(hts_tpool *p);
-
-
-/// Add an item to the work pool.
-/**
- * @param p     Thread pool
- * @param q     Process queue
- * @param func  Function run by the thread pool
- * @param arg   Data for use by func()
- * @return 0 on success
- *        -1 on failure
- */
-// FIXME: should this drop the hts_tpool*p argument? It's just q->p
-HTSLIB_EXPORT
-int hts_tpool_dispatch(hts_tpool *p, hts_tpool_process *q,
-                       void *(*func)(void *arg), void *arg);
-
-/// Add an item to the work pool, with nonblocking option.
-/**
- * @param p         Thread pool
- * @param q         Process queue
- * @param func      Function run by the thread pool
- * @param arg       Data for use by func()
- * @param nonblock  Non-blocking flag (see description)
- * @return 0 on success
- *        -1 on failure
- *
- * The @p nonblock parameter can take one of the following values:
- *      0 => block if input queue is full
- *     +1 => don't block if input queue is full, but do not add task
- *     -1 => add task regardless of whether queue is full (over-size)
- *
- * If @p nonblock is +1 and the queue is full, -1 will be returned and
- * `errno` is set to `EAGAIN`.
- */
-HTSLIB_EXPORT
-int hts_tpool_dispatch2(hts_tpool *p, hts_tpool_process *q,
-                        void *(*func)(void *arg), void *arg, int nonblock);
-
-/// Add an item to the work pool, with nonblocking and cleanup callbacks.
-/**
- * @param p               Thread pool
- * @param q               Process queue
- * @param exec_func       Function run by the thread pool
- * @param arg             Data for use by func()
- * @param job_cleanup     Callback to clean up when discarding jobs
- * @param result_cleanup  Callback to clean up when discarding result data
- * @param nonblock        Non-blocking flag (see description)
- * @return 0 on success
- *        -1 on failure
- *
- * The @p nonblock parameter can take one of the following values:
- *      0 => block if input queue is full
- *     +1 => don't block if input queue is full, but do not add task
- *     -1 => add task regardless of whether queue is full (over-size)
- *
- * If @p nonblock is +1 and the queue is full, -1 will be returned and
- * `errno` is set to `EAGAIN`.
- *
- * The job_cleanup() and result_cleanup() callbacks are used when discarding
- * data from a queue, for example when calling hts_tpool_process_reset()
- * or hts_tpool_process_destroy().
- *
- * If not NULL, job_cleanup() will be called for each pending job with the
- * value of @p arg that was set for that job.  This can be used to free
- * any data associated with @p arg, and also @p arg itself.
- *
- * Similarly, result_cleanup() can be used to free any results left by
- * jobs that had started before hts_tpool_process_reset() was called.
- * The argument passed to result_cleanup() is the pointer that would
- * have been returned by calling hts_tpool_result_data() on the result
- * when pulled from the queue.
- *
- * job_cleanup() and result_cleanup() are only called when discarding jobs.
- * For jobs that are processed normally, it is the responsibility of
- * exec_func() and / or consumers of any results to do any cleaning up
- * necessary.
- */
-HTSLIB_EXPORT
-int hts_tpool_dispatch3(hts_tpool *p, hts_tpool_process *q,
-                        void *(*exec_func)(void *arg), void *arg,
-                        void (*job_cleanup)(void *arg),
-                        void (*result_cleanup)(void *data),
-                        int nonblock);
-
-/*
- * Wakes up a single thread stuck in dispatch and make it return with
- * errno EAGAIN.
- */
-HTSLIB_EXPORT
-void hts_tpool_wake_dispatch(hts_tpool_process *q);
-
-/*
- * Flushes the process-queue, but doesn't exit. This simply drains the queue
- * and ensures all worker threads have finished their current tasks
- * associated with this process.
- *
- * NOT: This does not mean the worker threads are not executing jobs in
- * another process-queue.
- *
- * Returns 0 on success;
- *        -1 on failure
- */
-HTSLIB_EXPORT
-int hts_tpool_process_flush(hts_tpool_process *q);
-
-/*
- * Resets a process to the initial state.
- *
- * This removes any queued up input jobs, disables any notification of
- * new results/output, flushes what is left and then discards any
- * queued output.  Anything consumer stuck in a wait on results to
- * appear should stay stuck and will only wake up when new data is
- * pushed through the queue.
- *
- * Returns 0 on success;
- *        -1 on failure
- */
-HTSLIB_EXPORT
-int hts_tpool_process_reset(hts_tpool_process *q, int free_results);
-
-/* Returns the process queue size */
-HTSLIB_EXPORT
-int hts_tpool_process_qsize(hts_tpool_process *q);
-
-
-/*
- * Destroys a thread pool.  The threads are joined into the main
- * thread so they will finish their current work load.
- */
-HTSLIB_EXPORT
-void hts_tpool_destroy(hts_tpool *p);
-
-/*
- * Destroys a thread pool without waiting on jobs to complete.
- * Use hts_tpool_kill(p) to quickly exit after a fatal error.
- */
-HTSLIB_EXPORT
-void hts_tpool_kill(hts_tpool *p);
-
-/*
- * Pulls the next item off the process result queue.  The caller should free
- * it (and any internals as appropriate) after use.  This doesn't wait for a
- * result to be present.
- *
- * Results will be returned in strict order.
- *
- * Returns hts_tpool_result pointer if a result is ready.
- *         NULL if not.
- */
-HTSLIB_EXPORT
-hts_tpool_result *hts_tpool_next_result(hts_tpool_process *q);
-
-/*
- * Pulls the next item off the process result queue.  The caller should free
- * it (and any internals as appropriate) after use.  This will wait for
- * a result to be present if none are currently available.
- *
- * Results will be returned in strict order.
- *
- * Returns hts_tpool_result pointer if a result is ready.
- *         NULL on error or during shutdown.
- */
-HTSLIB_EXPORT
-hts_tpool_result *hts_tpool_next_result_wait(hts_tpool_process *q);
-
-/*
- * Frees a result 'r' and if free_data is true also frees
- * the internal r->data result too.
- */
-HTSLIB_EXPORT
-void hts_tpool_delete_result(hts_tpool_result *r, int free_data);
-
-/*
- * Returns the data portion of a hts_tpool_result, corresponding
- * to the actual "result" itself.
- */
-HTSLIB_EXPORT
-void *hts_tpool_result_data(hts_tpool_result *r);
-
-/*
- * Initialises a thread process-queue.
- *
- * In_only, if true, indicates that the process generates does not need to
- * hold any output.  Otherwise an output queue is used to store the results
- * of processing each input job.
- *
- * Results hts_tpool_process pointer on success;
- *         NULL on failure
- *
- * The hts_tpool_process struct returned by a successful call should be freed
- * via hts_tpool_process_destroy() when it is no longer needed.
- */
-HTSLIB_EXPORT
-hts_tpool_process *hts_tpool_process_init(hts_tpool *p, int qsize, int in_only);
-
-
-/* Deallocates memory for a thread process-queue.
- * Must be called before the thread pool is destroyed.
- */
-HTSLIB_EXPORT
-void hts_tpool_process_destroy(hts_tpool_process *q);
-
-/*
- * Returns true if there are no items in the process results queue and
- * also none still pending.
- */
-HTSLIB_EXPORT
-int hts_tpool_process_empty(hts_tpool_process *q);
-
-/*
- * Returns the number of completed jobs in the process results queue.
- */
-HTSLIB_EXPORT
-int hts_tpool_process_len(hts_tpool_process *q);
-
-/*
- * Returns the number of completed jobs in the process results queue plus the
- * number running and queued up to run.
- */
-HTSLIB_EXPORT
-int hts_tpool_process_sz(hts_tpool_process *q);
-
-/*
- * Shutdown a process.
- *
- * This sets the shutdown flag and wakes any threads waiting on process
- * condition variables.
- */
-HTSLIB_EXPORT
-void hts_tpool_process_shutdown(hts_tpool_process *q);
-
-/*
- * Returns whether this process queue has been shutdown.
- * Return value of 1 signifies normal shutdown while >1 signifies it
- * was shutdown due to an error condition.
- */
-HTSLIB_EXPORT
-int hts_tpool_process_is_shutdown(hts_tpool_process *q);
-
-/*
- * Attach and detach a thread process-queue with / from the thread pool
- * scheduler.
- *
- * We need to do attach after making a thread process, but may also wish
- * to temporarily detach if we wish to stop running jobs on a specific
- * process while permitting other process to continue.
- */
-HTSLIB_EXPORT
-void hts_tpool_process_attach(hts_tpool *p, hts_tpool_process *q);
-
-HTSLIB_EXPORT
-void hts_tpool_process_detach(hts_tpool *p, hts_tpool_process *q);
-
-/*
- * Increment and decrement the reference count in a process-queue.
- * If the queue is being driven from two external (non thread-pool)
- * threads, eg "main" and a "reader", this permits each end to
- * decrement its use of the process-queue independently.
- */
-HTSLIB_EXPORT
-void hts_tpool_process_ref_incr(hts_tpool_process *q);
-
-HTSLIB_EXPORT
-void hts_tpool_process_ref_decr(hts_tpool_process *q);
-
-#ifdef __cplusplus
-}
-#endif
-
-#endif
diff -ruN stringtie.orig/htslib/htslib/vcf.h stringtie/htslib/htslib/vcf.h
--- stringtie.orig/htslib/htslib/vcf.h	2024-02-28 13:57:39.704579460 +0100
+++ stringtie/htslib/htslib/vcf.h	1970-01-01 01:00:00.000000000 +0100
@@ -1,1515 +0,0 @@
-/// @file htslib/vcf.h
-/// High-level VCF/BCF variant calling file operations.
-/*
-    Copyright (C) 2012, 2013 Broad Institute.
-    Copyright (C) 2012-2020 Genome Research Ltd.
-
-    Author: Heng Li <lh3@sanger.ac.uk>
-
-Permission is hereby granted, free of charge, to any person obtaining a copy
-of this software and associated documentation files (the "Software"), to deal
-in the Software without restriction, including without limitation the rights
-to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
-copies of the Software, and to permit persons to whom the Software is
-furnished to do so, subject to the following conditions:
-
-The above copyright notice and this permission notice shall be included in
-all copies or substantial portions of the Software.
-
-THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
-IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
-FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
-THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
-LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
-FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
-DEALINGS IN THE SOFTWARE.  */
-
-/*
-    todo:
-        - make the function names consistent
-        - provide calls to abstract away structs as much as possible
- */
-
-#ifndef HTSLIB_VCF_H
-#define HTSLIB_VCF_H
-
-#include <stdint.h>
-#include <limits.h>
-#include <errno.h>
-#include "hts.h"
-#include "kstring.h"
-#include "hts_defs.h"
-#include "hts_endian.h"
-
-/* Included only for backwards compatibility with e.g. bcftools 1.10 */
-#include <assert.h>
-
-#ifdef __cplusplus
-extern "C" {
-#endif
-
-/*****************
- * Header struct *
- *****************/
-
-#define BCF_HL_FLT  0 // header line
-#define BCF_HL_INFO 1
-#define BCF_HL_FMT  2
-#define BCF_HL_CTG  3
-#define BCF_HL_STR  4 // structured header line TAG=<A=..,B=..>
-#define BCF_HL_GEN  5 // generic header line
-
-#define BCF_HT_FLAG 0 // header type
-#define BCF_HT_INT  1
-#define BCF_HT_REAL 2
-#define BCF_HT_STR  3
-#define BCF_HT_LONG (BCF_HT_INT | 0x100) // BCF_HT_INT, but for int64_t values; VCF only!
-
-#define BCF_VL_FIXED 0 // variable length
-#define BCF_VL_VAR   1
-#define BCF_VL_A     2
-#define BCF_VL_G     3
-#define BCF_VL_R     4
-
-/* === Dictionary ===
-
-   The header keeps three dictionaries. The first keeps IDs in the
-   "FILTER/INFO/FORMAT" lines, the second keeps the sequence names and lengths
-   in the "contig" lines and the last keeps the sample names. bcf_hdr_t::dict[]
-   is the actual hash table, which is opaque to the end users. In the hash
-   table, the key is the ID or sample name as a C string and the value is a
-   bcf_idinfo_t struct. bcf_hdr_t::id[] points to key-value pairs in the hash
-   table in the order that they appear in the VCF header. bcf_hdr_t::n[] is the
-   size of the hash table or, equivalently, the length of the id[] arrays.
-*/
-
-#define BCF_DT_ID       0 // dictionary type
-#define BCF_DT_CTG      1
-#define BCF_DT_SAMPLE   2
-
-// Complete textual representation of a header line
-typedef struct bcf_hrec_t {
-    int type;       // One of the BCF_HL_* type
-    char *key;      // The part before '=', i.e. FILTER/INFO/FORMAT/contig/fileformat etc.
-    char *value;    // Set only for generic lines, NULL for FILTER/INFO, etc.
-    int nkeys;              // Number of structured fields
-    char **keys, **vals;    // The key=value pairs
-} bcf_hrec_t;
-
-typedef struct bcf_idinfo_t {
-    uint64_t info[3];  // stores Number:20, var:4, Type:4, ColType:4 in info[0..2]
-                       // for BCF_HL_FLT,INFO,FMT and contig length in info[0] for BCF_HL_CTG
-    bcf_hrec_t *hrec[3];
-    int id;
-} bcf_idinfo_t;
-
-typedef struct bcf_idpair_t {
-    const char *key;
-    const bcf_idinfo_t *val;
-} bcf_idpair_t;
-
-// Note that bcf_hdr_t structs must always be created via bcf_hdr_init()
-typedef struct bcf_hdr_t {
-    int32_t n[3];           // n:the size of the dictionary block in use, (allocated size, m, is below to preserve ABI)
-    bcf_idpair_t *id[3];
-    void *dict[3];          // ID dictionary, contig dict and sample dict
-    char **samples;
-    bcf_hrec_t **hrec;
-    int nhrec, dirty;
-    int ntransl, *transl[2];    // for bcf_translate()
-    int nsamples_ori;           // for bcf_hdr_set_samples()
-    uint8_t *keep_samples;
-    kstring_t mem;
-    int32_t m[3];          // m: allocated size of the dictionary block in use (see n above)
-} bcf_hdr_t;
-
-extern uint8_t bcf_type_shift[];
-
-/**************
- * VCF record *
- **************/
-
-#define BCF_BT_NULL     0
-#define BCF_BT_INT8     1
-#define BCF_BT_INT16    2
-#define BCF_BT_INT32    3
-#define BCF_BT_INT64    4  // Unofficial, for internal use only.
-#define BCF_BT_FLOAT    5
-#define BCF_BT_CHAR     7
-
-#define VCF_REF      0
-#define VCF_SNP      1
-#define VCF_MNP      2
-#define VCF_INDEL    4
-#define VCF_OTHER    8
-#define VCF_BND     16    // breakend
-#define VCF_OVERLAP 32    // overlapping deletion, ALT=*
-
-typedef struct bcf_variant_t {
-    int type, n;    // variant type and the number of bases affected, negative for deletions
-} bcf_variant_t;
-
-typedef struct bcf_fmt_t {
-    int id;             // id: numeric tag id, the corresponding string is bcf_hdr_t::id[BCF_DT_ID][$id].key
-    int n, size, type;  // n: number of values per-sample; size: number of bytes per-sample; type: one of BCF_BT_* types
-    uint8_t *p;         // same as vptr and vptr_* in bcf_info_t below
-    uint32_t p_len;
-    uint32_t p_off:31, p_free:1;
-} bcf_fmt_t;
-
-typedef struct bcf_info_t {
-    int key;        // key: numeric tag id, the corresponding string is bcf_hdr_t::id[BCF_DT_ID][$key].key
-    int type;  // type: one of BCF_BT_* types
-    union {
-        int64_t i; // integer value
-        float f;   // float value
-    } v1; // only set if $len==1; for easier access
-    uint8_t *vptr;          // pointer to data array in bcf1_t->shared.s, excluding the size+type and tag id bytes
-    uint32_t vptr_len;      // length of the vptr block or, when set, of the vptr_mod block, excluding offset
-    uint32_t vptr_off:31,   // vptr offset, i.e., the size of the INFO key plus size+type bytes
-            vptr_free:1;    // indicates that vptr-vptr_off must be freed; set only when modified and the new
-                            //    data block is bigger than the original
-    int len;                // vector length, 1 for scalars
-} bcf_info_t;
-
-
-#define BCF1_DIRTY_ID  1
-#define BCF1_DIRTY_ALS 2
-#define BCF1_DIRTY_FLT 4
-#define BCF1_DIRTY_INF 8
-
-typedef struct bcf_dec_t {
-    int m_fmt, m_info, m_id, m_als, m_allele, m_flt; // allocated size (high-water mark); do not change
-    int n_flt;  // Number of FILTER fields
-    int *flt;   // FILTER keys in the dictionary
-    char *id, *als;     // ID and REF+ALT block (\0-separated)
-    char **allele;      // allele[0] is the REF (allele[] pointers to the als block); all null terminated
-    bcf_info_t *info;   // INFO
-    bcf_fmt_t *fmt;     // FORMAT and individual sample
-    bcf_variant_t *var; // $var and $var_type set only when set_variant_types called
-    int n_var, var_type;
-    int shared_dirty;   // if set, shared.s must be recreated on BCF output
-    int indiv_dirty;    // if set, indiv.s must be recreated on BCF output
-} bcf_dec_t;
-
-
-#define BCF_ERR_CTG_UNDEF 1
-#define BCF_ERR_TAG_UNDEF 2
-#define BCF_ERR_NCOLS     4
-#define BCF_ERR_LIMITS    8
-#define BCF_ERR_CHAR     16
-#define BCF_ERR_CTG_INVALID   32
-#define BCF_ERR_TAG_INVALID   64
-
-/*
-    The bcf1_t structure corresponds to one VCF/BCF line. Reading from VCF file
-    is slower because the string is first to be parsed, packed into BCF line
-    (done in vcf_parse), then unpacked into internal bcf1_t structure. If it
-    is known in advance that some of the fields will not be required (notably
-    the sample columns), parsing of these can be skipped by setting max_unpack
-    appropriately.
-    Similarly, it is fast to output a BCF line because the columns (kept in
-    shared.s, indiv.s, etc.) are written directly by bcf_write, whereas a VCF
-    line must be formatted in vcf_format.
- */
-typedef struct bcf1_t {
-    hts_pos_t pos;  // POS
-    hts_pos_t rlen; // length of REF
-    int32_t rid;  // CHROM
-    float qual;   // QUAL
-    uint32_t n_info:16, n_allele:16;
-    uint32_t n_fmt:8, n_sample:24;
-    kstring_t shared, indiv;
-    bcf_dec_t d; // lazy evaluation: $d is not generated by bcf_read(), but by explicitly calling bcf_unpack()
-    int max_unpack;         // Set to BCF_UN_STR, BCF_UN_FLT, or BCF_UN_INFO to boost performance of vcf_parse when some of the fields won't be needed
-    int unpacked;           // remember what has been unpacked to allow calling bcf_unpack() repeatedly without redoing the work
-    int unpack_size[3];     // the original block size of ID, REF+ALT and FILTER
-    int errcode;    // one of BCF_ERR_* codes
-} bcf1_t;
-
-/*******
- * API *
- *******/
-
-    /***********************************************************************
-     *  BCF and VCF I/O
-     *
-     *  A note about naming conventions: htslib internally represents VCF
-     *  records as bcf1_t data structures, therefore most functions are
-     *  prefixed with bcf_. There are a few exceptions where the functions must
-     *  be aware of both BCF and VCF worlds, such as bcf_parse vs vcf_parse. In
-     *  these cases, functions prefixed with bcf_ are more general and work
-     *  with both BCF and VCF.
-     *
-     ***********************************************************************/
-
-    /** These macros are defined only for consistency with other parts of htslib */
-    #define bcf_init1()         bcf_init()
-    #define bcf_read1(fp,h,v)   bcf_read((fp),(h),(v))
-    #define vcf_read1(fp,h,v)   vcf_read((fp),(h),(v))
-    #define bcf_write1(fp,h,v)  bcf_write((fp),(h),(v))
-    #define vcf_write1(fp,h,v)  vcf_write((fp),(h),(v))
-    #define bcf_destroy1(v)     bcf_destroy(v)
-    #define bcf_empty1(v)       bcf_empty(v)
-    #define vcf_parse1(s,h,v)   vcf_parse((s),(h),(v))
-    #define bcf_clear1(v)       bcf_clear(v)
-    #define vcf_format1(h,v,s)  vcf_format((h),(v),(s))
-
-    /**
-     *  bcf_hdr_init() - create an empty BCF header.
-     *  @param mode    "r" or "w"
-     *
-     *  When opened for writing, the mandatory fileFormat and
-     *  FILTER=PASS lines are added automatically.
-     *
-     * The bcf_hdr_t struct returned by a successful call should be freed
-     * via bcf_hdr_destroy() when it is no longer needed.
-     */
-    HTSLIB_EXPORT
-    bcf_hdr_t *bcf_hdr_init(const char *mode);
-
-    /** Destroy a BCF header struct */
-    HTSLIB_EXPORT
-    void bcf_hdr_destroy(bcf_hdr_t *h);
-
-    /** Allocate and initialize a bcf1_t object.
-     *
-     * The bcf1_t struct returned by a successful call should be freed
-     * via bcf_destroy() when it is no longer needed.
-     */
-    HTSLIB_EXPORT
-    bcf1_t *bcf_init(void);
-
-    /** Deallocate a bcf1_t object */
-    HTSLIB_EXPORT
-    void bcf_destroy(bcf1_t *v);
-
-    /**
-     *  Same as bcf_destroy() but frees only the memory allocated by bcf1_t,
-     *  not the bcf1_t object itself.
-     */
-    HTSLIB_EXPORT
-    void bcf_empty(bcf1_t *v);
-
-    /**
-     *  Make the bcf1_t object ready for next read. Intended mostly for
-     *  internal use, the user should rarely need to call this function
-     *  directly.
-     */
-    HTSLIB_EXPORT
-    void bcf_clear(bcf1_t *v);
-
-
-    /** bcf_open and vcf_open mode: please see hts_open() in hts.h */
-    typedef htsFile vcfFile;
-    #define bcf_open(fn, mode) hts_open((fn), (mode))
-    #define vcf_open(fn, mode) hts_open((fn), (mode))
-    #define bcf_close(fp) hts_close(fp)
-    #define vcf_close(fp) hts_close(fp)
-
-    /// Read a VCF or BCF header
-    /** @param  fp  The file to read the header from
-        @return Pointer to a populated header structure on success;
-                NULL on failure
-
-        The bcf_hdr_t struct returned by a successful call should be freed
-        via bcf_hdr_destroy() when it is no longer needed.
-    */
-    HTSLIB_EXPORT
-    bcf_hdr_t *bcf_hdr_read(htsFile *fp) HTS_RESULT_USED;
-
-    /**
-     *  bcf_hdr_set_samples() - for more efficient VCF parsing when only one/few samples are needed
-     *  @param samples  samples to include or exclude from file or as a comma-separated string.
-     *              LIST|FILE   .. select samples in list/file
-     *              ^LIST|FILE  .. exclude samples from list/file
-     *              -           .. include all samples
-     *              NULL        .. exclude all samples
-     *  @param is_file  @p samples is a file (1) or a comma-separated list (0)
-     *
-     *  The bottleneck of VCF reading is parsing of genotype fields. If the
-     *  reader knows in advance that only subset of samples is needed (possibly
-     *  no samples at all), the performance of bcf_read() can be significantly
-     *  improved by calling bcf_hdr_set_samples after bcf_hdr_read().
-     *  The function bcf_read() will subset the VCF/BCF records automatically
-     *  with the notable exception when reading records via bcf_itr_next().
-     *  In this case, bcf_subset_format() must be called explicitly, because
-     *  bcf_readrec() does not see the header.
-     *
-     *  Returns 0 on success, -1 on error or a positive integer if the list
-     *  contains samples not present in the VCF header. In such a case, the
-     *  return value is the index of the offending sample.
-     */
-    HTSLIB_EXPORT
-    int bcf_hdr_set_samples(bcf_hdr_t *hdr, const char *samples, int is_file) HTS_RESULT_USED;
-
-    HTSLIB_EXPORT
-    int bcf_subset_format(const bcf_hdr_t *hdr, bcf1_t *rec);
-
-    /// Write a VCF or BCF header
-    /** @param  fp  Output file
-        @param  h   The header to write
-        @return 0 on success; -1 on failure
-     */
-    HTSLIB_EXPORT
-    int bcf_hdr_write(htsFile *fp, bcf_hdr_t *h) HTS_RESULT_USED;
-
-    /**
-     * Parse VCF line contained in kstring and populate the bcf1_t struct
-     * The line must not end with \n or \r characters.
-     */
-    HTSLIB_EXPORT
-    int vcf_parse(kstring_t *s, const bcf_hdr_t *h, bcf1_t *v);
-
-    /**
-     * Complete the file opening mode, according to its extension.
-     * @param mode      Preallocated mode string to be completed.
-     * @param fn        File name to be opened.
-     * @param format    Format string (vcf|bcf|vcf.gz)
-     * @return          0 on success; -1 on failure
-     */
-    HTSLIB_EXPORT
-    int vcf_open_mode(char *mode, const char *fn, const char *format);
-
-    /** The opposite of vcf_parse. It should rarely be called directly, see vcf_write */
-    HTSLIB_EXPORT
-    int vcf_format(const bcf_hdr_t *h, const bcf1_t *v, kstring_t *s);
-
-    /// Read next VCF or BCF record
-    /** @param fp  The file to read the record from
-        @param h   The header for the vcf/bcf file
-        @param v   The bcf1_t structure to populate
-        @return 0 on success; -1 on end of file; < -1 on critical error
-
-On errors which are not critical for reading, such as missing header
-definitions in vcf files, zero will be returned but v->errcode will have been
-set to one of BCF_ERR* codes and must be checked before calling bcf_write().
-     */
-    HTSLIB_EXPORT
-    int bcf_read(htsFile *fp, const bcf_hdr_t *h, bcf1_t *v) HTS_RESULT_USED;
-
-    /**
-     *  bcf_unpack() - unpack/decode a BCF record (fills the bcf1_t::d field)
-     *
-     *  Note that bcf_unpack() must be called even when reading VCF. It is safe
-     *  to call the function repeatedly, it will not unpack the same field
-     *  twice.
-     */
-    #define BCF_UN_STR  1       // up to ALT inclusive
-    #define BCF_UN_FLT  2       // up to FILTER
-    #define BCF_UN_INFO 4       // up to INFO
-    #define BCF_UN_SHR  (BCF_UN_STR|BCF_UN_FLT|BCF_UN_INFO) // all shared information
-    #define BCF_UN_FMT  8                           // unpack format and each sample
-    #define BCF_UN_IND  BCF_UN_FMT                  // a synonym of BCF_UN_FMT
-    #define BCF_UN_ALL  (BCF_UN_SHR|BCF_UN_FMT)     // everything
-    HTSLIB_EXPORT
-    int bcf_unpack(bcf1_t *b, int which);
-
-    /*
-     *  bcf_dup() - create a copy of BCF record.
-     *
-     *  Note that bcf_unpack() must be called on the returned copy as if it was
-     *  obtained from bcf_read(). Also note that bcf_dup() calls bcf_sync1(src)
-     *  internally to reflect any changes made by bcf_update_* functions.
-     *
-     *  The bcf1_t struct returned by a successful call should be freed
-     *  via bcf_destroy() when it is no longer needed.
-     */
-    HTSLIB_EXPORT
-    bcf1_t *bcf_dup(bcf1_t *src);
-
-    HTSLIB_EXPORT
-    bcf1_t *bcf_copy(bcf1_t *dst, bcf1_t *src);
-
-    /// Write one VCF or BCF record. The type is determined at the open() call.
-    /** @param  fp  The file to write to
-        @param  h   The header for the vcf/bcf file
-        @param  v   The bcf1_t structure to write
-        @return 0 on success; -1 on error
-     */
-    HTSLIB_EXPORT
-    int bcf_write(htsFile *fp, bcf_hdr_t *h, bcf1_t *v) HTS_RESULT_USED;
-
-    /**
-     *  The following functions work only with VCFs and should rarely be called
-     *  directly. Usually one wants to use their bcf_* alternatives, which work
-     *  transparently with both VCFs and BCFs.
-     */
-    /// Read a VCF format header
-    /** @param  fp  The file to read the header from
-        @return Pointer to a populated header structure on success;
-                NULL on failure
-
-        Use bcf_hdr_read() instead.
-
-        The bcf_hdr_t struct returned by a successful call should be freed
-        via bcf_hdr_destroy() when it is no longer needed.
-    */
-    HTSLIB_EXPORT
-    bcf_hdr_t *vcf_hdr_read(htsFile *fp) HTS_RESULT_USED;
-
-    /// Write a VCF format header
-    /** @param  fp  Output file
-        @param  h   The header to write
-        @return 0 on success; -1 on failure
-
-        Use bcf_hdr_write() instead
-    */
-    HTSLIB_EXPORT
-    int vcf_hdr_write(htsFile *fp, const bcf_hdr_t *h) HTS_RESULT_USED;
-
-    /// Read a record from a VCF file
-    /** @param fp  The file to read the record from
-        @param h   The header for the vcf file
-        @param v   The bcf1_t structure to populate
-        @return 0 on success; -1 on end of file; < -1 on error
-
-        Use bcf_read() instead
-    */
-    HTSLIB_EXPORT
-    int vcf_read(htsFile *fp, const bcf_hdr_t *h, bcf1_t *v) HTS_RESULT_USED;
-
-    /// Write a record to a VCF file
-    /** @param  fp  The file to write to
-        @param h   The header for the vcf file
-        @param v   The bcf1_t structure to write
-        @return 0 on success; -1 on error
-
-        Use bcf_write() instead
-    */
-    HTSLIB_EXPORT
-    int vcf_write(htsFile *fp, const bcf_hdr_t *h, bcf1_t *v) HTS_RESULT_USED;
-
-    /** Helper function for the bcf_itr_next() macro; internal use, ignore it */
-    HTSLIB_EXPORT
-    int bcf_readrec(BGZF *fp, void *null, void *v, int *tid, hts_pos_t *beg, hts_pos_t *end);
-
-    /// Write a line to a VCF file
-    /** @param line   Line to write
-        @param fp     File to write it to
-        @return 0 on success; -1 on failure
-
-        @note No checks are done on the line being added, apart from
-              ensuring that it ends with a newline.  This function
-              should therefore be used with care.
-    */
-    HTSLIB_EXPORT
-    int vcf_write_line(htsFile *fp, kstring_t *line);
-
-    /**************************************************************************
-     *  Header querying and manipulation routines
-     **************************************************************************/
-
-    /** Create a new header using the supplied template
-     *
-     *  The bcf_hdr_t struct returned by a successful call should be freed
-     *  via bcf_hdr_destroy() when it is no longer needed.
-     *  @return NULL on failure, header otherwise
-     */
-    HTSLIB_EXPORT
-    bcf_hdr_t *bcf_hdr_dup(const bcf_hdr_t *hdr);
-
-    /**
-     *  Copy header lines from src to dst if not already present in dst. See also bcf_translate().
-     *  Returns 0 on success or sets a bit on error:
-     *      1 .. conflicting definitions of tag length
-     *      // todo
-     */
-    HTSLIB_EXPORT
-    int bcf_hdr_combine(bcf_hdr_t *dst, const bcf_hdr_t *src) HTS_DEPRECATED("Please use bcf_hdr_merge instead");
-
-    /**
-     *  bcf_hdr_merge() - copy header lines from src to dst, see also bcf_translate()
-     *  @param dst: the destination header to be merged into, NULL on the first pass
-     *  @param src: the source header
-     *  @return NULL on failure, header otherwise
-     *
-     *  Notes:
-     *      - use as:
-     *          bcf_hdr_t *dst = NULL;
-     *          for (i=0; i<nsrc; i++) dst = bcf_hdr_merge(dst,src[i]);
-     *
-     *      - bcf_hdr_merge() replaces bcf_hdr_combine() which had a problem when
-     *      combining multiple BCF headers. The current bcf_hdr_combine()
-     *      does not have this problem, but became slow when used for many files.
-     */
-    HTSLIB_EXPORT
-    bcf_hdr_t *bcf_hdr_merge(bcf_hdr_t *dst, const bcf_hdr_t *src);
-
-    /**
-     *  bcf_hdr_add_sample() - add a new sample.
-     *  @param sample:  sample name to be added
-     *
-     *  Note:
-     *      After all samples have been added, the internal header structure must be updated
-     *      by calling bcf_hdr_sync(). This is normally done automatically by the first bcf_hdr_write()
-     *      or bcf_write() call. Otherwise, the caller must force the update by calling bcf_hdr_sync()
-     *      explicitly.
-     */
-    HTSLIB_EXPORT
-    int bcf_hdr_add_sample(bcf_hdr_t *hdr, const char *sample);
-
-    /** Read VCF header from a file and update the header */
-    HTSLIB_EXPORT
-    int bcf_hdr_set(bcf_hdr_t *hdr, const char *fname);
-
-    /// Appends formatted header text to _str_.
-    /** If _is_bcf_ is zero, `IDX` fields are discarded.
-     *  @return 0 if successful, or negative if an error occurred
-     *  @since 1.4
-     */
-    HTSLIB_EXPORT
-    int bcf_hdr_format(const bcf_hdr_t *hdr, int is_bcf, kstring_t *str);
-
-    /** Returns formatted header (newly allocated string) and its length,
-     *  excluding the terminating \0. If is_bcf parameter is unset, IDX
-     *  fields are discarded.
-     *  @deprecated Use bcf_hdr_format() instead as it can handle huge headers.
-     */
-    HTSLIB_EXPORT
-    char *bcf_hdr_fmt_text(const bcf_hdr_t *hdr, int is_bcf, int *len)
-        HTS_DEPRECATED("use bcf_hdr_format() instead");
-
-    /** Append new VCF header line, returns 0 on success */
-    HTSLIB_EXPORT
-    int bcf_hdr_append(bcf_hdr_t *h, const char *line);
-
-    HTSLIB_EXPORT
-    int bcf_hdr_printf(bcf_hdr_t *h, const char *format, ...);
-
-    /** VCF version, e.g. VCFv4.2 */
-    HTSLIB_EXPORT
-    const char *bcf_hdr_get_version(const bcf_hdr_t *hdr);
-
-    /// Set version in bcf header
-    /**
-       @param hdr     BCF header struct
-       @param version Version to set, e.g. "VCFv4.3"
-       @return 0 on success; < 0 on error
-     */
-    HTSLIB_EXPORT
-    int bcf_hdr_set_version(bcf_hdr_t *hdr, const char *version);
-
-    /**
-     *  bcf_hdr_remove() - remove VCF header tag
-     *  @param type:      one of BCF_HL_*
-     *  @param key:       tag name or NULL to remove all tags of the given type
-     */
-    HTSLIB_EXPORT
-    void bcf_hdr_remove(bcf_hdr_t *h, int type, const char *key);
-
-    /**
-     *  bcf_hdr_subset() - creates a new copy of the header removing unwanted samples
-     *  @param n:        number of samples to keep
-     *  @param samples:  names of the samples to keep
-     *  @param imap:     mapping from index in @samples to the sample index in the original file
-     *  @return NULL on failure, header otherwise
-     *
-     *  Sample names not present in h0 are ignored. The number of unmatched samples can be checked
-     *  by comparing n and bcf_hdr_nsamples(out_hdr).
-     *  This function can be used to reorder samples.
-     *  See also bcf_subset() which subsets individual records.
-     *  The bcf_hdr_t struct returned by a successful call should be freed
-     *  via bcf_hdr_destroy() when it is no longer needed.
-     */
-    HTSLIB_EXPORT
-    bcf_hdr_t *bcf_hdr_subset(const bcf_hdr_t *h0, int n, char *const* samples, int *imap);
-
-    /** Creates a list of sequence names. It is up to the caller to free the list (but not the sequence names) */
-    HTSLIB_EXPORT
-    const char **bcf_hdr_seqnames(const bcf_hdr_t *h, int *nseqs);
-
-    /** Get number of samples */
-    #define bcf_hdr_nsamples(hdr) (hdr)->n[BCF_DT_SAMPLE]
-
-
-    /** The following functions are for internal use and should rarely be called directly */
-    HTSLIB_EXPORT
-    int bcf_hdr_parse(bcf_hdr_t *hdr, char *htxt);
-
-    /// Synchronize internal header structures
-    /** @param h  Header
-        @return 0 on success, -1 on failure
-
-        This function updates the id, sample and contig arrays in the
-        bcf_hdr_t structure so that they point to the same locations as
-        the id, sample and contig dictionaries.
-    */
-    HTSLIB_EXPORT
-    int bcf_hdr_sync(bcf_hdr_t *h) HTS_RESULT_USED;
-
-    /**
-     * bcf_hdr_parse_line() - parse a single line of VCF textual header
-     * @param h     BCF header struct
-     * @param line  One or more lines of header text
-     * @param len   Filled out with length data parsed from 'line'.
-     * @return bcf_hrec_t* on success;
-     *         NULL on error or on end of header text.
-     *         NB: to distinguish error from end-of-header, check *len:
-     *           *len == 0 indicates @p line did not start with "##"
-     *           *len == -1 indicates failure, likely due to out of memory
-     *           *len > 0 indicates a malformed header line
-     *
-     * If *len > 0 on exit, it will contain the full length of the line
-     * including any trailing newline (this includes cases where NULL was
-     * returned due to a malformed line).  Callers can use this to skip to
-     * the next header line.
-     */
-    HTSLIB_EXPORT
-    bcf_hrec_t *bcf_hdr_parse_line(const bcf_hdr_t *h, const char *line, int *len);
-    /// Convert a bcf header record to string form
-    /**
-     * @param hrec    Header record
-     * @param str     Destination kstring
-     * @return 0 on success; < 0 on error
-     */
-    HTSLIB_EXPORT
-    int bcf_hrec_format(const bcf_hrec_t *hrec, kstring_t *str);
-
-    HTSLIB_EXPORT
-    int bcf_hdr_add_hrec(bcf_hdr_t *hdr, bcf_hrec_t *hrec);
-
-    /**
-     *  bcf_hdr_get_hrec() - get header line info
-     *  @param type:  one of the BCF_HL_* types: FLT,INFO,FMT,CTG,STR,GEN
-     *  @param key:   the header key for generic lines (e.g. "fileformat"), any field
-     *                  for structured lines, typically "ID".
-     *  @param value: the value which pairs with key. Can be be NULL for BCF_HL_GEN
-     *  @param str_class: the class of BCF_HL_STR line (e.g. "ALT" or "SAMPLE"), otherwise NULL
-     */
-    HTSLIB_EXPORT
-    bcf_hrec_t *bcf_hdr_get_hrec(const bcf_hdr_t *hdr, int type, const char *key, const char *value, const char *str_class);
-
-    /// Duplicate a header record
-    /** @param hrec   Header record to copy
-        @return A new header record on success; NULL on failure
-
-        The bcf_hrec_t struct returned by a successful call should be freed
-        via bcf_hrec_destroy() when it is no longer needed.
-    */
-    HTSLIB_EXPORT
-    bcf_hrec_t *bcf_hrec_dup(bcf_hrec_t *hrec);
-
-    /// Add a new header record key
-    /** @param hrec  Header record
-        @param str   Key name
-        @param len   Length of @p str
-        @return 0 on success; -1 on failure
-    */
-    HTSLIB_EXPORT
-    int bcf_hrec_add_key(bcf_hrec_t *hrec, const char *str, size_t len) HTS_RESULT_USED;
-
-    /// Set a header record value
-    /** @param hrec      Header record
-        @param i         Index of value
-        @param str       Value to set
-        @param len       Length of @p str
-        @param is_quoted Value should be quoted
-        @return 0 on success; -1 on failure
-    */
-    HTSLIB_EXPORT
-    int bcf_hrec_set_val(bcf_hrec_t *hrec, int i, const char *str, size_t len, int is_quoted) HTS_RESULT_USED;
-
-    HTSLIB_EXPORT
-    int bcf_hrec_find_key(bcf_hrec_t *hrec, const char *key);
-
-
-    /// Add an IDX header record
-    /** @param hrec   Header record
-        @param idx    IDX value to add
-        @return 0 on success; -1 on failure
-    */
-    HTSLIB_EXPORT
-    int hrec_add_idx(bcf_hrec_t *hrec, int idx) HTS_RESULT_USED;
-
-    /// Free up a header record and associated structures
-    /** @param hrec  Header record
-     */
-    HTSLIB_EXPORT
-    void bcf_hrec_destroy(bcf_hrec_t *hrec);
-
-
-
-    /**************************************************************************
-     *  Individual record querying and manipulation routines
-     **************************************************************************/
-
-    /** See the description of bcf_hdr_subset() */
-    HTSLIB_EXPORT
-    int bcf_subset(const bcf_hdr_t *h, bcf1_t *v, int n, int *imap);
-
-    /**
-     *  bcf_translate() - translate tags ids to be consistent with different header. This function
-     *                    is useful when lines from multiple VCF need to be combined.
-     *  @dst_hdr:   the destination header, to be used in bcf_write(), see also bcf_hdr_combine()
-     *  @src_hdr:   the source header, used in bcf_read()
-     *  @src_line:  line obtained by bcf_read()
-     */
-    HTSLIB_EXPORT
-    int bcf_translate(const bcf_hdr_t *dst_hdr, bcf_hdr_t *src_hdr, bcf1_t *src_line);
-
-    /**
-     *  bcf_get_variant_type[s]()  - returns one of VCF_REF, VCF_SNP, etc
-     */
-    HTSLIB_EXPORT
-    int bcf_get_variant_types(bcf1_t *rec);
-
-    HTSLIB_EXPORT
-    int bcf_get_variant_type(bcf1_t *rec, int ith_allele);
-
-    HTSLIB_EXPORT
-    int bcf_is_snp(bcf1_t *v);
-
-    /**
-     *  bcf_update_filter() - sets the FILTER column
-     *  @flt_ids:  The filter IDs to set, numeric IDs returned by bcf_hdr_id2int(hdr, BCF_DT_ID, "PASS")
-     *  @n:        Number of filters. If n==0, all filters are removed
-     */
-    HTSLIB_EXPORT
-    int bcf_update_filter(const bcf_hdr_t *hdr, bcf1_t *line, int *flt_ids, int n);
-    /**
-     *  bcf_add_filter() - adds to the FILTER column
-     *  @flt_id:   filter ID to add, numeric ID returned by bcf_hdr_id2int(hdr, BCF_DT_ID, "PASS")
-     *
-     *  If flt_id is PASS, all existing filters are removed first. If other than PASS, existing PASS is removed.
-     */
-    HTSLIB_EXPORT
-    int bcf_add_filter(const bcf_hdr_t *hdr, bcf1_t *line, int flt_id);
-    /**
-     *  bcf_remove_filter() - removes from the FILTER column
-     *  @flt_id:   filter ID to remove, numeric ID returned by bcf_hdr_id2int(hdr, BCF_DT_ID, "PASS")
-     *  @pass:     when set to 1 and no filters are present, set to PASS
-     */
-    HTSLIB_EXPORT
-    int bcf_remove_filter(const bcf_hdr_t *hdr, bcf1_t *line, int flt_id, int pass);
-    /**
-     *  Returns 1 if present, 0 if absent, or -1 if filter does not exist. "PASS" and "." can be used interchangeably.
-     */
-    HTSLIB_EXPORT
-    int bcf_has_filter(const bcf_hdr_t *hdr, bcf1_t *line, char *filter);
-    /**
-     *  bcf_update_alleles() and bcf_update_alleles_str() - update REF and ALT column
-     *  @alleles:           Array of alleles
-     *  @nals:              Number of alleles
-     *  @alleles_string:    Comma-separated alleles, starting with the REF allele
-     */
-    HTSLIB_EXPORT
-    int bcf_update_alleles(const bcf_hdr_t *hdr, bcf1_t *line, const char **alleles, int nals);
-
-    HTSLIB_EXPORT
-    int bcf_update_alleles_str(const bcf_hdr_t *hdr, bcf1_t *line, const char *alleles_string);
-
-    /**
-      *  bcf_update_id() - sets new ID string
-      *  bcf_add_id() - adds to the ID string checking for duplicates
-      */
-    HTSLIB_EXPORT
-    int bcf_update_id(const bcf_hdr_t *hdr, bcf1_t *line, const char *id);
-
-    HTSLIB_EXPORT
-    int bcf_add_id(const bcf_hdr_t *hdr, bcf1_t *line, const char *id);
-
-    /**
-     *  bcf_update_info_*() - functions for updating INFO fields
-     *  @param hdr:       the BCF header
-     *  @param line:      VCF line to be edited
-     *  @param key:       the INFO tag to be updated
-     *  @param values:    pointer to the array of values. Pass NULL to remove the tag.
-     *  @param n:         number of values in the array. When set to 0, the INFO tag is removed
-     *  @return 0 on success or negative value on error.
-     *
-     *  The @p string in bcf_update_info_flag() is optional,
-     *  @p n indicates whether the flag is set or removed.
-     *
-     *  Note that updating an END info tag will cause line->rlen to be
-     *  updated as a side-effect (removing the tag will set it to the
-     *  string length of the REF allele). If line->pos is being changed as
-     *  well, it is important that this is done before calling
-     *  bcf_update_info_int32() to update the END tag, otherwise rlen will be
-     *  set incorrectly.  If the new END value is less than or equal to
-     *  line->pos, a warning will be printed and line->rlen will be set to
-     *  the length of the REF allele.
-     */
-    #define bcf_update_info_int32(hdr,line,key,values,n)   bcf_update_info((hdr),(line),(key),(values),(n),BCF_HT_INT)
-    #define bcf_update_info_float(hdr,line,key,values,n)   bcf_update_info((hdr),(line),(key),(values),(n),BCF_HT_REAL)
-    #define bcf_update_info_flag(hdr,line,key,string,n)    bcf_update_info((hdr),(line),(key),(string),(n),BCF_HT_FLAG)
-    #define bcf_update_info_string(hdr,line,key,string)    bcf_update_info((hdr),(line),(key),(string),1,BCF_HT_STR)
-    HTSLIB_EXPORT
-    int bcf_update_info(const bcf_hdr_t *hdr, bcf1_t *line, const char *key, const void *values, int n, int type);
-
-    /// Set or update 64-bit integer INFO values
-    /**
-     *  @param hdr:       the BCF header
-     *  @param line:      VCF line to be edited
-     *  @param key:       the INFO tag to be updated
-     *  @param values:    pointer to the array of values. Pass NULL to remove the tag.
-     *  @param n:         number of values in the array. When set to 0, the INFO tag is removed
-     *  @return 0 on success or negative value on error.
-     *
-     *  This function takes an int64_t values array as input.  The data
-     *  actually stored will be shrunk to the minimum size that can
-     *  accept all of the values.
-     *
-     *  INFO values outside of the range BCF_MIN_BT_INT32 to BCF_MAX_BT_INT32
-     *  can only be written to VCF files.
-     */
-    static inline int bcf_update_info_int64(const bcf_hdr_t *hdr, bcf1_t *line,
-                                            const char *key,
-                                            const int64_t *values, int n)
-    {
-        return bcf_update_info(hdr, line, key, values, n, BCF_HT_LONG);
-    }
-
-    /*
-     *  bcf_update_format_*() - functions for updating FORMAT fields
-     *  @values:    pointer to the array of values, the same number of elements
-     *              is expected for each sample. Missing values must be padded
-     *              with bcf_*_missing or bcf_*_vector_end values.
-     *  @n:         number of values in the array. If n==0, existing tag is removed.
-     *
-     *  The function bcf_update_format_string() is a higher-level (slower) variant of
-     *  bcf_update_format_char(). The former accepts array of \0-terminated strings
-     *  whereas the latter requires that the strings are collapsed into a single array
-     *  of fixed-length strings. In case of strings with variable length, shorter strings
-     *  can be \0-padded. Note that the collapsed strings passed to bcf_update_format_char()
-     *  are not \0-terminated.
-     *
-     *  Returns 0 on success or negative value on error.
-     */
-    #define bcf_update_format_int32(hdr,line,key,values,n) bcf_update_format((hdr),(line),(key),(values),(n),BCF_HT_INT)
-    #define bcf_update_format_float(hdr,line,key,values,n) bcf_update_format((hdr),(line),(key),(values),(n),BCF_HT_REAL)
-    #define bcf_update_format_char(hdr,line,key,values,n) bcf_update_format((hdr),(line),(key),(values),(n),BCF_HT_STR)
-    #define bcf_update_genotypes(hdr,line,gts,n) bcf_update_format((hdr),(line),"GT",(gts),(n),BCF_HT_INT)     // See bcf_gt_ macros below
-
-    HTSLIB_EXPORT
-    int bcf_update_format_string(const bcf_hdr_t *hdr, bcf1_t *line, const char *key, const char **values, int n);
-
-    HTSLIB_EXPORT
-    int bcf_update_format(const bcf_hdr_t *hdr, bcf1_t *line, const char *key, const void *values, int n, int type);
-
-    // Macros for setting genotypes correctly, for use with bcf_update_genotypes only; idx corresponds
-    // to VCF's GT (1-based index to ALT or 0 for the reference allele) and val is the opposite, obtained
-    // from bcf_get_genotypes() below.
-    #define bcf_gt_phased(idx)      (((idx)+1)<<1|1)
-    #define bcf_gt_unphased(idx)    (((idx)+1)<<1)
-    #define bcf_gt_missing          0
-    #define bcf_gt_is_missing(val)  ((val)>>1 ? 0 : 1)
-    #define bcf_gt_is_phased(idx)   ((idx)&1)
-    #define bcf_gt_allele(val)      (((val)>>1)-1)
-
-    /** Conversion between alleles indexes to Number=G genotype index (assuming diploid, all 0-based) */
-    #define bcf_alleles2gt(a,b) ((a)>(b)?((a)*((a)+1)/2+(b)):((b)*((b)+1)/2+(a)))
-    static inline void bcf_gt2alleles(int igt, int *a, int *b)
-    {
-        int k = 0, dk = 1;
-        while ( k<igt ) { dk++; k += dk; }
-        *b = dk - 1; *a = igt - k + *b;
-    }
-
-    /**
-     * bcf_get_fmt() - returns pointer to FORMAT's field data
-     * @header: for access to BCF_DT_ID dictionary
-     * @line:   VCF line obtained from vcf_parse1
-     * @fmt:    one of GT,PL,...
-     *
-     * Returns bcf_fmt_t* if the call succeeded, or returns NULL when the field
-     * is not available.
-     */
-    HTSLIB_EXPORT
-    bcf_fmt_t *bcf_get_fmt(const bcf_hdr_t *hdr, bcf1_t *line, const char *key);
-
-    HTSLIB_EXPORT
-    bcf_info_t *bcf_get_info(const bcf_hdr_t *hdr, bcf1_t *line, const char *key);
-
-    /**
-     * bcf_get_*_id() - returns pointer to FORMAT/INFO field data given the header index instead of the string ID
-     * @line: VCF line obtained from vcf_parse1
-     * @id:  The header index for the tag, obtained from bcf_hdr_id2int()
-     *
-     * Returns bcf_fmt_t* / bcf_info_t*. These functions do not check if the index is valid
-     * as their goal is to avoid the header lookup.
-     */
-    HTSLIB_EXPORT
-    bcf_fmt_t *bcf_get_fmt_id(bcf1_t *line, const int id);
-
-    HTSLIB_EXPORT
-    bcf_info_t *bcf_get_info_id(bcf1_t *line, const int id);
-
-    /**
-     *  bcf_get_info_*() - get INFO values, integers or floats
-     *  @param hdr:    BCF header
-     *  @param line:   BCF record
-     *  @param tag:    INFO tag to retrieve
-     *  @param dst:    *dst is pointer to a memory location, can point to NULL
-     *  @param ndst:   pointer to the size of allocated memory
-     *  @return  >=0 on success
-     *          -1 .. no such INFO tag defined in the header
-     *          -2 .. clash between types defined in the header and encountered in the VCF record
-     *          -3 .. tag is not present in the VCF record
-     *          -4 .. the operation could not be completed (e.g. out of memory)
-     *
-     *  Returns negative value on error or the number of values (including
-     *  missing values) put in *dst on success. bcf_get_info_string() returns
-     *  on success the number of characters stored excluding the nul-
-     *  terminating byte. bcf_get_info_flag() does not store anything in *dst
-     *  but returns 1 if the flag is set or 0 if not.
-     *
-     *  *dst will be reallocated if it is not big enough (i.e. *ndst is too
-     *  small) or NULL on entry.  The new size will be stored in *ndst.
-     */
-    #define bcf_get_info_int32(hdr,line,tag,dst,ndst)  bcf_get_info_values(hdr,line,tag,(void**)(dst),ndst,BCF_HT_INT)
-    #define bcf_get_info_float(hdr,line,tag,dst,ndst)  bcf_get_info_values(hdr,line,tag,(void**)(dst),ndst,BCF_HT_REAL)
-    #define bcf_get_info_string(hdr,line,tag,dst,ndst) bcf_get_info_values(hdr,line,tag,(void**)(dst),ndst,BCF_HT_STR)
-    #define bcf_get_info_flag(hdr,line,tag,dst,ndst)   bcf_get_info_values(hdr,line,tag,(void**)(dst),ndst,BCF_HT_FLAG)
-
-    HTSLIB_EXPORT
-    int bcf_get_info_values(const bcf_hdr_t *hdr, bcf1_t *line, const char *tag, void **dst, int *ndst, int type);
-
-    /// Put integer INFO values into an int64_t array
-    /**
-     *  @param hdr:    BCF header
-     *  @param line:   BCF record
-     *  @param tag:    INFO tag to retrieve
-     *  @param dst:    *dst is pointer to a memory location, can point to NULL
-     *  @param ndst:   pointer to the size of allocated memory
-     *  @return  >=0 on success
-     *          -1 .. no such INFO tag defined in the header
-     *          -2 .. clash between types defined in the header and encountered in the VCF record
-     *          -3 .. tag is not present in the VCF record
-     *          -4 .. the operation could not be completed (e.g. out of memory)
-     *
-     *  Returns negative value on error or the number of values (including
-     *  missing values) put in *dst on success.
-     *
-     *  *dst will be reallocated if it is not big enough (i.e. *ndst is too
-     *  small) or NULL on entry.  The new size will be stored in *ndst.
-     */
-    static inline int bcf_get_info_int64(const bcf_hdr_t *hdr, bcf1_t *line,
-                                         const char *tag, int64_t **dst,
-                                         int *ndst)
-    {
-        return bcf_get_info_values(hdr, line, tag,
-                                   (void **) dst, ndst, BCF_HT_LONG);
-    }
-
-    /**
-     *  bcf_get_format_*() - same as bcf_get_info*() above
-     *
-     *  The function bcf_get_format_string() is a higher-level (slower) variant of bcf_get_format_char().
-     *  see the description of bcf_update_format_string() and bcf_update_format_char() above.
-     *  Unlike other bcf_get_format__*() functions, bcf_get_format_string() allocates two arrays:
-     *  a single block of \0-terminated strings collapsed into a single array and an array of pointers
-     *  to these strings. Both arrays must be cleaned by the user.
-     *
-     *  Returns negative value on error or the number of written values on success.
-     *
-     *  Use the returned number of written values for accessing valid entries of dst, as ndst is only a
-     *  watermark that can be higher than the returned value, i.e. the end of dst can contain carry-over
-     *  values from previous calls to bcf_get_format_*() on lines with more values per sample.
-     *
-     *  Example:
-     *      int ndst = 0; char **dst = NULL;
-     *      if ( bcf_get_format_string(hdr, line, "XX", &dst, &ndst) > 0 )
-     *          for (i=0; i<bcf_hdr_nsamples(hdr); i++) printf("%s\n", dst[i]);
-     *      free(dst[0]); free(dst);
-     *
-     *  Example:
-     *      int i, j, ngt, nsmpl = bcf_hdr_nsamples(hdr);
-     *      int32_t *gt_arr = NULL, ngt_arr = 0;
-     *
-     *      ngt = bcf_get_genotypes(hdr, line, &gt_arr, &ngt_arr);
-     *      if ( ngt<=0 ) return; // GT not present
-     *
-     *      int max_ploidy = ngt/nsmpl;
-     *      for (i=0; i<nsmpl; i++)
-     *      {
-     *        int32_t *ptr = gt_arr + i*max_ploidy;
-     *        for (j=0; j<max_ploidy; j++)
-     *        {
-     *           // if true, the sample has smaller ploidy
-     *           if ( ptr[j]==bcf_int32_vector_end ) break;
-     *
-     *           // missing allele
-     *           if ( bcf_gt_is_missing(ptr[j]) ) continue;
-     *
-     *           // the VCF 0-based allele index
-     *           int allele_index = bcf_gt_allele(ptr[j]);
-     *
-     *           // is phased?
-     *           int is_phased = bcf_gt_is_phased(ptr[j]);
-     *
-     *           // .. do something ..
-     *         }
-     *      }
-     *      free(gt_arr);
-     *
-     */
-    #define bcf_get_format_int32(hdr,line,tag,dst,ndst)  bcf_get_format_values(hdr,line,tag,(void**)(dst),ndst,BCF_HT_INT)
-    #define bcf_get_format_float(hdr,line,tag,dst,ndst)  bcf_get_format_values(hdr,line,tag,(void**)(dst),ndst,BCF_HT_REAL)
-    #define bcf_get_format_char(hdr,line,tag,dst,ndst)   bcf_get_format_values(hdr,line,tag,(void**)(dst),ndst,BCF_HT_STR)
-    #define bcf_get_genotypes(hdr,line,dst,ndst)         bcf_get_format_values(hdr,line,"GT",(void**)(dst),ndst,BCF_HT_INT)
-
-    HTSLIB_EXPORT
-    int bcf_get_format_string(const bcf_hdr_t *hdr, bcf1_t *line, const char *tag, char ***dst, int *ndst);
-
-    HTSLIB_EXPORT
-    int bcf_get_format_values(const bcf_hdr_t *hdr, bcf1_t *line, const char *tag, void **dst, int *ndst, int type);
-
-
-
-    /**************************************************************************
-     *  Helper functions
-     **************************************************************************/
-
-    /**
-     *  bcf_hdr_id2int() - Translates string into numeric ID
-     *  bcf_hdr_int2id() - Translates numeric ID into string
-     *  @type:     one of BCF_DT_ID, BCF_DT_CTG, BCF_DT_SAMPLE
-     *  @id:       tag name, such as: PL, DP, GT, etc.
-     *
-     *  Returns -1 if string is not in dictionary, otherwise numeric ID which identifies
-     *  fields in BCF records.
-     */
-    HTSLIB_EXPORT
-    int bcf_hdr_id2int(const bcf_hdr_t *hdr, int type, const char *id);
-    #define bcf_hdr_int2id(hdr,type,int_id) ((hdr)->id[type][int_id].key)
-
-    /**
-     *  bcf_hdr_name2id() - Translates sequence names (chromosomes) into numeric ID
-     *  bcf_hdr_id2name() - Translates numeric ID to sequence name
-     */
-    static inline int bcf_hdr_name2id(const bcf_hdr_t *hdr, const char *id) { return bcf_hdr_id2int(hdr, BCF_DT_CTG, id); }
-    static inline const char *bcf_hdr_id2name(const bcf_hdr_t *hdr, int rid)
-    {
-        if ( !hdr || rid<0 || rid>=hdr->n[BCF_DT_CTG] ) return NULL;
-        return hdr->id[BCF_DT_CTG][rid].key;
-    }
-    static inline const char *bcf_seqname(const bcf_hdr_t *hdr, const bcf1_t *rec) {
-        return bcf_hdr_id2name(hdr, rec ? rec->rid : -1);
-    }
-
-    /** Return CONTIG name, or "(unknown)"
-
-        Like bcf_seqname(), but this function will never return NULL.  If
-        the contig name cannot be found (either because @p hdr was not
-        supplied or rec->rid was out of range) it returns the string
-        "(unknown)".
-    */
-    static inline const char *bcf_seqname_safe(const bcf_hdr_t *hdr, const bcf1_t *rec) {
-        const char *name = bcf_seqname(hdr, rec);
-        return name ? name : "(unknown)";
-    }
-
-    /**
-     *  bcf_hdr_id2*() - Macros for accessing bcf_idinfo_t
-     *  @type:      one of BCF_HL_FLT, BCF_HL_INFO, BCF_HL_FMT
-     *  @int_id:    return value of bcf_hdr_id2int, must be >=0
-     *
-     *  The returned values are:
-     *     bcf_hdr_id2length   ..  whether the number of values is fixed or variable, one of BCF_VL_*
-     *     bcf_hdr_id2number   ..  the number of values, 0xfffff for variable length fields
-     *     bcf_hdr_id2type     ..  the field type, one of BCF_HT_*
-     *     bcf_hdr_id2coltype  ..  the column type, one of BCF_HL_*
-     *
-     *  Notes: Prior to using the macros, the presence of the info should be
-     *  tested with bcf_hdr_idinfo_exists().
-     */
-    #define bcf_hdr_id2length(hdr,type,int_id)  ((hdr)->id[BCF_DT_ID][int_id].val->info[type]>>8 & 0xf)
-    #define bcf_hdr_id2number(hdr,type,int_id)  ((hdr)->id[BCF_DT_ID][int_id].val->info[type]>>12)
-    #define bcf_hdr_id2type(hdr,type,int_id)    (uint32_t)((hdr)->id[BCF_DT_ID][int_id].val->info[type]>>4 & 0xf)
-    #define bcf_hdr_id2coltype(hdr,type,int_id) (uint32_t)((hdr)->id[BCF_DT_ID][int_id].val->info[type] & 0xf)
-    #define bcf_hdr_idinfo_exists(hdr,type,int_id)  ((int_id)>=0 && bcf_hdr_id2coltype((hdr),(type),(int_id))!=0xf)
-    #define bcf_hdr_id2hrec(hdr,dict_type,col_type,int_id)    ((hdr)->id[(dict_type)==BCF_DT_CTG?BCF_DT_CTG:BCF_DT_ID][int_id].val->hrec[(dict_type)==BCF_DT_CTG?0:(col_type)])
-    /// Convert BCF FORMAT data to string form
-    /**
-     * @param s    kstring to write into
-     * @param n    number of items in @p data
-     * @param type type of items in @p data
-     * @param data BCF format data
-     * @return  0 on success
-     *         -1 if out of memory
-     */
-    HTSLIB_EXPORT
-    int bcf_fmt_array(kstring_t *s, int n, int type, void *data);
-
-    HTSLIB_EXPORT
-    uint8_t *bcf_fmt_sized_array(kstring_t *s, uint8_t *ptr);
-
-    /// Encode a variable-length char array in BCF format
-    /**
-     * @param s    kstring to write into
-     * @param l    length of input
-     * @param a    input data to encode
-     * @return 0 on success; < 0 on error
-     */
-    HTSLIB_EXPORT
-    int bcf_enc_vchar(kstring_t *s, int l, const char *a);
-
-    /// Encode a variable-length integer array in BCF format
-    /**
-     * @param s      kstring to write into
-     * @param n      total number of items in @p a (<= 0 to encode BCF_BT_NULL)
-     * @param a      input data to encode
-     * @param wsize  vector length (<= 0 is equivalent to @p n)
-     * @return 0 on success; < 0 on error
-     * @note @p n should be an exact multiple of @p wsize
-     */
-    HTSLIB_EXPORT
-    int bcf_enc_vint(kstring_t *s, int n, int32_t *a, int wsize);
-
-    /// Encode a variable-length float array in BCF format
-    /**
-     * @param s      kstring to write into
-     * @param n      total number of items in @p a (<= 0 to encode BCF_BT_NULL)
-     * @param a      input data to encode
-     * @return 0 on success; < 0 on error
-     */
-    HTSLIB_EXPORT
-    int bcf_enc_vfloat(kstring_t *s, int n, float *a);
-
-
-    /**************************************************************************
-     *  BCF index
-     *
-     *  Note that these functions work with BCFs only. See synced_bcf_reader.h
-     *  which provides (amongst other things) an API to work transparently with
-     *  both indexed BCFs and VCFs.
-     **************************************************************************/
-
-    #define bcf_itr_destroy(iter) hts_itr_destroy(iter)
-    #define bcf_itr_queryi(idx, tid, beg, end) hts_itr_query((idx), (tid), (beg), (end), bcf_readrec)
-    #define bcf_itr_querys(idx, hdr, s) hts_itr_querys((idx), (s), (hts_name2id_f)(bcf_hdr_name2id), (hdr), hts_itr_query, bcf_readrec)
-
-    static inline int bcf_itr_next(htsFile *htsfp, hts_itr_t *itr, void *r) {
-        if (htsfp->is_bgzf)
-            return hts_itr_next(htsfp->fp.bgzf, itr, r, 0);
-
-        hts_log_error("Only bgzf compressed files can be used with iterators");
-        errno = EINVAL;
-        return -2;
-    }
-/// Load a BCF index
-/** @param fn   BCF file name
-    @return The index, or NULL if an error occurred.
-     @note This only works for BCF files.  Consider synced_bcf_reader instead
-which works for both BCF and VCF.
-*/
-    #define bcf_index_load(fn) hts_idx_load(fn, HTS_FMT_CSI)
-    #define bcf_index_seqnames(idx, hdr, nptr) hts_idx_seqnames((idx),(nptr),(hts_id2name_f)(bcf_hdr_id2name),(hdr))
-
-/// Load a BCF index from a given index file name
-/**  @param fn     Input BAM/BCF/etc filename
-     @param fnidx  The input index filename
-     @return  The index, or NULL if an error occurred.
-     @note This only works for BCF files.  Consider synced_bcf_reader instead
-which works for both BCF and VCF.
-*/
-    HTSLIB_EXPORT
-    hts_idx_t *bcf_index_load2(const char *fn, const char *fnidx);
-
-/// Load a BCF index from a given index file name
-/**  @param fn     Input BAM/BCF/etc filename
-     @param fnidx  The input index filename
-     @param flags  Flags to alter behaviour (see description)
-     @return  The index, or NULL if an error occurred.
-     @note This only works for BCF files.  Consider synced_bcf_reader instead
-which works for both BCF and VCF.
-
-     The @p flags parameter can be set to a combination of the following
-     values:
-
-        HTS_IDX_SAVE_REMOTE   Save a local copy of any remote indexes
-        HTS_IDX_SILENT_FAIL   Fail silently if the index is not present
-
-     Equivalent to hts_idx_load3(fn, fnidx, HTS_FMT_CSI, flags);
-*/
-    HTSLIB_EXPORT
-    hts_idx_t *bcf_index_load3(const char *fn, const char *fnidx, int flags);
-
-    /**
-     *  bcf_index_build() - Generate and save an index file
-     *  @fn:         Input VCF(compressed)/BCF filename
-     *  @min_shift:  log2(width of the smallest bin), e.g. a value of 14
-     *  imposes a 16k base lower limit on the width of index bins.
-     *  Positive to generate CSI, or 0 to generate TBI. However, a small
-     *  value of min_shift would create a large index, which would lead to
-     *  reduced performance when using the index. A recommended value is 14.
-     *  For BCF files, only the CSI index can be generated.
-     *
-     *  Returns 0 if successful, or negative if an error occurred.
-     *
-     *  List of error codes:
-     *      -1 .. indexing failed
-     *      -2 .. opening @fn failed
-     *      -3 .. format not indexable
-     *      -4 .. failed to create and/or save the index
-     */
-    HTSLIB_EXPORT
-    int bcf_index_build(const char *fn, int min_shift);
-
-    /**
-     *  bcf_index_build2() - Generate and save an index to a specific file
-     *  @fn:         Input VCF/BCF filename
-     *  @fnidx:      Output filename, or NULL to add .csi/.tbi to @fn
-     *  @min_shift:  Positive to generate CSI, or 0 to generate TBI
-     *
-     *  Returns 0 if successful, or negative if an error occurred.
-     *
-     *  List of error codes:
-     *      -1 .. indexing failed
-     *      -2 .. opening @fn failed
-     *      -3 .. format not indexable
-     *      -4 .. failed to create and/or save the index
-     */
-    HTSLIB_EXPORT
-    int bcf_index_build2(const char *fn, const char *fnidx, int min_shift);
-
-    /**
-     *  bcf_index_build3() - Generate and save an index to a specific file
-     *  @fn:         Input VCF/BCF filename
-     *  @fnidx:      Output filename, or NULL to add .csi/.tbi to @fn
-     *  @min_shift:  Positive to generate CSI, or 0 to generate TBI
-     *  @n_threads:  Number of VCF/BCF decoder threads
-     *
-     *  Returns 0 if successful, or negative if an error occurred.
-     *
-     *  List of error codes:
-     *      -1 .. indexing failed
-     *      -2 .. opening @fn failed
-     *      -3 .. format not indexable
-     *      -4 .. failed to create and/or save the index
-     */
-     HTSLIB_EXPORT
-     int bcf_index_build3(const char *fn, const char *fnidx, int min_shift, int n_threads);
-
-     /// Initialise fp->idx for the current format type, for VCF and BCF files.
-     /** @param fp        File handle for the data file being written.
-         @param h         BCF header structured (needed for BAI and CSI).
-         @param min_shift CSI bin size (CSI default is 14).
-         @param fnidx     Filename to write index to.  This pointer must remain valid
-                          until after bcf_idx_save is called.
-         @return          0 on success, <0 on failure.
-         @note This must be called after the header has been written, but before
-               any other data.
-     */
-     HTSLIB_EXPORT
-     int bcf_idx_init(htsFile *fp, bcf_hdr_t *h, int min_shift, const char *fnidx);
-
-     /// Writes the index initialised with bcf_idx_init to disk.
-     /** @param fp        File handle for the data file being written.
-         @return          0 on success, <0 on failure.
-     */
-     HTSLIB_EXPORT
-     int bcf_idx_save(htsFile *fp);
-
-/*******************
- * Typed value I/O *
- *******************/
-
-/*
-    Note that in contrast with BCFv2.1 specification, HTSlib implementation
-    allows missing values in vectors. For integer types, the values 0x80,
-    0x8000, 0x80000000 are interpreted as missing values and 0x81, 0x8001,
-    0x80000001 as end-of-vector indicators.  Similarly for floats, the value of
-    0x7F800001 is interpreted as a missing value and 0x7F800002 as an
-    end-of-vector indicator.
-    Note that the end-of-vector byte is not part of the vector.
-
-    This trial BCF version (v2.2) is compatible with the VCF specification and
-    enables to handle correctly vectors with different ploidy in presence of
-    missing values.
- */
-#define bcf_int8_vector_end  (-127)         /* INT8_MIN  + 1 */
-#define bcf_int16_vector_end (-32767)       /* INT16_MIN + 1 */
-#define bcf_int32_vector_end (-2147483647)  /* INT32_MIN + 1 */
-#define bcf_int64_vector_end (-9223372036854775807LL)  /* INT64_MIN + 1 */
-#define bcf_str_vector_end   0
-#define bcf_int8_missing     (-128)          /* INT8_MIN  */
-#define bcf_int16_missing    (-32767-1)      /* INT16_MIN */
-#define bcf_int32_missing    (-2147483647-1) /* INT32_MIN */
-#define bcf_int64_missing    (-9223372036854775807LL - 1LL)  /* INT64_MIN */
-#define bcf_str_missing      0x07
-
-// Limits on BCF values stored in given types.  Max values are the same
-// as for the underlying type.  Min values are slightly different as
-// the last 8 values for each type were reserved by BCFv2.2.
-#define BCF_MAX_BT_INT8  (0x7f)        /* INT8_MAX  */
-#define BCF_MAX_BT_INT16 (0x7fff)      /* INT16_MAX */
-#define BCF_MAX_BT_INT32 (0x7fffffff)  /* INT32_MAX */
-#define BCF_MIN_BT_INT8  (-120)        /* INT8_MIN  + 8 */
-#define BCF_MIN_BT_INT16 (-32760)      /* INT16_MIN + 8 */
-#define BCF_MIN_BT_INT32 (-2147483640) /* INT32_MIN + 8 */
-
-extern uint32_t bcf_float_vector_end;
-extern uint32_t bcf_float_missing;
-static inline void bcf_float_set(float *ptr, uint32_t value)
-{
-    union { uint32_t i; float f; } u;
-    u.i = value;
-    *ptr = u.f;
-}
-#define bcf_float_set_vector_end(x) bcf_float_set(&(x),bcf_float_vector_end)
-#define bcf_float_set_missing(x)    bcf_float_set(&(x),bcf_float_missing)
-static inline int bcf_float_is_missing(float f)
-{
-    union { uint32_t i; float f; } u;
-    u.f = f;
-    return u.i==bcf_float_missing ? 1 : 0;
-}
-static inline int bcf_float_is_vector_end(float f)
-{
-    union { uint32_t i; float f; } u;
-    u.f = f;
-    return u.i==bcf_float_vector_end ? 1 : 0;
-}
-
-static inline int bcf_format_gt(bcf_fmt_t *fmt, int isample, kstring_t *str)
-{
-    uint32_t e = 0;
-    #define BRANCH(type_t, missing, vector_end) { \
-        type_t *ptr = (type_t*) (fmt->p + isample*fmt->size); \
-        int i; \
-        for (i=0; i<fmt->n && ptr[i]!=vector_end; i++) \
-        { \
-            if ( i ) e |= kputc("/|"[ptr[i]&1], str) < 0; \
-            if ( !(ptr[i]>>1) ) e |= kputc('.', str) < 0; \
-            else e |= kputw((ptr[i]>>1) - 1, str) < 0; \
-        } \
-        if (i == 0) e |= kputc('.', str) < 0; \
-    }
-    switch (fmt->type) {
-        case BCF_BT_INT8:  BRANCH(int8_t,  bcf_int8_missing, bcf_int8_vector_end); break;
-        case BCF_BT_INT16: BRANCH(int16_t, bcf_int16_missing, bcf_int16_vector_end); break;
-        case BCF_BT_INT32: BRANCH(int32_t, bcf_int32_missing, bcf_int32_vector_end); break;
-        case BCF_BT_NULL:  e |= kputc('.', str) < 0; break;
-        default: hts_log_error("Unexpected type %d", fmt->type); return -2;
-    }
-    #undef BRANCH
-    return e == 0 ? 0 : -1;
-}
-
-static inline int bcf_enc_size(kstring_t *s, int size, int type)
-{
-    uint32_t e = 0;
-    uint8_t x[4];
-    if (size >= 15) {
-        e |= kputc(15<<4|type, s) < 0;
-        if (size >= 128) {
-            if (size >= 32768) {
-                i32_to_le(size, x);
-                e |= kputc(1<<4|BCF_BT_INT32, s) < 0;
-                e |= kputsn((char*)&x, 4, s) < 0;
-            } else {
-                i16_to_le(size, x);
-                e |= kputc(1<<4|BCF_BT_INT16, s) < 0;
-                e |= kputsn((char*)&x, 2, s) < 0;
-            }
-        } else {
-            e |= kputc(1<<4|BCF_BT_INT8, s) < 0;
-            e |= kputc(size, s) < 0;
-        }
-    } else e |= kputc(size<<4|type, s) < 0;
-    return e == 0 ? 0 : -1;
-}
-
-static inline int bcf_enc_inttype(long x)
-{
-    if (x <= BCF_MAX_BT_INT8 && x >= BCF_MIN_BT_INT8) return BCF_BT_INT8;
-    if (x <= BCF_MAX_BT_INT16 && x >= BCF_MIN_BT_INT16) return BCF_BT_INT16;
-    return BCF_BT_INT32;
-}
-
-static inline int bcf_enc_int1(kstring_t *s, int32_t x)
-{
-    uint32_t e = 0;
-    uint8_t z[4];
-    if (x == bcf_int32_vector_end) {
-        e |= bcf_enc_size(s, 1, BCF_BT_INT8);
-        e |= kputc(bcf_int8_vector_end, s) < 0;
-    } else if (x == bcf_int32_missing) {
-        e |= bcf_enc_size(s, 1, BCF_BT_INT8);
-        e |= kputc(bcf_int8_missing, s) < 0;
-    } else if (x <= BCF_MAX_BT_INT8 && x >= BCF_MIN_BT_INT8) {
-        e |= bcf_enc_size(s, 1, BCF_BT_INT8);
-        e |= kputc(x, s) < 0;
-    } else if (x <= BCF_MAX_BT_INT16 && x >= BCF_MIN_BT_INT16) {
-        i16_to_le(x, z);
-        e |= bcf_enc_size(s, 1, BCF_BT_INT16);
-        e |= kputsn((char*)&z, 2, s) < 0;
-    } else {
-        i32_to_le(x, z);
-        e |= bcf_enc_size(s, 1, BCF_BT_INT32);
-        e |= kputsn((char*)&z, 4, s) < 0;
-    }
-    return e == 0 ? 0 : -1;
-}
-
-/// Return the value of a single typed integer.
-/** @param      p    Pointer to input data block.
-    @param      type One of the BCF_BT_INT* type codes
-    @param[out] q    Location to store an updated value for p
-    @return The integer value, or zero if @p type is not valid.
-
-If @p type is not one of BCF_BT_INT8, BCF_BT_INT16, BCF_BT_INT32 or
-BCF_BT_INT64, zero will be returned and @p *q will not be updated.
-Otherwise, the integer value will be returned and @p *q will be set
-to the memory location immediately following the integer value.
-
-Cautious callers can detect invalid type codes by checking that *q has
-actually been updated.
-*/
-
-static inline int64_t bcf_dec_int1(const uint8_t *p, int type, uint8_t **q)
-{
-    if (type == BCF_BT_INT8) {
-        *q = (uint8_t*)p + 1;
-        return le_to_i8(p);
-    } else if (type == BCF_BT_INT16) {
-        *q = (uint8_t*)p + 2;
-        return le_to_i16(p);
-    } else if (type == BCF_BT_INT32) {
-        *q = (uint8_t*)p + 4;
-        return le_to_i32(p);
-    } else if (type == BCF_BT_INT64) {
-        *q = (uint8_t*)p + 8;
-        return le_to_i64(p);
-    } else { // Invalid type.
-        return 0;
-    }
-}
-
-/// Return the value of a single typed integer from a byte stream.
-/** @param      p    Pointer to input data block.
-    @param[out] q    Location to store an updated value for p
-    @return The integer value, or zero if the type code was not valid.
-
-Reads a one-byte type code from @p p, and uses it to decode an integer
-value from the following bytes in @p p.
-
-If the type is not one of BCF_BT_INT8, BCF_BT_INT16 or BCF_BT_INT32, zero
-will be returned and @p *q will unchanged.  Otherwise, the integer value will
-be returned and @p *q will be set to the memory location immediately following
-the integer value.
-
-Cautious callers can detect invalid type codes by checking that *q has
-actually been updated.
-*/
-static inline int64_t bcf_dec_typed_int1(const uint8_t *p, uint8_t **q)
-{
-    return bcf_dec_int1(p + 1, *p&0xf, q);
-}
-
-static inline int32_t bcf_dec_size(const uint8_t *p, uint8_t **q, int *type)
-{
-    *type = *p & 0xf;
-    if (*p>>4 != 15) {
-        *q = (uint8_t*)p + 1;
-        return *p>>4;
-    } else return bcf_dec_typed_int1(p + 1, q);
-}
-
-#ifdef __cplusplus
-}
-#endif
-
-#endif
diff -ruN stringtie.orig/htslib/htslib/vcf_sweep.h stringtie/htslib/htslib/vcf_sweep.h
--- stringtie.orig/htslib/htslib/vcf_sweep.h	2024-02-28 13:57:39.704579460 +0100
+++ stringtie/htslib/htslib/vcf_sweep.h	1970-01-01 01:00:00.000000000 +0100
@@ -1,57 +0,0 @@
-/// @file htslib/vcf_sweep.h
-/// Forward/reverse sweep API.
-/*
-    Copyright (C) 2013-2015, 2019 Genome Research Ltd.
-
-    Author: Petr Danecek <pd3@sanger.ac.uk>
-
-Permission is hereby granted, free of charge, to any person obtaining a copy
-of this software and associated documentation files (the "Software"), to deal
-in the Software without restriction, including without limitation the rights
-to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
-copies of the Software, and to permit persons to whom the Software is
-furnished to do so, subject to the following conditions:
-
-The above copyright notice and this permission notice shall be included in
-all copies or substantial portions of the Software.
-
-THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
-IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
-FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
-THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
-LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
-FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
-DEALINGS IN THE SOFTWARE.  */
-
-#ifndef HTSLIB_VCF_SWEEP_H
-#define HTSLIB_VCF_SWEEP_H
-
-#include "hts.h"
-#include "vcf.h"
-
-#ifdef __cplusplus
-extern "C" {
-#endif
-
-typedef struct bcf_sweep_t bcf_sweep_t;
-
-HTSLIB_EXPORT
-bcf_sweep_t *bcf_sweep_init(const char *fname);
-
-HTSLIB_EXPORT
-void bcf_sweep_destroy(bcf_sweep_t *sw);
-
-HTSLIB_EXPORT
-bcf_hdr_t *bcf_sweep_hdr(bcf_sweep_t *sw);
-
-HTSLIB_EXPORT
-bcf1_t *bcf_sweep_fwd(bcf_sweep_t *sw);
-
-HTSLIB_EXPORT
-bcf1_t *bcf_sweep_bwd(bcf_sweep_t *sw);
-
-#ifdef __cplusplus
-}
-#endif
-
-#endif
diff -ruN stringtie.orig/htslib/htslib/vcfutils.h stringtie/htslib/htslib/vcfutils.h
--- stringtie.orig/htslib/htslib/vcfutils.h	2024-02-28 13:57:39.704579460 +0100
+++ stringtie/htslib/htslib/vcfutils.h	1970-01-01 01:00:00.000000000 +0100
@@ -1,143 +0,0 @@
-/// @file htslib/vcfutils.h
-/// Allele-related utility functions.
-/*
-    Copyright (C) 2012, 2013, 2015-2016 Genome Research Ltd.
-
-    Author: Petr Danecek <pd3@sanger.ac.uk>
-
-Permission is hereby granted, free of charge, to any person obtaining a copy
-of this software and associated documentation files (the "Software"), to deal
-in the Software without restriction, including without limitation the rights
-to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
-copies of the Software, and to permit persons to whom the Software is
-furnished to do so, subject to the following conditions:
-
-The above copyright notice and this permission notice shall be included in
-all copies or substantial portions of the Software.
-
-THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
-IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
-FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
-THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
-LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
-FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
-DEALINGS IN THE SOFTWARE.  */
-
-#ifndef HTSLIB_VCFUTILS_H
-#define HTSLIB_VCFUTILS_H
-
-#include "vcf.h"
-
-#ifdef __cplusplus
-extern "C" {
-#endif
-
-struct kbitset_t;
-
-/**
- *  bcf_trim_alleles() - remove ALT alleles unused in genotype fields
- *  @header:  for access to BCF_DT_ID dictionary
- *  @line:    VCF line obtain from vcf_parse1
- *
- *  Returns the number of removed alleles on success or negative
- *  on error:
- *      -1 .. some allele index is out of bounds
- *      -2 .. could not remove alleles
- */
-HTSLIB_EXPORT
-int bcf_trim_alleles(const bcf_hdr_t *header, bcf1_t *line);
-
-/**
- *  bcf_remove_alleles() - remove ALT alleles according to bitmask @mask
- *  @header:  for access to BCF_DT_ID dictionary
- *  @line:    VCF line obtained from vcf_parse1
- *  @mask:    alleles to remove
- *
- *  If you have more than 31 alleles, then the integer bit mask will
- *  overflow, so use bcf_remove_allele_set instead
- *  Returns 0 on success, <0 on error
- */
-HTSLIB_EXPORT
-int bcf_remove_alleles(const bcf_hdr_t *header, bcf1_t *line, int mask) HTS_DEPRECATED("Please use bcf_remove_allele_set instead");
-
-/**
- *  bcf_remove_allele_set() - remove ALT alleles according to bitset @rm_set
- *  @header:  for access to BCF_DT_ID dictionary
- *  @line:    VCF line obtained from vcf_parse1
- *  @rm_set:  pointer to kbitset_t object with bits set for allele
- *            indexes to remove
- *
- *  Returns 0 on success or -1 on failure
- *
- *  Number=A,R,G INFO and FORMAT fields will be updated accordingly.
- */
-HTSLIB_EXPORT
-int bcf_remove_allele_set(const bcf_hdr_t *header, bcf1_t *line, const struct kbitset_t *rm_set);
-
-/**
- *  bcf_calc_ac() - calculate the number of REF and ALT alleles
- *  @header:  for access to BCF_DT_ID dictionary
- *  @line:    VCF line obtained from vcf_parse1
- *  @ac:      array of length line->n_allele
- *  @which:   determine if INFO/AN,AC and indv fields be used
- *
- *  Returns 1 if the call succeeded, or 0 if the value could not
- *  be determined.
- *
- *  The value of @which determines if existing INFO/AC,AN can be
- *  used (BCF_UN_INFO) and and if indv fields can be split (BCF_UN_FMT).
- */
-HTSLIB_EXPORT
-int bcf_calc_ac(const bcf_hdr_t *header, bcf1_t *line, int *ac, int which);
-
-
-/**
- * bcf_gt_type() - determines type of the genotype
- * @fmt_ptr:  the GT format field as set for example by set_fmt_ptr
- * @isample:  sample index (starting from 0)
- * @ial:      index of the 1st non-reference allele (starting from 1)
- * @jal:      index of the 2nd non-reference allele (starting from 1)
- *
- * Returns the type of the genotype (one of GT_HOM_RR, GT_HET_RA,
- * GT_HOM_AA, GT_HET_AA, GT_HAPL_R, GT_HAPL_A or GT_UNKN). If $ial
- * is not NULL and the genotype has one or more non-reference
- * alleles, $ial will be set. In case of GT_HET_AA, $ial is the
- * position of the allele which appeared first in ALT. If $jal is
- * not null and the genotype is GT_HET_AA, $jal will be set and is
- * the position of the second allele in ALT.
- */
-#define GT_HOM_RR 0 // note: the actual value of GT_* matters, used in dosage r2 calculation
-#define GT_HOM_AA 1
-#define GT_HET_RA 2
-#define GT_HET_AA 3
-#define GT_HAPL_R 4
-#define GT_HAPL_A 5
-#define GT_UNKN   6
-HTSLIB_EXPORT
-int bcf_gt_type(bcf_fmt_t *fmt_ptr, int isample, int *ial, int *jal);
-
-static inline int bcf_acgt2int(char c)
-{
-    if ( (int)c>96 ) c -= 32;
-    if ( c=='A' ) return 0;
-    if ( c=='C' ) return 1;
-    if ( c=='G' ) return 2;
-    if ( c=='T' ) return 3;
-    return -1;
-}
-
-#define bcf_int2acgt(i) "ACGT"[i]
-
-/**
-  * bcf_ij2G() - common task: allele indexes to Number=G index (diploid)
-  * @i,j:  allele indexes, 0-based, i<=j
-  *
-  * Returns index to the Number=G diploid array
-  */
-#define bcf_ij2G(i, j) ((j)*((j)+1)/2+(i))
-
-#ifdef __cplusplus
-}
-#endif
-
-#endif
diff -ruN stringtie.orig/htslib/htslib.mk stringtie/htslib/htslib.mk
--- stringtie.orig/htslib/htslib.mk	2024-02-28 13:57:39.701246126 +0100
+++ stringtie/htslib/htslib.mk	1970-01-01 01:00:00.000000000 +0100
@@ -1,195 +0,0 @@
-# Makefile rules useful for third-party code using htslib's public API.
-#
-#    Copyright (C) 2013-2017, 2019 Genome Research Ltd.
-#
-#    Author: John Marshall <jm18@sanger.ac.uk>
-#
-# Permission is hereby granted, free of charge, to any person obtaining a copy
-# of this software and associated documentation files (the "Software"), to deal
-# in the Software without restriction, including without limitation the rights
-# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
-# copies of the Software, and to permit persons to whom the Software is
-# furnished to do so, subject to the following conditions:
-#
-# The above copyright notice and this permission notice shall be included in
-# all copies or substantial portions of the Software.
-#
-# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
-# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
-# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
-# THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
-# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
-# FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
-# DEALINGS IN THE SOFTWARE.
-
-# The makefile fragment included below provides variables that can be used
-# to express dependencies on headers supplied by an in-development htslib.
-# If your source file foo.c #includes <htslib/hts.h> and <htslib/kstring.h>,
-# you can write the correct prerequisites for foo.o as:
-#
-#	HTSDIR = <path to htslib top-level directory>
-#	include $(HTSDIR)/htslib.mk
-#
-#	foo.o: foo.c $(htslib_hts_h) $(htslib_kstring_h)
-
-HTSPREFIX = $(HTSDIR)/
-include $(HTSDIR)/htslib_vars.mk
-
-# This file provides the HTSCODECS_SOURCES variable.  It may not be present
-# in a freshly checked-out htslib, so is only included if available.  The
-# absence is unlikely to cause a problem as there will be plenty of other
-# missing files that will trigger a build in htslib, and when that happens
-# htslib's makefile will create it.
--include $(HTSDIR)/htscodecs.mk
-
-# Rules for rebuilding an in-development htslib's static and shared libraries.
-# If your program foo links with libhts, adding the appropriate prerequisite
-# will cause the library to be rebuilt as necessary:
-#
-#	foo: foo.o $(HTSDIR)/libhts.a
-#
-# or similarly if your target requires any of the tools supplied:
-#
-#	bar.bed.bgz.tbi: bar.bed.bgz $(HTSDIR)/tabix
-#		$(HTSDIR)/tabix -p bed bar.bed.bgz
-
-HTSLIB_PUBLIC_HEADERS = \
-	$(HTSDIR)/htslib/bgzf.h \
-	$(HTSDIR)/htslib/cram.h \
-	$(HTSDIR)/htslib/faidx.h \
-	$(HTSDIR)/htslib/hfile.h \
-	$(HTSDIR)/htslib/hts.h \
-	$(HTSDIR)/htslib/hts_defs.h \
-	$(HTSDIR)/htslib/hts_endian.h \
-	$(HTSDIR)/htslib/hts_expr.h \
-	$(HTSDIR)/htslib/hts_log.h \
-	$(HTSDIR)/htslib/hts_os.h \
-	$(HTSDIR)/htslib/kbitset.h \
-	$(HTSDIR)/htslib/kfunc.h \
-	$(HTSDIR)/htslib/khash.h \
-	$(HTSDIR)/htslib/khash_str2int.h \
-	$(HTSDIR)/htslib/klist.h \
-	$(HTSDIR)/htslib/kseq.h \
-	$(HTSDIR)/htslib/ksort.h \
-	$(HTSDIR)/htslib/kstring.h \
-	$(HTSDIR)/htslib/regidx.h \
-	$(HTSDIR)/htslib/sam.h \
-	$(HTSDIR)/htslib/synced_bcf_reader.h \
-	$(HTSDIR)/htslib/tbx.h \
-	$(HTSDIR)/htslib/thread_pool.h \
-	$(HTSDIR)/htslib/vcf.h \
-	$(HTSDIR)/htslib/vcf_sweep.h \
-	$(HTSDIR)/htslib/vcfutils.h
-
-HTSLIB_ALL = \
-	$(HTSLIB_PUBLIC_HEADERS) \
-	$(HTSDIR)/bcf_sr_sort.c \
-	$(HTSDIR)/bcf_sr_sort.h \
-	$(HTSDIR)/bgzf.c \
-	$(HTSDIR)/config.h \
-	$(HTSDIR)/errmod.c \
-	$(HTSDIR)/faidx.c \
-	$(HTSDIR)/header.c \
-	$(HTSDIR)/header.h \
-	$(HTSDIR)/hfile_internal.h \
-	$(HTSDIR)/hfile.c \
-	$(HTSDIR)/hfile_gcs.c \
-	$(HTSDIR)/hfile_libcurl.c \
-	$(HTSDIR)/hfile_s3.c \
-	$(HTSDIR)/hfile_s3_write.c \
-	$(HTSDIR)/hts.c \
-	$(HTSDIR)/hts_expr.c \
-	$(HTSDIR)/hts_internal.h \
-	$(HTSDIR)/hts_os.c \
-	$(HTSDIR)/kfunc.c \
-	$(HTSDIR)/kstring.c \
-	$(HTSDIR)/md5.c \
-	$(HTSDIR)/multipart.c \
-	$(HTSDIR)/plugin.c \
-	$(HTSDIR)/probaln.c \
-	$(HTSDIR)/realn.c \
-	$(HTSDIR)/regidx.c \
-	$(HTSDIR)/region.c \
-	$(HTSDIR)/sam.c \
-	$(HTSDIR)/sam_internal.h \
-	$(HTSDIR)/synced_bcf_reader.c \
-	$(HTSDIR)/tbx.c \
-	$(HTSDIR)/textutils.c \
-	$(HTSDIR)/textutils_internal.h \
-	$(HTSDIR)/thread_pool.c \
-	$(HTSDIR)/thread_pool_internal.h \
-	$(HTSDIR)/vcf.c \
-	$(HTSDIR)/vcf_sweep.c \
-	$(HTSDIR)/vcfutils.c \
-	$(HTSDIR)/cram/cram.h \
-	$(HTSDIR)/cram/cram_codecs.c \
-	$(HTSDIR)/cram/cram_codecs.h \
-	$(HTSDIR)/cram/cram_decode.c \
-	$(HTSDIR)/cram/cram_decode.h \
-	$(HTSDIR)/cram/cram_encode.c \
-	$(HTSDIR)/cram/cram_encode.h \
-	$(HTSDIR)/cram/cram_external.c \
-	$(HTSDIR)/cram/cram_index.c \
-	$(HTSDIR)/cram/cram_index.h \
-	$(HTSDIR)/cram/cram_io.c \
-	$(HTSDIR)/cram/cram_io.h \
-	$(HTSDIR)/cram/cram_samtools.h \
-	$(HTSDIR)/cram/cram_stats.c \
-	$(HTSDIR)/cram/cram_stats.h \
-	$(HTSDIR)/cram/cram_structs.h \
-	$(HTSDIR)/cram/mFILE.c \
-	$(HTSDIR)/cram/mFILE.h \
-	$(HTSDIR)/cram/misc.h \
-	$(HTSDIR)/cram/open_trace_file.c \
-	$(HTSDIR)/cram/open_trace_file.h \
-	$(HTSDIR)/cram/os.h \
-	$(HTSDIR)/cram/pooled_alloc.c \
-	$(HTSDIR)/cram/pooled_alloc.h \
-	$(HTSDIR)/cram/string_alloc.c \
-	$(HTSDIR)/cram/string_alloc.h \
-	$(HTSDIR)/os/lzma_stub.h \
-	$(HTSDIR)/os/rand.c \
-	$(HTSCODECS_SOURCES)
-
-$(HTSDIR)/config.h:
-	+cd $(HTSDIR) && $(MAKE) config.h
-
-$(HTSDIR)/hts-object-files : $(HTSLIB_ALL)
-	+cd $(HTSDIR) && $(MAKE) hts-object-files
-
-$(HTSDIR)/libhts.a: $(HTSDIR)/hts-object-files
-	+cd $(HTSDIR) && $(MAKE) lib-static
-
-$(HTSDIR)/libhts.so: $(HTSLIB_ALL)
-	+cd $(HTSDIR) && $(MAKE) lib-shared
-
-$(HTSDIR)/libhts.dylib $(HTSDIR)/libhts.dll.a $(HTSDIR)/hts.dll.a: $(HTSDIR)/hts-object-files
-	+cd $(HTSDIR) && $(MAKE) lib-shared
-
-$(HTSDIR)/bgzip: $(HTSDIR)/bgzip.c $(HTSLIB_PUBLIC_HEADERS) $(HTSDIR)/libhts.a
-	+cd $(HTSDIR) && $(MAKE) bgzip
-
-$(HTSDIR)/htsfile: $(HTSDIR)/htsfile.c $(HTSLIB_PUBLIC_HEADERS) $(HTSDIR)/libhts.a
-
-	+cd $(HTSDIR) && $(MAKE) htsfile
-
-$(HTSDIR)/tabix: $(HTSDIR)/tabix.c $(HTSLIB_PUBLIC_HEADERS) $(HTSDIR)/libhts.a
-
-	+cd $(HTSDIR) && $(MAKE) tabix
-
-$(HTSDIR)/htslib_static.mk: $(HTSDIR)/htslib.pc.tmp
-	+cd $(HTSDIR) && $(MAKE) htslib_static.mk
-
-$(HTSDIR)/htslib.pc.tmp:
-	+cd $(HTSDIR) && $(MAKE) htslib.pc.tmp
-
-# Rules for phony targets.  You may wish to have your corresponding phony
-# targets invoke these in addition to their own recipes:
-#
-#	clean: clean-htslib
-
-all-htslib check-htslib clean-htslib distclean-htslib install-htslib mostlyclean-htslib plugins-htslib test-htslib testclean-htslib:
-	+cd $(HTSDIR) && $(MAKE) $(@:-htslib=)
-
-.PHONY: all-htslib check-htslib clean-htslib distclean-htslib install-htslib
-.PHONY: mostlyclean-htslib plugins-htslib test-htslib testclean-htslib
diff -ruN stringtie.orig/htslib/htslib.pc.in stringtie/htslib/htslib.pc.in
--- stringtie.orig/htslib/htslib.pc.in	2024-02-28 13:57:39.701246126 +0100
+++ stringtie/htslib/htslib.pc.in	1970-01-01 01:00:00.000000000 +0100
@@ -1,15 +0,0 @@
-includedir=@-includedir@
-libdir=@-libdir@
-
-# Flags and libraries needed when linking against a static libhts.a
-# (used by manual and semi-manual pkg-config(1)-style enquiries).
-static_ldflags=@static_LDFLAGS@
-static_libs=@static_LIBS@
-
-Name: htslib
-Description: C library for high-throughput sequencing data formats
-Version: @-PACKAGE_VERSION@
-Cflags: -I${includedir}
-Libs: -L${libdir} -lhts
-Libs.private: -L${libdir} @private_LIBS@ -lhts -lm -lpthread
-Requires.private: zlib @pc_requires@
diff -ruN stringtie.orig/htslib/htslib-s3-plugin.7 stringtie/htslib/htslib-s3-plugin.7
--- stringtie.orig/htslib/htslib-s3-plugin.7	2024-02-28 13:57:39.701246126 +0100
+++ stringtie/htslib/htslib-s3-plugin.7	1970-01-01 01:00:00.000000000 +0100
@@ -1,139 +0,0 @@
-.TH htslib-s3-plugin 7 "17 March 2021" "htslib-1.12" "Bioinformatics tools"
-.SH NAME
-s3 plugin \- htslib AWS S3 plugin
-.\"
-.\" Copyright (C) 2021 Genome Research Ltd.
-.\"
-.\" Author: Andrew Whitwham <aw7@sanger.ac.uk>
-.\"
-.\" Permission is hereby granted, free of charge, to any person obtaining a
-.\" copy of this software and associated documentation files (the "Software"),
-.\" to deal in the Software without restriction, including without limitation
-.\" the rights to use, copy, modify, merge, publish, distribute, sublicense,
-.\" and/or sell copies of the Software, and to permit persons to whom the
-.\" Software is furnished to do so, subject to the following conditions:
-.\"
-.\" The above copyright notice and this permission notice shall be included in
-.\" all copies or substantial portions of the Software.
-.\"
-.\" THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
-.\" IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
-.\" FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
-.\" THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
-.\" LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
-.\" FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
-.\" DEALINGS IN THE SOFTWARE.
-.\"
-.SH DESCRIPTION
-The S3 plugin allows htslib file functions to communicate with servers that use
-the AWS S3 protocol.  Files are identified by their bucket and object key in a
-URL format e.g.
-
-.B s3://mybucket/path/to/file
-
-With \fIpath/to/file\fR being the object key.
-
-Necessary security information can be provided in as part of the URL, in
-environment variables or from configuration files.
-
-The full URL format is:
-
-.B s3[+SCHEME]://[ID[:SECRET[:TOKEN]]@]BUCKET/PATH
-
-The elements are:
-.TP
-.I SCHEME
-The protocol used.  Defaults to \fIhttps\fR.
-.TP
-.I ID
-The user AWS access key.
-.TP
-.I SECRET
-The secret key for use with the access key.
-.TP
-.I TOKEN
-Token used for temporary security credentials.
-.TP
-.I BUCKET
-AWS S3 bucket.
-.TP
-.I PATH
-Path to the object under the bucket.
-.LP
-
-The environment variables below will be used if the user ID is not set.
-.TP
-.B AWS_ACCESS_KEY_ID
-The user AWS access key.
-.TP
-.B AWS_SECRET_ACCESS_KEY
-The secret key for use with the access key.
-.TP
-.B AWS_DEFAULT_REGION
-The region to use. Defaults to
-.IR us-east-1 .
-.TP
-.B AWS_SESSION_TOKEN
-Token used for temporary security credentials.
-.TP
-.B AWS_DEFAULT_PROFILE
-The profile to use in \fIcredentials\fR, \fIconfig\fR or \fIs3cfg\fR files.
-Defaults to
-.IR default .
-.TP
-.B AWS_PROFILE
-Same as above.
-.TP
-.B AWS_SHARED_CREDENTIALS_FILE
-Location of the credentials file.  Defaults to
-.IR ~/.aws/credentials .
-.TP
-.B HTS_S3_S3CFG
-Location of the s3cfg file.  Defaults to
-.IR ~/.s3cfg .
-.TP
-.B HTS_S3_HOST
-Sets the host.  Defaults to
-.IR s3.amazonaws.com .
-.TP
-.B HTS_S3_V2
-If set use signature v2 rather the default v4.  This will limit the plugin to
-reading only.
-.TP
-.B HTS_S3_PART_SIZE
-Sets the upload part size in Mb, the minimum being 5Mb.
-By default the part size starts at 5Mb and expands at regular intervals to
-accommodate bigger files (up to 2.5 Tbytes with the current rate).
-Using this setting disables the automatic part size expansion.
-.TP
-.B HTS_S3_ADDRESS_STYLE
-Sets the URL style.  Options are auto (default), virtual or path.  
-.LP
-In the absence of an ID from the previous two methods the credential/config
-files will be used.  The default file locations are either
-\fI~/.aws/credentials\fR or \fI~/.s3cfg\fR (in that order).
-
-Entries used in aws style credentials file are aws_access_key_id, 
-aws_secret_access_key, aws_session_token, region and addressing_style.  Only the
-first two are usually needed.
-
-Entries used in s3cmd style config files are access_key, secret_key,
-access_token, host_base, bucket_location and host_bucket. Again only the first
-two are usually needed. The host_bucket option is only used to set a path-style
-URL, see below.
-
-.SH NOTES
-In most cases this plugin transforms the given URL into a virtual host-style
-format e.g. \fIhttps://bucket.host/path/to/file\fR.  A path-style format is used
-where the URL is not DNS compliant or the bucket name contains a dot e.g.
-\fIhttps://host/bu.cket/path/to/file\fR.
-
-Path-style can be forced by setting one either HTS_S3_ADDRESS_STYLE,
-addressing_style or host_bucket.  The first two can be set to \fBpath\fR while
-host_bucket must \fBnot\fR include the \fB%(bucket).s\fR string.
-
-.SH "SEE ALSO"
-.BR htsfile (1)
-.BR samtools (1)
-.PP
-htslib website: <http://www.htslib.org/>
diff -ruN stringtie.orig/htslib/htslib_vars.mk stringtie/htslib/htslib_vars.mk
--- stringtie.orig/htslib/htslib_vars.mk	2024-02-28 13:57:39.701246126 +0100
+++ stringtie/htslib/htslib_vars.mk	1970-01-01 01:00:00.000000000 +0100
@@ -1,54 +0,0 @@
-# Makefile variables useful for third-party code using htslib's public API.
-#
-#    Copyright (C) 2013-2017, 2019-2020 Genome Research Ltd.
-#
-#    Author: John Marshall <jm18@sanger.ac.uk>
-#
-# Permission is hereby granted, free of charge, to any person obtaining a copy
-# of this software and associated documentation files (the "Software"), to deal
-# in the Software without restriction, including without limitation the rights
-# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
-# copies of the Software, and to permit persons to whom the Software is
-# furnished to do so, subject to the following conditions:
-#
-# The above copyright notice and this permission notice shall be included in
-# all copies or substantial portions of the Software.
-#
-# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
-# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
-# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
-# THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
-# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
-# FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
-# DEALINGS IN THE SOFTWARE.
-
-# These variables can be used to express dependencies on htslib headers.
-# See htslib.mk for details.
-
-htslib_bgzf_h = $(HTSPREFIX)htslib/bgzf.h $(htslib_hts_defs_h)
-htslib_cram_h = $(HTSPREFIX)htslib/cram.h $(htslib_hts_defs_h) $(htslib_hts_h) $(htslib_sam_h)
-htslib_faidx_h = $(HTSPREFIX)htslib/faidx.h $(htslib_hts_defs_h) $(htslib_hts_h)
-htslib_hfile_h = $(HTSPREFIX)htslib/hfile.h $(htslib_hts_defs_h)
-htslib_hts_h = $(HTSPREFIX)htslib/hts.h $(htslib_hts_defs_h) $(htslib_hts_log_h) $(htslib_kstring_h) $(htslib_kroundup_h)
-htslib_hts_defs_h = $(HTSPREFIX)htslib/hts_defs.h
-htslib_hts_endian_h = $(HTSPREFIX)htslib/hts_endian.h
-htslib_hts_expr_h = $(HTSPREFIX)htslib/hts_expr.h $(htslib_kstring_h) $(htslib_hts_defs_h)
-htslib_hts_log_h = $(HTSPREFIX)htslib/hts_log.h $(htslib_hts_defs_h)
-htslib_hts_os_h = $(HTSPREFIX)htslib/hts_os.h $(htslib_hts_defs_h)
-htslib_kbitset_h = $(HTSPREFIX)htslib/kbitset.h
-htslib_kfunc_h = $(HTSPREFIX)htslib/kfunc.h $(htslib_hts_defs_h)
-htslib_khash_h = $(HTSPREFIX)htslib/khash.h $(htslib_kstring_h) $(htslib_kroundup_h)
-htslib_khash_str2int_h = $(HTSPREFIX)htslib/khash_str2int.h $(htslib_khash_h)
-htslib_klist_h = $(HTSPREFIX)htslib/klist.h
-htslib_kroundup_h = $(HTSPREFIX)htslib/kroundup.h
-htslib_kseq_h = $(HTSPREFIX)htslib/kseq.h
-htslib_ksort_h = $(HTSPREFIX)htslib/ksort.h
-htslib_kstring_h = $(HTSPREFIX)htslib/kstring.h $(htslib_hts_defs_h) $(htslib_kroundup_h)
-htslib_regidx_h = $(HTSPREFIX)htslib/regidx.h $(htslib_hts_h)
-htslib_sam_h = $(HTSPREFIX)htslib/sam.h $(htslib_hts_h) $(htslib_hts_endian_h)
-htslib_synced_bcf_reader_h = $(HTSPREFIX)htslib/synced_bcf_reader.h $(htslib_hts_h) $(htslib_vcf_h) $(htslib_tbx_h)
-htslib_tbx_h = $(HTSPREFIX)htslib/tbx.h $(htslib_hts_h)
-htslib_thread_pool_h = $(HTSPREFIX)htslib/thread_pool.h $(htslib_hts_defs_h)
-htslib_vcf_h = $(HTSPREFIX)htslib/vcf.h $(htslib_hts_h) $(htslib_kstring_h) $(htslib_hts_defs_h) $(htslib_hts_endian_h)
-htslib_vcf_sweep_h = $(HTSPREFIX)htslib/vcf_sweep.h $(htslib_hts_h) $(htslib_vcf_h)
-htslib_vcfutils_h = $(HTSPREFIX)htslib/vcfutils.h $(htslib_vcf_h)
diff -ruN stringtie.orig/htslib/hts_os.c stringtie/htslib/hts_os.c
--- stringtie.orig/htslib/hts_os.c	2024-02-28 13:57:39.701246126 +0100
+++ stringtie/htslib/hts_os.c	1970-01-01 01:00:00.000000000 +0100
@@ -1,59 +0,0 @@
-/// @file hts_os.c
-/// Operating System specific tweaks, for compatibility with POSIX.
-/*
-   Copyright (C) 2017, 2019-2020 Genome Research Ltd.
-
-    Author: James Bonfield <jkb@sanger.ac.uk>
-
-Permission is hereby granted, free of charge, to any person obtaining a copy
-of this software and associated documentation files (the "Software"), to deal
-in the Software without restriction, including without limitation the rights
-to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
-copies of the Software, and to permit persons to whom the Software is
-furnished to do so, subject to the following conditions:
-
-The above copyright notice and this permission notice shall be included in
-all copies or substantial portions of the Software.
-
-THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
-IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
-FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
-THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
-LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
-FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
-DEALINGS IN THE SOFTWARE.  */
-
-#define HTS_BUILDING_LIBRARY // Enables HTSLIB_EXPORT, see htslib/hts_defs.h
-#include <config.h>
-#include "htslib/hts_defs.h"
-
-// Windows (maybe more) lack a drand48 implementation.
-#ifndef HAVE_DRAND48
-#include "os/rand.c"
-#else
-#include <stdlib.h>
-HTSLIB_EXPORT
-void hts_srand48(long seed)
-{
-#ifdef HAVE_SRAND48_DETERMINISTIC
-    srand48_deterministic(seed);
-#else
-    srand48(seed);
-#endif
-}
-
-HTSLIB_EXPORT
-double hts_erand48(unsigned short xseed[3]) { return erand48(xseed); }
-
-HTSLIB_EXPORT
-double hts_drand48(void) { return drand48(); }
-
-HTSLIB_EXPORT
-long hts_lrand48(void) { return lrand48(); }
-#endif
-
-// // On Windows when using the MSYS or Cygwin terminals, isatty fails
-// #ifdef _WIN32
-// #define USE_FILEEXTD
-// #include "os/iscygpty.c"
-// #endif
diff -ruN stringtie.orig/htslib/kfunc.c stringtie/htslib/kfunc.c
--- stringtie.orig/htslib/kfunc.c	2024-02-28 13:57:39.701246126 +0100
+++ stringtie/htslib/kfunc.c	1970-01-01 01:00:00.000000000 +0100
@@ -1,313 +0,0 @@
-/* The MIT License
-
-   Copyright (C) 2010, 2013-2014, 2020 Genome Research Ltd.
-   Copyright (C) 2011 Attractive Chaos <attractor@live.co.uk>
-
-   Permission is hereby granted, free of charge, to any person obtaining
-   a copy of this software and associated documentation files (the
-   "Software"), to deal in the Software without restriction, including
-   without limitation the rights to use, copy, modify, merge, publish,
-   distribute, sublicense, and/or sell copies of the Software, and to
-   permit persons to whom the Software is furnished to do so, subject to
-   the following conditions:
-
-   The above copyright notice and this permission notice shall be
-   included in all copies or substantial portions of the Software.
-
-   THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
-   EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
-   MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
-   NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS
-   BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
-   ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
-   CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
-   SOFTWARE.
-*/
-
-#define HTS_BUILDING_LIBRARY // Enables HTSLIB_EXPORT, see htslib/hts_defs.h
-#include <config.h>
-
-#include <math.h>
-#include <stdlib.h>
-#include <stdint.h>
-#include "htslib/kfunc.h"
-
-/* Log gamma function
- * \log{\Gamma(z)}
- * AS245, 2nd algorithm, http://lib.stat.cmu.edu/apstat/245
- */
-double kf_lgamma(double z)
-{
-	double x = 0;
-	x += 0.1659470187408462e-06 / (z+7);
-	x += 0.9934937113930748e-05 / (z+6);
-	x -= 0.1385710331296526     / (z+5);
-	x += 12.50734324009056      / (z+4);
-	x -= 176.6150291498386      / (z+3);
-	x += 771.3234287757674      / (z+2);
-	x -= 1259.139216722289      / (z+1);
-	x += 676.5203681218835      / z;
-	x += 0.9999999999995183;
-	return log(x) - 5.58106146679532777 - z + (z-0.5) * log(z+6.5);
-}
-
-/* complementary error function
- * \frac{2}{\sqrt{\pi}} \int_x^{\infty} e^{-t^2} dt
- * AS66, 2nd algorithm, http://lib.stat.cmu.edu/apstat/66
- */
-double kf_erfc(double x)
-{
-	const double p0 = 220.2068679123761;
-	const double p1 = 221.2135961699311;
-	const double p2 = 112.0792914978709;
-	const double p3 = 33.912866078383;
-	const double p4 = 6.37396220353165;
-	const double p5 = .7003830644436881;
-	const double p6 = .03526249659989109;
-	const double q0 = 440.4137358247522;
-	const double q1 = 793.8265125199484;
-	const double q2 = 637.3336333788311;
-	const double q3 = 296.5642487796737;
-	const double q4 = 86.78073220294608;
-	const double q5 = 16.06417757920695;
-	const double q6 = 1.755667163182642;
-	const double q7 = .08838834764831844;
-	double expntl, z, p;
-	z = fabs(x) * M_SQRT2;
-	if (z > 37.) return x > 0.? 0. : 2.;
-	expntl = exp(z * z * - .5);
-	if (z < 10. / M_SQRT2) // for small z
-	    p = expntl * ((((((p6 * z + p5) * z + p4) * z + p3) * z + p2) * z + p1) * z + p0)
-			/ (((((((q7 * z + q6) * z + q5) * z + q4) * z + q3) * z + q2) * z + q1) * z + q0);
-	else p = expntl / 2.506628274631001 / (z + 1. / (z + 2. / (z + 3. / (z + 4. / (z + .65)))));
-	return x > 0.? 2. * p : 2. * (1. - p);
-}
-
-/* The following computes regularized incomplete gamma functions.
- * Formulas are taken from Wiki, with additional input from Numerical
- * Recipes in C (for modified Lentz's algorithm) and AS245
- * (http://lib.stat.cmu.edu/apstat/245).
- *
- * A good online calculator is available at:
- *
- *   http://www.danielsoper.com/statcalc/calc23.aspx
- *
- * It calculates upper incomplete gamma function, which equals
- * kf_gammaq(s,z)*tgamma(s).
- */
-
-#define KF_GAMMA_EPS 1e-14
-#define KF_TINY 1e-290
-
-// regularized lower incomplete gamma function, by series expansion
-static double _kf_gammap(double s, double z)
-{
-	double sum, x;
-	int k;
-	for (k = 1, sum = x = 1.; k < 100; ++k) {
-		sum += (x *= z / (s + k));
-		if (x / sum < KF_GAMMA_EPS) break;
-	}
-	return exp(s * log(z) - z - kf_lgamma(s + 1.) + log(sum));
-}
-// regularized upper incomplete gamma function, by continued fraction
-static double _kf_gammaq(double s, double z)
-{
-	int j;
-	double C, D, f;
-	f = 1. + z - s; C = f; D = 0.;
-	// Modified Lentz's algorithm for computing continued fraction
-	// See Numerical Recipes in C, 2nd edition, section 5.2
-	for (j = 1; j < 100; ++j) {
-		double a = j * (s - j), b = (j<<1) + 1 + z - s, d;
-		D = b + a * D;
-		if (D < KF_TINY) D = KF_TINY;
-		C = b + a / C;
-		if (C < KF_TINY) C = KF_TINY;
-		D = 1. / D;
-		d = C * D;
-		f *= d;
-		if (fabs(d - 1.) < KF_GAMMA_EPS) break;
-	}
-	return exp(s * log(z) - z - kf_lgamma(s) - log(f));
-}
-
-double kf_gammap(double s, double z)
-{
-	return z <= 1. || z < s? _kf_gammap(s, z) : 1. - _kf_gammaq(s, z);
-}
-
-double kf_gammaq(double s, double z)
-{
-	return z <= 1. || z < s? 1. - _kf_gammap(s, z) : _kf_gammaq(s, z);
-}
-
-/* Regularized incomplete beta function. The method is taken from
- * Numerical Recipe in C, 2nd edition, section 6.4. The following web
- * page calculates the incomplete beta function, which equals
- * kf_betai(a,b,x) * gamma(a) * gamma(b) / gamma(a+b):
- *
- *   http://www.danielsoper.com/statcalc/calc36.aspx
- */
-static double kf_betai_aux(double a, double b, double x)
-{
-	double C, D, f;
-	int j;
-	if (x == 0.) return 0.;
-	if (x == 1.) return 1.;
-	f = 1.; C = f; D = 0.;
-	// Modified Lentz's algorithm for computing continued fraction
-	for (j = 1; j < 200; ++j) {
-		double aa, d;
-		int m = j>>1;
-		aa = (j&1)? -(a + m) * (a + b + m) * x / ((a + 2*m) * (a + 2*m + 1))
-			: m * (b - m) * x / ((a + 2*m - 1) * (a + 2*m));
-		D = 1. + aa * D;
-		if (D < KF_TINY) D = KF_TINY;
-		C = 1. + aa / C;
-		if (C < KF_TINY) C = KF_TINY;
-		D = 1. / D;
-		d = C * D;
-		f *= d;
-		if (fabs(d - 1.) < KF_GAMMA_EPS) break;
-	}
-	return exp(kf_lgamma(a+b) - kf_lgamma(a) - kf_lgamma(b) + a * log(x) + b * log(1.-x)) / a / f;
-}
-double kf_betai(double a, double b, double x)
-{
-	return x < (a + 1.) / (a + b + 2.)? kf_betai_aux(a, b, x) : 1. - kf_betai_aux(b, a, 1. - x);
-}
-
-#ifdef KF_MAIN
-#include <stdio.h>
-int main(int argc, char *argv[])
-{
-	double x = 5.5, y = 3;
-	double a, b;
-	printf("erfc(%lg): %lg, %lg\n", x, erfc(x), kf_erfc(x));
-	printf("upper-gamma(%lg,%lg): %lg\n", x, y, kf_gammaq(y, x)*tgamma(y));
-	a = 2; b = 2; x = 0.5;
-	printf("incomplete-beta(%lg,%lg,%lg): %lg\n", a, b, x, kf_betai(a, b, x) / exp(kf_lgamma(a+b) - kf_lgamma(a) - kf_lgamma(b)));
-	return 0;
-}
-#endif
-
-
-// log\binom{n}{k}
-static double lbinom(int n, int k)
-{
-    if (k == 0 || n == k) return 0;
-    return lgamma(n+1) - lgamma(k+1) - lgamma(n-k+1);
-}
-
-// n11  n12  | n1_
-// n21  n22  | n2_
-//-----------+----
-// n_1  n_2  | n
-
-// hypergeometric distribution
-static double hypergeo(int n11, int n1_, int n_1, int n)
-{
-    return exp(lbinom(n1_, n11) + lbinom(n-n1_, n_1-n11) - lbinom(n, n_1));
-}
-
-typedef struct {
-    int n11, n1_, n_1, n;
-    double p;
-} hgacc_t;
-
-// incremental version of hypergenometric distribution
-static double hypergeo_acc(int n11, int n1_, int n_1, int n, hgacc_t *aux)
-{
-    if (n1_ || n_1 || n) {
-        aux->n11 = n11; aux->n1_ = n1_; aux->n_1 = n_1; aux->n = n;
-    } else { // then only n11 changed; the rest fixed
-        if (n11%11 && n11 + aux->n - aux->n1_ - aux->n_1) {
-            if (n11 == aux->n11 + 1) { // incremental
-                aux->p *= (double)(aux->n1_ - aux->n11) / n11
-                    * (aux->n_1 - aux->n11) / (n11 + aux->n - aux->n1_ - aux->n_1);
-                aux->n11 = n11;
-                return aux->p;
-            }
-            if (n11 == aux->n11 - 1) { // incremental
-                aux->p *= (double)aux->n11 / (aux->n1_ - n11)
-                    * (aux->n11 + aux->n - aux->n1_ - aux->n_1) / (aux->n_1 - n11);
-                aux->n11 = n11;
-                return aux->p;
-            }
-        }
-        aux->n11 = n11;
-    }
-    aux->p = hypergeo(aux->n11, aux->n1_, aux->n_1, aux->n);
-    return aux->p;
-}
-
-double kt_fisher_exact(int n11, int n12, int n21, int n22, double *_left, double *_right, double *two)
-{
-    int i, j, max, min;
-    double p, q, left, right;
-    hgacc_t aux;
-    int n1_, n_1, n;
-
-    n1_ = n11 + n12; n_1 = n11 + n21; n = n11 + n12 + n21 + n22; // calculate n1_, n_1 and n
-    max = (n_1 < n1_) ? n_1 : n1_; // max n11, for right tail
-    min = n1_ + n_1 - n;    // not sure why n11-n22 is used instead of min(n_1,n1_)
-    if (min < 0) min = 0; // min n11, for left tail
-    *two = *_left = *_right = 1.;
-    if (min == max) return 1.; // no need to do test
-    q = hypergeo_acc(n11, n1_, n_1, n, &aux); // the probability of the current table
-
-    if (q == 0.0) {
-        /*
-          If here, the calculated probablility is so small it can't be stored
-          in a double, which is possible when the table contains fairly large
-          numbers.  If this happens, most of the calculation can be skipped
-          as 'left', 'right' and '*two' will be (to a good approximation) 0.0.
-          The returned values '*_left' and '*_right' depend on which side
-          of the hypergeometric PDF 'n11' sits.  This can be found by
-          comparing with the mode of the distribution, the formula for which
-          can be found at:
-          https://en.wikipedia.org/wiki/Hypergeometric_distribution
-          Note that in the comparison we multiply through by the denominator
-          of the mode (n + 2) to avoid a division.
-        */
-        if ((int64_t) n11 * ((int64_t) n + 2) < ((int64_t) n_1 + 1) * ((int64_t) n1_ + 1)) {
-            // Peak to right of n11, so probability will be lower for all
-            // of the region from min to n11 and higher for at least some
-            // of the region from n11 to max; hence abs(i-n11) will be 0,
-            // abs(j-n11) will be > 0 and:
-            *_left = 0.0; *_right = 1.0; *two = 0.0;
-            return 0.0;
-        } else {
-            // Peak to left of n11, so probability will be lower for all
-            // of the region from n11 to max and higher for at least some
-            // of the region from min to n11; hence abs(i-n11) will be > 0,
-            // abs(j-n11) will be 0 and:
-            *_left = 1.0; *_right = 0.0; *two = 0.0;
-            return 0.0;
-        }
-    }
-
-    // left tail
-    p = hypergeo_acc(min, 0, 0, 0, &aux);
-    for (left = 0., i = min + 1; p < 0.99999999 * q && i<=max; ++i) // loop until underflow
-        left += p, p = hypergeo_acc(i, 0, 0, 0, &aux);
-    --i;
-    if (p < 1.00000001 * q) left += p;
-    else --i;
-    // right tail
-    p = hypergeo_acc(max, 0, 0, 0, &aux);
-    for (right = 0., j = max - 1; p < 0.99999999 * q && j>=0; --j) // loop until underflow
-        right += p, p = hypergeo_acc(j, 0, 0, 0, &aux);
-    ++j;
-    if (p < 1.00000001 * q) right += p;
-    else ++j;
-    // two-tail
-    *two = left + right;
-    if (*two > 1.) *two = 1.;
-    // adjust left and right
-    if (abs(i - n11) < abs(j - n11)) right = 1. - left + q;
-    else left = 1.0 - right + q;
-    *_left = left; *_right = right;
-    return q;
-}
diff -ruN stringtie.orig/htslib/kstring.c stringtie/htslib/kstring.c
--- stringtie.orig/htslib/kstring.c	2024-02-28 13:57:39.701246126 +0100
+++ stringtie/htslib/kstring.c	1970-01-01 01:00:00.000000000 +0100
@@ -1,444 +0,0 @@
-/* The MIT License
-
-   Copyright (C) 2011 by Attractive Chaos <attractor@live.co.uk>
-   Copyright (C) 2013-2018, 2020-2021 Genome Research Ltd.
-
-   Permission is hereby granted, free of charge, to any person obtaining
-   a copy of this software and associated documentation files (the
-   "Software"), to deal in the Software without restriction, including
-   without limitation the rights to use, copy, modify, merge, publish,
-   distribute, sublicense, and/or sell copies of the Software, and to
-   permit persons to whom the Software is furnished to do so, subject to
-   the following conditions:
-
-   The above copyright notice and this permission notice shall be
-   included in all copies or substantial portions of the Software.
-
-   THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
-   EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
-   MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
-   NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS
-   BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
-   ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
-   CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
-   SOFTWARE.
-*/
-
-#define HTS_BUILDING_LIBRARY // Enables HTSLIB_EXPORT, see htslib/hts_defs.h
-#include <config.h>
-
-#include <stdarg.h>
-#include <stdio.h>
-#include <ctype.h>
-#include <string.h>
-#include <stdint.h>
-#include <math.h>
-#include "htslib/kstring.h"
-
-int kputd(double d, kstring_t *s) {
-	int len = 0;
-	char buf[21], *cp = buf+20, *ep;
-	if (d == 0) {
-		if (signbit(d)) {
-			kputsn("-0",2,s);
-			return 2;
-		} else {
-			kputsn("0",1,s);
-			return 1;
-		}
-	}
-
-	if (d < 0) {
-		kputc('-',s);
-		len = 1;
-		d=-d;
-	}
-	if (!(d >= 0.0001 && d <= 999999)) {
-		if (ks_resize(s, s->l + 50) < 0)
-			return EOF;
-		// We let stdio handle the exponent cases
-		int s2 = sprintf(s->s + s->l, "%g", d);
-		len += s2;
-		s->l += s2;
-		return len;
-	}
-
-	uint64_t i = d*10000000000LL;
-	// Correction for rounding - rather ugly
-
-	// Optimised for small numbers.
-	// Better still would be __builtin_clz on hi/lo 32 and get the
-	// starting point very rapidly.
-	if (d<.0001)
-		i+=0;
-	else if (d<0.001)
-		i+=5;
-	else if (d < 0.01)
-		i+=50;
-	else if (d < 0.1)
-		i+=500;
-	else if (d < 1)
-		i+=5000;
-	else if (d < 10)
-		i+=50000;
-	else if (d < 100)
-		i+=500000;
-	else if (d < 1000)
-		i+=5000000;
-	else if (d < 10000)
-		i+=50000000;
-	else if (d < 100000)
-		i+=500000000;
-	else
-		i+=5000000000LL;
-
-	do {
-		*--cp = '0' + i%10;
-		i /= 10;
-	} while (i >= 1);
-	buf[20] = 0;
-	int p = buf+20-cp;
-	if (p <= 10) { // d < 1
-		//assert(d/1);
-		cp[6] = 0; ep = cp+5;// 6 precision
-		while (p < 10) {
-			*--cp = '0';
-			p++;
-		}
-		*--cp = '.';
-		*--cp = '0';
-	} else {
-		char *xp = --cp;
-		while (p > 10) {
-			xp[0] = xp[1];
-			p--;
-			xp++;
-		}
-		xp[0] = '.';
-		cp[7] = 0; ep=cp+6;
-		if (cp[6] == '.') cp[6] = 0;
-	}
-
-	// Cull trailing zeros
-	while (*ep == '0' && ep > cp)
-		ep--;
-	char *z = ep+1;
-	while (ep > cp) {
-		if (*ep == '.') {
-			if (z[-1] == '.')
-				z[-1] = 0;
-			else
-				z[0] = 0;
-			break;
-		}
-		ep--;
-	}
-
-	int sl = strlen(cp);
-	len += sl;
-	kputsn(cp, sl, s);
-	return len;
-}
-
-int kvsprintf(kstring_t *s, const char *fmt, va_list ap)
-{
-	va_list args;
-	int l;
-	va_copy(args, ap);
-
-	if (fmt[0] == '%' && fmt[1] == 'g' && fmt[2] == 0) {
-		double d = va_arg(args, double);
-		l = kputd(d, s);
-		va_end(args);
-		return l;
-	}
-
-	if (!s->s) {
-		const size_t sz = 64;
-		s->s = malloc(sz);
-		if (!s->s)
-			return -1;
-		s->m = sz;
-		s->l = 0;
-	}
-
-	l = vsnprintf(s->s + s->l, s->m - s->l, fmt, args); // This line does not work with glibc 2.0. See `man snprintf'.
-	va_end(args);
-	if (l + 1 > s->m - s->l) {
-		if (ks_resize(s, s->l + l + 2) < 0)
-			return -1;
-		va_copy(args, ap);
-		l = vsnprintf(s->s + s->l, s->m - s->l, fmt, args);
-		va_end(args);
-	}
-	s->l += l;
-	return l;
-}
-
-int ksprintf(kstring_t *s, const char *fmt, ...)
-{
-	va_list ap;
-	int l;
-	va_start(ap, fmt);
-	l = kvsprintf(s, fmt, ap);
-	va_end(ap);
-	return l;
-}
-
-char *kstrtok(const char *str, const char *sep_in, ks_tokaux_t *aux)
-{
-	const unsigned char *p, *start, *sep = (unsigned char *) sep_in;
-	if (sep) { // set up the table
-		if (str == 0 && aux->finished) return 0; // no need to set up if we have finished
-		aux->finished = 0;
-		if (sep[0] && sep[1]) {
-			aux->sep = -1;
-			aux->tab[0] = aux->tab[1] = aux->tab[2] = aux->tab[3] = 0;
-			for (p = sep; *p; ++p) aux->tab[*p>>6] |= 1ull<<(*p&0x3f);
-		} else aux->sep = sep[0];
-	}
-	if (aux->finished) return 0;
-	else if (str) start = (unsigned char *) str, aux->finished = 0;
-	else start = (unsigned char *) aux->p + 1;
-	if (aux->sep < 0) {
-		for (p = start; *p; ++p)
-			if (aux->tab[*p>>6]>>(*p&0x3f)&1) break;
-	} else {
-		for (p = start; *p; ++p)
-			if (*p == aux->sep) break;
-	}
-	aux->p = (const char *) p; // end of token
-	if (*p == 0) aux->finished = 1; // no more tokens
-	return (char*)start;
-}
-
-// s MUST BE a null terminated string; l = strlen(s)
-int ksplit_core(char *s, int delimiter, int *_max, int **_offsets)
-{
-	int i, n, max, last_char, last_start, *offsets, l;
-	n = 0; max = *_max; offsets = *_offsets;
-	l = strlen(s);
-
-#define __ksplit_aux do {						\
-		if (_offsets) {						\
-			s[i] = 0;					\
-			if (n == max) {					\
-				int *tmp;				\
-				max = max? max<<1 : 2;			\
-				if ((tmp = (int*)realloc(offsets, sizeof(int) * max))) {  \
-					offsets = tmp;			\
-				} else	{				\
-					free(offsets);			\
-					*_offsets = NULL;		\
-					return 0;			\
-				}					\
-			}						\
-			offsets[n++] = last_start;			\
-		} else ++n;						\
-	} while (0)
-
-	for (i = 0, last_char = last_start = 0; i <= l; ++i) {
-		if (delimiter == 0) {
-			if (isspace((int)((unsigned char) s[i])) || s[i] == 0) {
-				if (isgraph(last_char))
-                    __ksplit_aux; // the end of a field
-			} else {
-				if (isspace(last_char) || last_char == 0)
-                    last_start = i;
-			}
-		} else {
-			if (s[i] == delimiter || s[i] == 0) {
-				if (last_char != 0 && last_char != delimiter) __ksplit_aux; // the end of a field
-			} else {
-				if (last_char == delimiter || last_char == 0) last_start = i;
-			}
-		}
-		last_char = (int)((unsigned char)s[i]);
-	}
-	*_max = max; *_offsets = offsets;
-	return n;
-}
-
-int kgetline(kstring_t *s, kgets_func *fgets_fn, void *fp)
-{
-	size_t l0 = s->l;
-
-	while (s->l == l0 || s->s[s->l-1] != '\n') {
-		if (s->m - s->l < 200) {
-			if (ks_resize(s, s->m + 200) < 0)
-				return EOF;
-		}
-		if (fgets_fn(s->s + s->l, s->m - s->l, fp) == NULL) break;
-		s->l += strlen(s->s + s->l);
-	}
-
-	if (s->l == l0) return EOF;
-
-	if (s->l > l0 && s->s[s->l-1] == '\n') {
-		s->l--;
-		if (s->l > l0 && s->s[s->l-1] == '\r') s->l--;
-	}
-	s->s[s->l] = '\0';
-	return 0;
-}
-
-int kgetline2(kstring_t *s, kgets_func2 *fgets_fn, void *fp)
-{
-	size_t l0 = s->l;
-
-	while (s->l == l0 || s->s[s->l-1] != '\n') {
-		if (s->m - s->l < 200) {
-			// We return EOF for both EOF and error and the caller
-			// needs to check for errors in fp, and we haven't
-			// even got there yet.
-			//
-			// The only way of propagating memory errors is to
-			// deliberately call something that we know triggers
-			// and error so fp is also set.  This works for
-			// hgets, but not for gets where reading <= 0 bytes
-			// isn't an error.
-			if (ks_resize(s, s->m + 200) < 0) {
-				fgets_fn(s->s + s->l, 0, fp);
-				return EOF;
-			}
-		}
-		ssize_t len = fgets_fn(s->s + s->l, s->m - s->l, fp);
-		if (len <= 0) break;
-		s->l += len;
-	}
-
-	if (s->l == l0) return EOF;
-
-	if (s->l > l0 && s->s[s->l-1] == '\n') {
-		s->l--;
-		if (s->l > l0 && s->s[s->l-1] == '\r') s->l--;
-	}
-	s->s[s->l] = '\0';
-	return 0;
-}
-
-/**********************
- * Boyer-Moore search *
- **********************/
-
-typedef unsigned char ubyte_t;
-
-// reference: http://www-igm.univ-mlv.fr/~lecroq/string/node14.html
-static int *ksBM_prep(const ubyte_t *pat, int m)
-{
-	int i, *suff, *prep, *bmGs, *bmBc;
-	prep = (int*)calloc(m + 256, sizeof(int));
-    if (!prep) return NULL;
-	bmGs = prep; bmBc = prep + m;
-	{ // preBmBc()
-		for (i = 0; i < 256; ++i) bmBc[i] = m;
-		for (i = 0; i < m - 1; ++i) bmBc[pat[i]] = m - i - 1;
-	}
-	suff = (int*)calloc(m, sizeof(int));
-    if (!suff) { free(prep); return NULL; }
-	{ // suffixes()
-		int f = 0, g;
-		suff[m - 1] = m;
-		g = m - 1;
-		for (i = m - 2; i >= 0; --i) {
-			if (i > g && suff[i + m - 1 - f] < i - g)
-				suff[i] = suff[i + m - 1 - f];
-			else {
-				if (i < g) g = i;
-				f = i;
-				while (g >= 0 && pat[g] == pat[g + m - 1 - f]) --g;
-				suff[i] = f - g;
-			}
-		}
-	}
-	{ // preBmGs()
-		int j = 0;
-		for (i = 0; i < m; ++i) bmGs[i] = m;
-		for (i = m - 1; i >= 0; --i)
-			if (suff[i] == i + 1)
-				for (; j < m - 1 - i; ++j)
-					if (bmGs[j] == m)
-						bmGs[j] = m - 1 - i;
-		for (i = 0; i <= m - 2; ++i)
-			bmGs[m - 1 - suff[i]] = m - 1 - i;
-	}
-	free(suff);
-	return prep;
-}
-
-void *kmemmem(const void *_str, int n, const void *_pat, int m, int **_prep)
-{
-	int i, j, *prep = 0, *bmGs, *bmBc;
-	const ubyte_t *str, *pat;
-	str = (const ubyte_t*)_str; pat = (const ubyte_t*)_pat;
-	prep = (_prep == 0 || *_prep == 0)? ksBM_prep(pat, m) : *_prep;
-    if (!prep) return NULL;
-	if (_prep && *_prep == 0) *_prep = prep;
-	bmGs = prep; bmBc = prep + m;
-	j = 0;
-	while (j <= n - m) {
-		for (i = m - 1; i >= 0 && pat[i] == str[i+j]; --i);
-		if (i >= 0) {
-			int max = bmBc[str[i+j]] - m + 1 + i;
-			if (max < bmGs[i]) max = bmGs[i];
-			j += max;
-		} else return (void*)(str + j);
-	}
-	if (_prep == 0) free(prep);
-	return 0;
-}
-
-char *kstrstr(const char *str, const char *pat, int **_prep)
-{
-	return (char*)kmemmem(str, strlen(str), pat, strlen(pat), _prep);
-}
-
-char *kstrnstr(const char *str, const char *pat, int n, int **_prep)
-{
-	return (char*)kmemmem(str, n, pat, strlen(pat), _prep);
-}
-
-/***********************
- * The main() function *
- ***********************/
-
-#ifdef KSTRING_MAIN
-#include <stdio.h>
-int main()
-{
-	kstring_t *s;
-	int *fields, n, i;
-	ks_tokaux_t aux;
-	char *p;
-	s = (kstring_t*)calloc(1, sizeof(kstring_t));
-	// test ksprintf()
-	ksprintf(s, " abcdefg:    %d ", 100);
-	printf("'%s'\n", s->s);
-	// test ksplit()
-	fields = ksplit(s, 0, &n);
-	for (i = 0; i < n; ++i)
-		printf("field[%d] = '%s'\n", i, s->s + fields[i]);
-	// test kstrtok()
-	s->l = 0;
-	for (p = kstrtok("ab:cde:fg/hij::k", ":/", &aux); p; p = kstrtok(0, 0, &aux)) {
-		kputsn(p, aux.p - p, s);
-		kputc('\n', s);
-	}
-	printf("%s", s->s);
-	// free
-	free(s->s); free(s); free(fields);
-
-	{
-		static char *str = "abcdefgcdgcagtcakcdcd";
-		static char *pat = "cd";
-		char *ret, *s = str;
-		int *prep = 0;
-		while ((ret = kstrstr(s, pat, &prep)) != 0) {
-			printf("match: %s\n", ret);
-			s = ret + prep[0];
-		}
-		free(prep);
-	}
-	return 0;
-}
-#endif
diff -ruN stringtie.orig/htslib/m4/hts_hide_dynamic_syms.m4 stringtie/htslib/m4/hts_hide_dynamic_syms.m4
--- stringtie.orig/htslib/m4/hts_hide_dynamic_syms.m4	2024-02-28 13:57:39.704579460 +0100
+++ stringtie/htslib/m4/hts_hide_dynamic_syms.m4	1970-01-01 01:00:00.000000000 +0100
@@ -1,65 +0,0 @@
-dnl @synopsis HTS_HIDE_DYNAMIC_SYMBOLS
-dnl
-dnl Turn on compiler options that prevent unwanted symbols from being exported
-dnl by shared libraries.
-dnl
-dnl @author Rob Davies <rmd@sanger.ac.uk>
-dnl @license MIT/Expat
-dnl
-dnl Copyright (C) 2018 Genome Research Ltd.
-dnl
-dnl Permission is hereby granted, free of charge, to any person obtaining a copy
-dnl of this software and associated documentation files (the "Software"), to
-dnl deal in the Software without restriction, including without limitation the
-dnl rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
-dnl  sell copies of the Software, and to permit persons to whom the Software is
-dnl furnished to do so, subject to the following conditions:
-dnl
-dnl The above copyright notice and this permission notice shall be included in
-dnl all copies or substantial portions of the Software.
-dnl
-dnl THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
-dnl IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
-dnl FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
-dnl THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
-dnl LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
-dnl FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
-dnl DEALINGS IN THE SOFTWARE.
-
-# SYNOPSIS
-#
-# HTS_TEST_CC_C_LD_FLAG(FLAG, FOUND_VAR)
-#
-# Test if FLAG can be used on both CFLAGS and LDFLAGS.  It it works,
-# variable FOUND_VAR is set to FLAG.
-
-AC_DEFUN([HTS_TEST_CC_C_LD_FLAG],
- [AS_VAR_PUSHDEF([hts_cv_check_flag],[hts_cv_check_$1])dnl
-  AC_CACHE_CHECK([whether the compiler accepts $1],
-   [hts_cv_check_flag],
-   [ac_check_save_cflags=$CFLAGS
-    ac_check_save_ldflags=$LDFLAGS
-    CFLAGS="$CFLAGS $1"
-    LDFLAGS="$LDFLAGS $1"
-    AC_LINK_IFELSE([AC_LANG_PROGRAM()],
-      [AS_VAR_SET([hts_cv_check_flag],[yes])
-       AS_IF([test "x$2" != x],[eval AS_TR_SH([$2])="$1"])],
-      [AS_VAR_SET([hts_cv_check_flag],[no])])
-    CFLAGS=$ac_check_save_cflags
-    LDFLAGS=$ac_check_save_ldflags])
-  AS_VAR_POPDEF([hts_cv_check_flag])dnl
-])
-
-AC_DEFUN([HTS_HIDE_DYNAMIC_SYMBOLS], [
-  # Test for flags to set default shared library visibility to hidden
-  # -fvisibility=hidden : GCC compatible
-  # -xldscope=hidden    : SunStudio
-  ac_opt_found=no
-  m4_foreach_w([ac_opt],[-fvisibility=hidden -xldscope=hidden],
-   [AS_IF([test "x$ac_opt_found" = "xno"],
-     [HTS_TEST_CC_C_LD_FLAG(ac_opt,[ac_opt_found])])
-   ])
-  AS_IF([test "x$ac_opt_found" != "xno"],
-   [CFLAGS="$CFLAGS $ac_opt_found"
-    LDFLAGS="$LDFLAGS $ac_opt_found"])
-])
diff -ruN stringtie.orig/htslib/m4/hts_prog_cc_warnings.m4 stringtie/htslib/m4/hts_prog_cc_warnings.m4
--- stringtie.orig/htslib/m4/hts_prog_cc_warnings.m4	2024-02-28 13:57:39.704579460 +0100
+++ stringtie/htslib/m4/hts_prog_cc_warnings.m4	1970-01-01 01:00:00.000000000 +0100
@@ -1,208 +0,0 @@
-dnl @synopsis HTS_PROG_CC_WARNINGS([ANSI])
-dnl
-dnl Derived from
-dnl     http://ac-archive.sourceforge.net/ac-archive/vl_prog_cc_warnings.html
-dnl
-dnl Enables a reasonable set of warnings for the C compiler.
-dnl Optionally, if the first argument is nonempty, turns on flags which
-dnl enforce and/or enable proper ANSI C if such are known with the
-dnl compiler used.
-dnl
-dnl Currently this macro knows about GCC, Solaris C compiler, Digital
-dnl Unix C compiler, C for AIX Compiler, HP-UX C compiler, IRIX C
-dnl compiler, NEC SX-5 (Super-UX 10) C compiler, and Cray J90 (Unicos
-dnl 10.0.0.8) C compiler.
-dnl
-dnl @category C
-dnl @author Ville Laurikari <vl@iki.fi>
-dnl Updated by Rob Davies <rmd@sanger.ac.uk> for HTSlib
-dnl @license AllPermissive
-dnl Copying and distribution of this file, with or without modification,
-dnl are permitted in any medium without royalty provided the copyright notice
-dnl and this notice are preserved. Users of this software should generally
-dnl follow the principles of the MIT License including its disclaimer.
-dnl Original Copyright (c) Ville Laurikari 2002
-dnl Modifications Copyright (c) Genome Research Limited 2015,2017
-
-AC_DEFUN([HTS_PROG_CC_WARNINGS], [
-  AC_ARG_ENABLE([warnings],
-    [AS_HELP_STRING([--disable-warnings], [turn off compiler warnings])],
-    [],
-    [enable_warnings=yes])
-
-  AS_IF([test "x$enable_warnings" != xno],[
-    AC_REQUIRE([AC_PROG_GREP])
-
-    ansi="$1"
-    AS_IF([test "x$ansi" = "x"],
-          [msg="for C compiler warning flags"],
-          [msg="for C compiler warning and ANSI conformance flags"])
-
-    AC_MSG_CHECKING($msg)
-    AC_CACHE_VAL(hts_cv_prog_cc_warnings, [dnl
-      hts_cv_prog_cc_warnings=""
-      AS_IF([test "x$CC" != "x"],[
-        cat > conftest.c <<EOF
-int main(int argc, char **argv) { return 0; }
-EOF
-
-dnl Most compilers print some kind of a version string with some command
-dnl line options (often "-V").  The version string should be checked
-dnl before doing a test compilation run with compiler-specific flags.
-dnl This is because some compilers (like the Cray compiler) only
-dnl produce a warning message for unknown flags instead of returning
-dnl an error, resulting in a false positive.  Also, compilers may do
-dnl erratic things when invoked with flags meant for a different
-dnl compiler.
-
-dnl We attempt to strip out any flags that are already on CFLAGS.
-dnl If an option needs more than one word (e.g. see Cray below) then
-dnl they should be separated by hash signs (#), which will be converted
-dnl to spaces before comparing and possibly adding to CFLAGS.
-dnl This separator will need to be changed if a new compiler ever needs
-dnl an option that includes a hash sign...
-
-        # Tests for flags to enable C compiler warnings
-        # GCC compatible
-        AS_IF([test "x$GCC" = "xyes" &&
-               "$CC" -c -Wall conftest.c > /dev/null 2>&1 &&
-               test -f conftest.o],[dnl
-          AS_IF([test "x$ansi" = "x"],
-                [hts_cv_prog_cc_warnings="-Wall"],
-                [hts_cv_prog_cc_warnings="-Wall -ansi -pedantic"])
-        ],
-        # Sun Studio or Solaris C compiler
-        ["$CC" -V 2>&1 | $GREP -i -E "WorkShop|Sun C" > /dev/null 2>&1 &&
-         "$CC" -c -v -Xc conftest.c > /dev/null 2>&1 &&
-         test -f conftest.o],[dnl
-        AS_IF([test "x$ansi" = "x"],
-              [hts_cv_prog_cc_warnings="-v"],
-              [hts_cv_prog_cc_warnings="-v -Xc"])
-        ],
-        # Digital Unix C compiler
-        ["$CC" -V 2>&1 | $GREP -i "Digital UNIX Compiler" > /dev/null 2>&1 &&
-         "$CC" -c -verbose -w0 -warnprotos -std1 conftest.c > /dev/null 2>&1 &&
-         test -f conftest.o], [dnl
-           AS_IF([test "x$ansi" = "x"],
-                 [hts_cv_prog_cc_warnings="-verbose -w0 -warnprotos"],
-                 [hts_cv_prog_cc_warnings="-verbose -w0 -warnprotos -std1"])
-           ],
-        # C for AIX Compiler
-        ["$CC" 2>&1 | $GREP -i "C for AIX Compiler" > /dev/null 2>&1 &&
-         "$CC" -c -qlanglvl=ansi -qinfo=all conftest.c > /dev/null 2>&1 &&
-         test -f conftest.o],[dnl
-        AS_IF([test "x$ansi" = "x"],
-              [hts_cv_prog_cc_warnings="-qsrcmsg -qinfo=all:noppt:noppc:noobs:nocnd"],
-              [hts_cv_prog_cc_warnings="-qsrcmsg -qinfo=all:noppt:noppc:noobs:nocnd -qlanglvl=ansi"])
-        ],
-        # IRIX C compiler
-        ["$CC" -version 2>&1 | $GREP -i "MIPSpro Compilers" > /dev/null 2>&1 &&
-         "$CC" -c -fullwarn -ansi -ansiE conftest.c > /dev/null 2>&1 &&
-         test -f conftest.o],[dnl
-           AS_IF([test "x$ansi" = "x"],
-                 [hts_cv_prog_cc_warnings="-fullwarn"],
-                 [hts_cv_prog_cc_warnings="-fullwarn -ansi -ansiE"])
-          ],
-        # HP-UX C compiler
-        [what "$CC" 2>&1 | $GREP -i "HP C Compiler" > /dev/null 2>&1 &&
-         "$CC" -c -Aa +w1 conftest.c > /dev/null 2>&1 &&
-         test -f conftest.o],[dnl
-        AS_IF([test "x$ansi" = "x"],
-              [hts_cv_prog_cc_warnings="+w1"],
-              [hts_cv_prog_cc_warnings="+w1 -Aa"])
-        ],
-        # The NEC SX series (Super-UX 10) C compiler
-        ["$CC" -V 2>&1 | $GREP "/SX" > /dev/null 2>&1 &&
-         "$CC" -c -pvctl[,]fullmsg -Xc conftest.c > /dev/null 2>&1 &&
-         test -f conftest.o],[
-        AS_IF([test "x$ansi" = "x"],
-              [hts_cv_prog_cc_warnings="-pvctl[,]fullmsg"],
-              [hts_cv_prog_cc_warnings="-pvctl[,]fullmsg -Xc"])
-        ],
-        # The Cray C compiler (Unicos)
-        ["$CC" -V 2>&1 | $GREP -i "Cray" > /dev/null 2>&1 &&
-         "$CC" -c -h msglevel_2 conftest.c > /dev/null 2>&1 &&
-         test -f conftest.o],[dnl
-        AS_IF([test "x$ansi" = "x"],
-              [hts_cv_prog_cc_warnings="-h#msglevel_2"],
-              [hts_cv_prog_cc_warnings="-h#msglevel_2,conform"])
-        ],
-	# The Tiny C Compiler
-        ["$CC" -v 2>&1 | $GREP "tcc version" > /dev/null &&
-         "$CC" -Wall -c conftest.c > /dev/null 2>&1 &&
-         test -f conftest.o],[dnl
-         hts_cv_prog_cc_warnings="-Wall"
-        ])
-        rm -f conftest.*
-      ])
-    ])
-
-    AS_IF([test "x$hts_cv_prog_cc_warnings" != "x"],[
-dnl Print result, with underscores as spaces
-ac_arg_result=`echo "$hts_cv_prog_cc_warnings" | tr '#' ' '`
-AC_MSG_RESULT($ac_arg_result)
-
-dnl Add options to CFLAGS only if they are not already present
-ac_arg_needed=""
-for ac_arg in $hts_cv_prog_cc_warnings
-do
-  ac_arg_sp=`echo "$ac_arg" | tr '#' ' '`
-  AS_CASE([" $CFLAGS "],
-[*" $ac_arg_sp "*], [],
-[ac_arg_needed="$ac_arg_all $ac_arg_sp"])
-done
-CFLAGS="$ac_arg_needed $CFLAGS"],[dnl
-      AC_MSG_RESULT(unknown)
-    ])
-  ])
-])dnl HTS_PROG_CC_WARNINGS
-
-# SYNOPSIS
-#
-# HTS_PROG_CC_WERROR(FLAGS_VAR)
-#
-# Set FLAGS_VAR to the flags needed to make the C compiler treat warnings
-# as errors.
-
-AC_DEFUN([HTS_PROG_CC_WERROR], [
-  AC_ARG_ENABLE([werror],
-    [AS_HELP_STRING([--enable-werror], [change warnings into errors, where supported])],
-    [],
-    [enable_werror=no])
-
-  AS_IF([test "x$enable_werror" != xno],[
-    AC_MSG_CHECKING([for C compiler flags to error on warnings])
-    AC_CACHE_VAL(hts_cv_prog_cc_werror, [dnl
-      hts_cv_prog_cc_werror=""
-      AS_IF([test "x$CC" != "x"],[
-        cat > conftest.c <<EOF
-int main(int argc, char **argv) { return 0; }
-EOF
-
-        AS_IF(dnl
-	 # Tests for flags to make the C compiler treat warnings as errors
-         # GCC compatible
-         [test "x$GCC" = "xyes" &&
-          "$CC" -c -Werror conftest.c > /dev/null 2>&1 &&
-          test -f conftest.o],[hts_cv_prog_cc_werror="-Werror"],
-         # Sun Studio or Solaris C compiler
-         ["$CC" -V 2>&1 | $GREP -i -E "WorkShop|Sun C" > /dev/null 2>&1 &&
-          "$CC" -c -errwarn=%all conftest.c > /dev/null 2>&1 &&
-          test -f conftest.o],[hts_cv_prog_cc_werror="-errwarn=%all"],
-	 # The Tiny C Compiler
-         ["$CC" -v 2>&1 | $GREP "tcc version" > /dev/null &&
-          "$CC" -Wall -c conftest.c > /dev/null 2>&1 &&
-          test -f conftest.o],[hts_cv_prog_cc_werror="-Werror"]
-         dnl TODO: Add more compilers
-        )
-        rm -f conftest.*
-      ])
-    ])
-    AS_IF([test "x$hts_cv_prog_cc_werror" != x],[
-      AC_MSG_RESULT($hts_cv_prog_cc_werror)
-      AS_IF([test "x$1" != x],[eval AS_TR_SH([$1])="$hts_cv_prog_cc_werror"])
-    ],[dnl
-      AC_MSG_RESULT(unknown)
-    ])
-  ])
-])dnl HTS_PROG_CC_WERROR
diff -ruN stringtie.orig/htslib/m4/pkg.m4 stringtie/htslib/m4/pkg.m4
--- stringtie.orig/htslib/m4/pkg.m4	2024-02-28 13:57:39.704579460 +0100
+++ stringtie/htslib/m4/pkg.m4	1970-01-01 01:00:00.000000000 +0100
@@ -1,275 +0,0 @@
-# pkg.m4 - Macros to locate and use pkg-config.   -*- Autoconf -*-
-# serial 12 (pkg-config-0.29.2)
-
-dnl Copyright  2004 Scott James Remnant <scott@netsplit.com>.
-dnl Copyright  2012-2015 Dan Nicholson <dbn.lists@gmail.com>
-dnl
-dnl This program is free software; you can redistribute it and/or modify
-dnl it under the terms of the GNU General Public License as published by
-dnl the Free Software Foundation; either version 2 of the License, or
-dnl (at your option) any later version.
-dnl
-dnl This program is distributed in the hope that it will be useful, but
-dnl WITHOUT ANY WARRANTY; without even the implied warranty of
-dnl MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
-dnl General Public License for more details.
-dnl
-dnl You should have received a copy of the GNU General Public License
-dnl along with this program; if not, write to the Free Software
-dnl Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA
-dnl 02111-1307, USA.
-dnl
-dnl As a special exception to the GNU General Public License, if you
-dnl distribute this file as part of a program that contains a
-dnl configuration script generated by Autoconf, you may include it under
-dnl the same distribution terms that you use for the rest of that
-dnl program.
-
-dnl PKG_PREREQ(MIN-VERSION)
-dnl -----------------------
-dnl Since: 0.29
-dnl
-dnl Verify that the version of the pkg-config macros are at least
-dnl MIN-VERSION. Unlike PKG_PROG_PKG_CONFIG, which checks the user's
-dnl installed version of pkg-config, this checks the developer's version
-dnl of pkg.m4 when generating configure.
-dnl
-dnl To ensure that this macro is defined, also add:
-dnl m4_ifndef([PKG_PREREQ],
-dnl     [m4_fatal([must install pkg-config 0.29 or later before running autoconf/autogen])])
-dnl
-dnl See the "Since" comment for each macro you use to see what version
-dnl of the macros you require.
-m4_defun([PKG_PREREQ],
-[m4_define([PKG_MACROS_VERSION], [0.29.2])
-m4_if(m4_version_compare(PKG_MACROS_VERSION, [$1]), -1,
-    [m4_fatal([pkg.m4 version $1 or higher is required but ]PKG_MACROS_VERSION[ found])])
-])dnl PKG_PREREQ
-
-dnl PKG_PROG_PKG_CONFIG([MIN-VERSION])
-dnl ----------------------------------
-dnl Since: 0.16
-dnl
-dnl Search for the pkg-config tool and set the PKG_CONFIG variable to
-dnl first found in the path. Checks that the version of pkg-config found
-dnl is at least MIN-VERSION. If MIN-VERSION is not specified, 0.9.0 is
-dnl used since that's the first version where most current features of
-dnl pkg-config existed.
-AC_DEFUN([PKG_PROG_PKG_CONFIG],
-[m4_pattern_forbid([^_?PKG_[A-Z_]+$])
-m4_pattern_allow([^PKG_CONFIG(_(PATH|LIBDIR|SYSROOT_DIR|ALLOW_SYSTEM_(CFLAGS|LIBS)))?$])
-m4_pattern_allow([^PKG_CONFIG_(DISABLE_UNINSTALLED|TOP_BUILD_DIR|DEBUG_SPEW)$])
-AC_ARG_VAR([PKG_CONFIG], [path to pkg-config utility])
-AC_ARG_VAR([PKG_CONFIG_PATH], [directories to add to pkg-config's search path])
-AC_ARG_VAR([PKG_CONFIG_LIBDIR], [path overriding pkg-config's built-in search path])
-
-if test "x$ac_cv_env_PKG_CONFIG_set" != "xset"; then
-	AC_PATH_TOOL([PKG_CONFIG], [pkg-config])
-fi
-if test -n "$PKG_CONFIG"; then
-	_pkg_min_version=m4_default([$1], [0.9.0])
-	AC_MSG_CHECKING([pkg-config is at least version $_pkg_min_version])
-	if $PKG_CONFIG --atleast-pkgconfig-version $_pkg_min_version; then
-		AC_MSG_RESULT([yes])
-	else
-		AC_MSG_RESULT([no])
-		PKG_CONFIG=""
-	fi
-fi[]dnl
-])dnl PKG_PROG_PKG_CONFIG
-
-dnl PKG_CHECK_EXISTS(MODULES, [ACTION-IF-FOUND], [ACTION-IF-NOT-FOUND])
-dnl -------------------------------------------------------------------
-dnl Since: 0.18
-dnl
-dnl Check to see whether a particular set of modules exists. Similar to
-dnl PKG_CHECK_MODULES(), but does not set variables or print errors.
-dnl
-dnl Please remember that m4 expands AC_REQUIRE([PKG_PROG_PKG_CONFIG])
-dnl only at the first occurrence in configure.ac, so if the first place
-dnl it's called might be skipped (such as if it is within an "if", you
-dnl have to call PKG_CHECK_EXISTS manually
-AC_DEFUN([PKG_CHECK_EXISTS],
-[AC_REQUIRE([PKG_PROG_PKG_CONFIG])dnl
-if test -n "$PKG_CONFIG" && \
-    AC_RUN_LOG([$PKG_CONFIG --exists --print-errors "$1"]); then
-  m4_default([$2], [:])
-m4_ifvaln([$3], [else
-  $3])dnl
-fi])
-
-dnl _PKG_CONFIG([VARIABLE], [COMMAND], [MODULES])
-dnl ---------------------------------------------
-dnl Internal wrapper calling pkg-config via PKG_CONFIG and setting
-dnl pkg_failed based on the result.
-m4_define([_PKG_CONFIG],
-[if test -n "$$1"; then
-    pkg_cv_[]$1="$$1"
- elif test -n "$PKG_CONFIG"; then
-    PKG_CHECK_EXISTS([$3],
-                     [pkg_cv_[]$1=`$PKG_CONFIG --[]$2 "$3" 2>/dev/null`
-		      test "x$?" != "x0" && pkg_failed=yes ],
-		     [pkg_failed=yes])
- else
-    pkg_failed=untried
-fi[]dnl
-])dnl _PKG_CONFIG
-
-dnl _PKG_SHORT_ERRORS_SUPPORTED
-dnl ---------------------------
-dnl Internal check to see if pkg-config supports short errors.
-AC_DEFUN([_PKG_SHORT_ERRORS_SUPPORTED],
-[AC_REQUIRE([PKG_PROG_PKG_CONFIG])
-if $PKG_CONFIG --atleast-pkgconfig-version 0.20; then
-        _pkg_short_errors_supported=yes
-else
-        _pkg_short_errors_supported=no
-fi[]dnl
-])dnl _PKG_SHORT_ERRORS_SUPPORTED
-
-
-dnl PKG_CHECK_MODULES(VARIABLE-PREFIX, MODULES, [ACTION-IF-FOUND],
-dnl   [ACTION-IF-NOT-FOUND])
-dnl --------------------------------------------------------------
-dnl Since: 0.4.0
-dnl
-dnl Note that if there is a possibility the first call to
-dnl PKG_CHECK_MODULES might not happen, you should be sure to include an
-dnl explicit call to PKG_PROG_PKG_CONFIG in your configure.ac
-AC_DEFUN([PKG_CHECK_MODULES],
-[AC_REQUIRE([PKG_PROG_PKG_CONFIG])dnl
-AC_ARG_VAR([$1][_CFLAGS], [C compiler flags for $1, overriding pkg-config])dnl
-AC_ARG_VAR([$1][_LIBS], [linker flags for $1, overriding pkg-config])dnl
-
-pkg_failed=no
-AC_MSG_CHECKING([for $2])
-
-_PKG_CONFIG([$1][_CFLAGS], [cflags], [$2])
-_PKG_CONFIG([$1][_LIBS], [libs], [$2])
-
-m4_define([_PKG_TEXT], [Alternatively, you may set the environment variables $1[]_CFLAGS
-and $1[]_LIBS to avoid the need to call pkg-config.
-See the pkg-config man page for more details.])
-
-if test $pkg_failed = yes; then
-        AC_MSG_RESULT([no])
-        _PKG_SHORT_ERRORS_SUPPORTED
-        if test $_pkg_short_errors_supported = yes; then
-	        $1[]_PKG_ERRORS=`$PKG_CONFIG --short-errors --print-errors --cflags --libs "$2" 2>&1`
-        else
-	        $1[]_PKG_ERRORS=`$PKG_CONFIG --print-errors --cflags --libs "$2" 2>&1`
-        fi
-	# Put the nasty error message in config.log where it belongs
-	echo "$$1[]_PKG_ERRORS" >&AS_MESSAGE_LOG_FD
-
-	m4_default([$4], [AC_MSG_ERROR(
-[Package requirements ($2) were not met:
-
-$$1_PKG_ERRORS
-
-Consider adjusting the PKG_CONFIG_PATH environment variable if you
-installed software in a non-standard prefix.
-
-_PKG_TEXT])[]dnl
-        ])
-elif test $pkg_failed = untried; then
-        AC_MSG_RESULT([no])
-	m4_default([$4], [AC_MSG_FAILURE(
-[The pkg-config script could not be found or is too old.  Make sure it
-is in your PATH or set the PKG_CONFIG environment variable to the full
-path to pkg-config.
-
-_PKG_TEXT
-
-To get pkg-config, see <http://pkg-config.freedesktop.org/>.])[]dnl
-        ])
-else
-	$1[]_CFLAGS=$pkg_cv_[]$1[]_CFLAGS
-	$1[]_LIBS=$pkg_cv_[]$1[]_LIBS
-        AC_MSG_RESULT([yes])
-	$3
-fi[]dnl
-])dnl PKG_CHECK_MODULES
-
-
-dnl PKG_CHECK_MODULES_STATIC(VARIABLE-PREFIX, MODULES, [ACTION-IF-FOUND],
-dnl   [ACTION-IF-NOT-FOUND])
-dnl ---------------------------------------------------------------------
-dnl Since: 0.29
-dnl
-dnl Checks for existence of MODULES and gathers its build flags with
-dnl static libraries enabled. Sets VARIABLE-PREFIX_CFLAGS from --cflags
-dnl and VARIABLE-PREFIX_LIBS from --libs.
-dnl
-dnl Note that if there is a possibility the first call to
-dnl PKG_CHECK_MODULES_STATIC might not happen, you should be sure to
-dnl include an explicit call to PKG_PROG_PKG_CONFIG in your
-dnl configure.ac.
-AC_DEFUN([PKG_CHECK_MODULES_STATIC],
-[AC_REQUIRE([PKG_PROG_PKG_CONFIG])dnl
-_save_PKG_CONFIG=$PKG_CONFIG
-PKG_CONFIG="$PKG_CONFIG --static"
-PKG_CHECK_MODULES($@)
-PKG_CONFIG=$_save_PKG_CONFIG[]dnl
-])dnl PKG_CHECK_MODULES_STATIC
-
-
-dnl PKG_INSTALLDIR([DIRECTORY])
-dnl -------------------------
-dnl Since: 0.27
-dnl
-dnl Substitutes the variable pkgconfigdir as the location where a module
-dnl should install pkg-config .pc files. By default the directory is
-dnl $libdir/pkgconfig, but the default can be changed by passing
-dnl DIRECTORY. The user can override through the --with-pkgconfigdir
-dnl parameter.
-AC_DEFUN([PKG_INSTALLDIR],
-[m4_pushdef([pkg_default], [m4_default([$1], ['${libdir}/pkgconfig'])])
-m4_pushdef([pkg_description],
-    [pkg-config installation directory @<:@]pkg_default[@:>@])
-AC_ARG_WITH([pkgconfigdir],
-    [AS_HELP_STRING([--with-pkgconfigdir], pkg_description)],,
-    [with_pkgconfigdir=]pkg_default)
-AC_SUBST([pkgconfigdir], [$with_pkgconfigdir])
-m4_popdef([pkg_default])
-m4_popdef([pkg_description])
-])dnl PKG_INSTALLDIR
-
-
-dnl PKG_NOARCH_INSTALLDIR([DIRECTORY])
-dnl --------------------------------
-dnl Since: 0.27
-dnl
-dnl Substitutes the variable noarch_pkgconfigdir as the location where a
-dnl module should install arch-independent pkg-config .pc files. By
-dnl default the directory is $datadir/pkgconfig, but the default can be
-dnl changed by passing DIRECTORY. The user can override through the
-dnl --with-noarch-pkgconfigdir parameter.
-AC_DEFUN([PKG_NOARCH_INSTALLDIR],
-[m4_pushdef([pkg_default], [m4_default([$1], ['${datadir}/pkgconfig'])])
-m4_pushdef([pkg_description],
-    [pkg-config arch-independent installation directory @<:@]pkg_default[@:>@])
-AC_ARG_WITH([noarch-pkgconfigdir],
-    [AS_HELP_STRING([--with-noarch-pkgconfigdir], pkg_description)],,
-    [with_noarch_pkgconfigdir=]pkg_default)
-AC_SUBST([noarch_pkgconfigdir], [$with_noarch_pkgconfigdir])
-m4_popdef([pkg_default])
-m4_popdef([pkg_description])
-])dnl PKG_NOARCH_INSTALLDIR
-
-
-dnl PKG_CHECK_VAR(VARIABLE, MODULE, CONFIG-VARIABLE,
-dnl [ACTION-IF-FOUND], [ACTION-IF-NOT-FOUND])
-dnl -------------------------------------------
-dnl Since: 0.28
-dnl
-dnl Retrieves the value of the pkg-config variable for the given module.
-AC_DEFUN([PKG_CHECK_VAR],
-[AC_REQUIRE([PKG_PROG_PKG_CONFIG])dnl
-AC_ARG_VAR([$1], [value of $3 for $2, overriding pkg-config])dnl
-
-_PKG_CONFIG([$1], [variable="][$3]["], [$2])
-AS_VAR_COPY([$1], [pkg_cv_][$1])
-
-AS_VAR_IF([$1], [""], [$5], [$4])dnl
-])dnl PKG_CHECK_VAR
diff -ruN stringtie.orig/htslib/Makefile stringtie/htslib/Makefile
--- stringtie.orig/htslib/Makefile	2024-02-28 13:57:39.701246126 +0100
+++ stringtie/htslib/Makefile	1970-01-01 01:00:00.000000000 +0100
@@ -1,795 +0,0 @@
-# Makefile for htslib, a C library for high-throughput sequencing data formats.
-#
-#    Copyright (C) 2013-2021 Genome Research Ltd.
-#
-#    Author: John Marshall <jm18@sanger.ac.uk>
-#
-# Permission is hereby granted, free of charge, to any person obtaining a copy
-# of this software and associated documentation files (the "Software"), to deal
-# in the Software without restriction, including without limitation the rights
-# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
-# copies of the Software, and to permit persons to whom the Software is
-# furnished to do so, subject to the following conditions:
-#
-# The above copyright notice and this permission notice shall be included in
-# all copies or substantial portions of the Software.
-#
-# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
-# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
-# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
-# THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
-# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
-# FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
-# DEALINGS IN THE SOFTWARE.
-
-CC     = gcc
-AR     = ar
-RANLIB = ranlib
-
-# Default libraries to link if configure is not used
-htslib_default_libs = -lz -lm -lbz2 -ldeflate -llzma 
-
-CPPFLAGS = -I./xlibs/include
-# TODO: make the 64-bit support for VCF optional via configure, for now add -DVCF_ALLOW_INT64
-#       to CFLAGS manually, here or in config.mk if the latter exists.
-# TODO: probably update cram code to make it compile cleanly with -Wc++-compat
-# For testing strict C99 support add -std=c99 -D_XOPEN_SOURCE=600
-#CFLAGS   = -g -Wall -O2 -pedantic -std=c99 -D_XOPEN_SOURCE=600
-CFLAGS   = -g -Wall -O2 -fvisibility=hidden -D HAVE_LIBDEFLATE -D HAVE_LIBLZMA
-
-EXTRA_CFLAGS_PIC = -fpic
-LDFLAGS  = -fvisibility=hidden -L./xlibs/lib
-LIBS     = $(htslib_default_libs)
-
-prefix      = /usr/local
-exec_prefix = $(prefix)
-bindir      = $(exec_prefix)/bin
-includedir  = $(prefix)/include
-libdir      = $(exec_prefix)/lib
-libexecdir  = $(exec_prefix)/libexec
-datarootdir = $(prefix)/share
-mandir      = $(datarootdir)/man
-man1dir     = $(mandir)/man1
-man5dir     = $(mandir)/man5
-man7dir     = $(mandir)/man7
-pkgconfigdir= $(libdir)/pkgconfig
-
-MKDIR_P = mkdir -p
-INSTALL = install -p
-INSTALL_DATA    = $(INSTALL) -m 644
-INSTALL_DIR     = $(MKDIR_P) -m 755
-INSTALL_LIB     = $(INSTALL_DATA)
-INSTALL_MAN     = $(INSTALL_DATA)
-INSTALL_PROGRAM = $(INSTALL)
-
-# Set by config.mk if plugins are enabled
-plugindir =
-
-BUILT_PROGRAMS = \
-	bgzip \
-	htsfile \
-	tabix
-
-BUILT_TEST_PROGRAMS = \
-	test/hts_endian \
-	test/fieldarith \
-	test/hfile \
-	test/pileup \
-	test/plugins-dlhts \
-	test/sam \
-	test/test_bgzf \
-	test/test_expr \
-	test/test_kfunc \
-	test/test_kstring \
-	test/test_realn \
-	test/test-regidx \
-	test/test_str2int \
-	test/test_view \
-	test/test_index \
-	test/test-vcf-api \
-	test/test-vcf-sweep \
-	test/test-bcf-sr \
-	test/fuzz/hts_open_fuzzer.o \
-	test/test-bcf-translate \
-	test/test-parse-reg \
-	test/test_introspection
-
-BUILT_THRASH_PROGRAMS = \
-	test/thrash_threads1 \
-	test/thrash_threads2 \
-	test/thrash_threads3 \
-	test/thrash_threads4 \
-	test/thrash_threads5 \
-	test/thrash_threads6 \
-	test/thrash_threads7
-
-all: lib-static lib-shared $(BUILT_PROGRAMS) plugins $(BUILT_TEST_PROGRAMS) \
-     htslib_static.mk htslib-uninstalled.pc
-
-ALL_CPPFLAGS = -I. $(CPPFLAGS)
-
-# Usually htscodecs.mk is generated by running configure or config.status,
-# but if those aren't used create a default here.
-htscodecs.mk:
-	echo '# Default htscodecs.mk generated by Makefile' > $@
-	echo 'include $$(HTSPREFIX)htscodecs_bundled.mk' >> $@
-
-HTSPREFIX =
-include htslib_vars.mk
-include htscodecs.mk
-
-# If not using GNU make, you need to copy the version number from version.sh
-# into here.
-PACKAGE_VERSION := $(shell ./version.sh)
-
-LIBHTS_SOVERSION = 3
-
-# Version numbers for the Mac dynamic library.  Note that the leading 3
-# is not strictly necessary and should be removed the next time
-# LIBHTS_SOVERSION is bumped (see #1144 and
-# https://developer.apple.com/library/archive/documentation/DeveloperTools/Conceptual/DynamicLibraries/100-Articles/DynamicLibraryDesignGuidelines.html#//apple_ref/doc/uid/TP40002013-SW23)
-MACH_O_COMPATIBILITY_VERSION = 3.1.12
-MACH_O_CURRENT_VERSION = 3.1.12
-
-# $(NUMERIC_VERSION) is for items that must have a numeric X.Y.Z string
-# even if this is a dirty or untagged Git working tree.
-NUMERIC_VERSION := $(shell ./version.sh numeric)
-
-# Force version.h to be remade if $(PACKAGE_VERSION) has changed.
-version.h: $(if $(wildcard version.h),$(if $(findstring "$(PACKAGE_VERSION)",$(shell cat version.h)),,force))
-
-version.h:
-	echo '#define HTS_VERSION_TEXT "$(PACKAGE_VERSION)"' > $@
-
-print-version:
-	@echo $(PACKAGE_VERSION)
-
-show-version:
-	@echo PACKAGE_VERSION = $(PACKAGE_VERSION)
-	@echo NUMERIC_VERSION = $(NUMERIC_VERSION)
-
-config_vars.h:
-	echo '#define HTS_CC "$(CC)"' > $@
-	echo '#define HTS_CPPFLAGS "$(CPPFLAGS)"' >> $@
-	echo '#define HTS_CFLAGS "$(CFLAGS)"' >> $@
-	echo '#define HTS_LDFLAGS "$(LDFLAGS)"' >> $@
-	echo '#define HTS_LIBS "$(LIBS)"' >> $@
-
-.SUFFIXES: .bundle .c .cygdll .dll .o .pico .so
-
-.c.o:
-	$(CC) $(CFLAGS) $(ALL_CPPFLAGS) -c -o $@ $<
-
-.c.pico:
-	$(CC) $(CFLAGS) $(ALL_CPPFLAGS) $(EXTRA_CFLAGS_PIC) -c -o $@ $<
-
-
-LIBHTS_OBJS = \
-	kfunc.o \
-	kstring.o \
-	bcf_sr_sort.o \
-	bgzf.o \
-	errmod.o \
-	faidx.o \
-	header.o \
-	hfile.o \
-	hts.o \
-	hts_expr.o \
-	hts_os.o\
-	md5.o \
-	multipart.o \
-	probaln.o \
-	realn.o \
-	regidx.o \
-	region.o \
-	sam.o \
-	synced_bcf_reader.o \
-	vcf_sweep.o \
-	tbx.o \
-	textutils.o \
-	thread_pool.o \
-	vcf.o \
-	vcfutils.o \
-	cram/cram_codecs.o \
-	cram/cram_decode.o \
-	cram/cram_encode.o \
-	cram/cram_external.o \
-	cram/cram_index.o \
-	cram/cram_io.o \
-	cram/cram_stats.o \
-	cram/mFILE.o \
-	cram/open_trace_file.o \
-	cram/pooled_alloc.o \
-	cram/string_alloc.o \
-	$(HTSCODECS_OBJS) \
-	$(NONCONFIGURE_OBJS)
-
-# Without configure we wish to have a rich set of default figures,
-# but we still need conditional inclusion as we wish to still
-# support ./configure --disable-blah.
-#NONCONFIGURE_OBJS = hfile_libcurl.o
-NONCONFIGURE_OBJS = 
-
-PLUGIN_EXT  =
-PLUGIN_OBJS =
-
-cram_h = cram/cram.h $(cram_samtools_h) $(header_h) $(cram_structs_h) $(cram_io_h) cram/cram_encode.h cram/cram_decode.h cram/cram_stats.h cram/cram_codecs.h cram/cram_index.h $(htslib_cram_h)
-cram_io_h = cram/cram_io.h $(cram_misc_h)
-cram_misc_h = cram/misc.h
-cram_os_h = cram/os.h $(htslib_hts_endian_h)
-cram_samtools_h = cram/cram_samtools.h $(htslib_sam_h)
-cram_structs_h = cram/cram_structs.h $(htslib_thread_pool_h) $(htslib_cram_h) cram/string_alloc.h cram/mFILE.h $(htslib_khash_h)
-cram_open_trace_file_h = cram/open_trace_file.h cram/mFILE.h
-bcf_sr_sort_h = bcf_sr_sort.h $(htslib_synced_bcf_reader_h) $(htslib_kbitset_h)
-header_h = header.h cram/string_alloc.h cram/pooled_alloc.h $(htslib_khash_h) $(htslib_kstring_h) $(htslib_sam_h)
-hfile_internal_h = hfile_internal.h $(htslib_hts_defs_h) $(htslib_hfile_h) $(textutils_internal_h)
-hts_internal_h = hts_internal.h $(htslib_hts_h) $(textutils_internal_h)
-sam_internal_h = sam_internal.h $(htslib_sam_h)
-textutils_internal_h = textutils_internal.h $(htslib_kstring_h)
-thread_pool_internal_h = thread_pool_internal.h $(htslib_thread_pool_h)
-
-# To be effective, config.mk needs to appear after most Makefile variables are
-# set but before most rules appear, so that it can both use previously-set
-# variables in its own rules' prerequisites and also update variables for use
-# in later rules' prerequisites.
-
-# If your make doesn't accept -include, change this to 'include' if you are
-# using the configure script or just comment the line out if you are not.
--include config.mk
-
-# Usually config.h is generated by running configure or config.status,
-# but if those aren't used create a default config.h here.
-config.h:
-	echo '/* Default config.h generated by Makefile */' > $@
-	echo '#ifndef _XOPEN_SOURCE' >> $@
-	echo '#define _XOPEN_SOURCE 600' >> $@
-	echo '#endif' >> $@
-	echo '#define HAVE_LIBBZ2 1' >> $@
-	echo '#define HAVE_LIBLZMA 1' >> $@
-	echo '#ifndef __APPLE__' >> $@
-	echo '#define HAVE_LZMA_H 1' >> $@
-	echo '#endif' >> $@
-	echo '#define HAVE_DRAND48 1' >> $@
-	echo '#define HAVE_LIBDEFLATE 1' >> $@
-
-# And similarly for htslib.pc.tmp ("pkg-config template").  No dependency
-# on htslib.pc.in listed, as if that file is newer the usual way to regenerate
-# this target is via configure or config.status rather than this rule.
-htslib.pc.tmp:
-	sed -e '/^static_libs=/s/@static_LIBS@/$(htslib_default_libs)/;s#@[^-][^@]*@##g' htslib.pc.in > $@
-
-# Create a makefile fragment listing the libraries and LDFLAGS needed for
-# static linking.  This can be included by projects that want to build
-# and link against the htslib source tree instead of an installed library.
-htslib_static.mk: htslib.pc.tmp
-	sed -n '/^static_libs=/s/[^=]*=/HTSLIB_static_LIBS = /p;/^static_ldflags=/s/[^=]*=/HTSLIB_static_LDFLAGS = /p' $< > $@
-
-
-lib-static: libhts.a
-
-# $(shell), :=, and ifeq/.../endif are GNU Make-specific.  If you don't have
-# GNU Make, comment out the parts of these conditionals that don't apply.
-ifneq "$(origin PLATFORM)" "file"
-PLATFORM := $(shell uname -s)
-endif
-ifeq "$(PLATFORM)" "Darwin"
-SHLIB_FLAVOUR = dylib
-lib-shared: libhts.dylib
-else ifeq "$(findstring CYGWIN,$(PLATFORM))" "CYGWIN"
-SHLIB_FLAVOUR = cygdll
-lib-shared: cyghts-$(LIBHTS_SOVERSION).dll
-else ifeq "$(findstring MSYS,$(PLATFORM))" "MSYS"
-SHLIB_FLAVOUR = dll
-lib-shared: hts-$(LIBHTS_SOVERSION).dll
-else ifeq "$(findstring MINGW,$(PLATFORM))" "MINGW"
-SHLIB_FLAVOUR = dll
-lib-shared: hts-$(LIBHTS_SOVERSION).dll
-else
-SHLIB_FLAVOUR = so
-lib-shared: libhts.so
-endif
-
-BUILT_PLUGINS = $(PLUGIN_OBJS:.o=$(PLUGIN_EXT))
-
-plugins: $(BUILT_PLUGINS)
-
-
-libhts.a: $(LIBHTS_OBJS)
-	@-rm -f $@
-	$(AR) -rc $@ $(LIBHTS_OBJS)
-	-$(RANLIB) $@
-
-print-config:
-	@echo LDFLAGS = $(LDFLAGS)
-	@echo LIBHTS_OBJS = $(LIBHTS_OBJS)
-	@echo LIBS = $(LIBS)
-	@echo PLATFORM = $(PLATFORM)
-
-# The target here is libhts.so, as that is the built file that other rules
-# depend upon and that is used when -lhts appears in other program's recipes.
-# As a byproduct invisible to make, libhts.so.NN is also created, as it is the
-# file used at runtime (when $LD_LIBRARY_PATH includes the build directory).
-
-libhts.so: $(LIBHTS_OBJS:.o=.pico)
-	$(CC) -shared -Wl,-soname,libhts.so.$(LIBHTS_SOVERSION) $(LDFLAGS) -o $@ $(LIBHTS_OBJS:.o=.pico) $(LIBS) -lpthread
-	ln -sf $@ libhts.so.$(LIBHTS_SOVERSION)
-
-# Similarly this also creates libhts.NN.dylib as a byproduct, so that programs
-# when run can find this uninstalled shared library (when $DYLD_LIBRARY_PATH
-# includes this project's build directory).
-
-libhts.dylib: $(LIBHTS_OBJS)
-	$(CC) -dynamiclib -install_name $(libdir)/libhts.$(LIBHTS_SOVERSION).dylib -current_version $(MACH_O_CURRENT_VERSION) -compatibility_version $(MACH_O_COMPATIBILITY_VERSION) $(LDFLAGS) -o $@ $(LIBHTS_OBJS) $(LIBS)
-	ln -sf $@ libhts.$(LIBHTS_SOVERSION).dylib
-
-cyghts-$(LIBHTS_SOVERSION).dll libhts.dll.a: $(LIBHTS_OBJS)
-	$(CC) -shared -Wl,--out-implib=libhts.dll.a -Wl,--enable-auto-import $(LDFLAGS) -o $@ -Wl,--whole-archive $(LIBHTS_OBJS) -Wl,--no-whole-archive $(LIBS) -lpthread
-
-hts-$(LIBHTS_SOVERSION).dll hts.dll.a: $(LIBHTS_OBJS)
-	$(CC) -shared -Wl,--out-implib=hts.dll.a -Wl,--enable-auto-import -Wl,--exclude-all-symbols $(LDFLAGS) -o $@ -Wl,--whole-archive $(LIBHTS_OBJS) -Wl,--no-whole-archive $(LIBS) -lpthread
-
-# Target to allow htslib.mk to build all the object files before it
-# links the shared and static libraries.
-hts-object-files: $(LIBHTS_OBJS)
-	touch $@
-
-# On Unix dlopen("libhts.so.NN", RTLD_LAZY) may default to RTLD_LOCAL.
-# Hence plugins need to link to (shared) libhts.so.NN themselves, as they
-# may not be able to access libhts symbols via the main program's libhts
-# if that was dynamically loaded without an explicit RTLD_GLOBAL.
-%.so: %.pico libhts.so
-	$(CC) -shared -Wl,-E $(LDFLAGS) -o $@ $< libhts.so $(LIBS) -lpthread
-
-# For programs *statically* linked to libhts.a, on macOS loading a plugin
-# linked to a shared libhts.NN.dylib would lead to conflicting duplicate
-# symbols.  Fortunately macOS dlopen() defaults to RTLD_GLOBAL so there
-# is less need for plugins to link back to libhts themselves.
-%.bundle: %.o
-	$(CC) -bundle -Wl,-undefined,dynamic_lookup $(LDFLAGS) -o $@ $< $(LIBS)
-
-%.cygdll: %.o libhts.dll.a
-	$(CC) -shared $(LDFLAGS) -o $@ $< libhts.dll.a $(LIBS)
-
-%.dll: %.o hts.dll.a
-	$(CC) -shared $(LDFLAGS) -o $@ $< hts.dll.a $(LIBS)
-
-
-bgzf.o bgzf.pico: bgzf.c config.h $(htslib_hts_h) $(htslib_bgzf_h) $(htslib_hfile_h) $(htslib_thread_pool_h) $(htslib_hts_endian_h) cram/pooled_alloc.h $(hts_internal_h) $(htslib_khash_h)
-errmod.o errmod.pico: errmod.c config.h $(htslib_hts_h) $(htslib_ksort_h) $(htslib_hts_os_h)
-kstring.o kstring.pico: kstring.c config.h $(htslib_kstring_h)
-header.o header.pico: header.c config.h $(textutils_internal_h) $(header_h)
-hfile.o hfile.pico: hfile.c config.h $(htslib_hfile_h) $(hfile_internal_h) $(htslib_kstring_h) $(hts_internal_h) $(htslib_khash_h)
-hfile_gcs.o hfile_gcs.pico: hfile_gcs.c config.h $(htslib_hts_h) $(htslib_kstring_h) $(hfile_internal_h)
-hfile_libcurl.o hfile_libcurl.pico: hfile_libcurl.c config.h $(hfile_internal_h) $(htslib_hts_h) $(htslib_kstring_h) $(htslib_khash_h)
-hfile_s3_write.o hfile_s3_write.pico: hfile_s3_write.c config.h $(hfile_internal_h) $(htslib_hts_h) $(htslib_kstring_h) $(htslib_khash_h)
-hfile_s3.o hfile_s3.pico: hfile_s3.c config.h $(hfile_internal_h) $(htslib_hts_h) $(htslib_kstring_h)
-hts.o hts.pico: hts.c config.h $(htslib_hts_expr_h) $(htslib_hts_h) $(htslib_bgzf_h) $(cram_h) $(htslib_hfile_h) $(htslib_hts_endian_h) version.h config_vars.h $(hts_internal_h) $(hfile_internal_h) $(sam_internal_h) $(htslib_hts_os_h) $(htslib_khash_h) $(htslib_kseq_h) $(htslib_ksort_h) $(htslib_tbx_h) $(htscodecs_htscodecs_h)
-hts_expr.o hts_expr.pico: hts_expr.c config.h $(htslib_hts_expr_h) $(textutils_internal_h)
-hts_os.o hts_os.pico: hts_os.c config.h $(htslib_hts_defs_h) os/rand.c
-vcf.o vcf.pico: vcf.c config.h $(htslib_vcf_h) $(htslib_bgzf_h) $(htslib_tbx_h) $(htslib_hfile_h) $(hts_internal_h) $(htslib_khash_str2int_h) $(htslib_kstring_h) $(htslib_sam_h) $(htslib_khash_h) $(htslib_kseq_h) $(htslib_hts_endian_h)
-sam.o sam.pico: sam.c config.h $(htslib_hts_defs_h) $(htslib_sam_h) $(htslib_bgzf_h) $(cram_h) $(hts_internal_h) $(sam_internal_h) $(htslib_hfile_h) $(htslib_hts_endian_h) $(htslib_hts_expr_h) $(header_h) $(htslib_khash_h) $(htslib_kseq_h) $(htslib_kstring_h)
-tbx.o tbx.pico: tbx.c config.h $(htslib_tbx_h) $(htslib_bgzf_h) $(htslib_hts_endian_h) $(hts_internal_h) $(htslib_khash_h)
-faidx.o faidx.pico: faidx.c config.h $(htslib_bgzf_h) $(htslib_faidx_h) $(htslib_hfile_h) $(htslib_khash_h) $(htslib_kstring_h) $(hts_internal_h)
-bcf_sr_sort.o bcf_sr_sort.pico: bcf_sr_sort.c config.h $(bcf_sr_sort_h) $(htslib_khash_str2int_h) $(htslib_kbitset_h)
-synced_bcf_reader.o synced_bcf_reader.pico: synced_bcf_reader.c config.h $(htslib_synced_bcf_reader_h) $(htslib_kseq_h) $(htslib_khash_str2int_h) $(htslib_bgzf_h) $(htslib_thread_pool_h) $(bcf_sr_sort_h)
-vcf_sweep.o vcf_sweep.pico: vcf_sweep.c config.h $(htslib_vcf_sweep_h) $(htslib_bgzf_h)
-vcfutils.o vcfutils.pico: vcfutils.c config.h $(htslib_vcfutils_h) $(htslib_kbitset_h)
-kfunc.o kfunc.pico: kfunc.c config.h $(htslib_kfunc_h)
-regidx.o regidx.pico: regidx.c config.h $(htslib_hts_h) $(htslib_kstring_h) $(htslib_kseq_h) $(htslib_khash_str2int_h) $(htslib_regidx_h) $(hts_internal_h)
-region.o region.pico: region.c config.h $(htslib_hts_h) $(htslib_khash_h)
-md5.o md5.pico: md5.c config.h $(htslib_hts_h) $(htslib_hts_endian_h)
-multipart.o multipart.pico: multipart.c config.h $(htslib_kstring_h) $(hts_internal_h) $(hfile_internal_h)
-plugin.o plugin.pico: plugin.c config.h $(hts_internal_h) $(htslib_kstring_h)
-probaln.o probaln.pico: probaln.c config.h $(htslib_hts_h)
-realn.o realn.pico: realn.c config.h $(htslib_hts_h) $(htslib_sam_h)
-textutils.o textutils.pico: textutils.c config.h $(htslib_hfile_h) $(htslib_kstring_h) $(htslib_sam_h) $(hts_internal_h)
-
-cram/cram_codecs.o cram/cram_codecs.pico: cram/cram_codecs.c config.h $(htslib_hts_endian_h) $(htscodecs_varint_h) $(htscodecs_pack_h) $(htscodecs_rle_h) $(cram_h)
-cram/cram_decode.o cram/cram_decode.pico: cram/cram_decode.c config.h $(cram_h) $(cram_os_h) $(htslib_hts_h)
-cram/cram_encode.o cram/cram_encode.pico: cram/cram_encode.c config.h $(cram_h) $(cram_os_h) $(sam_internal_h) $(htslib_hts_h) $(htslib_hts_endian_h)
-cram/cram_external.o cram/cram_external.pico: cram/cram_external.c config.h $(htslib_hfile_h) $(cram_h)
-cram/cram_index.o cram/cram_index.pico: cram/cram_index.c config.h $(htslib_bgzf_h) $(htslib_hfile_h) $(hts_internal_h) $(cram_h) $(cram_os_h)
-cram/cram_io.o cram/cram_io.pico: cram/cram_io.c config.h os/lzma_stub.h $(cram_h) $(cram_os_h) $(htslib_hts_h) $(cram_open_trace_file_h) $(htscodecs_rANS_static_h) $(htscodecs_rANS_static4x16_h) $(htscodecs_arith_dynamic_h) $(htscodecs_tokenise_name3_h) $(htscodecs_fqzcomp_qual_h) $(htscodecs_varint_h) $(htslib_hfile_h) $(htslib_bgzf_h) $(htslib_faidx_h) $(hts_internal_h)
-cram/cram_stats.o cram/cram_stats.pico: cram/cram_stats.c config.h $(cram_h) $(cram_os_h)
-cram/mFILE.o cram/mFILE.pico: cram/mFILE.c config.h $(htslib_hts_log_h) $(cram_os_h) cram/mFILE.h
-cram/open_trace_file.o cram/open_trace_file.pico: cram/open_trace_file.c config.h $(cram_os_h) $(cram_open_trace_file_h) $(cram_misc_h) $(htslib_hfile_h) $(htslib_hts_log_h) $(htslib_hts_h)
-cram/pooled_alloc.o cram/pooled_alloc.pico: cram/pooled_alloc.c config.h cram/pooled_alloc.h $(cram_misc_h)
-cram/string_alloc.o cram/string_alloc.pico: cram/string_alloc.c config.h cram/string_alloc.h
-thread_pool.o thread_pool.pico: thread_pool.c config.h $(thread_pool_internal_h) $(htslib_hts_log_h)
-
-htscodecs/htscodecs/arith_dynamic.o htscodecs/htscodecs/arith_dynamic.pico: htscodecs/htscodecs/arith_dynamic.c config.h $(htscodecs_arith_dynamic_h) $(htscodecs_varint_h) $(htscodecs_pack_h) $(htscodecs_utils_h) $(htscodecs_c_simple_model_h)
-htscodecs/htscodecs/fqzcomp_qual.o htscodecs/htscodecs/fqzcomp_qual.pico: htscodecs/htscodecs/fqzcomp_qual.c config.h $(htscodecs_fqzcomp_qual_h) $(htscodecs_varint_h) $(htscodecs_c_simple_model_h)
-htscodecs/htscodecs/htscodecs.o htscodecs/htscodecs/htscodecs.pico: htscodecs/htscodecs/htscodecs.c $(htscodecs_htscodecs_h) $(htscodecs_version_h)
-htscodecs/htscodecs/pack.o htscodecs/htscodecs/pack.pico: htscodecs/htscodecs/pack.c config.h $(htscodecs_pack_h)
-htscodecs/htscodecs/rANS_static4x16pr.o htscodecs/htscodecs/rANS_static4x16pr.pico: htscodecs/htscodecs/rANS_static4x16pr.c config.h $(htscodecs_rANS_word_h) $(htscodecs_rANS_static4x16_h) $(htscodecs_varint_h) $(htscodecs_pack_h) $(htscodecs_rle_h) $(htscodecs_utils_h)
-htscodecs/htscodecs/rANS_static.o htscodecs/htscodecs/rANS_static.pico: htscodecs/htscodecs/rANS_static.c config.h $(htscodecs_rANS_byte_h) $(htscodecs_utils_h) $(htscodecs_rANS_static_h)
-htscodecs/htscodecs/rle.o htscodecs/htscodecs/rle.pico: htscodecs/htscodecs/rle.c config.h $(htscodecs_varint_h) $(htscodecs_rle_h)
-htscodecs/htscodecs/tokenise_name3.o htscodecs/htscodecs/tokenise_name3.pico: htscodecs/htscodecs/tokenise_name3.c config.h $(htscodecs_pooled_alloc_h) $(htscodecs_arith_dynamic_h) $(htscodecs_rANS_static4x16_h) $(htscodecs_tokenise_name3_h) $(htscodecs_varint_h)
-
-
-bgzip: bgzip.o libhts.a
-	$(CC) $(LDFLAGS) -o $@ bgzip.o libhts.a $(LIBS) -lpthread
-
-htsfile: htsfile.o libhts.a
-	$(CC) $(LDFLAGS) -o $@ htsfile.o libhts.a $(LIBS) -lpthread
-
-tabix: tabix.o libhts.a
-	$(CC) $(LDFLAGS) -o $@ tabix.o libhts.a $(LIBS) -lpthread
-
-bgzip.o: bgzip.c config.h $(htslib_bgzf_h) $(htslib_hts_h)
-htsfile.o: htsfile.c config.h $(htslib_hfile_h) $(htslib_hts_h) $(htslib_sam_h) $(htslib_vcf_h)
-tabix.o: tabix.c config.h $(htslib_tbx_h) $(htslib_sam_h) $(htslib_vcf_h) $(htslib_kseq_h) $(htslib_bgzf_h) $(htslib_hts_h) $(htslib_regidx_h) $(htslib_hts_defs_h) $(htslib_hts_log_h)
-
-# Runes to check that the htscodecs submodule is present
-ifdef HTSCODECS_SOURCES
-htscodecs/htscodecs/%.c: | htscodecs/htscodecs
-	@if test -e htscodecs/.git && test ! -e "$@" ; then \
-	  echo "Missing file '$@'" ; \
-	  echo "  - Do you need to update the htscodecs submodule?" ; \
-	  false ; \
-	fi
-
-htscodecs/htscodecs/%.h: | htscodecs/htscodecs
-	@if test -e htscodecs/.git && test ! -e "$@" ; then \
-	  echo "Missing file '$@'" ; \
-	  echo "  - Do you need to update the htscodecs submodule?" ; \
-	  false ; \
-	fi
-
-htscodecs/htscodecs:
-	@if test -e .git ; then \
-	printf "\\n\\nError: htscodecs submodule files not present for htslib.\\n\
-	Try running: \\n\
-	    git submodule update --init --recursive\\n\
-	in the top-level htslib directory and then re-run make.\\n\\n\\n" ; \
-	else \
-	  printf "\\n\\nError: htscodecs submodule files not present and this is not a git checkout.\\n\
-	  You have an incomplete distribution.  Please try downloading one of the\\n\
-	  official releases from https://www.htslib.org/\\n" ; \
-	fi
-	@false
-
-# Build the htscodecs/htscodecs/version.h file if necessary
-htscodecs/htscodecs/version.h: force
-	@if test -e htscodecs/configure.ac ; then \
-	  cd htscodecs ; \
-	  iv=`awk '/^AC_INIT/ { match($$0, /^AC_INIT\(htscodecs, *([0-9](\.[0-9])*)\)/, m); print substr($$0, m[1, "start"], m[1, "length"]) }' configure.ac` ; \
-	  vers="$$iv$${vers:+-g$$vers}" ; \
-	  if ! grep -s -q '"'"$$vers"'"' htscodecs/version.h ; then \
-	    echo 'Updating $@ : #define HTSCODECS_VERSION_TEXT "'"$$vers"'"' ; \
-	    echo '#define HTSCODECS_VERSION_TEXT "'"$$vers"'"' > htscodecs/version.h ; \
-	  fi ; \
-	fi
-endif
-
-# Maintainer source code checks
-# - copyright boilerplate presence
-# - tab and trailing space detection
-maintainer-check:
-	test/maintainer/check_copyright.pl .
-	test/maintainer/check_spaces.pl .
-
-# For tests that might use it, set $REF_PATH explicitly to use only reference
-# areas within the test suite (or set it to ':' to use no reference areas).
-#
-# If using MSYS, avoid poor shell expansion via:
-#    MSYS2_ARG_CONV_EXCL="*" make check
-check test: $(BUILT_PROGRAMS) $(BUILT_TEST_PROGRAMS) $(BUILT_PLUGINS) $(HTSCODECS_TEST_TARGETS)
-	test/hts_endian
-	test/test_expr
-	test/test_kfunc
-	test/test_kstring
-	test/test_str2int
-	test/fieldarith test/fieldarith.sam
-	test/hfile
-	HTS_PATH=. test/with-shlib.sh test/plugins-dlhts -g ./libhts.$(SHLIB_FLAVOUR)
-	HTS_PATH=. test/with-shlib.sh test/plugins-dlhts -l ./libhts.$(SHLIB_FLAVOUR)
-	test/test_bgzf test/bgziptest.txt
-	test/test-parse-reg -t test/colons.bam
-	cd test/sam_filter && ./filter.sh filter.tst
-	cd test/tabix && ./test-tabix.sh tabix.tst
-	cd test/mpileup && ./test-pileup.sh mpileup.tst
-	REF_PATH=: test/sam test/ce.fa test/faidx.fa test/fastqs.fq
-	test/test-regidx
-	cd test && REF_PATH=: ./test.pl $${TEST_OPTS:-}
-
-test/hts_endian: test/hts_endian.o
-	$(CC) $(LDFLAGS) -o $@ test/hts_endian.o $(LIBS)
-
-test/fuzz/hts_open_fuzzer: test/fuzz/hts_open_fuzzer.o
-	$(CC) $(LDFLAGS) -o $@ test/fuzz/hts_open_fuzzer.o libhts.a $(LIBS) -lpthread
-
-test/fieldarith: test/fieldarith.o libhts.a
-	$(CC) $(LDFLAGS) -o $@ test/fieldarith.o libhts.a $(LIBS) -lpthread
-
-test/hfile: test/hfile.o libhts.a
-	$(CC) $(LDFLAGS) -o $@ test/hfile.o libhts.a $(LIBS) -lpthread
-
-test/pileup: test/pileup.o libhts.a
-	$(CC) $(LDFLAGS) -o $@ test/pileup.o libhts.a $(LIBS) -lpthread
-
-test/plugins-dlhts: test/plugins-dlhts.o
-	$(CC) $(LDFLAGS) -o $@ test/plugins-dlhts.o $(LIBS)
-
-test/sam: test/sam.o libhts.a
-	$(CC) $(LDFLAGS) -o $@ test/sam.o libhts.a $(LIBS) -lpthread
-
-test/test_bgzf: test/test_bgzf.o libhts.a
-	$(CC) $(LDFLAGS) -o $@ test/test_bgzf.o libhts.a -lz $(LIBS) -lpthread
-
-test/test_expr: test/test_expr.o libhts.a
-	$(CC) $(LDFLAGS) -o $@ test/test_expr.o libhts.a -lz $(LIBS) -lpthread
-
-test/test_kfunc: test/test_kfunc.o libhts.a
-	$(CC) $(LDFLAGS) -o $@ test/test_kfunc.o libhts.a -lz $(LIBS) -lpthread
-
-test/test_kstring: test/test_kstring.o libhts.a
-	$(CC) $(LDFLAGS) -o $@ test/test_kstring.o libhts.a -lz $(LIBS) -lpthread
-
-test/test_realn: test/test_realn.o libhts.a
-	$(CC) $(LDFLAGS) -o $@ test/test_realn.o libhts.a $(LIBS) -lpthread
-
-test/test-regidx: test/test-regidx.o libhts.a
-	$(CC) $(LDFLAGS) -o $@ test/test-regidx.o libhts.a $(LIBS) -lpthread
-
-test/test-parse-reg: test/test-parse-reg.o libhts.a
-	$(CC) $(LDFLAGS) -o $@ test/test-parse-reg.o libhts.a $(LIBS) -lpthread
-
-test/test_str2int: test/test_str2int.o libhts.a
-	$(CC) $(LDFLAGS) -o $@ test/test_str2int.o libhts.a $(LIBS) -lpthread
-
-test/test_view: test/test_view.o libhts.a
-	$(CC) $(LDFLAGS) -o $@ test/test_view.o libhts.a $(LIBS) -lpthread
-
-test/test_index: test/test_index.o libhts.a
-	$(CC) $(LDFLAGS) -o $@ test/test_index.o libhts.a $(LIBS) -lpthread
-
-test/test-vcf-api: test/test-vcf-api.o libhts.a
-	$(CC) $(LDFLAGS) -o $@ test/test-vcf-api.o libhts.a $(LIBS) -lpthread
-
-test/test-vcf-sweep: test/test-vcf-sweep.o libhts.a
-	$(CC) $(LDFLAGS) -o $@ test/test-vcf-sweep.o libhts.a $(LIBS) -lpthread
-
-test/test-bcf-sr: test/test-bcf-sr.o libhts.a
-	$(CC) $(LDFLAGS) -o $@ test/test-bcf-sr.o libhts.a -lz $(LIBS) -lpthread
-
-test/test-bcf-translate: test/test-bcf-translate.o libhts.a
-	$(CC) $(LDFLAGS) -o $@ test/test-bcf-translate.o libhts.a -lz $(LIBS) -lpthread
-
-test/test_introspection: test/test_introspection.o libhts.a
-	$(CC) $(LDFLAGS) -o $@ test/test_introspection.o libhts.a $(LIBS) -lpthread
-
-# Extra tests for bundled htscodecs
-test_htscodecs_rans4x8: htscodecs/tests/rans4x8
-	cd htscodecs/tests && srcdir=. && export srcdir && ./rans4x8.test
-
-test_htscodecs_rans4x16: htscodecs/tests/rans4x16pr
-	cd htscodecs/tests && srcdir=. && export srcdir && ./rans4x16.test
-
-test_htscodecs_arith: htscodecs/tests/arith_dynamic
-	cd htscodecs/tests && srcdir=. && export srcdir && ./arith.test
-
-test_htscodecs_tok3: htscodecs/tests/tokenise_name3
-	cd htscodecs/tests && srcdir=. && export srcdir && ./tok3.test
-
-test_htscodecs_fqzcomp: htscodecs/tests/fqzcomp_qual
-	cd htscodecs/tests && srcdir=. && export srcdir && ./fqzcomp.test
-
-test_htscodecs_varint: htscodecs/tests/varint
-	cd htscodecs/tests && ./varint
-
-htscodecs/tests/arith_dynamic: htscodecs/tests/arith_dynamic_test.o $(HTSCODECS_OBJS)
-	$(CC) $(LDFLAGS) -o $@ $^ $(LIBS) -lm -lpthread
-
-htscodecs/tests/fqzcomp_qual: htscodecs/tests/fqzcomp_qual_test.o $(HTSCODECS_OBJS)
-	$(CC) $(LDFLAGS) -o $@ $^ $(LIBS) -lm -lpthread
-
-htscodecs/tests/rans4x16pr: htscodecs/tests/rANS_static4x16pr_test.o $(HTSCODECS_OBJS)
-	$(CC) $(LDFLAGS) -o $@ $^ $(LIBS) -lm -lpthread
-
-htscodecs/tests/rans4x8: htscodecs/tests/rANS_static_test.o $(HTSCODECS_OBJS)
-	$(CC) $(LDFLAGS) -o $@ $^ $(LIBS) -lm -lpthread
-
-htscodecs/tests/tokenise_name3: htscodecs/tests/tokenise_name3_test.o $(HTSCODECS_OBJS)
-	$(CC) $(LDFLAGS) -o $@ $^ $(LIBS) -lm -lpthread
-
-htscodecs/tests/varint: htscodecs/tests/varint_test.o $(HTSCODECS_OBJS)
-	$(CC) $(LDFLAGS) -o $@ $^ $(LIBS) -lm -lpthread
-
-htscodecs/tests/arith_dynamic_test.o: CPPFLAGS += -Ihtscodecs -D_POSIX_C_SOURCE=200112L
-htscodecs/tests/arith_dynamic_test.o: htscodecs/tests/arith_dynamic_test.c $(htscodecs_arith_dynamic_h)
-htscodecs/tests/fqzcomp_qual_test.o: CPPFLAGS += -Ihtscodecs -D_POSIX_C_SOURCE=200112L
-htscodecs/tests/fqzcomp_qual_test.o: htscodecs/tests/fqzcomp_qual_test.c $(htscodecs_fqzcomp_qual_h) $(htscodecs_varint_h)
-htscodecs/tests/rANS_static4x16pr_test.o: CPPFLAGS += -Ihtscodecs -D_POSIX_C_SOURCE=200112L
-htscodecs/tests/rANS_static4x16pr_test.o: htscodecs/tests/rANS_static4x16pr_test.c $(htscodecs_rANS_static4x16_h)
-htscodecs/tests/rANS_static_test.o: CPPFLAGS += -Ihtscodecs -D_POSIX_C_SOURCE=200112L
-htscodecs/tests/rANS_static_test.o: htscodecs/tests/rANS_static_test.c $(htscodecs_rANS_static_h)
-htscodecs/tests/tokenise_name3_test.o: CPPFLAGS += -Ihtscodecs -D_POSIX_C_SOURCE=200112L
-htscodecs/tests/tokenise_name3_test.o: htscodecs/tests/tokenise_name3_test.c $(htscodecs_tokenise_name3_h)
-htscodecs/tests/varint_test.o: CPPFLAGS += -Ihtscodecs -D_POSIX_C_SOURCE=200112L
-htscodecs/tests/varint_test.o: htscodecs/tests/varint_test.c $(htscodecs_varint_h)
-
-test/hts_endian.o: test/hts_endian.c config.h $(htslib_hts_endian_h)
-test/fuzz/hts_open_fuzzer.o: test/fuzz/hts_open_fuzzer.c config.h $(htslib_hfile_h) $(htslib_hts_h) $(htslib_sam_h) $(htslib_vcf_h)
-test/fieldarith.o: test/fieldarith.c config.h $(htslib_sam_h)
-test/hfile.o: test/hfile.c config.h $(htslib_hfile_h) $(htslib_hts_defs_h) $(htslib_kstring_h)
-test/pileup.o: test/pileup.c config.h $(htslib_sam_h) $(htslib_kstring_h)
-test/plugins-dlhts.o: test/plugins-dlhts.c config.h
-test/sam.o: test/sam.c config.h $(htslib_hts_defs_h) $(htslib_sam_h) $(htslib_faidx_h) $(htslib_khash_h) $(htslib_hts_log_h)
-test/test_bgzf.o: test/test_bgzf.c config.h $(htslib_bgzf_h) $(htslib_hfile_h) $(hfile_internal_h)
-test/test_expr.o: test/test_expr.c config.h $(htslib_hts_expr_h)
-test/test_kfunc.o: test/test_kfunc.c config.h $(htslib_kfunc_h)
-test/test_kstring.o: test/test_kstring.c config.h $(htslib_kstring_h)
-test/test-parse-reg.o: test/test-parse-reg.c config.h $(htslib_hts_h) $(htslib_sam_h)
-test/test_realn.o: test/test_realn.c config.h $(htslib_hts_h) $(htslib_sam_h) $(htslib_faidx_h)
-test/test-regidx.o: test/test-regidx.c config.h $(htslib_kstring_h) $(htslib_regidx_h) $(htslib_hts_defs_h) $(textutils_internal_h)
-test/test_str2int.o: test/test_str2int.c config.h $(textutils_internal_h)
-test/test_view.o: test/test_view.c config.h $(cram_h) $(htslib_sam_h) $(htslib_vcf_h) $(htslib_hts_log_h)
-test/test_index.o: test/test_index.c config.h $(htslib_sam_h) $(htslib_vcf_h)
-test/test-vcf-api.o: test/test-vcf-api.c config.h $(htslib_hts_h) $(htslib_vcf_h) $(htslib_kstring_h) $(htslib_kseq_h)
-test/test-vcf-sweep.o: test/test-vcf-sweep.c config.h $(htslib_vcf_sweep_h)
-test/test-bcf-sr.o: test/test-bcf-sr.c config.h $(htslib_synced_bcf_reader_h)
-test/test-bcf-translate.o: test/test-bcf-translate.c config.h $(htslib_vcf_h)
-test/test_introspection.o: test/test_introspection.c config.h $(htslib_hts_h) $(htslib_hfile_h)
-
-
-test/thrash_threads1: test/thrash_threads1.o libhts.a
-	$(CC) $(LDFLAGS) -o $@ test/thrash_threads1.o libhts.a -lz $(LIBS) -lpthread
-
-test/thrash_threads2: test/thrash_threads2.o libhts.a
-	$(CC) $(LDFLAGS) -o $@ test/thrash_threads2.o libhts.a -lz $(LIBS) -lpthread
-
-test/thrash_threads3: test/thrash_threads3.o libhts.a
-	$(CC) $(LDFLAGS) -o $@ test/thrash_threads3.o libhts.a -lz $(LIBS) -lpthread
-
-test/thrash_threads4: test/thrash_threads4.o libhts.a
-	$(CC) $(LDFLAGS) -o $@ test/thrash_threads4.o libhts.a -lz $(LIBS) -lpthread
-
-test/thrash_threads5: test/thrash_threads5.o libhts.a
-	$(CC) $(LDFLAGS) -o $@ test/thrash_threads5.o libhts.a -lz $(LIBS) -lpthread
-
-test/thrash_threads6: test/thrash_threads6.o libhts.a
-	$(CC) $(LDFLAGS) -o $@ test/thrash_threads6.o libhts.a -lz $(LIBS) -lpthread
-
-test/thrash_threads7: test/thrash_threads7.o libhts.a
-	$(CC) $(LDFLAGS) -o $@ test/thrash_threads7.o libhts.a -lz $(LIBS) -lpthread
-
-test_thrash: $(BUILT_THRASH_PROGRAMS)
-
-# Test to ensure the functions in the header files are exported by the shared
-# library.  This currently works by comparing the output from ctags on
-# the headers with the list of functions exported by the shared library.
-# Note that functions marked as exported in the .c files and not the public
-# headers will be missed by this test.
-test-shlib-exports: header-exports.txt shlib-exports-$(SHLIB_FLAVOUR).txt
-	@echo "Checking shared library exports"
-	@if test ! -s header-exports.txt ; then echo "Error: header-exports.txt empty" ; false ; fi
-	@if test ! -s shlib-exports-$(SHLIB_FLAVOUR).txt ; then echo "Error: shlib-exports-$(SHLIB_FLAVOUR).txt empty" ; false ; fi
-	@! comm -23 header-exports.txt shlib-exports-$(SHLIB_FLAVOUR).txt | grep . || \
-	( echo "Error: Found unexported symbols (listed above)" ; false )
-
-# Extract symbols that should be exported from public headers using ctags
-# Filter out macros in htslib/hts_defs.h.
-header-exports.txt: test/header_syms.pl htslib/*.h
-	test/header_syms.pl htslib/*.h | sort -u -o $@
-
-shlib-exports-so.txt: libhts.so
-	nm -D -g libhts.so | awk '$$2 == "T" { print $$3 }' | sort -u -o $@
-
-shlib-exports-dylib.txt: libhts.dylib
-	nm -Ug libhts.dylib | awk '$$2 == "T" { sub("^_", "", $$3); print $$3 }' | sort -u -o $@
-
-shlib-exports-dll.txt: hts.dll.a
-	nm -g hts.dll.a | awk '$$2 == "T" { print $$3 }' | sort -u -o $@
-
-install: libhts.a $(BUILT_PROGRAMS) $(BUILT_PLUGINS) installdirs install-$(SHLIB_FLAVOUR) install-pkgconfig
-	$(INSTALL_PROGRAM) $(BUILT_PROGRAMS) $(DESTDIR)$(bindir)
-	if test -n "$(BUILT_PLUGINS)"; then $(INSTALL_PROGRAM) $(BUILT_PLUGINS) $(DESTDIR)$(plugindir); fi
-	$(INSTALL_DATA) htslib/*.h $(DESTDIR)$(includedir)/htslib
-	$(INSTALL_DATA) libhts.a $(DESTDIR)$(libdir)/libhts.a
-	$(INSTALL_MAN) bgzip.1 htsfile.1 tabix.1 $(DESTDIR)$(man1dir)
-	$(INSTALL_MAN) faidx.5 sam.5 vcf.5 $(DESTDIR)$(man5dir)
-	$(INSTALL_MAN) htslib-s3-plugin.7 $(DESTDIR)$(man7dir)
-
-installdirs:
-	$(INSTALL_DIR) $(DESTDIR)$(bindir) $(DESTDIR)$(includedir) $(DESTDIR)$(includedir)/htslib $(DESTDIR)$(libdir) $(DESTDIR)$(man1dir) $(DESTDIR)$(man5dir) $(DESTDIR)$(man7dir) $(DESTDIR)$(pkgconfigdir)
-	if test -n "$(plugindir)"; then $(INSTALL_DIR) $(DESTDIR)$(plugindir); fi
-
-# After installation, the real file in $(libdir) will be libhts.so.X.Y.Z,
-# with symlinks libhts.so (used via -lhts during linking of client programs)
-# and libhts.so.NN (used by client executables at runtime).
-
-install-so: libhts.so installdirs
-	$(INSTALL_LIB) libhts.so $(DESTDIR)$(libdir)/libhts.so.$(PACKAGE_VERSION)
-	ln -sf libhts.so.$(PACKAGE_VERSION) $(DESTDIR)$(libdir)/libhts.so
-	ln -sf libhts.so.$(PACKAGE_VERSION) $(DESTDIR)$(libdir)/libhts.so.$(LIBHTS_SOVERSION)
-
-install-cygdll: cyghts-$(LIBHTS_SOVERSION).dll installdirs
-	$(INSTALL_PROGRAM) cyghts-$(LIBHTS_SOVERSION).dll $(DESTDIR)$(bindir)/cyghts-$(LIBHTS_SOVERSION).dll
-	$(INSTALL_PROGRAM) libhts.dll.a $(DESTDIR)$(libdir)/libhts.dll.a
-
-install-dll: hts-$(LIBHTS_SOVERSION).dll installdirs
-	$(INSTALL_PROGRAM) hts-$(LIBHTS_SOVERSION).dll $(DESTDIR)$(bindir)/hts-$(LIBHTS_SOVERSION).dll
-	$(INSTALL_PROGRAM) hts.dll.a $(DESTDIR)$(libdir)/hts.dll.a
-
-install-dylib: libhts.dylib installdirs
-	$(INSTALL_PROGRAM) libhts.dylib $(DESTDIR)$(libdir)/libhts.$(PACKAGE_VERSION).dylib
-	ln -sf libhts.$(PACKAGE_VERSION).dylib $(DESTDIR)$(libdir)/libhts.dylib
-	ln -sf libhts.$(PACKAGE_VERSION).dylib $(DESTDIR)$(libdir)/libhts.$(LIBHTS_SOVERSION).dylib
-
-# Substitute these pseudo-autoconf variables only at install time
-# so that "make install prefix=/prefix/path" etc continue to work.
-install-pkgconfig: htslib.pc.tmp installdirs
-	sed -e 's#@-includedir@#$(includedir)#g;s#@-libdir@#$(libdir)#g;s#@-PACKAGE_VERSION@#$(PACKAGE_VERSION)#g' htslib.pc.tmp > $(DESTDIR)$(pkgconfigdir)/htslib.pc
-	chmod 644 $(DESTDIR)$(pkgconfigdir)/htslib.pc
-
-# A pkg-config file (suitable for copying to $PKG_CONFIG_PATH) that provides
-# flags for building against the uninstalled library in this build directory.
-htslib-uninstalled.pc: htslib.pc.tmp
-	sed -e 's#@-includedir@#'`pwd`'#g;s#@-libdir@#'`pwd`'#g' htslib.pc.tmp > $@
-
-
-testclean:
-	-rm -f test/*.tmp test/*.tmp.* test/longrefs/*.tmp.* test/tabix/*.tmp.* test/tabix/FAIL* header-exports.txt shlib-exports-$(SHLIB_FLAVOUR).txt
-	-rm -rf htscodecs/tests/test.out
-
-# Only remove this in git checkouts
-DEL_HTSCODECS_VERSION := $(if $(wildcard htscodecs/.git),htscodecs/htscodecs/version.h)
-
-mostlyclean: testclean
-	-rm -f *.o *.pico cram/*.o cram/*.pico test/*.o test/*.dSYM config_vars.h version.h
-	-rm -f htscodecs/htscodecs/*.o htscodecs/htscodecs/*.pico $(DEL_HTSCODECS_VERSION)
-	-rm -f hts-object-files
-	-rm -f htscodecs/tests/*.o
-
-clean: mostlyclean clean-$(SHLIB_FLAVOUR)
-	-rm -f libhts.a $(BUILT_PROGRAMS) $(BUILT_PLUGINS) $(BUILT_TEST_PROGRAMS) $(BUILT_THRASH_PROGRAMS)
-	-rm -f htscodecs/tests/rans4x8 htscodecs/tests/rans4x16pr htscodecs/tests/arith_dynamic htscodecs/tests/tokenise_name3 htscodecs/tests/fqzcomp_qual htscodecs/tests/varint
-
-distclean maintainer-clean: clean
-	-rm -f config.cache config.h config.log config.mk config.status
-	-rm -f TAGS *.pc.tmp *-uninstalled.pc htslib_static.mk htscodecs.mk
-	-rm -rf autom4te.cache
-
-clean-so:
-	-rm -f libhts.so libhts.so.*
-
-clean-cygdll:
-	-rm -f cyghts-*.dll libhts.dll.a
-
-clean-dll:
-	-rm -f hts-*.dll hts.dll.a
-
-clean-dylib:
-	-rm -f libhts.dylib libhts.*.dylib
-
-
-tags TAGS:
-	ctags -f TAGS *.[ch] cram/*.[ch] htslib/*.h
-
-# We recommend libhts-using programs be built against a separate htslib
-# installation.  However if you feel that you must bundle htslib source
-# code with your program, this hook enables Automake-style "make dist"
-# for this subdirectory.  If you do bundle an htslib snapshot, please
-# add identifying information to $(PACKAGE_VERSION) as appropriate.
-# (The wildcards attempt to omit non-exported files (.git*, README.md,
-# etc) and other detritus that might be in the top-level directory.)
-distdir:
-	@if [ -z "$(distdir)" ]; then echo "Please supply a distdir=DIR argument."; false; fi
-	tar -c *.[ch15] [ILMNRchtv]*[ELSbcekmnth] | (cd $(distdir) && tar -x)
-	+cd $(distdir) && $(MAKE) distclean
-
-force:
-
-
-.PHONY: all check clean distclean distdir force
-.PHONY: install install-pkgconfig installdirs lib-shared lib-static
-.PHONY: maintainer-check maintainer-clean mostlyclean plugins
-.PHONY: print-config print-version show-version tags
-.PHONY: test test-shlib-exports test_thrash testclean
-.PHONY: clean-so install-so
-.PHONY: clean-cygdll install-cygdll
-.PHONY: clean-dll install-dll
-.PHONY: clean-dylib install-dylib
-.PHONY: test_htscodecs_rans4x8 test_htscodecs_rans4x16 test_htscodecs_arith
-.PHONY: test_htscodecs_tok3 test_htscodecs_fqzcomp test_htscodecs_varint
diff -ruN stringtie.orig/htslib/md5.c stringtie/htslib/md5.c
--- stringtie.orig/htslib/md5.c	2024-02-28 13:57:39.701246126 +0100
+++ stringtie/htslib/md5.c	1970-01-01 01:00:00.000000000 +0100
@@ -1,388 +0,0 @@
-/*
- * Trivial amendments by James Bonfield <jkb@sanger.ac.uk> to provide an
- * HTSlib interface. 2015.
- *
- * Externally our API uses an opaque hts_md5_context structure.
- *
- * Internally either this gets defined and used with the routines here
- * or it remains incomplete and is cast to the OpenSSL MD5_CTX structure
- * and used by routines from OpenSSL.
- */
-
-/*
- * This is an OpenSSL-compatible implementation of the RSA Data Security, Inc.
- * MD5 Message-Digest Algorithm (RFC 1321).
- *
- * Homepage:
- * http://openwall.info/wiki/people/solar/software/public-domain-source-code/md5
- *
- * Author:
- * Alexander Peslyak, better known as Solar Designer <solar at openwall.com>
- *
- * This software was written by Alexander Peslyak in 2001.  No copyright is
- * claimed, and the software is hereby placed in the public domain.
- * In case this attempt to disclaim copyright and place the software in the
- * public domain is deemed null and void, then the software is
- * Copyright (c) 2001 Alexander Peslyak and it is hereby released to the
- * general public under the following terms:
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted.
- *
- * There's ABSOLUTELY NO WARRANTY, express or implied.
- *
- * (This is a heavily cut-down "BSD license".)
- *
- * This differs from Colin Plumb's older public domain implementation in that
- * no exactly 32-bit integer data type is required (any 32-bit or wider
- * unsigned integer data type will do), there's no compile-time endianness
- * configuration, and the function prototypes match OpenSSL's.  No code from
- * Colin Plumb's implementation has been reused; this comment merely compares
- * the properties of the two independent implementations.
- *
- * The primary goals of this implementation are portability and ease of use.
- * It is meant to be fast, but not as fast as possible.  Some known
- * optimizations are not included to reduce source code size and avoid
- * compile-time configuration.
- */
-
-#define HTS_BUILDING_LIBRARY // Enables HTSLIB_EXPORT, see htslib/hts_defs.h
-#include <config.h>
-
-#include <stdlib.h>
-#include "htslib/hts.h"
-#include "htslib/hts_endian.h"
-
-#ifndef HAVE_OPENSSL
-
-#include <string.h>
-
-/* Any 32-bit or wider unsigned integer data type will do */
-typedef unsigned int hts_md5_u32plus;
-
-struct hts_md5_context {
-	hts_md5_u32plus lo, hi;
-	hts_md5_u32plus a, b, c, d;
-	unsigned char buffer[64];
-	hts_md5_u32plus block[16];
-};
-
-/*
- * The basic MD5 functions.
- *
- * F and G are optimized compared to their RFC 1321 definitions for
- * architectures that lack an AND-NOT instruction, just like in Colin Plumb's
- * implementation.
- */
-#define F(x, y, z)			((z) ^ ((x) & ((y) ^ (z))))
-#define G(x, y, z)			((y) ^ ((z) & ((x) ^ (y))))
-#define H(x, y, z)			(((x) ^ (y)) ^ (z))
-#define H2(x, y, z)			((x) ^ ((y) ^ (z)))
-#define I(x, y, z)			((y) ^ ((x) | ~(z)))
-
-/*
- * The MD5 transformation for all four rounds.
- */
-#define STEP(f, a, b, c, d, x, t, s) \
-	(a) += f((b), (c), (d)) + (x) + (t); \
-	(a) = (((a) << (s)) | (((a) & 0xffffffff) >> (32 - (s)))); \
-	(a) += (b);
-
-/*
- * SET reads 4 input bytes in little-endian byte order and stores them
- * in a properly aligned word in host byte order.
- *
- * The check for little-endian architectures that tolerate unaligned
- * memory accesses is just an optimization.  Nothing will break if it
- * doesn't work.
- */
-#if defined(HTS_LITTLE_ENDIAN) && HTS_ALLOW_UNALIGNED != 0
-#define SET(n) \
-	(*(hts_md5_u32plus *)&ptr[(n) * 4])
-#define GET(n) \
-	SET(n)
-#else
-#define SET(n) \
-	(ctx->block[(n)] = \
-	(hts_md5_u32plus)ptr[(n) * 4] | \
-	((hts_md5_u32plus)ptr[(n) * 4 + 1] << 8) | \
-	((hts_md5_u32plus)ptr[(n) * 4 + 2] << 16) | \
-	((hts_md5_u32plus)ptr[(n) * 4 + 3] << 24))
-#define GET(n) \
-	(ctx->block[(n)])
-#endif
-
-/*
- * This processes one or more 64-byte data blocks, but does NOT update
- * the bit counters.  There are no alignment requirements.
- */
-static const void *body(hts_md5_context *ctx, const void *data, unsigned long size)
-{
-	const unsigned char *ptr;
-	hts_md5_u32plus a, b, c, d;
-	hts_md5_u32plus saved_a, saved_b, saved_c, saved_d;
-
-	ptr = (const unsigned char *)data;
-
-	a = ctx->a;
-	b = ctx->b;
-	c = ctx->c;
-	d = ctx->d;
-
-	do {
-		saved_a = a;
-		saved_b = b;
-		saved_c = c;
-		saved_d = d;
-
-/* Round 1 */
-		STEP(F, a, b, c, d, SET(0), 0xd76aa478, 7)
-		STEP(F, d, a, b, c, SET(1), 0xe8c7b756, 12)
-		STEP(F, c, d, a, b, SET(2), 0x242070db, 17)
-		STEP(F, b, c, d, a, SET(3), 0xc1bdceee, 22)
-		STEP(F, a, b, c, d, SET(4), 0xf57c0faf, 7)
-		STEP(F, d, a, b, c, SET(5), 0x4787c62a, 12)
-		STEP(F, c, d, a, b, SET(6), 0xa8304613, 17)
-		STEP(F, b, c, d, a, SET(7), 0xfd469501, 22)
-		STEP(F, a, b, c, d, SET(8), 0x698098d8, 7)
-		STEP(F, d, a, b, c, SET(9), 0x8b44f7af, 12)
-		STEP(F, c, d, a, b, SET(10), 0xffff5bb1, 17)
-		STEP(F, b, c, d, a, SET(11), 0x895cd7be, 22)
-		STEP(F, a, b, c, d, SET(12), 0x6b901122, 7)
-		STEP(F, d, a, b, c, SET(13), 0xfd987193, 12)
-		STEP(F, c, d, a, b, SET(14), 0xa679438e, 17)
-		STEP(F, b, c, d, a, SET(15), 0x49b40821, 22)
-
-/* Round 2 */
-		STEP(G, a, b, c, d, GET(1), 0xf61e2562, 5)
-		STEP(G, d, a, b, c, GET(6), 0xc040b340, 9)
-		STEP(G, c, d, a, b, GET(11), 0x265e5a51, 14)
-		STEP(G, b, c, d, a, GET(0), 0xe9b6c7aa, 20)
-		STEP(G, a, b, c, d, GET(5), 0xd62f105d, 5)
-		STEP(G, d, a, b, c, GET(10), 0x02441453, 9)
-		STEP(G, c, d, a, b, GET(15), 0xd8a1e681, 14)
-		STEP(G, b, c, d, a, GET(4), 0xe7d3fbc8, 20)
-		STEP(G, a, b, c, d, GET(9), 0x21e1cde6, 5)
-		STEP(G, d, a, b, c, GET(14), 0xc33707d6, 9)
-		STEP(G, c, d, a, b, GET(3), 0xf4d50d87, 14)
-		STEP(G, b, c, d, a, GET(8), 0x455a14ed, 20)
-		STEP(G, a, b, c, d, GET(13), 0xa9e3e905, 5)
-		STEP(G, d, a, b, c, GET(2), 0xfcefa3f8, 9)
-		STEP(G, c, d, a, b, GET(7), 0x676f02d9, 14)
-		STEP(G, b, c, d, a, GET(12), 0x8d2a4c8a, 20)
-
-/* Round 3 */
-		STEP(H, a, b, c, d, GET(5), 0xfffa3942, 4)
-		STEP(H2, d, a, b, c, GET(8), 0x8771f681, 11)
-		STEP(H, c, d, a, b, GET(11), 0x6d9d6122, 16)
-		STEP(H2, b, c, d, a, GET(14), 0xfde5380c, 23)
-		STEP(H, a, b, c, d, GET(1), 0xa4beea44, 4)
-		STEP(H2, d, a, b, c, GET(4), 0x4bdecfa9, 11)
-		STEP(H, c, d, a, b, GET(7), 0xf6bb4b60, 16)
-		STEP(H2, b, c, d, a, GET(10), 0xbebfbc70, 23)
-		STEP(H, a, b, c, d, GET(13), 0x289b7ec6, 4)
-		STEP(H2, d, a, b, c, GET(0), 0xeaa127fa, 11)
-		STEP(H, c, d, a, b, GET(3), 0xd4ef3085, 16)
-		STEP(H2, b, c, d, a, GET(6), 0x04881d05, 23)
-		STEP(H, a, b, c, d, GET(9), 0xd9d4d039, 4)
-		STEP(H2, d, a, b, c, GET(12), 0xe6db99e5, 11)
-		STEP(H, c, d, a, b, GET(15), 0x1fa27cf8, 16)
-		STEP(H2, b, c, d, a, GET(2), 0xc4ac5665, 23)
-
-/* Round 4 */
-		STEP(I, a, b, c, d, GET(0), 0xf4292244, 6)
-		STEP(I, d, a, b, c, GET(7), 0x432aff97, 10)
-		STEP(I, c, d, a, b, GET(14), 0xab9423a7, 15)
-		STEP(I, b, c, d, a, GET(5), 0xfc93a039, 21)
-		STEP(I, a, b, c, d, GET(12), 0x655b59c3, 6)
-		STEP(I, d, a, b, c, GET(3), 0x8f0ccc92, 10)
-		STEP(I, c, d, a, b, GET(10), 0xffeff47d, 15)
-		STEP(I, b, c, d, a, GET(1), 0x85845dd1, 21)
-		STEP(I, a, b, c, d, GET(8), 0x6fa87e4f, 6)
-		STEP(I, d, a, b, c, GET(15), 0xfe2ce6e0, 10)
-		STEP(I, c, d, a, b, GET(6), 0xa3014314, 15)
-		STEP(I, b, c, d, a, GET(13), 0x4e0811a1, 21)
-		STEP(I, a, b, c, d, GET(4), 0xf7537e82, 6)
-		STEP(I, d, a, b, c, GET(11), 0xbd3af235, 10)
-		STEP(I, c, d, a, b, GET(2), 0x2ad7d2bb, 15)
-		STEP(I, b, c, d, a, GET(9), 0xeb86d391, 21)
-
-		a += saved_a;
-		b += saved_b;
-		c += saved_c;
-		d += saved_d;
-
-		ptr += 64;
-	} while (size -= 64);
-
-	ctx->a = a;
-	ctx->b = b;
-	ctx->c = c;
-	ctx->d = d;
-
-	return ptr;
-}
-
-void hts_md5_reset(hts_md5_context *ctx)
-{
-	ctx->a = 0x67452301;
-	ctx->b = 0xefcdab89;
-	ctx->c = 0x98badcfe;
-	ctx->d = 0x10325476;
-
-	ctx->lo = 0;
-	ctx->hi = 0;
-}
-
-void hts_md5_update(hts_md5_context *ctx, const void *data, unsigned long size)
-{
-	hts_md5_u32plus saved_lo;
-	unsigned long used, available;
-
-	saved_lo = ctx->lo;
-	if ((ctx->lo = (saved_lo + size) & 0x1fffffff) < saved_lo)
-		ctx->hi++;
-	ctx->hi += size >> 29;
-
-	used = saved_lo & 0x3f;
-
-	if (used) {
-		available = 64 - used;
-
-		if (size < available) {
-			memcpy(&ctx->buffer[used], data, size);
-			return;
-		}
-
-		memcpy(&ctx->buffer[used], data, available);
-		data = (const unsigned char *)data + available;
-		size -= available;
-		body(ctx, ctx->buffer, 64);
-	}
-
-	if (size >= 64) {
-		data = body(ctx, data, size & ~(unsigned long)0x3f);
-		size &= 0x3f;
-	}
-
-	memcpy(ctx->buffer, data, size);
-}
-
-void hts_md5_final(unsigned char *result, hts_md5_context *ctx)
-{
-	unsigned long used, available;
-
-	used = ctx->lo & 0x3f;
-
-	ctx->buffer[used++] = 0x80;
-
-	available = 64 - used;
-
-	if (available < 8) {
-		memset(&ctx->buffer[used], 0, available);
-		body(ctx, ctx->buffer, 64);
-		used = 0;
-		available = 64;
-	}
-
-	memset(&ctx->buffer[used], 0, available - 8);
-
-	ctx->lo <<= 3;
-	ctx->buffer[56] = ctx->lo;
-	ctx->buffer[57] = ctx->lo >> 8;
-	ctx->buffer[58] = ctx->lo >> 16;
-	ctx->buffer[59] = ctx->lo >> 24;
-	ctx->buffer[60] = ctx->hi;
-	ctx->buffer[61] = ctx->hi >> 8;
-	ctx->buffer[62] = ctx->hi >> 16;
-	ctx->buffer[63] = ctx->hi >> 24;
-
-	body(ctx, ctx->buffer, 64);
-
-	result[0] = ctx->a;
-	result[1] = ctx->a >> 8;
-	result[2] = ctx->a >> 16;
-	result[3] = ctx->a >> 24;
-	result[4] = ctx->b;
-	result[5] = ctx->b >> 8;
-	result[6] = ctx->b >> 16;
-	result[7] = ctx->b >> 24;
-	result[8] = ctx->c;
-	result[9] = ctx->c >> 8;
-	result[10] = ctx->c >> 16;
-	result[11] = ctx->c >> 24;
-	result[12] = ctx->d;
-	result[13] = ctx->d >> 8;
-	result[14] = ctx->d >> 16;
-	result[15] = ctx->d >> 24;
-
-	memset(ctx, 0, sizeof(*ctx));
-}
-
-
-hts_md5_context *hts_md5_init(void)
-{
-    hts_md5_context *ctx = malloc(sizeof(*ctx));
-    if (!ctx)
-        return NULL;
-
-    hts_md5_reset(ctx);
-    return ctx;
-}
-
-#else
-
-#include <openssl/md5.h>
-#include <assert.h>
-
-/*
- * Wrappers around the OpenSSL libcrypto.so MD5 implementation.
- *
- * These are here to ensure they end up in the symbol table of the
- * library regardless of the static inline in the headers.
- */
-hts_md5_context *hts_md5_init(void)
-{
-    MD5_CTX *ctx = malloc(sizeof(*ctx));
-    if (!ctx)
-        return NULL;
-
-    MD5_Init(ctx);
-
-    return (hts_md5_context *)ctx;
-}
-
-void hts_md5_reset(hts_md5_context *ctx)
-{
-    MD5_Init((MD5_CTX *)ctx);
-}
-
-void hts_md5_update(hts_md5_context *ctx, const void *data, unsigned long size)
-{
-    MD5_Update((MD5_CTX *)ctx, data, size);
-}
-
-void hts_md5_final(unsigned char *result, hts_md5_context *ctx)
-{
-    MD5_Final(result, (MD5_CTX *)ctx);
-}
-
-#endif
-
-void hts_md5_destroy(hts_md5_context *ctx)
-{
-    if (!ctx)
-        return;
-
-    free(ctx);
-}
-
-void hts_md5_hex(char *hex, const unsigned char *digest)
-{
-    int i;
-    for (i = 0; i < 16; i++) {
-        hex[i*2+0] = "0123456789abcdef"[(digest[i]>>4)&0xf];
-        hex[i*2+1] = "0123456789abcdef"[digest[i]&0xf];
-    }
-    hex[32] = 0;
-}
diff -ruN stringtie.orig/htslib/multipart.c stringtie/htslib/multipart.c
--- stringtie.orig/htslib/multipart.c	2024-02-28 13:57:39.701246126 +0100
+++ stringtie/htslib/multipart.c	1970-01-01 01:00:00.000000000 +0100
@@ -1,267 +0,0 @@
-/*  multipart.c -- GA4GH redirection and multipart backend for file streams.
-
-    Copyright (C) 2016-2017 Genome Research Ltd.
-
-    Author: John Marshall <jm18@sanger.ac.uk>
-
-Permission is hereby granted, free of charge, to any person obtaining a copy
-of this software and associated documentation files (the "Software"), to deal
-in the Software without restriction, including without limitation the rights
-to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
-copies of the Software, and to permit persons to whom the Software is
-furnished to do so, subject to the following conditions:
-
-The above copyright notice and this permission notice shall be included in
-all copies or substantial portions of the Software.
-
-THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
-IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
-FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
-THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
-LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
-FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
-DEALINGS IN THE SOFTWARE.  */
-
-#define HTS_BUILDING_LIBRARY // Enables HTSLIB_EXPORT, see htslib/hts_defs.h
-#include <config.h>
-
-#include <stdio.h>
-#include <string.h>
-#include <errno.h>
-
-#include "htslib/kstring.h"
-
-#include "hts_internal.h"
-#include "hfile_internal.h"
-
-#ifndef EPROTO
-#define EPROTO ENOEXEC
-#endif
-
-typedef struct hfile_part {
-    char *url;
-    char **headers;
-} hfile_part;
-
-typedef struct {
-    hFILE base;
-    hfile_part *parts;
-    size_t nparts, maxparts, current;
-    hFILE *currentfp;
-} hFILE_multipart;
-
-static void free_part(hfile_part *p)
-{
-    free(p->url);
-    if (p->headers) {
-        char **hdr;
-        for (hdr = p->headers; *hdr; hdr++) free(*hdr);
-        free(p->headers);
-    }
-
-    p->url = NULL;
-    p->headers = NULL;
-}
-
-static void free_all_parts(hFILE_multipart *fp)
-{
-    size_t i;
-    for (i = 0; i < fp->nparts; i++) free_part(&fp->parts[i]);
-    free(fp->parts);
-}
-
-static ssize_t multipart_read(hFILE *fpv, void *buffer, size_t nbytes)
-{
-    hFILE_multipart *fp = (hFILE_multipart *) fpv;
-    size_t n;
-
-open_next:
-    if (fp->currentfp == NULL) {
-        if (fp->current < fp->nparts) {
-            const hfile_part *p = &fp->parts[fp->current];
-            hts_log_debug("Opening part #%zu of %zu: \"%.120s%s\"",
-                fp->current+1, fp->nparts, p->url,
-                (strlen(p->url) > 120)? "..." : "");
-
-            fp->currentfp = p->headers?
-                  hopen(p->url, "r:",
-                        "httphdr:v", p->headers,
-                        "auth_token_enabled", "false", NULL)
-                : hopen(p->url, "r:", "auth_token_enabled", "false", NULL);
-
-            if (fp->currentfp == NULL) return -1;
-        }
-        else return 0;  // No more parts, so we're truly at EOF
-    }
-
-    n = fp->currentfp->mobile?
-          fp->currentfp->backend->read(fp->currentfp, buffer, nbytes)
-        : hread(fp->currentfp, buffer, nbytes);
-
-    if (n == 0) {
-        // We're at EOF on this part, so set up the next part
-        hFILE *prevfp = fp->currentfp;
-        free_part(&fp->parts[fp->current]);
-        fp->current++;
-        fp->currentfp = NULL;
-        if (hclose(prevfp) < 0) return -1;
-        goto open_next;
-    }
-
-    return n;  // Number of bytes read by (or an error from) fp->currentfp
-}
-
-static ssize_t multipart_write(hFILE *fpv, const void *buffer, size_t nbytes)
-{
-    errno = EROFS;
-    return -1;
-}
-
-static off_t multipart_seek(hFILE *fpv, off_t offset, int whence)
-{
-    errno = ESPIPE;
-    return -1;
-}
-
-static int multipart_close(hFILE *fpv)
-{
-    hFILE_multipart *fp = (hFILE_multipart *) fpv;
-
-    free_all_parts(fp);
-    if (fp->currentfp) {
-        if (hclose(fp->currentfp) < 0) return -1;
-    }
-
-    return 0;
-}
-
-static const struct hFILE_backend multipart_backend =
-{
-    multipart_read, multipart_write, multipart_seek, NULL, multipart_close
-};
-
-// Returns 'v' (valid value), 'i' (invalid; required GA4GH field missing),
-// or upon encountering an unexpected token, that token's type.
-// Explicit `return '?'` means a JSON parsing error, typically a member key
-// that is not a string.  An unexpected token may be a valid token that was
-// not the type expected for a particular GA4GH field, or it may be '?' or
-// '\0' which should be propagated.
-static char
-parse_ga4gh_body_json(hFILE_multipart *fp, hFILE *json,
-                      kstring_t *b, kstring_t *header)
-{
-    hts_json_token t;
-
-    if (hts_json_fnext(json, &t, b) != '{') return t.type;
-    while (hts_json_fnext(json, &t, b) != '}') {
-        if (t.type != 's') return '?';
-
-        if (strcmp(t.str, "urls") == 0) {
-            if (hts_json_fnext(json, &t, b) != '[') return t.type;
-
-            while (hts_json_fnext(json, &t, b) != ']') {
-                hfile_part *part;
-                size_t n = 0, max = 0;
-
-                hts_expand(hfile_part, fp->nparts+1, fp->maxparts, fp->parts);
-                part = &fp->parts[fp->nparts++];
-                part->url = NULL;
-                part->headers = NULL;
-
-                if (t.type != '{') return t.type;
-                while (hts_json_fnext(json, &t, b) != '}') {
-                    if (t.type != 's') return '?';
-
-                    if (strcmp(t.str, "url") == 0) {
-                        if (hts_json_fnext(json, &t, b) != 's') return t.type;
-                        part->url = ks_release(b);
-                    }
-                    else if (strcmp(t.str, "headers") == 0) {
-                        if (hts_json_fnext(json, &t, b) != '{') return t.type;
-
-                        while (hts_json_fnext(json, &t, header) != '}') {
-                            if (t.type != 's') return '?';
-
-                            if (hts_json_fnext(json, &t, b) != 's')
-                                return t.type;
-
-                            kputs(": ", header);
-                            kputs(t.str, header);
-                            n++;
-                            hts_expand(char *, n+1, max, part->headers);
-                            part->headers[n-1] = ks_release(header);
-                            part->headers[n] = NULL;
-                        }
-                    }
-                    else if (hts_json_fskip_value(json, '\0') != 'v')
-                        return '?';
-                }
-
-                if (! part->url) return 'i';
-            }
-        }
-        else if (strcmp(t.str, "format") == 0) {
-            if (hts_json_fnext(json, &t, b) != 's') return t.type;
-
-            hts_log_debug("GA4GH JSON redirection to multipart %s data", t.str);
-        }
-        else if (hts_json_fskip_value(json, '\0') != 'v') return '?';
-    }
-
-    return 'v';
-}
-
-// Returns 'v' (valid value), 'i' (invalid; required GA4GH field missing),
-// or upon encountering an unexpected token, that token's type.
-// Explicit `return '?'` means a JSON parsing error, typically a member key
-// that is not a string.  An unexpected token may be a valid token that was
-// not the type expected for a particular GA4GH field, or it may be '?' or
-// '\0' which should be propagated.
-static char
-parse_ga4gh_redirect_json(hFILE_multipart *fp, hFILE *json,
-                          kstring_t *b, kstring_t *header) {
-    hts_json_token t;
-
-    if (hts_json_fnext(json, &t, b) != '{') return t.type;
-    while (hts_json_fnext(json, &t, b) != '}') {
-        if (t.type != 's') return '?';
-
-        if (strcmp(t.str, "htsget") == 0) {
-            char ret = parse_ga4gh_body_json(fp, json, b, header);
-            if (ret != 'v') return ret;
-        }
-        else return '?';
-    }
-
-    if (hts_json_fnext(json, &t, b) != '\0') return '?';
-
-    return 'v';
-}
-
-hFILE *hopen_htsget_redirect(hFILE *hfile, const char *mode)
-{
-    hFILE_multipart *fp;
-    kstring_t s1 = { 0, 0, NULL }, s2 = { 0, 0, NULL };
-    char ret;
-
-    fp = (hFILE_multipart *) hfile_init(sizeof (hFILE_multipart), mode, 0);
-    if (fp == NULL) return NULL;
-
-    fp->parts = NULL;
-    fp->nparts = fp->maxparts = 0;
-
-    ret = parse_ga4gh_redirect_json(fp, hfile, &s1, &s2);
-    free(s1.s);
-    free(s2.s);
-    if (ret != 'v') {
-        free_all_parts(fp);
-        hfile_destroy((hFILE *) fp);
-        errno = (ret == '?' || ret == '\0')? EPROTO : EINVAL;
-        return NULL;
-    }
-
-    fp->current = 0;
-    fp->currentfp = NULL;
-    fp->base.backend = &multipart_backend;
-    return &fp->base;
-}
diff -ruN stringtie.orig/htslib/os/lzma_stub.h stringtie/htslib/os/lzma_stub.h
--- stringtie.orig/htslib/os/lzma_stub.h	2024-02-28 13:57:39.704579460 +0100
+++ stringtie/htslib/os/lzma_stub.h	1970-01-01 01:00:00.000000000 +0100
@@ -1,85 +0,0 @@
-#ifndef LZMA_STUB_H
-#define LZMA_STUB_H
-
-/* Some platforms, notably macOS, ship a usable liblzma shared library but
-   do not ship any LZMA header files. The <lzma.h> and <lzma/{*}.h> header
-   files that come with the library contain the following statement:
-
-     *
-     * Author: Lasse Collin
-     *
-     * This file has been put into the public domain.
-     * You can do whatever you want with this file.
-     *
-
-   Accordingly the following declarations have been copied and distilled
-   from <lzma/base.h> and <lzma/container.h> (primarily) and are sufficient
-   to compile cram/cram_io.c in the absence of proper LZMA headers.
-
-   This file, lzma_stub.h, remains in the public domain.  */
-
-#include <stdint.h>
-
-#ifdef __cplusplus
-extern "C" {
-#endif
-
-typedef enum { LZMA_OK = 0, LZMA_STREAM_END = 1 } lzma_ret;
-typedef enum { LZMA_RUN = 0, LZMA_FINISH = 3 } lzma_action;
-typedef enum { LZMA_CHECK_CRC32 = 1 } lzma_check;
-typedef enum { LZMA_RESERVED_ENUM = 0 } lzma_reserved_enum;
-
-struct lzma_allocator;
-struct lzma_internal;
-
-typedef struct {
-    const uint8_t *next_in;
-    size_t avail_in;
-    uint64_t total_in;
-
-    uint8_t *next_out;
-    size_t avail_out;
-    uint64_t total_out;
-
-    const struct lzma_allocator *allocator;
-    struct lzma_internal *internal;
-
-    void *reserved_ptr1;
-    void *reserved_ptr2;
-    void *reserved_ptr3;
-    void *reserved_ptr4;
-    uint64_t reserved_int1;
-    uint64_t reserved_int2;
-    size_t reserved_int3;
-    size_t reserved_int4;
-    lzma_reserved_enum reserved_enum1;
-    lzma_reserved_enum reserved_enum2;
-} lzma_stream;
-
-#define LZMA_STREAM_INIT \
-    { NULL, 0, 0, NULL, 0, 0, NULL, NULL, \
-    NULL, NULL, NULL, NULL, 0, 0, 0, 0, \
-    LZMA_RESERVED_ENUM, LZMA_RESERVED_ENUM }
-
-extern size_t lzma_stream_buffer_bound(size_t uncompressed_size);
-
-extern lzma_ret lzma_easy_buffer_encode(
-        uint32_t preset, lzma_check check,
-        const struct lzma_allocator *allocator,
-        const uint8_t *in, size_t in_size,
-        uint8_t *out, size_t *out_pos, size_t out_size);
-
-extern lzma_ret lzma_stream_decoder(
-        lzma_stream *strm, uint64_t memlimit, uint32_t flags);
-
-extern uint64_t lzma_easy_decoder_memusage(uint32_t preset);
-
-extern lzma_ret lzma_code(lzma_stream *strm, lzma_action action);
-
-extern void lzma_end(lzma_stream *strm);
-
-#ifdef __cplusplus
-}
-#endif
-
-#endif
diff -ruN stringtie.orig/htslib/os/rand.c stringtie/htslib/os/rand.c
--- stringtie.orig/htslib/os/rand.c	2024-02-28 13:57:39.704579460 +0100
+++ stringtie/htslib/os/rand.c	1970-01-01 01:00:00.000000000 +0100
@@ -1,97 +0,0 @@
-/*  rand.c -- drand48 implementation from the FreeBSD source tree. */
-
-// This file is an amalgamation of the many small files in FreeBSD to do with
-// drand48 and friends implementations.
-// It comprises _rand48.c, rand48.h, srand48.c, drand48.c, erand48.c, lrand48.c
-
-/*
- * Copyright (c) 1993 Martin Birgmeier
- * All rights reserved.
- *
- * You may redistribute unmodified or modified versions of this source
- * code provided that the above copyright notice and this and the
- * following conditions are retained.
- *
- * This software is provided ``as is'', and comes with no warranties
- * of any kind. I shall in no event be liable for anything that happens
- * to anyone/anything when using this software.
- */
-
-//#include <sys/cdefs.h>
-//__FBSDID("$FreeBSD: src/lib/libc/gen/_rand48.c,v 1.2 2002/03/22 21:52:05 obrien Exp $");
-
-#include <math.h>
-
-#define	RAND48_SEED_0	(0x330e)
-#define	RAND48_SEED_1	(0xabcd)
-#define	RAND48_SEED_2	(0x1234)
-#define	RAND48_MULT_0	(0xe66d)
-#define	RAND48_MULT_1	(0xdeec)
-#define	RAND48_MULT_2	(0x0005)
-#define	RAND48_ADD	(0x000b)
-
-static unsigned short _rand48_seed[3] = {
-	RAND48_SEED_0,
-	RAND48_SEED_1,
-	RAND48_SEED_2
-};
-static unsigned short _rand48_mult[3] = {
-	RAND48_MULT_0,
-	RAND48_MULT_1,
-	RAND48_MULT_2
-};
-static unsigned short _rand48_add = RAND48_ADD;
-
-static void
-_dorand48(unsigned short xseed[3])
-{
-	unsigned long accu;
-	unsigned short temp[2];
-
-	accu = (unsigned long) _rand48_mult[0] * (unsigned long) xseed[0] +
-	 (unsigned long) _rand48_add;
-	temp[0] = (unsigned short) accu;	/* lower 16 bits */
-	accu >>= sizeof(unsigned short) * 8;
-	accu += (unsigned long) _rand48_mult[0] * (unsigned long) xseed[1] +
-	 (unsigned long) _rand48_mult[1] * (unsigned long) xseed[0];
-	temp[1] = (unsigned short) accu;	/* middle 16 bits */
-	accu >>= sizeof(unsigned short) * 8;
-	accu += _rand48_mult[0] * xseed[2] + _rand48_mult[1] * xseed[1] + _rand48_mult[2] * xseed[0];
-	xseed[0] = temp[0];
-	xseed[1] = temp[1];
-	xseed[2] = (unsigned short) accu;
-}
-
-HTSLIB_EXPORT
-void hts_srand48(long seed)
-{
-	_rand48_seed[0] = RAND48_SEED_0;
-	_rand48_seed[1] = (unsigned short) seed;
-	_rand48_seed[2] = (unsigned short) (seed >> 16);
-	_rand48_mult[0] = RAND48_MULT_0;
-	_rand48_mult[1] = RAND48_MULT_1;
-	_rand48_mult[2] = RAND48_MULT_2;
-	_rand48_add = RAND48_ADD;
-}
-
-HTSLIB_EXPORT
-double hts_erand48(unsigned short xseed[3])
-{
-	_dorand48(xseed);
-	return ldexp((double) xseed[0], -48) +
-	       ldexp((double) xseed[1], -32) +
-	       ldexp((double) xseed[2], -16);
-}
-
-HTSLIB_EXPORT
-double hts_drand48(void)
-{
-	return hts_erand48(_rand48_seed);
-}
-
-HTSLIB_EXPORT
-long hts_lrand48(void)
-{
-	_dorand48(_rand48_seed);
-	return ((long) _rand48_seed[2] << 15) + ((long) _rand48_seed[1] >> 1);
-}
diff -ruN stringtie.orig/htslib/plugin.c stringtie/htslib/plugin.c
--- stringtie.orig/htslib/plugin.c	2024-02-28 13:57:39.701246126 +0100
+++ stringtie/htslib/plugin.c	1970-01-01 01:00:00.000000000 +0100
@@ -1,220 +0,0 @@
-/*  plugin.c -- low-level path parsing and plugin functions.
-
-    Copyright (C) 2015-2016, 2020 Genome Research Ltd.
-
-    Author: John Marshall <jm18@sanger.ac.uk>
-
-Permission is hereby granted, free of charge, to any person obtaining a copy
-of this software and associated documentation files (the "Software"), to deal
-in the Software without restriction, including without limitation the rights
-to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
-copies of the Software, and to permit persons to whom the Software is
-furnished to do so, subject to the following conditions:
-
-The above copyright notice and this permission notice shall be included in
-all copies or substantial portions of the Software.
-
-THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
-IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
-FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
-THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
-LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
-FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
-DEALINGS IN THE SOFTWARE.  */
-
-#include <config.h>
-
-#include <stdio.h>
-#include <stdlib.h>
-#include <string.h>
-#include <errno.h>
-
-#include <dirent.h>
-#include <dlfcn.h>
-
-#include "hts_internal.h"
-#include "htslib/kstring.h"
-
-#ifndef PLUGINPATH
-#define PLUGINPATH ""
-#endif
-
-static DIR *open_nextdir(struct hts_path_itr *itr)
-{
-    DIR *dir;
-
-    while (1) {
-        const char *colon = strchr(itr->pathdir, HTS_PATH_SEPARATOR_CHAR);
-        if (colon == NULL) return NULL;
-
-        itr->entry.l = 0;
-        kputsn(itr->pathdir, colon - itr->pathdir, &itr->entry);
-        itr->pathdir = &colon[1];
-        if (itr->entry.l == 0) continue;
-
-        dir = opendir(itr->entry.s);
-        if (dir) break;
-
-        if (hts_verbose >= 4)
-            fprintf(stderr,
-                    "[W::hts_path_itr] can't scan directory \"%s\": %s\n",
-                    itr->entry.s, strerror(errno));
-    }
-
-    if (itr->entry.s[itr->entry.l-1] != '/') kputc('/', &itr->entry);
-    itr->entry_dir_l = itr->entry.l;
-    return dir;
-}
-
-void hts_path_itr_setup(struct hts_path_itr *itr, const char *path,
-        const char *builtin_path, const char *prefix, size_t prefix_len,
-        const char *suffix, size_t suffix_len)
-{
-    itr->prefix = prefix;
-    itr->prefix_len = prefix_len;
-
-    if (suffix) itr->suffix = suffix, itr->suffix_len = suffix_len;
-    else itr->suffix = PLUGIN_EXT, itr->suffix_len = strlen(PLUGIN_EXT);
-
-    itr->path.l = itr->path.m = 0; itr->path.s = NULL;
-    itr->entry.l = itr->entry.m = 0; itr->entry.s = NULL;
-
-    if (! builtin_path) builtin_path = PLUGINPATH;
-    if (! path) {
-        path = getenv("HTS_PATH");
-        if (! path) path = "";
-    }
-
-    while (1) {
-        size_t len = strcspn(path, HTS_PATH_SEPARATOR_STR);
-        if (len == 0) kputs(builtin_path, &itr->path);
-        else kputsn(path, len, &itr->path);
-        kputc(HTS_PATH_SEPARATOR_CHAR, &itr->path);
-
-        path += len;
-        if (*path == HTS_PATH_SEPARATOR_CHAR) path++;
-        else break;
-    }
-
-    // Note that ':' now terminates entries rather than separates them
-    itr->pathdir = itr->path.s;
-    itr->dirv = open_nextdir(itr);
-}
-
-const char *hts_path_itr_next(struct hts_path_itr *itr)
-{
-    while (itr->dirv) {
-        struct dirent *e;
-        while ((e = readdir((DIR *) itr->dirv)) != NULL) {
-            size_t d_name_len = strlen(e->d_name);
-            if (strncmp(e->d_name, itr->prefix, itr->prefix_len) == 0 &&
-                d_name_len >= itr->suffix_len &&
-                strncmp(e->d_name + d_name_len - itr->suffix_len, itr->suffix,
-                        itr->suffix_len) == 0) {
-                itr->entry.l = itr->entry_dir_l;
-                kputs(e->d_name, &itr->entry);
-                return itr->entry.s;
-            }
-        }
-
-        closedir((DIR *) itr->dirv);
-        itr->dirv = open_nextdir(itr);
-    }
-
-    itr->pathdir = NULL;
-    free(itr->path.s); itr->path.s = NULL;
-    free(itr->entry.s); itr->entry.s = NULL;
-    return NULL;
-}
-
-
-#ifndef RTLD_NOLOAD
-#define RTLD_NOLOAD 0
-#endif
-
-plugin_void_func *load_plugin(void **pluginp, const char *filename, const char *symbol)
-{
-    void *lib = dlopen(filename, RTLD_NOW | RTLD_LOCAL);
-    if (lib == NULL) goto error;
-
-    plugin_void_func *sym;
-    *(void **) &sym = dlsym(lib, symbol);
-    if (sym == NULL) {
-        // Reopen the plugin with RTLD_GLOBAL and check for uniquified symbol
-        void *libg = dlopen(filename, RTLD_NOLOAD | RTLD_NOW | RTLD_GLOBAL);
-        if (libg == NULL) goto error;
-        dlclose(lib);
-        lib = libg;
-
-        kstring_t symbolg = { 0, 0, NULL };
-        kputs(symbol, &symbolg);
-        kputc('_', &symbolg);
-        const char *slash = strrchr(filename, '/');
-        const char *basename = slash? slash+1 : filename;
-        kputsn(basename, strcspn(basename, ".-+"), &symbolg);
-
-        *(void **) &sym = dlsym(lib, symbolg.s);
-        free(symbolg.s);
-        if (sym == NULL) goto error;
-    }
-
-    *pluginp = lib;
-    return sym;
-
-error:
-    if (hts_verbose >= 4)
-        fprintf(stderr, "[W::%s] can't load plugin \"%s\": %s\n",
-                __func__, filename, dlerror());
-    if (lib) dlclose(lib);
-    return NULL;
-}
-
-void *plugin_sym(void *plugin, const char *name, const char **errmsg)
-{
-    void *sym = dlsym(plugin, name);
-    if (sym == NULL) *errmsg = dlerror();
-    return sym;
-}
-
-plugin_void_func *plugin_func(void *plugin, const char *name, const char **errmsg)
-{
-    plugin_void_func *sym;
-    *(void **) &sym = plugin_sym(plugin, name, errmsg);
-    return sym;
-}
-
-void close_plugin(void *plugin)
-{
-    if (dlclose(plugin) != 0) {
-        if (hts_verbose >= 4)
-            fprintf(stderr, "[W::%s] dlclose() failed: %s\n",
-                    __func__, dlerror());
-    }
-}
-
-const char *hts_plugin_path(void) {
-#ifdef ENABLE_PLUGINS
-    char *path = getenv("HTS_PATH");
-    if (!path) path = "";
-
-    kstring_t ks = {0};
-    while(1) {
-        size_t len = strcspn(path, HTS_PATH_SEPARATOR_STR);
-        if (len == 0) kputs(PLUGINPATH, &ks);
-        else kputsn(path, len, &ks);
-        kputc(HTS_PATH_SEPARATOR_CHAR, &ks);
-
-        path += len;
-        if (*path == HTS_PATH_SEPARATOR_CHAR) path++;
-        else break;
-    }
-
-    static char s_path[1024];
-    sprintf(s_path, "%.1023s", ks.s ? ks.s : "");
-    free(ks.s);
-
-    return s_path;
-#else
-    return NULL;
-#endif
-}
diff -ruN stringtie.orig/htslib/probaln.c stringtie/htslib/probaln.c
--- stringtie.orig/htslib/probaln.c	2024-02-28 13:57:39.701246126 +0100
+++ stringtie/htslib/probaln.c	1970-01-01 01:00:00.000000000 +0100
@@ -1,448 +0,0 @@
-/* The MIT License
-
-   Copyright (C) 2003-2006, 2008-2010 by Heng Li <lh3lh3@live.co.uk>
-   Copyright (C) 2016-2017, 2020 Genome Research Ltd.
-
-   Permission is hereby granted, free of charge, to any person obtaining
-   a copy of this software and associated documentation files (the
-   "Software"), to deal in the Software without restriction, including
-   without limitation the rights to use, copy, modify, merge, publish,
-   distribute, sublicense, and/or sell copies of the Software, and to
-   permit persons to whom the Software is furnished to do so, subject to
-   the following conditions:
-
-   The above copyright notice and this permission notice shall be
-   included in all copies or substantial portions of the Software.
-
-   THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
-   EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
-   MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
-   NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS
-   BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
-   ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
-   CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
-   SOFTWARE.
-*/
-
-#define HTS_BUILDING_LIBRARY // Enables HTSLIB_EXPORT, see htslib/hts_defs.h
-#include <config.h>
-
-#include <stdlib.h>
-#include <stdio.h>
-#include <string.h>
-#include <stdint.h>
-#include <limits.h>
-#include <math.h>
-#include <errno.h>
-#include "htslib/hts.h"
-
-/*****************************************
- * Probabilistic banded glocal alignment *
- *****************************************/
-
-#define EI .25
-#define EM .33333333333
-
-static float g_qual2prob[256];
-
-#define set_u(u, b, i, k) { int x=(i)-(b); x=x>0?x:0; (u)=((k)-x+1)*3; }
-
-/*
-  The topology of the profile HMM:
-
-           /\             /\        /\             /\
-           I[1]           I[k-1]    I[k]           I[L]
-            ^   \      \    ^    \   ^   \      \   ^
-            |    \      \   |     \  |    \      \  |
-    M[0]   M[1] -> ... -> M[k-1] -> M[k] -> ... -> M[L]   M[L+1]
-                \      \/        \/      \/      /
-                 \     /\        /\      /\     /
-                       -> D[k-1] -> D[k] ->
-
-   M[0] points to every {M,I}[k] and every {M,I}[k] points to M[L+1].
-
-   On input, ref is the reference sequence and query is the query
-   sequence. Both are sequences of 0/1/2/3/4 where 4 stands for an
-   ambiguous residue. iqual is the base quality. c sets the gap open
-   probability, gap extension probability and band width.
-
-   On output, state and q are arrays of length l_query. The higher 30
-   bits give the reference position the query base is matched to and the
-   lower two bits can be 0 (an alignment match) or 1 (an
-   insertion). q[i] gives the phred scaled posterior probability of
-   state[i] being wrong.
-
-   Returns phred-scaled likelihood score, or INT_MIN on failure.
- */
-int probaln_glocal(const uint8_t *ref, int l_ref, const uint8_t *query,
-                   int l_query, const uint8_t *iqual, const probaln_par_t *c,
-                   int *state, uint8_t *q)
-{
-    double *f = NULL, *b = NULL, *s = NULL, m[9], sI, sM, bI, bM;
-    float *qual = NULL;
-    int bw, bw2, i, k, is_backward = 1, Pr;
-
-    if ( l_ref<0 || l_query<0 || l_query >= INT_MAX - 2) {
-        errno = EINVAL;
-        return INT_MIN;
-    }
-    if (l_ref==0 || l_query==0)
-        return 0;  // Is this actually invalid??
-
-    /*** initialization ***/
-    is_backward = state && q? 1 : 0;
-    bw = l_ref > l_query? l_ref : l_query;
-    if (bw > c->bw) bw = c->bw;
-    if (bw < abs(l_ref - l_query)) bw = abs(l_ref - l_query);
-    bw2 = bw * 2 + 1;
-    size_t i_dim = bw2 < l_ref ? (size_t) bw2*3+6 : (size_t) l_ref*3+6;
-
-    // allocate the forward and backward matrices f[][] and b[][]
-    // and the scaling array s[]
-    // Ideally these callocs would be mallocs + initialisation of
-    // the few bits needed.
-    if (SIZE_MAX / (l_query+1) / i_dim < sizeof(double)) {
-        errno = ENOMEM; // Allocation would fail
-        return INT_MIN;
-    }
-    f = calloc((l_query+1)*i_dim, sizeof(double));
-    if (!f) goto fail;
-    if (is_backward) {
-        b = calloc((l_query+1)*i_dim, sizeof(double));
-        if (!b) goto fail;
-    }
-
-    // s[] is the scaling factor to avoid underflow
-    s = malloc((l_query+2) * sizeof(double));
-    if (!s) goto fail;
-
-    // initialize qual
-    qual = malloc(l_query * sizeof(float));
-    if (!qual) goto fail;
-    if (g_qual2prob[0] == 0)
-        for (i = 0; i < 256; ++i)
-            g_qual2prob[i] = pow(10, -i/10.);
-    qual[0] = 0.0; // Should be unused
-    for (i = 0; i < l_query; ++i)
-        qual[i] = g_qual2prob[iqual? iqual[i] : 30];
-
-    // initialize transition probability
-    // the value here seems not to affect results; FIXME: need proof
-    sM = sI = 1. / (2 * l_query + 2);
-    m[0*3+0] = (1 - c->d - c->d) * (1 - sM);
-    m[0*3+1] = m[0*3+2] = c->d * (1 - sM);
-    m[1*3+0] = (1 - c->e) * (1 - sI);
-    m[1*3+1] = c->e * (1 - sI);
-    m[1*3+2] = 0.;
-    m[2*3+0] = 1 - c->e;
-    m[2*3+1] = 0.;
-    m[2*3+2] = c->e;
-    bM = (1 - c->d) / l_ref; // (bM+bI)*l_ref==1
-    bI = c->d / l_ref;
-
-    /*** forward ***/
-    // f[0]
-    set_u(k, bw, 0, 0);
-    f[0*i_dim+k] = s[0] = 1.;
-    { // f[1]
-        double *fi = &f[1*i_dim], sum;
-        int beg = 1, end = l_ref < bw + 1? l_ref : bw + 1;
-        for (k = beg, sum = 0.; k <= end; ++k) {
-            int u;
-            double e = (ref[k - 1] > 3 || query[0] > 3)? 1. : ref[k - 1] == query[0]? 1. - qual[0] : qual[0] * EM;
-            set_u(u, bw, 1, k);
-            fi[u+0] = e * bM; fi[u+1] = EI * bI;
-            sum += fi[u] + fi[u+1];
-        }
-        s[1] = sum;
-    }
-    // f[2..l_query]
-    for (i = 2; i <= l_query; ++i) {
-        double *fi = &f[i*i_dim], *fi1 = &f[(i-1)*i_dim], sum, qli = qual[i-1];
-        int beg = 1, end = l_ref, x;
-        uint8_t qyi = query[i - 1];
-        x = i - bw; beg = beg > x? beg : x; // band start
-        x = i + bw; end = end < x? end : x; // band end
-
-        // NB end-beg is almost always 14 (99.9% of the time)
-        // Hence not a large volume to parallelise.
-        //
-        // Maybe stripe in diagonal doing 14 lines together?
-        //
-        // Consider rotation? 150x14 vs 14x150 so inner loop
-        // takes longer.
-
-        double E[] = {
-            qli * EM, // 00
-            1. - qli, // 01
-            1.,       // 10
-            1.,       // 11
-        };
-        double M = 1./s[i-1];
-
-        // Note this code has the original version listed here (albeit
-        // with improved formatting), but we do not compile using
-        // -DPROBALN_ORIG.  The purpose of this code is to act as an
-        // easier(?) to understand version of the heavily optimised
-        // version following it and as an easy validation path in case
-        // of any differences in results.
-#ifdef PROBALN_ORIG
-        for (k = beg, sum = 0.; k <= end; ++k) {
-            int u, v11, v01, v10;
-            double e;
-            e = E[(ref[k - 1] > 3 || qyi > 3)*2 + (ref[k - 1] == qyi)];
-            set_u(u, bw, i, k);
-            set_u(v11, bw, i-1, k-1);
-            set_u(v10, bw, i-1, k);
-            set_u(v01, bw, i, k-1);
-            fi[u+0] = e * (m[0] * M*fi1[v11+0] + m[3] * M*fi1[v11+1] + m[6] * M*fi1[v11+2]);
-            fi[u+1] = EI * (m[1] * M*fi1[v10+0] + m[4] * M*fi1[v10+1]);
-            fi[u+2] = m[2] * fi[v01+0] + m[8] * fi[v01+2];
-            sum += fi[u] + fi[u+1] + fi[u+2];
-        }
-#else
-        // We use EI*(M*m[1]*? + M*m[4]*?) a lot.  So factor it out here.
-        double xm[5];
-        xm[0] =    M*m[0];
-        xm[1] =    M*m[3];
-        xm[2] =    M*m[6];
-        xm[3] = EI*M*m[1];
-        xm[4] = EI*M*m[4];
-
-        {
-            int u, v11;
-            set_u(u,   bw, i,   beg);
-            set_u(v11, bw, i-1, beg-1);
-            // Rather than recompute k->{u,v01,v10,v11} each loop
-            // we just increment the pointers.
-            double *xi = &fi[u];
-            double *yi = &fi1[v11];
-            // Derived from xi[0,2] in previous loop iter.
-            double  l_x0 = m[2]*xi[0];
-            double  l_x2 = m[8]*xi[2];
-            for (k = beg, sum = 0.; k <= end; ++k, xi+=3, yi+=3) {
-                int cond = (ref[k-1] > 3 || qyi > 3)*2 + (ref[k-1] == qyi);
-
-                double z0 = xm[0]*yi[0];
-                double z1 = xm[1]*yi[1];
-                double z2 = xm[2]*yi[2];
-                double z3 = xm[3]*yi[3];
-                double z4 = xm[4]*yi[4];
-
-                xi[0] = E[cond] * (z0+z1+z2);
-                xi[1] = z3 + z4;
-                xi[2] = l_x0 + l_x2;
-                sum  += xi[0] + xi[1] + xi[2];
-
-                l_x0 = m[2]*xi[0];
-                l_x2 = m[8]*xi[2];
-            }
-        }
-#endif
-        s[i] = sum;
-    }
-
-    { // f[l_query+1]
-        double sum;
-        double M = 1./s[l_query];
-        for (k = 1, sum = 0.; k <= l_ref; ++k) {
-            int u;
-            set_u(u, bw, l_query, k);
-            if (u < 3 || u >= i_dim - 3) continue;
-            sum += M*f[l_query*i_dim + u+0] * sM + M*f[l_query*i_dim + u+1] * sI;
-        }
-        s[l_query+1] = sum; // the last scaling factor
-    }
-    { // compute likelihood
-        double p = 1., Pr1 = 0.;
-        for (i = 0; i <= l_query + 1; ++i) {
-            p *= s[i];
-            if (p < 1e-100) Pr1 += -4.343 * log(p), p = 1.;
-        }
-        Pr1 += -4.343 * log(p * l_ref * l_query);
-        Pr = (int)(Pr1 + .499);
-        if (!is_backward) { // skip backward and MAP
-            free(f); free(s); free(qual);
-            return Pr;
-        }
-    }
-    /*** backward ***/
-    // b[l_query] (b[l_query+1][0]=1 and thus \tilde{b}[][]=1/s[l_query+1]; this is where s[l_query+1] comes from)
-    for (k = 1; k <= l_ref; ++k) {
-        int u;
-        double *bi = &b[l_query*i_dim];
-        set_u(u, bw, l_query, k);
-        if (u < 3 || u >= i_dim - 3) continue;
-        bi[u+0] = sM / s[l_query] / s[l_query+1]; bi[u+1] = sI / s[l_query] / s[l_query+1];
-    }
-    // b[l_query-1..1]
-    for (i = l_query - 1; i >= 1; --i) {
-        int beg = 1, end = l_ref, x;
-        double *bi = &b[i*i_dim], *bi1 = &b[(i+1)*i_dim], y = (i > 1), qli1 = qual[i];
-        uint8_t qyi1 = query[i];
-        x = i - bw; beg = beg > x? beg : x;
-        x = i + bw; end = end < x? end : x;
-        double E[] = {
-            qli1 * EM, //000
-            1. - qli1, //001
-            1.,        //010
-            1.,        //011
-            //0,0,0,0    //1xx
-        };
-
-#ifdef PROBALN_ORIG
-        for (k = end; k >= beg; --k) {
-            int u, v11, v01, v10;
-            double e;
-            set_u(u, bw, i, k);
-            set_u(v11, bw, i+1, k+1);
-            set_u(v10, bw, i+1, k);
-            set_u(v01, bw, i, k+1);
-            e = (k>=l_ref)?0 :E[(ref[k] > 3 || qyi1 > 3)*2 + (ref[k] == qyi1)] * bi1[v11];
-            bi[u+0] = e * m[0] + EI * m[1] * bi1[v10+1] + m[2] * bi[v01+2]; // bi1[v11] has been foled into e.
-            bi[u+1] = e * m[3] + EI * m[4] * bi1[v10+1];
-            bi[u+2] = (e * m[6] + m[8] * bi[v01+2]) * y;
-//          fprintf(stderr, "B (%d,%d;%d): %lg,%lg,%lg\n", i, k, u, bi[u], bi[u+1], bi[u+2]); // DEBUG
-        }
-        // rescale
-        int _beg, _end;
-        set_u(_beg, bw, i, beg); set_u(_end, bw, i, end); _end += 2;
-        for (k = _beg, y = 1./s[i]; k <= _end; ++k) bi[k] *= y;
-#else
-        {
-            int u, v10;
-            set_u(u,   bw, i,   end);
-            set_u(v10, bw, i+1, end);
-            // Rather than recompute k->{u,v01,v10,v11} each loop
-            // we just increment the pointers.
-            double *xi = &bi[u];
-            double *yi = &bi1[v10];
-            // NB xi[5] is equiv to v01+2.
-            double xi_5 = xi[5];
-            // Manual loop invariant removal
-            double e1 = EI*m[1];
-            double e4 = EI*m[4];
-            // Do renorm too in the same pass.
-            double n = 1./s[i];
-            for (k = end; k >= beg; --k, xi -= 3, yi -= 3) {
-                double e = (k>=l_ref)
-                    ? 0
-                    : E[(ref[k]>3 || qyi1>3)*2 + (ref[k] == qyi1)] * yi[3];
-
-                xi[1] =  e * m[3] +   e4 * yi[1];
-                xi[0] =  e * m[0] +   e1 * yi[1]  + m[2] * xi_5;
-                xi[2] = (e * m[6] + m[8] * xi_5) * y;
-                // bi[u+2] from this iter becomes bi[v01+2] in next iter
-                xi_5 = xi[2];
-
-                // rescale
-                xi[1] *= n;
-                xi[0] *= n;
-                xi[2] *= n;
-            }
-        }
-#endif
-    }
-    { // b[0]
-        int beg = 1, end = l_ref < bw + 1? l_ref : bw + 1;
-        double sum = 0.;
-        for (k = end; k >= beg; --k) {
-            int u;
-            double e = (ref[k - 1] > 3 || query[0] > 3)? 1. : ref[k - 1] == query[0]? 1. - qual[0] : qual[0] * EM;
-            set_u(u, bw, 1, k);
-            if (u < 3 || u >= i_dim - 3) continue;
-            sum += e * b[1*i_dim + u+0] * bM + EI * b[1*i_dim + u+1] * bI;
-        }
-        set_u(k, bw, 0, 0);
-        b[0*i_dim + k] = sum / s[0]; // if everything works as is expected, b[0][k] == 1.0
-    }
-    /*** MAP ***/
-    for (i = 1; i <= l_query; ++i) {
-        double sum = 0., *fi = &f[i*i_dim], *bi = &b[i*i_dim], max = 0.;
-        int beg = 1, end = l_ref, x, max_k = -1;
-        x = i - bw; beg = beg > x? beg : x;
-        x = i + bw; end = end < x? end : x;
-        double M = 1./s[i];
-#ifdef PROBALN_ORIG
-        for (k = beg; k <= end; ++k) {
-            int u;
-            double z;
-            set_u(u, bw, i, k);
-            z = M*fi[u+0] * bi[u+0];
-            if (z > max) max = z, max_k = (k-1)<<2 | 0;
-            sum += z;
-            z = M*fi[u+1] * bi[u+1];
-            if (z > max) max = z, max_k = (k-1)<<2 | 1;
-            sum += z;
-        }
-#else
-        {
-            int u;
-            set_u(u, bw, i, beg);
-            for (k = beg; k <= end; ++k, u+=3) {
-                double z1, z2;
-                z1 = M*fi[u+0] * bi[u+0];
-                z2 = M*fi[u+1] * bi[u+1];
-                int which = z2 > z1; // strictly z2 >= z1 matches old code
-                double zm = which ? z2 : z1;
-                if (zm > max) {
-                    max   = zm;
-                    max_k = (k-1)<<2 | which;
-                }
-                sum += z1 + z2;
-            }
-        }
-#endif
-        max /= sum; sum *= s[i]; // if everything works as is expected, sum == 1.0
-        if (state) state[i-1] = max_k;
-        if (q) k = (int)(-4.343 * log(1. - max) + .499), q[i-1] = k > 100? 99 : k;
-#ifdef PROBALN_MAIN
-        k = 0;
-        set_u(k, bw, 0, 0);
-        fprintf(stderr, "(%.10lg,%.10lg) (%d,%d:%c,%c:%d) %lg\n", b[0][k], sum, i-1, max_k>>2,
-                "ACGT"[query[i - 1]], "ACGT"[ref[(max_k>>2)]], max_k&3, max); // DEBUG
-#endif
-    }
-
-    /*** free ***/
-    free(f); free(b); free(s); free(qual);
-    return Pr;
-
- fail:
-    free(f); free(b); free(s); free(qual);
-    return INT_MIN;
-}
-
-#ifdef PROBALN_MAIN
-#include <unistd.h>
-int main(int argc, char *argv[])
-{
-    uint8_t conv[256], *iqual, *ref, *query;
-    probaln_par_t par = { 0.001, 0.1, 10 };
-    int c, l_ref, l_query, i, q = 30, b = 10, P;
-    while ((c = getopt(argc, argv, "b:q:")) >= 0) {
-        switch (c) {
-        case 'b': b = atoi(optarg); break;
-        case 'q': q = atoi(optarg); break;
-        }
-    }
-    if (optind + 2 > argc) {
-        fprintf(stderr, "Usage: %s [-q %d] [-b %d] <ref> <query>\n", argv[0], q, b); // example: acttc attc
-        return 1;
-    }
-    memset(conv, 4, 256);
-    conv['a'] = conv['A'] = 0; conv['c'] = conv['C'] = 1;
-    conv['g'] = conv['G'] = 2; conv['t'] = conv['T'] = 3;
-    ref = (uint8_t*)argv[optind]; query = (uint8_t*)argv[optind+1];
-    l_ref = strlen((char*)ref); l_query = strlen((char*)query);
-    for (i = 0; i < l_ref; ++i) ref[i] = conv[ref[i]];
-    for (i = 0; i < l_query; ++i) query[i] = conv[query[i]];
-    iqual = malloc(l_query);
-    memset(iqual, q, l_query);
-    par.bw = b;
-    P = probaln_glocal(ref, l_ref, query, l_query, iqual, &par, 0, 0);
-    fprintf(stderr, "%d\n", P);
-    free(iqual);
-    return 0;
-}
-#endif
diff -ruN stringtie.orig/htslib/README.md stringtie/htslib/README.md
--- stringtie.orig/htslib/README.md	2024-02-28 13:57:39.701246126 +0100
+++ stringtie/htslib/README.md	1970-01-01 01:00:00.000000000 +0100
@@ -1,41 +0,0 @@
-[![Build Status](https://api.cirrus-ci.com/github/samtools/htslib.svg?branch=develop)](https://api.cirrus-ci.com/github/samtools/htslib)
-[![Build status](https://ci.appveyor.com/api/projects/status/v46hkwyfjp3l8nd3/branch/develop?svg=true)](https://ci.appveyor.com/project/samtools/htslib/branch/develop)
-[![Github All Releases](https://img.shields.io/github/downloads/samtools/htslib/total.svg)](https://github.com/samtools/htslib)
-
-HTSlib is an implementation of a unified C library for accessing common file
-formats, such as [SAM, CRAM and VCF][1], used for high-throughput sequencing
-data, and is the core library used by [samtools][2] and [bcftools][3].
-HTSlib only depends on [zlib][4].
-It is known to be compatible with gcc, g++ and clang.
-
-HTSlib implements a generalized BAM index, with file extension `.csi`
-(coordinate-sorted index). The HTSlib file reader first looks for the new index
-and then for the old if the new index is absent.
-
-This project also includes the popular tabix indexer, which indexes both `.tbi`
-and `.csi` formats, and the bgzip compression utility.
-
-[1]: http://samtools.github.io/hts-specs/
-[2]: http://github.com/samtools/samtools
-[3]: http://samtools.github.io/bcftools/
-[4]: http://zlib.net/
-
-### Building HTSlib
-
-See [INSTALL](INSTALL) for complete details. Release tarballs may contain generated files that have not been
-committed to this repository, so building the code from a Git repository requires extra steps:
-
-```sh
-autoreconf -i  # Build the configure script and install files it uses
-./configure    # Optional but recommended, for choosing extra functionality
-make
-make install
-```
-For example, if linking with `libdeflate` is desired (to speed up zlib compression/decompression), and 
-the installation prefix should be `/ccb/sw/` (which could also be the prefix of libdeflate installation in this exmple), the following configure command can be used:
-
-```sh
-CPPFLAGS=-I/ccb/sw/include LDFLAGS=-L/ccb/sw/lib \
-./configure --prefix=/ccb/sw --with-libdeflate
-```
-
diff -ruN stringtie.orig/htslib/realn.c stringtie/htslib/realn.c
--- stringtie.orig/htslib/realn.c	2024-02-28 13:57:39.701246126 +0100
+++ stringtie/htslib/realn.c	1970-01-01 01:00:00.000000000 +0100
@@ -1,290 +0,0 @@
-/*  realn.c -- BAQ calculation and realignment.
-
-    Copyright (C) 2009-2011, 2014-2016, 2018 Genome Research Ltd.
-    Portions copyright (C) 2009-2011 Broad Institute.
-
-    Author: Heng Li <lh3@sanger.ac.uk>
-
-Permission is hereby granted, free of charge, to any person obtaining a copy
-of this software and associated documentation files (the "Software"), to deal
-in the Software without restriction, including without limitation the rights
-to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
-copies of the Software, and to permit persons to whom the Software is
-furnished to do so, subject to the following conditions:
-
-The above copyright notice and this permission notice shall be included in
-all copies or substantial portions of the Software.
-
-THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
-IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
-FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
-THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
-LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
-FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
-DEALINGS IN THE SOFTWARE.  */
-
-#define HTS_BUILDING_LIBRARY // Enables HTSLIB_EXPORT, see htslib/hts_defs.h
-#include <config.h>
-
-#include <stdlib.h>
-#include <string.h>
-#include <math.h>
-#include <limits.h>
-#include <stdint.h>
-#include <errno.h>
-#include <assert.h>
-#include "htslib/hts.h"
-#include "htslib/sam.h"
-
-int sam_cap_mapq(bam1_t *b, const char *ref, hts_pos_t ref_len, int thres)
-{
-    uint8_t *seq = bam_get_seq(b), *qual = bam_get_qual(b);
-    uint32_t *cigar = bam_get_cigar(b);
-    bam1_core_t *c = &b->core;
-    int i, y, mm, q, len, clip_l, clip_q;
-    hts_pos_t x;
-    double t;
-    if (thres < 0) thres = 40; // set the default
-    mm = q = len = clip_l = clip_q = 0;
-    for (i = y = 0, x = c->pos; i < c->n_cigar; ++i) {
-        int j, l = cigar[i]>>4, op = cigar[i]&0xf;
-        if (op == BAM_CMATCH || op == BAM_CEQUAL || op == BAM_CDIFF) {
-            for (j = 0; j < l; ++j) {
-                int c1, c2, z = y + j;
-                if (x+j >= ref_len || ref[x+j] == '\0') break; // out of bounds
-                c1 = bam_seqi(seq, z), c2 = seq_nt16_table[(unsigned char)ref[x+j]];
-                if (c2 != 15 && c1 != 15 && qual[z] >= 13) { // not ambiguous
-                    ++len;
-                    if (c1 && c1 != c2 && qual[z] >= 13) { // mismatch
-                        ++mm;
-                        q += qual[z] > 33? 33 : qual[z];
-                    }
-                }
-            }
-            if (j < l) break;
-            x += l; y += l; len += l;
-        } else if (op == BAM_CDEL) {
-            for (j = 0; j < l; ++j)
-                if (x+j >= ref_len || ref[x+j] == '\0') break;
-            if (j < l) break;
-            x += l;
-        } else if (op == BAM_CSOFT_CLIP) {
-            for (j = 0; j < l; ++j) clip_q += qual[y+j];
-            clip_l += l;
-            y += l;
-        } else if (op == BAM_CHARD_CLIP) {
-            clip_q += 13 * l;
-            clip_l += l;
-        } else if (op == BAM_CINS) y += l;
-        else if (op == BAM_CREF_SKIP) x += l;
-    }
-    for (i = 0, t = 1; i < mm; ++i)
-        t *= (double)len / (i+1);
-    t = q - 4.343 * log(t) + clip_q / 5.;
-    if (t > thres) return -1;
-    if (t < 0) t = 0;
-    t = sqrt((thres - t) / thres) * thres;
-    //fprintf(stderr, "%s %lf %d\n", bam_get_qname(b), t, q);
-    return (int)(t + .499);
-}
-
-static int realn_check_tag(const uint8_t *tg, enum htsLogLevel severity,
-                           const char *type, const bam1_t *b) {
-    if (*tg != 'Z') {
-        hts_log(severity, "Incorrect %s tag type (%c) for read %s",
-                type, *tg, bam_get_qname(b));
-        return -1;
-    }
-    if (b->core.l_qseq != strlen((const char *) tg + 1)) {
-        hts_log(severity, "Read %s %s tag is wrong length",
-                bam_get_qname(b), type);
-        return -1;
-    }
-    return 0;
-}
-
-int sam_prob_realn(bam1_t *b, const char *ref, hts_pos_t ref_len, int flag)
-{
-    int k, bw, y, yb, ye, xb, xe, apply_baq = flag&1, extend_baq = flag>>1&1, redo_baq = flag&4, fix_bq = 0;
-    hts_pos_t i, x;
-    uint32_t *cigar = bam_get_cigar(b);
-    bam1_core_t *c = &b->core;
-    probaln_par_t conf = { 0.001, 0.1, 10 };
-    uint8_t *bq = NULL, *zq = NULL, *qual = bam_get_qual(b);
-    int *state = NULL;
-    if ((c->flag & BAM_FUNMAP) || b->core.l_qseq == 0 || qual[0] == (uint8_t)-1)
-        return -1; // do nothing
-
-    // test if BQ or ZQ is present, and make sanity checks
-    if ((bq = bam_aux_get(b, "BQ")) != NULL) {
-        if (!redo_baq) {
-            if (realn_check_tag(bq, HTS_LOG_WARNING, "BQ", b) < 0)
-                fix_bq = 1;
-        }
-        ++bq;
-    }
-    if ((zq = bam_aux_get(b, "ZQ")) != NULL) {
-        if (realn_check_tag(zq, HTS_LOG_ERROR, "ZQ", b) < 0)
-            return -4;
-        ++zq;
-    }
-    if (bq && redo_baq)
-    {
-        bam_aux_del(b, bq-1);
-        bq = 0;
-    }
-    if (bq && zq) { // remove the ZQ tag
-        bam_aux_del(b, zq-1);
-        zq = 0;
-    }
-    if (!zq && fix_bq) { // Need to fix invalid BQ tag (by realigning)
-        assert(bq != NULL);
-        bam_aux_del(b, bq-1);
-        bq = 0;
-    }
-
-    if (bq || zq) {
-        if ((apply_baq && zq) || (!apply_baq && bq)) return -3; // in both cases, do nothing
-        if (bq && apply_baq) { // then convert BQ to ZQ
-            for (i = 0; i < c->l_qseq; ++i)
-                qual[i] = qual[i] + 64 < bq[i]? 0 : qual[i] - ((int)bq[i] - 64);
-            *(bq - 3) = 'Z';
-        } else if (zq && !apply_baq) { // then convert ZQ to BQ
-            for (i = 0; i < c->l_qseq; ++i)
-                qual[i] += (int)zq[i] - 64;
-            *(zq - 3) = 'B';
-        }
-        return 0;
-    }
-    // find the start and end of the alignment
-    x = c->pos, y = 0, yb = ye = xb = xe = -1;
-    for (k = 0; k < c->n_cigar; ++k) {
-        int op, l;
-        op = cigar[k]&0xf; l = cigar[k]>>4;
-        if (op == BAM_CMATCH || op == BAM_CEQUAL || op == BAM_CDIFF) {
-            if (yb < 0) yb = y;
-            if (xb < 0) xb = x;
-            ye = y + l; xe = x + l;
-            x += l; y += l;
-        } else if (op == BAM_CSOFT_CLIP || op == BAM_CINS) y += l;
-        else if (op == BAM_CDEL) x += l;
-        else if (op == BAM_CREF_SKIP) return -1; // do nothing if there is a reference skip
-    }
-    if (xb == -1) // No matches in CIGAR.
-        return -1;
-    // set bandwidth and the start and the end
-    bw = 7;
-    if (abs((xe - xb) - (ye - yb)) > bw)
-        bw = abs((xe - xb) - (ye - yb)) + 3;
-    conf.bw = bw;
-    xb -= yb + bw/2; if (xb < 0) xb = 0;
-    xe += c->l_qseq - ye + bw/2;
-    if (xe - xb - c->l_qseq > bw)
-        xb += (xe - xb - c->l_qseq - bw) / 2, xe -= (xe - xb - c->l_qseq - bw) / 2;
-    { // glocal
-        uint8_t *seq = bam_get_seq(b);
-        uint8_t *tseq; // translated seq A=>0,C=>1,G=>2,T=>3,other=>4
-        uint8_t *tref; // translated ref
-        uint8_t *q; // Probability of incorrect alignment from probaln_glocal()
-        size_t lref = xe > xb ? xe - xb : 1;
-        size_t align_lqseq;
-        if (extend_baq && lref < c->l_qseq)
-            lref = c->l_qseq; // So we can recycle tseq,tref for left,rght below
-        // Try to make q,tref,tseq reasonably well aligned
-        align_lqseq = ((c->l_qseq + 1) | 0xf) + 1;
-        // Overflow check - 3 for *bq, sizeof(int) for *state
-        if ((SIZE_MAX - lref) / (3 + sizeof(int)) < align_lqseq) {
-            errno = ENOMEM;
-            goto fail;
-        }
-
-        assert(bq == NULL); // bq was used above, but should now be NULL
-        bq = malloc(align_lqseq * 3 + lref);
-        if (!bq) goto fail;
-        q = bq + align_lqseq;
-        tseq = q + align_lqseq;
-        tref = tseq + align_lqseq;
-
-        memcpy(bq, qual, c->l_qseq); bq[c->l_qseq] = 0;
-        for (i = 0; i < c->l_qseq; ++i)
-            tseq[i] = seq_nt16_int[bam_seqi(seq, i)];
-        for (i = xb; i < xe; ++i) {
-            if (i >= ref_len || ref[i] == '\0') { xe = i; break; }
-            tref[i-xb] = seq_nt16_int[seq_nt16_table[(unsigned char)ref[i]]];
-        }
-
-        state = malloc(c->l_qseq * sizeof(int));
-        if (!state) goto fail;
-        if (probaln_glocal(tref, xe-xb, tseq, c->l_qseq, qual,
-                           &conf, state, q) == INT_MIN) {
-            goto fail;
-        }
-
-        if (!extend_baq) { // in this block, bq[] is capped by base quality qual[]
-            for (k = 0, x = c->pos, y = 0; k < c->n_cigar; ++k) {
-                int op = cigar[k]&0xf, l = cigar[k]>>4;
-                if (l == 0) continue;
-                if (op == BAM_CMATCH || op == BAM_CEQUAL || op == BAM_CDIFF) {
-                    // Sanity check running off the end of the sequence
-                    // Can only happen if the alignment is broken
-                    if (l > c->l_qseq - y)
-                        l = c->l_qseq - y;
-                    for (i = y; i < y + l; ++i) {
-                        if ((state[i]&3) != 0 || state[i]>>2 != x - xb + (i - y)) bq[i] = 0;
-                        else bq[i] = bq[i] < q[i]? bq[i] : q[i];
-                    }
-                    x += l; y += l;
-                } else if (op == BAM_CSOFT_CLIP || op == BAM_CINS) {
-                    // Need sanity check here too.
-                    if (l > c->l_qseq - y)
-                        l = c->l_qseq - y;
-                    y += l;
-                } else if (op == BAM_CDEL) {
-                    x += l;
-                }
-            }
-            for (i = 0; i < c->l_qseq; ++i) bq[i] = qual[i] - bq[i] + 64; // finalize BQ
-        } else { // in this block, bq[] is BAQ that can be larger than qual[] (different from the above!)
-            // tseq,tref are no longer needed, so we can steal them to avoid mallocs
-            uint8_t *left = tseq;
-            uint8_t *rght = tref;
-            for (k = 0, x = c->pos, y = 0; k < c->n_cigar; ++k) {
-                int op = cigar[k]&0xf, l = cigar[k]>>4;
-                if (l == 0) continue;
-                if (op == BAM_CMATCH || op == BAM_CEQUAL || op == BAM_CDIFF) {
-                    // Sanity check running off the end of the sequence
-                    // Can only happen if the alignment is broken
-                    if (l > c->l_qseq - y)
-                        l = c->l_qseq - y;
-                    for (i = y; i < y + l; ++i)
-                        bq[i] = ((state[i]&3) != 0 || state[i]>>2 != x - xb + (i - y))? 0 : q[i];
-                    for (left[y] = bq[y], i = y + 1; i < y + l; ++i)
-                        left[i] = bq[i] > left[i-1]? bq[i] : left[i-1];
-                    for (rght[y+l-1] = bq[y+l-1], i = y + l - 2; i >= y; --i)
-                        rght[i] = bq[i] > rght[i+1]? bq[i] : rght[i+1];
-                    for (i = y; i < y + l; ++i)
-                        bq[i] = left[i] < rght[i]? left[i] : rght[i];
-                    x += l; y += l;
-                } else if (op == BAM_CSOFT_CLIP || op == BAM_CINS) {
-                    // Need sanity check here too.
-                    if (l > c->l_qseq - y)
-                        l = c->l_qseq - y;
-                    y += l;
-                } else if (op == BAM_CDEL) {
-                    x += l;
-                }
-            }
-            for (i = 0; i < c->l_qseq; ++i) bq[i] = 64 + (qual[i] <= bq[i]? 0 : qual[i] - bq[i]); // finalize BQ
-        }
-        if (apply_baq) {
-            for (i = 0; i < c->l_qseq; ++i) qual[i] -= bq[i] - 64; // modify qual
-            bam_aux_append(b, "ZQ", 'Z', c->l_qseq + 1, bq);
-        } else bam_aux_append(b, "BQ", 'Z', c->l_qseq + 1, bq);
-        free(bq); free(state);
-    }
-    return 0;
-
- fail:
-    free(bq); free(state);
-    return -4;
-}
diff -ruN stringtie.orig/htslib/regidx.c stringtie/htslib/regidx.c
--- stringtie.orig/htslib/regidx.c	2024-02-28 13:57:39.701246126 +0100
+++ stringtie/htslib/regidx.c	1970-01-01 01:00:00.000000000 +0100
@@ -1,686 +0,0 @@
-/*
-    Copyright (C) 2014-2019 Genome Research Ltd.
-
-    Author: Petr Danecek <pd3@sanger.ac.uk>
-
-    Permission is hereby granted, free of charge, to any person obtaining a copy
-    of this software and associated documentation files (the "Software"), to deal
-    in the Software without restriction, including without limitation the rights
-    to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
-    copies of the Software, and to permit persons to whom the Software is
-    furnished to do so, subject to the following conditions:
-
-    The above copyright notice and this permission notice shall be included in
-    all copies or substantial portions of the Software.
-
-    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
-    IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
-    FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
-    AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
-    LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
-    OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
-    THE SOFTWARE.
-*/
-
-#define HTS_BUILDING_LIBRARY // Enables HTSLIB_EXPORT, see htslib/hts_defs.h
-#include <config.h>
-#include <strings.h>
-#include <assert.h>
-#include "htslib/hts.h"
-#include "htslib/kstring.h"
-#include "htslib/kseq.h"
-#include "htslib/khash_str2int.h"
-#include "htslib/regidx.h"
-#include "hts_internal.h"
-
-#define MAX_COOR_0 REGIDX_MAX   // CSI and hts_itr_query limit, 0-based
-
-#define iBIN(x) ((x)>>13)
-
-typedef struct
-{
-    hts_pos_t beg, end;
-}
-reg_t;
-
-typedef struct
-{
-    hts_pos_t pos;  // position
-    uint32_t  ireg; // index to reglist.reg and reglist.dat
-}
-pos_t;
-
-typedef struct reglist_t reglist_t;
-
-typedef struct
-{
-    hts_pos_t beg, end; // query region
-    uint32_t ireg;      // index of active region
-    regidx_t *ridx;
-    reglist_t *list;
-    int active;
-}
-itr_t_;
-
-// List of regions for one chromosome.
-struct reglist_t
-{
-    uint32_t *idx, nidx;    // index to list.reg+1
-    uint32_t nreg, mreg;    // n:used, m:allocated
-    reg_t *reg;             // regions
-    uint8_t *dat;           // payload data
-    char *seq;              // sequence name
-    int unsorted;
-};
-
-// Container of all sequences
-struct regidx_t
-{
-    int nseq, mseq;         // n:used, m:alloced
-    reglist_t *seq;         // regions for each sequence
-    void *seq2regs;         // hash for fast lookup from chr name to regions
-    char **seq_names;
-    regidx_free_f free;     // function to free any data allocated by regidx_parse_f
-    regidx_parse_f parse;   // parse one input line
-    void *usr;              // user data to pass to regidx_parse_f
-    int payload_size;
-    void *payload;          // temporary payload data set by regidx_parse_f (sequence is not known beforehand)
-    kstring_t str;
-};
-
-int regidx_seq_nregs(regidx_t *idx, const char *seq)
-{
-    int iseq;
-    if ( khash_str2int_get(idx->seq2regs, seq, &iseq)!=0 ) return 0; // no such sequence
-    return idx->seq[iseq].nreg;
-}
-
-int regidx_nregs(regidx_t *idx)
-{
-    int i, nreg = 0;
-    for (i=0; i<idx->nseq; i++) nreg += idx->seq[i].nreg;
-    return nreg;
-}
-
-char **regidx_seq_names(regidx_t *idx, int *n)
-{
-    *n = idx->nseq;
-    return idx->seq_names;
-}
-
-int regidx_insert_list(regidx_t *idx, char *line, char delim)
-{
-    kstring_t tmp = KS_INITIALIZE;
-    char *ss = line;
-    while ( *ss )
-    {
-        char *se = ss;
-        while ( *se && *se!=delim ) se++;
-        kputsn(ss, se-ss, ks_clear(&tmp));
-        if ( regidx_insert(idx,tmp.s) < 0 )
-        {
-            ks_free(&tmp);
-            return -1;
-        }
-        if ( !*se ) break;
-        ss = se+1;
-    }
-    ks_free(&tmp);
-    return 0;
-}
-
-static inline int cmp_regs(reg_t *a, reg_t *b)
-{
-    if ( a->beg < b->beg ) return -1;
-    if ( a->beg > b->beg ) return 1;
-    if ( a->end < b->end ) return 1;    // longer intervals come first
-    if ( a->end > b->end ) return -1;
-    return 0;
-}
-static int cmp_reg_ptrs(const void *a, const void *b)
-{
-    return cmp_regs((reg_t*)a,(reg_t*)b);
-}
-static int cmp_reg_ptrs2(const void *a, const void *b)
-{
-    return cmp_regs(*((reg_t**)a),*((reg_t**)b));
-}
-
-int regidx_push(regidx_t *idx, char *chr_beg, char *chr_end, hts_pos_t beg, hts_pos_t end, void *payload)
-{
-    if (beg < 0) beg = 0;
-    if (end < 0) end = 0;
-    if ( beg > MAX_COOR_0 ) beg = MAX_COOR_0;
-    if ( end > MAX_COOR_0 ) end = MAX_COOR_0;
-
-    int rid;
-    if (kputsn(chr_beg, chr_end-chr_beg+1, ks_clear(&idx->str)) < 0) return -1;
-    if ( khash_str2int_get(idx->seq2regs, idx->str.s, &rid)!=0 )
-    {
-        // new chromosome
-        int m_tmp = idx->mseq;
-        if (hts_resize(char*, idx->nseq + 1, &m_tmp,
-                       &idx->seq_names, HTS_RESIZE_CLEAR) < 0) {
-            return -1;
-        }
-        if (hts_resize(reglist_t, idx->nseq + 1, &idx->mseq,
-                       &idx->seq, HTS_RESIZE_CLEAR) < 0) {
-            return -1;
-        }
-        assert(m_tmp == idx->mseq);
-        idx->seq_names[idx->nseq] = strdup(idx->str.s);
-        rid = khash_str2int_inc(idx->seq2regs, idx->seq_names[idx->nseq]);
-        idx->nseq++;
-    }
-
-    reglist_t *list = &idx->seq[rid];
-    list->seq = idx->seq_names[rid];
-    int mreg = list->mreg;
-    if (hts_resize(reg_t, list->nreg + 1, &list->mreg, &list->reg, 0) < 0)
-        return -1;
-    list->reg[list->nreg].beg = beg;
-    list->reg[list->nreg].end = end;
-    if ( idx->payload_size ) {
-        if ( mreg != list->mreg ) {
-            uint8_t *new_dat = realloc(list->dat, idx->payload_size*list->mreg);
-            if (!new_dat) return -1;
-            list->dat = new_dat;
-        }
-        memcpy(list->dat + idx->payload_size*list->nreg, payload, idx->payload_size);
-    }
-    list->nreg++;
-    if ( !list->unsorted && list->nreg>1 && cmp_regs(&list->reg[list->nreg-2],&list->reg[list->nreg-1])>0 ) list->unsorted = 1;
-    return 0;
-}
-
-int regidx_insert(regidx_t *idx, char *line)
-{
-    if ( !line ) return 0;
-    char *chr_from, *chr_to;
-    hts_pos_t beg,end;
-    int ret = idx->parse(line,&chr_from,&chr_to,&beg,&end,idx->payload,idx->usr);
-    if ( ret==-2 ) return -1;   // error
-    if ( ret==-1 ) return 0;    // skip the line
-    return regidx_push(idx, chr_from,chr_to,beg,end,idx->payload);
-}
-
-regidx_t *regidx_init_string(const char *str, regidx_parse_f parser, regidx_free_f free_f, size_t payload_size, void *usr_dat)
-{
-    kstring_t tmp = KS_INITIALIZE;
-    regidx_t *idx = (regidx_t*) calloc(1,sizeof(regidx_t));
-    if ( !idx ) return NULL;
-
-    idx->free  = free_f;
-    idx->parse = parser ? parser : regidx_parse_tab;
-    idx->usr   = usr_dat;
-    idx->seq2regs = khash_str2int_init();
-    if (!idx->seq2regs) goto fail;
-    idx->payload_size = payload_size;
-    if ( payload_size ) {
-        idx->payload = malloc(payload_size);
-        if (!idx->payload) goto fail;
-    }
-
-    const char *ss = str;
-    while ( *ss )
-    {
-        while ( *ss && isspace_c(*ss) ) ss++;
-        const char *se = ss;
-        while ( *se && *se!='\r' && *se!='\n' ) se++;
-        if (kputsn(ss, se-ss, ks_clear(&tmp)) < 0) goto fail;
-        if (regidx_insert(idx, tmp.s) < 0) goto fail;
-        while ( *se && isspace_c(*se) ) se++;
-        ss = se;
-    }
-    ks_free(&tmp);
-    return idx;
-
- fail:
-    regidx_destroy(idx);
-    ks_free(&tmp);
-    return NULL;
-}
-
-regidx_t *regidx_init(const char *fname, regidx_parse_f parser, regidx_free_f free_f, size_t payload_size, void *usr_dat)
-{
-    if ( !parser )
-    {
-        if ( !fname ) parser = regidx_parse_tab;
-        else
-        {
-            int len = strlen(fname);
-            if ( len>=7 && !strcasecmp(".bed.gz",fname+len-7) )
-                parser = regidx_parse_bed;
-            else if ( len>=8 && !strcasecmp(".bed.bgz",fname+len-8) )
-                parser = regidx_parse_bed;
-            else if ( len>=4 && !strcasecmp(".bed",fname+len-4) )
-                parser = regidx_parse_bed;
-            else if ( len>=4 && !strcasecmp(".vcf",fname+len-4) )
-                parser = regidx_parse_vcf;
-            else if ( len>=7 && !strcasecmp(".vcf.gz",fname+len-7) )
-                parser = regidx_parse_vcf;
-            else
-                parser = regidx_parse_tab;
-        }
-    }
-
-    kstring_t str = KS_INITIALIZE;
-    htsFile *fp = NULL;
-    int ret;
-    regidx_t *idx = (regidx_t*) calloc(1,sizeof(regidx_t));
-    if (!idx) return NULL;
-    idx->free  = free_f;
-    idx->parse = parser;
-    idx->usr   = usr_dat;
-    idx->seq2regs = khash_str2int_init();
-    if (!idx->seq2regs) goto error;
-    idx->payload_size = payload_size;
-    if ( payload_size ) {
-        idx->payload = malloc(payload_size);
-        if (!idx->payload) goto error;
-    }
-
-    if ( !fname ) return idx;
-
-    fp = hts_open(fname,"r");
-    if ( !fp ) goto error;
-
-    while ((ret = hts_getline(fp, KS_SEP_LINE, &str)) > 0 ) {
-        if ( regidx_insert(idx, str.s) ) goto error;
-    }
-    if (ret < -1) goto error;
-
-    ret = hts_close(fp);
-    fp = NULL;
-    if ( ret != 0 ) {
-        hts_log_error("Close failed .. %s", fname);
-        goto error;
-    }
-    ks_free(&str);
-    return idx;
-
-error:
-    ks_free(&str);
-    if ( fp ) hts_close(fp);
-    regidx_destroy(idx);
-    return NULL;
-}
-
-void regidx_destroy(regidx_t *idx)
-{
-    int i, j;
-    if (!idx) return;
-    for (i=0; i<idx->nseq; i++)
-    {
-        reglist_t *list = &idx->seq[i];
-        if ( idx->free )
-        {
-            for (j=0; j<list->nreg; j++)
-                idx->free((char *)list->dat + idx->payload_size*j);
-        }
-        free(list->dat);
-        free(list->reg);
-        free(list->idx);
-    }
-    free(idx->seq_names);
-    free(idx->seq);
-    free(idx->str.s);
-    free(idx->payload);
-    khash_str2int_destroy_free(idx->seq2regs);
-    free(idx);
-}
-
-static int reglist_build_index_(regidx_t *regidx, reglist_t *list)
-{
-    int i;
-    if ( list->unsorted ) {
-        if ( !regidx->payload_size ) {
-            qsort(list->reg,list->nreg,sizeof(reg_t),cmp_reg_ptrs);
-        } else {
-            reg_t **ptr = malloc(sizeof(*ptr)*list->nreg);
-            if (!ptr) return -1;
-            for (i=0; i<list->nreg; i++) ptr[i] = list->reg + i;
-            qsort(ptr,list->nreg,sizeof(*ptr),cmp_reg_ptrs2);
-
-            uint8_t *tmp_dat = malloc(regidx->payload_size*list->nreg);
-            if (!tmp_dat) { free(ptr); return -1; }
-            for (i=0; i<list->nreg; i++) {
-                size_t iori = ptr[i] - list->reg;
-                memcpy(tmp_dat+i*regidx->payload_size,
-                       list->dat+iori*regidx->payload_size,
-                       regidx->payload_size);
-            }
-            free(list->dat);
-            list->dat = tmp_dat;
-
-            reg_t *tmp_reg = (reg_t*) malloc(sizeof(reg_t)*list->nreg);
-            if (!tmp_reg) { free(ptr); return -1; }
-            for (i=0; i<list->nreg; i++) {
-                size_t iori = ptr[i] - list->reg;
-                tmp_reg[i] = list->reg[iori];
-            }
-            free(ptr);
-            free(list->reg);
-            list->reg  = tmp_reg;
-            list->mreg = list->nreg;
-        }
-        list->unsorted = 0;
-    }
-
-    list->nidx = 0;
-    uint32_t j,k, midx = 0;
-    // Find highest index bin.  It's possible that we could just look at
-    // the last region, but go through the list in case some entries overlap.
-    for (j=0; j<list->nreg; j++) {
-        int iend = iBIN(list->reg[j].end);
-        if (midx <= iend) midx = iend;
-    }
-    midx++;
-    uint32_t *new_idx = calloc(midx, sizeof(uint32_t));
-    if (!new_idx) return -1;
-    free(list->idx); // Should be NULL on entry, but just in case...
-    list->idx = new_idx;
-    list->nidx = midx;
-
-    for (j=0; j<list->nreg; j++) {
-        int ibeg = iBIN(list->reg[j].beg);
-        int iend = iBIN(list->reg[j].end);
-        if ( ibeg==iend ) {
-            if ( !list->idx[ibeg] ) list->idx[ibeg] = j + 1;
-        } else {
-            for (k=ibeg; k<=iend; k++)
-                if ( !list->idx[k] ) list->idx[k] = j + 1;
-        }
-    }
-
-    return 0;
-}
-
-int regidx_overlap(regidx_t *regidx, const char *chr, hts_pos_t beg, hts_pos_t end, regitr_t *regitr)
-{
-    if ( regitr ) regitr->seq = NULL;
-
-    int iseq, ireg;
-    if ( khash_str2int_get(regidx->seq2regs, chr, &iseq)!=0 ) return 0;    // no such sequence
-
-    reglist_t *list = &regidx->seq[iseq];
-    if ( !list->nreg ) return 0;
-
-    if ( list->nreg==1 )
-    {
-        if ( beg > list->reg[0].end ) return 0;
-        if ( end < list->reg[0].beg ) return 0;
-        ireg = 0;
-    }
-    else
-    {
-        if ( !list->idx ) {
-            if (reglist_build_index_(regidx,list) < 0) return -1;
-        }
-
-        int ibeg = iBIN(beg);
-        if ( ibeg >= list->nidx ) return 0;     // beg is too big
-
-        // find a matching region
-        uint32_t i = list->idx[ibeg];
-        if ( !i )
-        {
-            int iend = iBIN(end);
-            if ( iend > list->nidx ) iend = list->nidx;
-            for (i=ibeg; i<=iend; i++)
-                if ( list->idx[i] ) break;
-            if ( i>iend ) return 0;
-            i = list->idx[i];
-        }
-        for (ireg=i-1; ireg<list->nreg; ireg++)
-        {
-            if ( list->reg[ireg].beg > end ) return 0;   // no match, past the query region
-            if ( list->reg[ireg].end >= beg && list->reg[ireg].beg <= end ) break; // found
-        }
-
-        if ( ireg >= list->nreg ) return 0;   // no match
-    }
-
-    if ( !regitr ) return 1;    // match, but no more info to save
-
-    // may need to iterate over the matching regions later
-    itr_t_ *itr = (itr_t_*)regitr->itr;
-    itr->ridx = regidx;
-    itr->list = list;
-    itr->beg  = beg;
-    itr->end  = end;
-    itr->ireg = ireg;
-    itr->active = 0;
-
-    regitr->seq = list->seq;
-    regitr->beg = list->reg[ireg].beg;
-    regitr->end = list->reg[ireg].end;
-    if ( regidx->payload_size )
-        regitr->payload = list->dat + regidx->payload_size*ireg;
-
-    return 1;
-}
-
-int regidx_parse_bed(const char *line, char **chr_beg, char **chr_end, hts_pos_t *beg, hts_pos_t *end, void *payload, void *usr)
-{
-    char *ss = (char*) line;
-    while ( *ss && isspace_c(*ss) ) ss++;
-    if ( !*ss ) return -1;      // skip blank lines
-    if ( *ss=='#' ) return -1;  // skip comments
-
-    char *se = ss;
-    while ( *se && !isspace_c(*se) ) se++;
-
-    *chr_beg = ss;
-    *chr_end = se-1;
-
-    if ( !*se )
-    {
-        // just the chromosome name
-        *beg = 0;
-        *end = MAX_COOR_0;
-        return 0;
-    }
-
-    ss = se+1;
-    *beg = hts_parse_decimal(ss, &se, 0);
-    if ( ss==se ) { hts_log_error("Could not parse bed line: %s", line); return -2; }
-
-    ss = se+1;
-    *end = hts_parse_decimal(ss, &se, 0) - 1;
-    if ( ss==se ) { hts_log_error("Could not parse bed line: %s", line); return -2; }
-
-    return 0;
-}
-
-int regidx_parse_tab(const char *line, char **chr_beg, char **chr_end, hts_pos_t *beg, hts_pos_t *end, void *payload, void *usr)
-{
-    char *ss = (char*) line;
-    while ( *ss && isspace_c(*ss) ) ss++;
-    if ( !*ss ) return -1;      // skip blank lines
-    if ( *ss=='#' ) return -1;  // skip comments
-
-    char *se = ss;
-    while ( *se && !isspace_c(*se) ) se++;
-
-    *chr_beg = ss;
-    *chr_end = se-1;
-
-    if ( !*se )
-    {
-        // just the chromosome name
-        *beg = 0;
-        *end = MAX_COOR_0;
-        return 0;
-    }
-
-    ss = se+1;
-    *beg = hts_parse_decimal(ss, &se, 0);
-    if ( ss==se ) { hts_log_error("Could not parse tab line: %s", line); return -2; }
-    if ( *beg==0 ) { hts_log_error("Could not parse tab line, expected 1-based coordinate: %s", line); return -2; }
-    (*beg)--;
-
-    if ( !se[0] || !se[1] )
-        *end = *beg;
-    else
-    {
-        ss = se+1;
-        *end = hts_parse_decimal(ss, &se, 0);
-        if ( ss==se || (*se && !isspace_c(*se)) ) *end = *beg;
-        else if ( *end==0 ) { hts_log_error("Could not parse tab line, expected 1-based coordinate: %s", line); return -2; }
-        else (*end)--;
-    }
-    return 0;
-}
-
-int regidx_parse_vcf(const char *line, char **chr_beg, char **chr_end, hts_pos_t *beg, hts_pos_t *end, void *payload, void *usr)
-{
-    int ret = regidx_parse_tab(line, chr_beg, chr_end, beg, end, payload, usr);
-    if ( !ret ) *end = *beg;
-    return ret;
-}
-
-int regidx_parse_reg(const char *line, char **chr_beg, char **chr_end, hts_pos_t *beg, hts_pos_t *end, void *payload, void *usr)
-{
-    char *ss = (char*) line;
-    while ( *ss && isspace_c(*ss) ) ss++;
-    if ( !*ss ) return -1;      // skip blank lines
-    if ( *ss=='#' ) return -1;  // skip comments
-
-    char *se = ss;
-    while ( *se && *se!=':' ) se++;
-
-    *chr_beg = ss;
-    *chr_end = se-1;
-
-    if ( !*se )
-    {
-        *beg = 0;
-        *end = MAX_COOR_0;
-        return 0;
-    }
-
-    ss = se+1;
-    *beg = hts_parse_decimal(ss, &se, 0);
-    if ( ss==se ) { hts_log_error("Could not parse reg line: %s", line); return -2; }
-    if ( *beg==0 ) { hts_log_error("Could not parse reg line, expected 1-based coordinate: %s", line); return -2; }
-    (*beg)--;
-
-    if ( !se[0] || !se[1] )
-        *end = se[0]=='-' ? MAX_COOR_0 : *beg;
-    else
-    {
-        ss = se+1;
-        *end = hts_parse_decimal(ss, &se, 0);
-        if ( ss==se ) *end = *beg;
-        else if ( *end==0 ) { hts_log_error("Could not parse reg line, expected 1-based coordinate: %s", line); return -2; }
-        else (*end)--;
-    }
-    return 0;
-}
-
-regitr_t *regitr_init(regidx_t *regidx)
-{
-    regitr_t *regitr = (regitr_t*) calloc(1,sizeof(regitr_t));
-    if (!regitr) return NULL;
-    regitr->itr  = (itr_t_*) calloc(1,sizeof(itr_t_));
-    if (!regitr->itr) {
-        free(regitr);
-        return NULL;
-    }
-    itr_t_ *itr = (itr_t_*) regitr->itr;
-    itr->ridx = regidx;
-    itr->list = NULL;
-    return regitr;
-}
-
-void regitr_reset(regidx_t *regidx, regitr_t *regitr)
-{
-    itr_t_ *itr = (itr_t_*) regitr->itr;
-    memset(itr,0,sizeof(itr_t_));
-    itr->ridx = regidx;
-}
-
-void regitr_destroy(regitr_t *regitr)
-{
-    free(regitr->itr);
-    free(regitr);
-}
-
-int regitr_overlap(regitr_t *regitr)
-{
-    if ( !regitr || !regitr->seq || !regitr->itr ) return 0;
-
-    itr_t_ *itr = (itr_t_*) regitr->itr;
-    if ( !itr->active )
-    {
-        // is this the first call after regidx_overlap?
-        itr->active = 1;
-        itr->ireg++;
-        return 1;
-    }
-
-    reglist_t *list = itr->list;
-
-    int i;
-    for (i=itr->ireg; i<list->nreg; i++)
-    {
-        if ( list->reg[i].beg > itr->end ) return 0;   // no match, past the query region
-        if ( list->reg[i].end >= itr->beg && list->reg[i].beg <= itr->end ) break; // found
-    }
-
-    if ( i >= list->nreg ) return 0;   // no match
-
-    itr->ireg = i + 1;
-    regitr->seq = list->seq;
-    regitr->beg = list->reg[i].beg;
-    regitr->end = list->reg[i].end;
-    if ( itr->ridx->payload_size )
-        regitr->payload = (char *)list->dat + itr->ridx->payload_size*i;
-
-    return 1;
-}
-
-int regitr_loop(regitr_t *regitr)
-{
-    if ( !regitr || !regitr->itr ) return 0;
-
-    itr_t_ *itr = (itr_t_*) regitr->itr;
-    regidx_t *regidx = itr->ridx;
-
-    if ( !itr->list )    // first time here
-    {
-        itr->list = regidx->seq;
-        itr->ireg = 0;
-    }
-
-    size_t iseq = itr->list - regidx->seq;
-    if ( iseq >= regidx->nseq ) return 0;
-
-    if ( itr->ireg >= itr->list->nreg )
-    {
-        iseq++;
-        if ( iseq >= regidx->nseq ) return 0; // no more sequences, done
-        itr->ireg = 0;
-        itr->list = &regidx->seq[iseq];
-    }
-
-    regitr->seq = itr->list->seq;
-    regitr->beg = itr->list->reg[itr->ireg].beg;
-    regitr->end = itr->list->reg[itr->ireg].end;
-    if ( regidx->payload_size )
-        regitr->payload = (char *)itr->list->dat + regidx->payload_size*itr->ireg;
-    itr->ireg++;
-
-    return 1;
-}
-
-
-void regitr_copy(regitr_t *dst, regitr_t *src)
-{
-    itr_t_ *dst_itr = (itr_t_*) dst->itr;
-    itr_t_ *src_itr = (itr_t_*) src->itr;
-    *dst_itr = *src_itr;
-    *dst = *src;
-    dst->itr = dst_itr;
-}
diff -ruN stringtie.orig/htslib/region.c stringtie/htslib/region.c
--- stringtie.orig/htslib/region.c	2024-02-28 13:57:39.701246126 +0100
+++ stringtie/htslib/region.c	1970-01-01 01:00:00.000000000 +0100
@@ -1,276 +0,0 @@
-/*  region.c -- Functions to create and free region lists
-
-    Copyright (C) 2019 Genome Research Ltd.
-
-    Author: Valeriu Ohan <vo2@sanger.ac.uk>
-
-Permission is hereby granted, free of charge, to any person obtaining a copy
-of this software and associated documentation files (the "Software"), to deal
-in the Software without restriction, including without limitation the rights
-to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
-copies of the Software, and to permit persons to whom the Software is
-furnished to do so, subject to the following conditions:
-
-The above copyright notice and this permission notice shall be included in
-all copies or substantial portions of the Software.
-
-THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
-IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
-FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
-THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
-LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
-FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
-DEALINGS IN THE SOFTWARE.  */
-
-#define HTS_BUILDING_LIBRARY // Enables HTSLIB_EXPORT, see htslib/hts_defs.h
-#include <config.h>
-
-#include "htslib/hts.h"
-#include "htslib/khash.h"
-
-typedef struct reglist
-{
-    uint32_t n, m;
-    hts_pair_pos_t *a;
-    int tid;
-} reglist_t;
-
-KHASH_MAP_INIT_INT(reg, reglist_t)
-typedef kh_reg_t reghash_t;
-
-static int compare_hts_pair_pos_t (const void *av, const void *bv)
-{
-    hts_pair_pos_t *a = (hts_pair_pos_t *) av;
-    hts_pair_pos_t *b = (hts_pair_pos_t *) bv;
-    if (a->beg < b->beg) return -1;
-    if (a->beg > b->beg) return  1;
-    if (a->end < b->end) return -1;
-    if (a->end > b->end) return  1;
-
-    return 0;
-}
-
-#if 0
-/**
- * Good to have around for debugging
- */
-static void reg_print(reghash_t *h) {
-    reglist_t *p;
-    khint_t k;
-    uint32_t i;
-    khint32_t key;
-
-    if (!h) {
-        fprintf(stderr, "Hash table is empty!\n");
-        return;
-    }
-    for (k = kh_begin(h); k < kh_end(h); k++) {
-        if (kh_exist(h,k)) {
-            key = kh_key(h,k);
-            fprintf(stderr, "Region: key %u tid %d\n", key, p->tid);
-            if ((p = &kh_val(h,k)) != NULL && p->n > 0) {
-                for (i=0; i<p->n; i++) {
-                    fprintf(stderr, "\tinterval[%d]: %"PRIhts_pos"-%"PRIhts_pos"\n", i,
-                            p->a[i].beg, p->a[i].end);
-                }
-            } else {
-                fprintf(stderr, "Region key %u has no intervals!\n", key);
-            }
-        }
-    }
-}
-#endif
-
-/**
- * Sort and merge overlapping or adjacent intervals.
- */
-static int reg_compact(reghash_t *h) {
-    khint_t i;
-    uint32_t j, new_n;
-    reglist_t *p;
-    int count = 0;
-
-    if (!h)
-        return 0;
-
-    for (i = kh_begin(h); i < kh_end(h); i++) {
-        if (!kh_exist(h,i) || !(p = &kh_val(h,i)) || !(p->n))
-            continue;
-
-        qsort(p->a, p->n, sizeof(p->a[0]), compare_hts_pair_pos_t);
-        for (new_n = 0, j = 1; j < p->n; j++) {
-            if (p->a[new_n].end < p->a[j].beg) {
-                p->a[++new_n].beg = p->a[j].beg;
-                p->a[new_n].end = p->a[j].end;
-            } else {
-                if (p->a[new_n].end < p->a[j].end)
-                    p->a[new_n].end = p->a[j].end;
-            }
-        }
-        ++new_n;
-        if (p->n > new_n) {
-            // Shrink array to required size.
-            hts_pair_pos_t *new_a = realloc(p->a, new_n * sizeof(p->a[0]));
-            if (new_a) p->a = new_a;
-        }
-        p->n = new_n;
-        count++;
-    }
-
-    return count;
-}
-
-static int reg_insert(reghash_t *h, int tid, hts_pos_t beg, hts_pos_t end) {
-
-    khint_t k;
-    reglist_t *p;
-
-    if (!h)
-        return -1;
-
-    // Put reg in the hash table if not already there
-    k = kh_get(reg, h, tid);
-    if (k == kh_end(h)) { // absent from the hash table
-        int ret;
-        k = kh_put(reg, h, tid, &ret);
-        if (-1 == ret) {
-            return -1;
-        }
-        memset(&kh_val(h, k), 0, sizeof(reglist_t));
-        kh_val(h, k).tid = tid;
-    }
-    p = &kh_val(h, k);
-
-    // Add beg and end to the list
-    if (p->n == p->m) {
-        uint32_t new_m = p->m ? p->m<<1 : 4;
-        if (new_m == 0) return -1;
-        hts_pair_pos_t *new_a = realloc(p->a, new_m * sizeof(p->a[0]));
-        if (new_a == NULL) return -1;
-        p->m = new_m;
-        p->a = new_a;
-    }
-    p->a[p->n].beg = beg;
-    p->a[p->n++].end = end;
-
-    return 0;
-}
-
-static void reg_destroy(reghash_t *h) {
-
-    khint_t k;
-
-    if (!h)
-        return;
-
-    for (k = 0; k < kh_end(h); ++k) {
-        if (kh_exist(h, k)) {
-            free(kh_val(h, k).a);
-        }
-    }
-    kh_destroy(reg, h);
-}
-
-/**
- * Take a char array of reg:interval elements and produce a hts_reglis_t with r_count elements.
- */
-hts_reglist_t *hts_reglist_create(char **argv, int argc, int *r_count, void *hdr,  hts_name2id_f getid) {
-
-    if (!argv || argc < 1)
-        return NULL;
-
-    reghash_t *h = NULL;
-    reglist_t *p;
-    hts_reglist_t *h_reglist = NULL;
-
-    khint_t k;
-    int i, l_count = 0, tid;
-    const char *q;
-    hts_pos_t beg, end;
-
-    /* First, transform the char array into a hash table */
-    h = kh_init(reg);
-    if (!h) {
-        hts_log_error("Error when creating the region hash table");
-        return NULL;
-    }
-
-    for (i=0; i<argc; i++) {
-        if (!strcmp(argv[i], ".")) {
-            q = argv[i] + 1;
-            tid = HTS_IDX_START; beg = 0; end = INT64_MAX;
-        } else if (!strcmp(argv[i], "*")) {
-            q = argv[i] + 1;
-            tid = HTS_IDX_NOCOOR; beg = 0; end = INT64_MAX;
-        } else {
-            q = hts_parse_region(argv[i], &tid, &beg, &end, getid, hdr,
-                                 HTS_PARSE_THOUSANDS_SEP);
-        }
-        if (!q) {
-            if (tid < -1) {
-                hts_log_error("Failed to parse header");
-                goto fail;
-            } else {
-                // not parsable as a region
-                hts_log_warning("Region '%s' specifies an unknown reference name. Continue anyway", argv[i]);
-                continue;
-            }
-        }
-
-        if (reg_insert(h, tid, beg, end) != 0) {
-            hts_log_error("Error when inserting region='%s' in the bed hash table at address=%p", argv[i], (void *) h);
-            goto fail;
-        }
-    }
-
-    *r_count = reg_compact(h);
-    if (!*r_count)
-        goto fail;
-
-    /* Transform the hash table into a list */
-    h_reglist = (hts_reglist_t *)calloc(*r_count, sizeof(hts_reglist_t));
-    if (!h_reglist)
-        goto fail;
-
-    for (k = kh_begin(h); k < kh_end(h) && l_count < *r_count; k++) {
-        if (!kh_exist(h,k) || !(p = &kh_val(h,k)))
-            continue;
-
-        h_reglist[l_count].tid = p->tid;
-        h_reglist[l_count].intervals = p->a;
-        h_reglist[l_count].count = p->n;
-        p->a = NULL; // As we stole it.
-
-        // After reg_compact(), list is ordered and non-overlapping, so...
-        if (p->n > 0) {
-            h_reglist[l_count].min_beg = h_reglist[l_count].intervals[0].beg;
-            h_reglist[l_count].max_end = h_reglist[l_count].intervals[p->n - 1].end;
-        } else {
-            h_reglist[l_count].min_beg = 0;
-            h_reglist[l_count].max_end = 0;
-        }
-
-        l_count++;
-    }
-    reg_destroy(h);
-
-    return h_reglist;
-
-fail:
-    reg_destroy(h);
-    if(h_reglist) hts_reglist_free(h_reglist, l_count);
-
-    return NULL;
-}
-
-void hts_reglist_free(hts_reglist_t *reglist, int count) {
-
-    int i;
-    if(reglist) {
-        for (i = 0; i < count; i++) {
-            if (reglist[i].intervals)
-                free(reglist[i].intervals);
-        }
-        free(reglist);
-    }
-}
diff -ruN stringtie.orig/htslib/sam.c stringtie/htslib/sam.c
--- stringtie.orig/htslib/sam.c	2024-02-28 13:57:39.701246126 +0100
+++ stringtie/htslib/sam.c	1970-01-01 01:00:00.000000000 +0100
@@ -1,5308 +0,0 @@
-/*  sam.c -- SAM and BAM file I/O and manipulation.
-
-    Copyright (C) 2008-2010, 2012-2021 Genome Research Ltd.
-    Copyright (C) 2010, 2012, 2013 Broad Institute.
-
-    Author: Heng Li <lh3@sanger.ac.uk>
-
-Permission is hereby granted, free of charge, to any person obtaining a copy
-of this software and associated documentation files (the "Software"), to deal
-in the Software without restriction, including without limitation the rights
-to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
-copies of the Software, and to permit persons to whom the Software is
-furnished to do so, subject to the following conditions:
-
-The above copyright notice and this permission notice shall be included in
-all copies or substantial portions of the Software.
-
-THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
-IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
-FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
-THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
-LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
-FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
-DEALINGS IN THE SOFTWARE.  */
-
-#define HTS_BUILDING_LIBRARY // Enables HTSLIB_EXPORT, see htslib/hts_defs.h
-#include <config.h>
-
-#include <strings.h>
-#include <stdio.h>
-#include <stdlib.h>
-#include <string.h>
-#include <errno.h>
-#include <zlib.h>
-#include <assert.h>
-#include <signal.h>
-#include <inttypes.h>
-#include <unistd.h>
-
-// Suppress deprecation message for cigar_tab, which we initialise
-#include "htslib/hts_defs.h"
-#undef HTS_DEPRECATED
-#define HTS_DEPRECATED(message)
-
-#include "htslib/sam.h"
-#include "htslib/bgzf.h"
-#include "cram/cram.h"
-#include "hts_internal.h"
-#include "sam_internal.h"
-#include "htslib/hfile.h"
-#include "htslib/hts_endian.h"
-#include "htslib/hts_expr.h"
-#include "header.h"
-
-#include "htslib/khash.h"
-KHASH_DECLARE(s2i, kh_cstr_t, int64_t)
-
-#ifndef EFTYPE
-#define EFTYPE ENOEXEC
-#endif
-#ifndef EOVERFLOW
-#define EOVERFLOW ERANGE
-#endif
-
-/**********************
- *** BAM header I/O ***
- **********************/
-
-HTSLIB_EXPORT
-const int8_t bam_cigar_table[256] = {
-    // 0 .. 47
-    -1, -1, -1, -1,  -1, -1, -1, -1,  -1, -1, -1, -1,  -1, -1, -1, -1,
-    -1, -1, -1, -1,  -1, -1, -1, -1,  -1, -1, -1, -1,  -1, -1, -1, -1,
-    -1, -1, -1, -1,  -1, -1, -1, -1,  -1, -1, -1, -1,  -1, -1, -1, -1,
-
-    // 48 .. 63  (including =)
-    -1, -1, -1, -1,  -1, -1, -1, -1,  -1, -1, -1, -1,  -1, BAM_CEQUAL, -1, -1,
-
-    // 64 .. 79  (including MIDNHB)
-    -1, -1, BAM_CBACK, -1,  BAM_CDEL, -1, -1, -1,
-        BAM_CHARD_CLIP, BAM_CINS, -1, -1,  -1, BAM_CMATCH, BAM_CREF_SKIP, -1,
-
-    // 80 .. 95  (including SPX)
-    BAM_CPAD, -1, -1, BAM_CSOFT_CLIP,  -1, -1, -1, -1,
-        BAM_CDIFF, -1, -1, -1,  -1, -1, -1, -1,
-
-    // 96 .. 127
-    -1, -1, -1, -1,  -1, -1, -1, -1,  -1, -1, -1, -1,  -1, -1, -1, -1,
-    -1, -1, -1, -1,  -1, -1, -1, -1,  -1, -1, -1, -1,  -1, -1, -1, -1,
-
-    // 128 .. 255
-    -1, -1, -1, -1,  -1, -1, -1, -1,  -1, -1, -1, -1,  -1, -1, -1, -1,
-    -1, -1, -1, -1,  -1, -1, -1, -1,  -1, -1, -1, -1,  -1, -1, -1, -1,
-    -1, -1, -1, -1,  -1, -1, -1, -1,  -1, -1, -1, -1,  -1, -1, -1, -1,
-    -1, -1, -1, -1,  -1, -1, -1, -1,  -1, -1, -1, -1,  -1, -1, -1, -1,
-    -1, -1, -1, -1,  -1, -1, -1, -1,  -1, -1, -1, -1,  -1, -1, -1, -1,
-    -1, -1, -1, -1,  -1, -1, -1, -1,  -1, -1, -1, -1,  -1, -1, -1, -1,
-    -1, -1, -1, -1,  -1, -1, -1, -1,  -1, -1, -1, -1,  -1, -1, -1, -1,
-    -1, -1, -1, -1,  -1, -1, -1, -1,  -1, -1, -1, -1,  -1, -1, -1, -1
-};
-
-sam_hdr_t *sam_hdr_init()
-{
-    sam_hdr_t *bh = (sam_hdr_t*)calloc(1, sizeof(sam_hdr_t));
-    if (bh == NULL) return NULL;
-
-    bh->cigar_tab = bam_cigar_table;
-    return bh;
-}
-
-void sam_hdr_destroy(sam_hdr_t *bh)
-{
-    int32_t i;
-
-    if (bh == NULL) return;
-
-    if (bh->ref_count > 0) {
-        --bh->ref_count;
-        return;
-    }
-
-    if (bh->target_name) {
-        for (i = 0; i < bh->n_targets; ++i)
-            free(bh->target_name[i]);
-        free(bh->target_name);
-        free(bh->target_len);
-    }
-    free(bh->text);
-    if (bh->hrecs)
-        sam_hrecs_free(bh->hrecs);
-    if (bh->sdict)
-        kh_destroy(s2i, (khash_t(s2i) *) bh->sdict);
-    free(bh);
-}
-
-// Copy the sam_hdr_t::sdict hash, used to store the real lengths of long
-// references before sam_hdr_t::hrecs is populated
-int sam_hdr_dup_sdict(const sam_hdr_t *h0, sam_hdr_t *h)
-{
-    const khash_t(s2i) *src_long_refs = (khash_t(s2i) *) h0->sdict;
-    khash_t(s2i) *dest_long_refs = kh_init(s2i);
-    int i;
-    if (!dest_long_refs) return -1;
-
-    for (i = 0; i < h->n_targets; i++) {
-        int ret;
-        khiter_t ksrc, kdest;
-        if (h->target_len[i] < UINT32_MAX) continue;
-        ksrc = kh_get(s2i, src_long_refs, h->target_name[i]);
-        if (ksrc == kh_end(src_long_refs)) continue;
-        kdest = kh_put(s2i, dest_long_refs, h->target_name[i], &ret);
-        if (ret < 0) {
-            kh_destroy(s2i, dest_long_refs);
-            return -1;
-        }
-        kh_val(dest_long_refs, kdest) = kh_val(src_long_refs, ksrc);
-    }
-
-    h->sdict = dest_long_refs;
-    return 0;
-}
-
-sam_hdr_t *sam_hdr_dup(const sam_hdr_t *h0)
-{
-    if (h0 == NULL) return NULL;
-    sam_hdr_t *h;
-    if ((h = sam_hdr_init()) == NULL) return NULL;
-    // copy the simple data
-    h->n_targets = 0;
-    h->ignore_sam_err = h0->ignore_sam_err;
-    h->l_text = 0;
-
-    // Then the pointery stuff
-
-    if (!h0->hrecs) {
-        h->target_len = (uint32_t*)calloc(h0->n_targets, sizeof(uint32_t));
-        if (!h->target_len) goto fail;
-        h->target_name = (char**)calloc(h0->n_targets, sizeof(char*));
-        if (!h->target_name) goto fail;
-
-        int i;
-        for (i = 0; i < h0->n_targets; ++i) {
-            h->target_len[i] = h0->target_len[i];
-            h->target_name[i] = strdup(h0->target_name[i]);
-            if (!h->target_name[i]) break;
-        }
-        h->n_targets = i;
-        if (i < h0->n_targets) goto fail;
-
-        if (h0->sdict) {
-            if (sam_hdr_dup_sdict(h0, h) < 0) goto fail;
-        }
-    }
-
-    if (h0->hrecs) {
-        kstring_t tmp = { 0, 0, NULL };
-        if (sam_hrecs_rebuild_text(h0->hrecs, &tmp) != 0) {
-            free(ks_release(&tmp));
-            goto fail;
-        }
-
-        h->l_text = tmp.l;
-        h->text   = ks_release(&tmp);
-
-        if (sam_hdr_update_target_arrays(h, h0->hrecs, 0) != 0)
-            goto fail;
-    } else {
-        h->l_text = h0->l_text;
-        h->text = malloc(h->l_text + 1);
-        if (!h->text) goto fail;
-        memcpy(h->text, h0->text, h->l_text);
-        h->text[h->l_text] = '\0';
-    }
-
-    return h;
-
- fail:
-    sam_hdr_destroy(h);
-    return NULL;
-}
-
-sam_hdr_t *bam_hdr_read(BGZF *fp)
-{
-    sam_hdr_t *h;
-    uint8_t buf[4];
-    int magic_len, has_EOF;
-    int32_t i, name_len, num_names = 0;
-    size_t bufsize;
-    ssize_t bytes;
-    // check EOF
-    has_EOF = bgzf_check_EOF(fp);
-    if (has_EOF < 0) {
-        perror("[W::bam_hdr_read] bgzf_check_EOF");
-    } else if (has_EOF == 0) {
-        hts_log_warning("EOF marker is absent. The input is probably truncated");
-    }
-    // read "BAM1"
-    magic_len = bgzf_read(fp, buf, 4);
-    if (magic_len != 4 || memcmp(buf, "BAM\1", 4)) {
-        hts_log_error("Invalid BAM binary header");
-        return 0;
-    }
-    h = sam_hdr_init();
-    if (!h) goto nomem;
-
-    // read plain text and the number of reference sequences
-    bytes = bgzf_read(fp, buf, 4);
-    if (bytes != 4) goto read_err;
-    h->l_text = le_to_u32(buf);
-
-    bufsize = h->l_text + 1;
-    if (bufsize < h->l_text) goto nomem; // so large that adding 1 overflowed
-    h->text = (char*)malloc(bufsize);
-    if (!h->text) goto nomem;
-    h->text[h->l_text] = 0; // make sure it is NULL terminated
-    bytes = bgzf_read(fp, h->text, h->l_text);
-    if (bytes != h->l_text) goto read_err;
-
-    bytes = bgzf_read(fp, &h->n_targets, 4);
-    if (bytes != 4) goto read_err;
-    if (fp->is_be) ed_swap_4p(&h->n_targets);
-
-    if (h->n_targets < 0) goto invalid;
-
-    // read reference sequence names and lengths
-    if (h->n_targets > 0) {
-        h->target_name = (char**)calloc(h->n_targets, sizeof(char*));
-        if (!h->target_name) goto nomem;
-        h->target_len = (uint32_t*)calloc(h->n_targets, sizeof(uint32_t));
-        if (!h->target_len) goto nomem;
-    }
-    else {
-        h->target_name = NULL;
-        h->target_len = NULL;
-    }
-
-    for (i = 0; i != h->n_targets; ++i) {
-        bytes = bgzf_read(fp, &name_len, 4);
-        if (bytes != 4) goto read_err;
-        if (fp->is_be) ed_swap_4p(&name_len);
-        if (name_len <= 0) goto invalid;
-
-        h->target_name[i] = (char*)malloc(name_len);
-        if (!h->target_name[i]) goto nomem;
-        num_names++;
-
-        bytes = bgzf_read(fp, h->target_name[i], name_len);
-        if (bytes != name_len) goto read_err;
-
-        if (h->target_name[i][name_len - 1] != '\0') {
-            /* Fix missing NUL-termination.  Is this being too nice?
-               We could alternatively bail out with an error. */
-            char *new_name;
-            if (name_len == INT32_MAX) goto invalid;
-            new_name = realloc(h->target_name[i], name_len + 1);
-            if (new_name == NULL) goto nomem;
-            h->target_name[i] = new_name;
-            h->target_name[i][name_len] = '\0';
-        }
-
-        bytes = bgzf_read(fp, &h->target_len[i], 4);
-        if (bytes != 4) goto read_err;
-        if (fp->is_be) ed_swap_4p(&h->target_len[i]);
-    }
-    return h;
-
- nomem:
-    hts_log_error("Out of memory");
-    goto clean;
-
- read_err:
-    if (bytes < 0) {
-        hts_log_error("Error reading BGZF stream");
-    } else {
-        hts_log_error("Truncated BAM header");
-    }
-    goto clean;
-
- invalid:
-    hts_log_error("Invalid BAM binary header");
-
- clean:
-    if (h != NULL) {
-        h->n_targets = num_names; // ensure we free only allocated target_names
-        sam_hdr_destroy(h);
-    }
-    return NULL;
-}
-
-int bam_hdr_write(BGZF *fp, const sam_hdr_t *h)
-{
-    int32_t i, name_len, x;
-    kstring_t hdr_ks = { 0, 0, NULL };
-    char *text;
-    uint32_t l_text;
-
-    if (!h) return -1;
-
-    if (h->hrecs) {
-        if (sam_hrecs_rebuild_text(h->hrecs, &hdr_ks) != 0) return -1;
-        if (hdr_ks.l > INT32_MAX) {
-            hts_log_error("Header too long for BAM format");
-            free(hdr_ks.s);
-            return -1;
-        }
-        text = hdr_ks.s;
-        l_text = hdr_ks.l;
-    } else {
-        if (h->l_text > INT32_MAX) {
-            hts_log_error("Header too long for BAM format");
-            return -1;
-        }
-        text = h->text;
-        l_text = h->l_text;
-    }
-    // write "BAM1"
-    if (bgzf_write(fp, "BAM\1", 4) < 0) { free(hdr_ks.s); return -1; }
-    // write plain text and the number of reference sequences
-    if (fp->is_be) {
-        x = ed_swap_4(l_text);
-        if (bgzf_write(fp, &x, 4) < 0) { free(hdr_ks.s); return -1; }
-        if (l_text) {
-            if (bgzf_write(fp, text, l_text) < 0) { free(hdr_ks.s); return -1; }
-        }
-        x = ed_swap_4(h->n_targets);
-        if (bgzf_write(fp, &x, 4) < 0) { free(hdr_ks.s); return -1; }
-    } else {
-        if (bgzf_write(fp, &l_text, 4) < 0) { free(hdr_ks.s); return -1; }
-        if (l_text) {
-            if (bgzf_write(fp, text, l_text) < 0) { free(hdr_ks.s); return -1; }
-        }
-        if (bgzf_write(fp, &h->n_targets, 4) < 0) { free(hdr_ks.s); return -1; }
-    }
-    free(hdr_ks.s);
-    // write sequence names and lengths
-    for (i = 0; i != h->n_targets; ++i) {
-        char *p = h->target_name[i];
-        name_len = strlen(p) + 1;
-        if (fp->is_be) {
-            x = ed_swap_4(name_len);
-            if (bgzf_write(fp, &x, 4) < 0) return -1;
-        } else {
-            if (bgzf_write(fp, &name_len, 4) < 0) return -1;
-        }
-        if (bgzf_write(fp, p, name_len) < 0) return -1;
-        if (fp->is_be) {
-            x = ed_swap_4(h->target_len[i]);
-            if (bgzf_write(fp, &x, 4) < 0) return -1;
-        } else {
-            if (bgzf_write(fp, &h->target_len[i], 4) < 0) return -1;
-        }
-    }
-    if (bgzf_flush(fp) < 0) return -1;
-    return 0;
-}
-
-const char *sam_parse_region(sam_hdr_t *h, const char *s, int *tid,
-                             hts_pos_t *beg, hts_pos_t *end, int flags) {
-    return hts_parse_region(s, tid, beg, end, (hts_name2id_f)bam_name2id, h, flags);
-}
-
-/*************************
- *** BAM alignment I/O ***
- *************************/
-
-bam1_t *bam_init1()
-{
-    return (bam1_t*)calloc(1, sizeof(bam1_t));
-}
-
-int sam_realloc_bam_data(bam1_t *b, size_t desired)
-{
-    uint32_t new_m_data;
-    uint8_t *new_data;
-    new_m_data = desired;
-    kroundup32(new_m_data);
-    if (new_m_data < desired) {
-        errno = ENOMEM; // Not strictly true but we can't store the size
-        return -1;
-    }
-    if ((bam_get_mempolicy(b) & BAM_USER_OWNS_DATA) == 0) {
-        new_data = realloc(b->data, new_m_data);
-    } else {
-        if ((new_data = malloc(new_m_data)) != NULL) {
-            if (b->l_data > 0)
-                memcpy(new_data, b->data,
-                       b->l_data < b->m_data ? b->l_data : b->m_data);
-            bam_set_mempolicy(b, bam_get_mempolicy(b) & (~BAM_USER_OWNS_DATA));
-        }
-    }
-    if (!new_data) return -1;
-    b->data = new_data;
-    b->m_data = new_m_data;
-    return 0;
-}
-
-void bam_destroy1(bam1_t *b)
-{
-    if (b == 0) return;
-    if ((bam_get_mempolicy(b) & BAM_USER_OWNS_DATA) == 0) {
-        free(b->data);
-        if ((bam_get_mempolicy(b) & BAM_USER_OWNS_STRUCT) != 0) {
-            // In case of reuse
-            b->data = NULL;
-            b->m_data = 0;
-            b->l_data = 0;
-        }
-    }
-
-    if ((bam_get_mempolicy(b) & BAM_USER_OWNS_STRUCT) == 0)
-        free(b);
-}
-
-bam1_t *bam_copy1(bam1_t *bdst, const bam1_t *bsrc)
-{
-    if (realloc_bam_data(bdst, bsrc->l_data) < 0) return NULL;
-    memcpy(bdst->data, bsrc->data, bsrc->l_data); // copy var-len data
-    memcpy(&bdst->core, &bsrc->core, sizeof(bsrc->core)); // copy the rest
-    bdst->l_data = bsrc->l_data;
-    bdst->id = bsrc->id;
-    return bdst;
-}
-
-bam1_t *bam_dup1(const bam1_t *bsrc)
-{
-    if (bsrc == NULL) return NULL;
-    bam1_t *bdst = bam_init1();
-    if (bdst == NULL) return NULL;
-    if (bam_copy1(bdst, bsrc) == NULL) {
-        bam_destroy1(bdst);
-        return NULL;
-    }
-    return bdst;
-}
-
-static void bam_cigar2rqlens(int n_cigar, const uint32_t *cigar,
-                             hts_pos_t *rlen, hts_pos_t *qlen)
-{
-    int k;
-    *rlen = *qlen = 0;
-    for (k = 0; k < n_cigar; ++k) {
-        int type = bam_cigar_type(bam_cigar_op(cigar[k]));
-        int len = bam_cigar_oplen(cigar[k]);
-        if (type & 1) *qlen += len;
-        if (type & 2) *rlen += len;
-    }
-}
-
-static int subtract_check_underflow(size_t length, size_t *limit)
-{
-    if (length <= *limit) {
-        *limit -= length;
-        return 0;
-    }
-
-    return -1;
-}
-
-int bam_set1(bam1_t *bam,
-             size_t l_qname, const char *qname,
-             uint16_t flag, int32_t tid, hts_pos_t pos, uint8_t mapq,
-             size_t n_cigar, const uint32_t *cigar,
-             int32_t mtid, hts_pos_t mpos, hts_pos_t isize,
-             size_t l_seq, const char *seq, const char *qual,
-             size_t l_aux)
-{
-    // use a default qname "*" if none is provided
-    if (l_qname == 0) {
-        l_qname = 1;
-        qname = "*";
-    }
-
-    // note: the qname is stored nul terminated and padded as described in the
-    // documentation for the bam1_t struct.
-    size_t qname_nuls = 4 - l_qname % 4;
-
-    // the aligment length, needed for bam_reg2bin(), is calculated as in bam_endpos().
-    // can't use bam_endpos() directly as some fields not yet set up.
-    hts_pos_t rlen = 0, qlen = 0;
-    if (!(flag & BAM_FUNMAP)) {
-        bam_cigar2rqlens((int)n_cigar, cigar, &rlen, &qlen);
-    }
-    if (rlen == 0) {
-        rlen = 1;
-    }
-
-    // validate parameters
-    if (l_qname > 254) {
-        hts_log_error("Query name too long");
-        errno = EINVAL;
-        return -1;
-    }
-    if (HTS_POS_MAX - rlen <= pos) {
-        hts_log_error("Read ends beyond highest supported position");
-        errno = EINVAL;
-        return -1;
-    }
-    if (!(flag & BAM_FUNMAP) && l_seq > 0 && n_cigar == 0) {
-        hts_log_error("Mapped query must have a CIGAR");
-        errno = EINVAL;
-        return -1;
-    }
-    if (!(flag & BAM_FUNMAP) && l_seq > 0 && l_seq != qlen) {
-        hts_log_error("CIGAR and query sequence are of different length");
-        errno = EINVAL;
-        return -1;
-    }
-
-    size_t limit = INT32_MAX;
-    int u = subtract_check_underflow(l_qname + qname_nuls, &limit);
-    u    += subtract_check_underflow(n_cigar * 4, &limit);
-    u    += subtract_check_underflow((l_seq + 1) / 2, &limit);
-    u    += subtract_check_underflow(l_seq, &limit);
-    u    += subtract_check_underflow(l_aux, &limit);
-    if (u != 0) {
-        hts_log_error("Size overflow");
-        errno = EINVAL;
-        return -1;
-    }
-
-    // re-allocate the data buffer as needed.
-    size_t data_len = l_qname + qname_nuls + n_cigar * 4 + (l_seq + 1) / 2 + l_seq;
-    if (realloc_bam_data(bam, data_len + l_aux) < 0) {
-        return -1;
-    }
-
-    bam->l_data = (int)data_len;
-    bam->core.pos = pos;
-    bam->core.tid = tid;
-    bam->core.bin = bam_reg2bin(pos, pos + rlen);
-    bam->core.qual = mapq;
-    bam->core.l_extranul = (uint8_t)(qname_nuls - 1);
-    bam->core.flag = flag;
-    bam->core.l_qname = (uint16_t)(l_qname + qname_nuls);
-    bam->core.n_cigar = (uint32_t)n_cigar;
-    bam->core.l_qseq = (int32_t)l_seq;
-    bam->core.mtid = mtid;
-    bam->core.mpos = mpos;
-    bam->core.isize = isize;
-
-    uint8_t *cp = bam->data;
-    strncpy((char *)cp, qname, l_qname);
-    int i;
-    for (i = 0; i < qname_nuls; i++) {
-        cp[l_qname + i] = '\0';
-    }
-    cp += l_qname + qname_nuls;
-
-    if (n_cigar > 0) {
-        memcpy(cp, cigar, n_cigar * 4);
-    }
-    cp += n_cigar * 4;
-
-    for (i = 0; i + 1 < l_seq; i += 2) {
-        *cp++ = (seq_nt16_table[(unsigned char)seq[i]] << 4) | seq_nt16_table[(unsigned char)seq[i + 1]];
-    }
-    for (; i < l_seq; i++) {
-        *cp++ = seq_nt16_table[(unsigned char)seq[i]] << 4;
-    }
-
-    if (qual) {
-        memcpy(cp, qual, l_seq);
-    }
-    else {
-        memset(cp, '\xff', l_seq);
-    }
-
-    return (int)data_len;
-}
-
-hts_pos_t bam_cigar2qlen(int n_cigar, const uint32_t *cigar)
-{
-    int k;
-    hts_pos_t l;
-    for (k = l = 0; k < n_cigar; ++k)
-        if (bam_cigar_type(bam_cigar_op(cigar[k]))&1)
-            l += bam_cigar_oplen(cigar[k]);
-    return l;
-}
-
-hts_pos_t bam_cigar2rlen(int n_cigar, const uint32_t *cigar)
-{
-    int k;
-    hts_pos_t l;
-    for (k = l = 0; k < n_cigar; ++k)
-        if (bam_cigar_type(bam_cigar_op(cigar[k]))&2)
-            l += bam_cigar_oplen(cigar[k]);
-    return l;
-}
-
-hts_pos_t bam_endpos(const bam1_t *b)
-{
-    hts_pos_t rlen = (b->core.flag & BAM_FUNMAP)? 0 : bam_cigar2rlen(b->core.n_cigar, bam_get_cigar(b));
-    if (rlen == 0) rlen = 1;
-    return b->core.pos + rlen;
-}
-
-static int bam_tag2cigar(bam1_t *b, int recal_bin, int give_warning) // return 0 if CIGAR is untouched; 1 if CIGAR is updated with CG
-{
-    bam1_core_t *c = &b->core;
-    uint32_t cigar_st, n_cigar4, CG_st, CG_en, ori_len = b->l_data, *cigar0, CG_len, fake_bytes;
-    uint8_t *CG;
-
-    // test where there is a real CIGAR in the CG tag to move
-    if (c->n_cigar == 0 || c->tid < 0 || c->pos < 0) return 0;
-    cigar0 = bam_get_cigar(b);
-    if (bam_cigar_op(cigar0[0]) != BAM_CSOFT_CLIP || bam_cigar_oplen(cigar0[0]) != c->l_qseq) return 0;
-    fake_bytes = c->n_cigar * 4;
-    int saved_errno = errno;
-    CG = bam_aux_get(b, "CG");
-    if (!CG) {
-        if (errno != ENOENT) return -1;  // Bad aux data
-        errno = saved_errno; // restore errno on expected no-CG-tag case
-        return 0;
-    }
-    if (CG[0] != 'B' || CG[1] != 'I') return 0; // not of type B,I
-    CG_len = le_to_u32(CG + 2);
-    if (CG_len < c->n_cigar || CG_len >= 1U<<29) return 0; // don't move if the real CIGAR length is shorter than the fake cigar length
-
-    // move from the CG tag to the right position
-    cigar_st = (uint8_t*)cigar0 - b->data;
-    c->n_cigar = CG_len;
-    n_cigar4 = c->n_cigar * 4;
-    CG_st = CG - b->data - 2;
-    CG_en = CG_st + 8 + n_cigar4;
-    if (possibly_expand_bam_data(b, n_cigar4 - fake_bytes) < 0) return -1;
-    b->l_data = b->l_data - fake_bytes + n_cigar4; // we need c->n_cigar-fake_bytes bytes to swap CIGAR to the right place
-    memmove(b->data + cigar_st + n_cigar4, b->data + cigar_st + fake_bytes, ori_len - (cigar_st + fake_bytes)); // insert c->n_cigar-fake_bytes empty space to make room
-    memcpy(b->data + cigar_st, b->data + (n_cigar4 - fake_bytes) + CG_st + 8, n_cigar4); // copy the real CIGAR to the right place; -fake_bytes for the fake CIGAR
-    if (ori_len > CG_en) // move data after the CG tag
-        memmove(b->data + CG_st + n_cigar4 - fake_bytes, b->data + CG_en + n_cigar4 - fake_bytes, ori_len - CG_en);
-    b->l_data -= n_cigar4 + 8; // 8: CGBI (4 bytes) and CGBI length (4)
-    if (recal_bin)
-        b->core.bin = hts_reg2bin(b->core.pos, bam_endpos(b), 14, 5);
-    if (give_warning)
-        hts_log_error("%s encodes a CIGAR with %d operators at the CG tag", bam_get_qname(b), c->n_cigar);
-    return 1;
-}
-
-static inline int aux_type2size(uint8_t type)
-{
-    switch (type) {
-    case 'A': case 'c': case 'C':
-        return 1;
-    case 's': case 'S':
-        return 2;
-    case 'i': case 'I': case 'f':
-        return 4;
-    case 'd':
-        return 8;
-    case 'Z': case 'H': case 'B':
-        return type;
-    default:
-        return 0;
-    }
-}
-
-static void swap_data(const bam1_core_t *c, int l_data, uint8_t *data, int is_host)
-{
-    uint32_t *cigar = (uint32_t*)(data + c->l_qname);
-    uint32_t i;
-    for (i = 0; i < c->n_cigar; ++i) ed_swap_4p(&cigar[i]);
-}
-
-// Fix bad records where qname is not terminated correctly.
-static int fixup_missing_qname_nul(bam1_t *b) {
-    bam1_core_t *c = &b->core;
-
-    // Note this is called before c->l_extranul is added to c->l_qname
-    if (c->l_extranul > 0) {
-        b->data[c->l_qname++] = '\0';
-        c->l_extranul--;
-    } else {
-        if (b->l_data > INT_MAX - 4) return -1;
-        if (realloc_bam_data(b, b->l_data + 4) < 0) return -1;
-        b->l_data += 4;
-        b->data[c->l_qname++] = '\0';
-        c->l_extranul = 3;
-    }
-    return 0;
-}
-
-/*
- * Note a second interface that returns a bam pointer instead would avoid bam_copy1
- * in multi-threaded handling.  This may be worth considering for htslib2.
- */
-int bam_read1(BGZF *fp, bam1_t *b)
-{
-    bam1_core_t *c = &b->core;
-    int32_t block_len, ret, i;
-    uint32_t x[8], new_l_data;
-
-    b->l_data = 0;
-
-    if ((ret = bgzf_read(fp, &block_len, 4)) != 4) {
-        if (ret == 0) return -1; // normal end-of-file
-        else return -2; // truncated
-    }
-    if (fp->is_be)
-        ed_swap_4p(&block_len);
-    if (block_len < 32) return -4;  // block_len includes core data
-    if (bgzf_read(fp, x, 32) != 32) return -3;
-    if (fp->is_be) {
-        for (i = 0; i < 8; ++i) ed_swap_4p(x + i);
-    }
-    c->tid = x[0]; c->pos = (int32_t)x[1];
-    c->bin = x[2]>>16; c->qual = x[2]>>8&0xff; c->l_qname = x[2]&0xff;
-    c->l_extranul = (c->l_qname%4 != 0)? (4 - c->l_qname%4) : 0;
-    c->flag = x[3]>>16; c->n_cigar = x[3]&0xffff;
-    c->l_qseq = x[4];
-    c->mtid = x[5]; c->mpos = (int32_t)x[6]; c->isize = (int32_t)x[7];
-
-    new_l_data = block_len - 32 + c->l_extranul;
-    if (new_l_data > INT_MAX || c->l_qseq < 0 || c->l_qname < 1) return -4;
-    if (((uint64_t) c->n_cigar << 2) + c->l_qname + c->l_extranul
-        + (((uint64_t) c->l_qseq + 1) >> 1) + c->l_qseq > (uint64_t) new_l_data)
-        return -4;
-    if (realloc_bam_data(b, new_l_data) < 0) return -4;
-    b->l_data = new_l_data;
-
-    if (bgzf_read(fp, b->data, c->l_qname) != c->l_qname) return -4;
-    if (b->data[c->l_qname - 1] != '\0') { // Try to fix missing NUL termination
-        if (fixup_missing_qname_nul(b) < 0) return -4;
-    }
-    for (i = 0; i < c->l_extranul; ++i) b->data[c->l_qname+i] = '\0';
-    c->l_qname += c->l_extranul;
-    if (b->l_data < c->l_qname ||
-        bgzf_read(fp, b->data + c->l_qname, b->l_data - c->l_qname) != b->l_data - c->l_qname)
-        return -4;
-    if (fp->is_be) swap_data(c, b->l_data, b->data, 0);
-    if (bam_tag2cigar(b, 0, 0) < 0)
-        return -4;
-
-    if (c->n_cigar > 0) { // recompute "bin" and check CIGAR-qlen consistency
-        hts_pos_t rlen, qlen;
-        bam_cigar2rqlens(c->n_cigar, bam_get_cigar(b), &rlen, &qlen);
-        if ((b->core.flag & BAM_FUNMAP) || rlen == 0) rlen = 1;
-        b->core.bin = hts_reg2bin(b->core.pos, b->core.pos + rlen, 14, 5);
-        // Sanity check for broken CIGAR alignments
-        if (c->l_qseq > 0 && !(c->flag & BAM_FUNMAP) && qlen != c->l_qseq) {
-            hts_log_error("CIGAR and query sequence lengths differ for %s",
-                    bam_get_qname(b));
-            return -4;
-        }
-    }
-
-    return 4 + block_len;
-}
-
-int bam_write1(BGZF *fp, const bam1_t *b)
-{
-    const bam1_core_t *c = &b->core;
-    uint32_t x[8], block_len = b->l_data - c->l_extranul + 32, y;
-    int i, ok;
-    if (c->l_qname - c->l_extranul > 255) {
-        hts_log_error("QNAME \"%s\" is longer than 254 characters", bam_get_qname(b));
-        errno = EOVERFLOW;
-        return -1;
-    }
-    if (c->n_cigar > 0xffff) block_len += 16; // "16" for "CGBI", 4-byte tag length and 8-byte fake CIGAR
-    if (c->pos > INT_MAX ||
-        c->mpos > INT_MAX ||
-        c->isize < INT_MIN || c->isize > INT_MAX) {
-        hts_log_error("Positional data is too large for BAM format");
-        return -1;
-    }
-    x[0] = c->tid;
-    x[1] = c->pos;
-    x[2] = (uint32_t)c->bin<<16 | c->qual<<8 | (c->l_qname - c->l_extranul);
-    if (c->n_cigar > 0xffff) x[3] = (uint32_t)c->flag << 16 | 2;
-    else x[3] = (uint32_t)c->flag << 16 | (c->n_cigar & 0xffff);
-    x[4] = c->l_qseq;
-    x[5] = c->mtid;
-    x[6] = c->mpos;
-    x[7] = c->isize;
-    ok = (bgzf_flush_try(fp, 4 + block_len) >= 0);
-    if (fp->is_be) {
-        for (i = 0; i < 8; ++i) ed_swap_4p(x + i);
-        y = block_len;
-        if (ok) ok = (bgzf_write(fp, ed_swap_4p(&y), 4) >= 0);
-        swap_data(c, b->l_data, b->data, 1);
-    } else {
-        if (ok) ok = (bgzf_write(fp, &block_len, 4) >= 0);
-    }
-    if (ok) ok = (bgzf_write(fp, x, 32) >= 0);
-    if (ok) ok = (bgzf_write(fp, b->data, c->l_qname - c->l_extranul) >= 0);
-    if (c->n_cigar <= 0xffff) { // no long CIGAR; write normally
-        if (ok) ok = (bgzf_write(fp, b->data + c->l_qname, b->l_data - c->l_qname) >= 0);
-    } else { // with long CIGAR, insert a fake CIGAR record and move the real CIGAR to the CG:B,I tag
-        uint8_t buf[8];
-        uint32_t cigar_st, cigar_en, cigar[2];
-        hts_pos_t cigreflen = bam_cigar2rlen(c->n_cigar, bam_get_cigar(b));
-        if (cigreflen >= (1<<28)) {
-            // Length of reference covered is greater than the biggest
-            // CIGAR operation currently allowed.
-            hts_log_error("Record %s with %d CIGAR ops and ref length %"PRIhts_pos
-                          " cannot be written in BAM.  Try writing SAM or CRAM instead.\n",
-                          bam_get_qname(b), c->n_cigar, cigreflen);
-            return -1;
-        }
-        cigar_st = (uint8_t*)bam_get_cigar(b) - b->data;
-        cigar_en = cigar_st + c->n_cigar * 4;
-        cigar[0] = (uint32_t)c->l_qseq << 4 | BAM_CSOFT_CLIP;
-        cigar[1] = (uint32_t)cigreflen << 4 | BAM_CREF_SKIP;
-        u32_to_le(cigar[0], buf);
-        u32_to_le(cigar[1], buf + 4);
-        if (ok) ok = (bgzf_write(fp, buf, 8) >= 0); // write cigar: <read_length>S<ref_length>N
-        if (ok) ok = (bgzf_write(fp, &b->data[cigar_en], b->l_data - cigar_en) >= 0); // write data after CIGAR
-        if (ok) ok = (bgzf_write(fp, "CGBI", 4) >= 0); // write CG:B,I
-        u32_to_le(c->n_cigar, buf);
-        if (ok) ok = (bgzf_write(fp, buf, 4) >= 0); // write the true CIGAR length
-        if (ok) ok = (bgzf_write(fp, &b->data[cigar_st], c->n_cigar * 4) >= 0); // write the real CIGAR
-    }
-    if (fp->is_be) swap_data(c, b->l_data, b->data, 0);
-    return ok? 4 + block_len : -1;
-}
-
-/*
- * Write a BAM file and append to the in-memory index simultaneously.
- */
-static int bam_write_idx1(htsFile *fp, const sam_hdr_t *h, const bam1_t *b) {
-    BGZF *bfp = fp->fp.bgzf;
-
-    if (!fp->idx)
-        return bam_write1(bfp, b);
-
-    uint32_t block_len = b->l_data - b->core.l_extranul + 32;
-    if (bgzf_flush_try(bfp, 4 + block_len) < 0)
-        return -1;
-    if (!bfp->mt)
-        hts_idx_amend_last(fp->idx, bgzf_tell(bfp));
-    else
-        bgzf_idx_amend_last(bfp, fp->idx, bgzf_tell(bfp));
-
-    int ret = bam_write1(bfp, b);
-    if (ret < 0)
-        return -1;
-
-    if (bgzf_idx_push(bfp, fp->idx, b->core.tid, b->core.pos, bam_endpos(b), bgzf_tell(bfp), !(b->core.flag&BAM_FUNMAP)) < 0) {
-        hts_log_error("Read '%s' with ref_name='%s', ref_length=%"PRIhts_pos", flags=%d, pos=%"PRIhts_pos" cannot be indexed",
-                bam_get_qname(b), sam_hdr_tid2name(h, b->core.tid), sam_hdr_tid2len(h, b->core.tid), b->core.flag, b->core.pos+1);
-        ret = -1;
-    }
-
-    return ret;
-}
-
-/*
- * Set the qname in a BAM record
- */
-int bam_set_qname(bam1_t *rec, const char *qname)
-{
-    if (!rec) return -1;
-    if (!qname || !*qname) return -1;
-
-    size_t old_len = rec->core.l_qname;
-    size_t new_len = strlen(qname) + 1;
-    if (new_len < 1 || new_len > 255) return -1;
-
-    int extranul = (new_len%4 != 0) ? (4 - new_len%4) : 0;
-
-    size_t new_data_len = rec->l_data - old_len + new_len + extranul;
-    if (realloc_bam_data(rec, new_data_len) < 0) return -1;
-
-    // Make room
-    if (new_len + extranul != rec->core.l_qname)
-        memmove(rec->data + new_len + extranul, rec->data + rec->core.l_qname, rec->l_data - rec->core.l_qname);
-    // Copy in new name and pad if needed
-    memcpy(rec->data, qname, new_len);
-    int n;
-    for (n = 0; n < extranul; n++) rec->data[new_len + n] = '\0';
-
-    rec->l_data = new_data_len;
-    rec->core.l_qname = new_len + extranul;
-    rec->core.l_extranul = extranul;
-
-    return 0;
-}
-
-/********************
- *** BAM indexing ***
- ********************/
-
-static hts_idx_t *sam_index(htsFile *fp, int min_shift)
-{
-    int n_lvls, i, fmt, ret;
-    bam1_t *b;
-    hts_idx_t *idx;
-    sam_hdr_t *h;
-    h = sam_hdr_read(fp);
-    if (h == NULL) return NULL;
-    if (min_shift > 0) {
-        hts_pos_t max_len = 0, s;
-        for (i = 0; i < h->n_targets; ++i) {
-            hts_pos_t len = sam_hdr_tid2len(h, i);
-            if (max_len < len) max_len = len;
-        }
-        max_len += 256;
-        for (n_lvls = 0, s = 1<<min_shift; max_len > s; ++n_lvls, s <<= 3);
-        fmt = HTS_FMT_CSI;
-    } else min_shift = 14, n_lvls = 5, fmt = HTS_FMT_BAI;
-    idx = hts_idx_init(h->n_targets, fmt, bgzf_tell(fp->fp.bgzf), min_shift, n_lvls);
-    b = bam_init1();
-    while ((ret = sam_read1(fp, h, b)) >= 0) {
-        ret = hts_idx_push(idx, b->core.tid, b->core.pos, bam_endpos(b), bgzf_tell(fp->fp.bgzf), !(b->core.flag&BAM_FUNMAP));
-        if (ret < 0) { // unsorted or doesn't fit
-            hts_log_error("Read '%s' with ref_name='%s', ref_length=%"PRIhts_pos", flags=%d, pos=%"PRIhts_pos" cannot be indexed", bam_get_qname(b), sam_hdr_tid2name(h, b->core.tid), sam_hdr_tid2len(h, b->core.tid), b->core.flag, b->core.pos+1);
-            goto err;
-        }
-    }
-    if (ret < -1) goto err; // corrupted BAM file
-
-    hts_idx_finish(idx, bgzf_tell(fp->fp.bgzf));
-    sam_hdr_destroy(h);
-    bam_destroy1(b);
-    return idx;
-
-err:
-    bam_destroy1(b);
-    hts_idx_destroy(idx);
-    return NULL;
-}
-
-int sam_index_build3(const char *fn, const char *fnidx, int min_shift, int nthreads)
-{
-    hts_idx_t *idx;
-    htsFile *fp;
-    int ret = 0;
-
-    if ((fp = hts_open(fn, "r")) == 0) return -2;
-    if (nthreads)
-        hts_set_threads(fp, nthreads);
-
-    switch (fp->format.format) {
-    case cram:
-
-        ret = cram_index_build(fp->fp.cram, fn, fnidx);
-        break;
-
-    case bam:
-    case sam:
-        if (fp->format.compression != bgzf) {
-            hts_log_error("%s file \"%s\" not BGZF compressed",
-                          fp->format.format == bam ? "BAM" : "SAM", fn);
-            ret = -1;
-            break;
-        }
-        idx = sam_index(fp, min_shift);
-        if (idx) {
-            ret = hts_idx_save_as(idx, fn, fnidx, (min_shift > 0)? HTS_FMT_CSI : HTS_FMT_BAI);
-            if (ret < 0) ret = -4;
-            hts_idx_destroy(idx);
-        }
-        else ret = -1;
-        break;
-
-    default:
-        ret = -3;
-        break;
-    }
-    hts_close(fp);
-
-    return ret;
-}
-
-int sam_index_build2(const char *fn, const char *fnidx, int min_shift)
-{
-    return sam_index_build3(fn, fnidx, min_shift, 0);
-}
-
-int sam_index_build(const char *fn, int min_shift)
-{
-    return sam_index_build3(fn, NULL, min_shift, 0);
-}
-
-// Provide bam_index_build() symbol for binary compatibility with earlier HTSlib
-#undef bam_index_build
-int bam_index_build(const char *fn, int min_shift)
-{
-    return sam_index_build2(fn, NULL, min_shift);
-}
-
-// Initialise fp->idx for the current format type.
-// This must be called after the header has been written but no other data.
-int sam_idx_init(htsFile *fp, sam_hdr_t *h, int min_shift, const char *fnidx) {
-    fp->fnidx = fnidx;
-    if (fp->format.format == bam || fp->format.format == bcf ||
-        (fp->format.format == sam && fp->format.compression == bgzf)) {
-        int n_lvls, fmt = HTS_FMT_CSI;
-        if (min_shift > 0) {
-            int64_t max_len = 0, s;
-            int i;
-            for (i = 0; i < h->n_targets; ++i)
-                if (max_len < h->target_len[i]) max_len = h->target_len[i];
-            max_len += 256;
-            for (n_lvls = 0, s = 1<<min_shift; max_len > s; ++n_lvls, s <<= 3);
-
-        } else min_shift = 14, n_lvls = 5, fmt = HTS_FMT_BAI;
-
-        fp->idx = hts_idx_init(h->n_targets, fmt, bgzf_tell(fp->fp.bgzf), min_shift, n_lvls);
-        return fp->idx ? 0 : -1;
-    }
-
-    if (fp->format.format == cram) {
-        fp->fp.cram->idxfp = bgzf_open(fnidx, "wg");
-        return fp->fp.cram->idxfp ? 0 : -1;
-    }
-
-    return -1;
-}
-
-// Finishes an index. Call after the last record has been written.
-// Returns 0 on success, <0 on failure.
-int sam_idx_save(htsFile *fp) {
-    if (fp->format.format == bam || fp->format.format == bcf ||
-        fp->format.format == vcf || fp->format.format == sam) {
-        int ret;
-        if ((ret = sam_state_destroy(fp)) < 0) {
-            errno = -ret;
-            return -1;
-        }
-        if (bgzf_flush(fp->fp.bgzf) < 0)
-            return -1;
-        hts_idx_amend_last(fp->idx, bgzf_tell(fp->fp.bgzf));
-
-        if (hts_idx_finish(fp->idx, bgzf_tell(fp->fp.bgzf)) < 0)
-            return -1;
-
-        return hts_idx_save_as(fp->idx, NULL, fp->fnidx, hts_idx_fmt(fp->idx));
-
-    } else if (fp->format.format == cram) {
-        // flushed and closed by cram_close
-    }
-
-    return 0;
-}
-
-static int sam_readrec(BGZF *ignored, void *fpv, void *bv, int *tid, hts_pos_t *beg, hts_pos_t *end)
-{
-    htsFile *fp = (htsFile *)fpv;
-    bam1_t *b = bv;
-    fp->line.l = 0;
-    int ret = sam_read1(fp, fp->bam_header, b);
-    if (ret >= 0) {
-        *tid = b->core.tid;
-        *beg = b->core.pos;
-        *end = bam_endpos(b);
-    }
-    return ret;
-}
-
-// This is used only with read_rest=1 iterators, so need not set tid/beg/end.
-static int sam_readrec_rest(BGZF *ignored, void *fpv, void *bv, int *tid, hts_pos_t *beg, hts_pos_t *end)
-{
-    htsFile *fp = (htsFile *)fpv;
-    bam1_t *b = bv;
-    fp->line.l = 0;
-    int ret = sam_read1(fp, fp->bam_header, b);
-    return ret;
-}
-
-// Internal (for now) func used by bam_sym_lookup.  This is copied from
-// samtools/bam.c.
-static const char *bam_get_library(const bam_hdr_t *h, const bam1_t *b)
-{
-    const char *rg;
-    kstring_t lib = { 0, 0, NULL };
-    rg = (char *)bam_aux_get(b, "RG");
-
-    if (!rg)
-        return NULL;
-    else
-        rg++;
-
-    if (sam_hdr_find_tag_id((bam_hdr_t *)h, "RG", "ID", rg, "LB", &lib)  < 0)
-        return NULL;
-
-    static char LB_text[1024];
-    int len = lib.l < sizeof(LB_text) - 1 ? lib.l : sizeof(LB_text) - 1;
-
-    memcpy(LB_text, lib.s, len);
-    LB_text[len] = 0;
-
-    free(lib.s);
-
-    return LB_text;
-}
-
-
-// Bam record pointer and SAM header combined
-typedef struct {
-    const sam_hdr_t *h;
-    const bam1_t *b;
-} hb_pair;
-
-// Looks up variable names in str and replaces them with their value.
-// Also supports aux tags.
-//
-// Note the expression parser deliberately overallocates str size so it
-// is safe to use memcmp over strcmp.
-static int bam_sym_lookup(void *data, char *str, char **end,
-                          hts_expr_val_t *res) {
-    hb_pair *hb = (hb_pair *)data;
-    const bam1_t *b = hb->b;
-
-    res->is_str = 0;
-    switch(*str) {
-    case 'c':
-        if (memcmp(str, "cigar", 5) == 0) {
-            *end = str+5;
-            res->is_str = 1;
-            ks_clear(&res->s);
-            uint32_t *cigar = bam_get_cigar(b);
-            int i, n = b->core.n_cigar, r = 0;
-            for (i = 0; i < n; i++) {
-                r |= kputw (bam_cigar_oplen(cigar[i]), &res->s);
-                r |= kputc_(bam_cigar_opchr(cigar[i]), &res->s);
-            }
-            kputs("", &res->s);
-            return r ? 0 : -1;
-        }
-        break;
-
-    case 'f':
-        if (memcmp(str, "flag", 4) == 0) {
-            str = *end = str+4;
-            if (*str != '.') {
-                res->d = b->core.flag;
-                return 0;
-            } else {
-                str++;
-                if (!memcmp(str, "paired", 6)) {
-                    *end = str+6;
-                    res->d = b->core.flag & BAM_FPAIRED;
-                    return 0;
-                } else if (!memcmp(str, "proper_pair", 11)) {
-                    *end = str+11;
-                    res->d = b->core.flag & BAM_FPROPER_PAIR;
-                    return 0;
-                } else if (!memcmp(str, "unmap", 5)) {
-                    *end = str+5;
-                    res->d = b->core.flag & BAM_FUNMAP;
-                    return 0;
-                } else if (!memcmp(str, "munmap", 6)) {
-                    *end = str+6;
-                    res->d = b->core.flag & BAM_FMUNMAP;
-                    return 0;
-                } else if (!memcmp(str, "reverse", 7)) {
-                    *end = str+7;
-                    res->d = b->core.flag & BAM_FREVERSE;
-                    return 0;
-                } else if (!memcmp(str, "mreverse", 8)) {
-                    *end = str+8;
-                    res->d = b->core.flag & BAM_FMREVERSE;
-                    return 0;
-                } else if (!memcmp(str, "read1", 5)) {
-                    *end = str+5;
-                    res->d = b->core.flag & BAM_FREAD1;
-                    return 0;
-                } else if (!memcmp(str, "read2", 6)) {
-                    *end = str+5;
-                    res->d = b->core.flag & BAM_FREAD2;
-                    return 0;
-                } else if (!memcmp(str, "secondary", 9)) {
-                    *end = str+9;
-                    res->d = b->core.flag & BAM_FSECONDARY;
-                    return 0;
-                } else if (!memcmp(str, "qcfail", 6)) {
-                    *end = str+6;
-                    res->d = b->core.flag & BAM_FQCFAIL;
-                    return 0;
-                } else if (!memcmp(str, "dup", 3)) {
-                    *end = str+3;
-                    res->d = b->core.flag & BAM_FDUP;
-                    return 0;
-                } else if (!memcmp(str, "supplementary", 13)) {
-                    *end = str+13;
-                    res->d = b->core.flag & BAM_FSUPPLEMENTARY;
-                    return 0;
-                } else {
-                    hts_log_error("Unrecognised flag string");
-                    return -1;
-                }
-            }
-        }
-        break;
-
-    case 'l':
-        if (memcmp(str, "library", 7) == 0) {
-            *end = str+7;
-            res->is_str = 1;
-            const char *lib = bam_get_library(hb->h, b);
-            kputs(lib ? lib : "", ks_clear(&res->s));
-            return 0;
-        }
-        break;
-
-    case 'm':
-        if (memcmp(str, "mapq", 4) == 0) {
-            *end = str+4;
-            res->d = b->core.qual;
-            return 0;
-        } else if (memcmp(str, "mpos", 4) == 0) {
-            *end = str+4;
-            res->d = b->core.mpos+1;
-            return 0;
-        } else if (memcmp(str, "mrname", 6) == 0) {
-            *end = str+6;
-            res->is_str = 1;
-            const char *rn = sam_hdr_tid2name(hb->h, b->core.mtid);
-            kputs(rn ? rn : "*", ks_clear(&res->s));
-            return 0;
-        } else if (memcmp(str, "mrefid", 6) == 0) {
-            *end = str+6;
-            res->d = b->core.mtid;
-            return 0;
-        }
-        break;
-
-    case 'n':
-        if (memcmp(str, "ncigar", 6) == 0) {
-            *end = str+6;
-            res->d = b->core.n_cigar;
-            return 0;
-        }
-        break;
-
-    case 'p':
-        if (memcmp(str, "pos", 3) == 0) {
-            *end = str+3;
-            res->d = b->core.pos+1;
-            return 0;
-        } else if (memcmp(str, "pnext", 5) == 0) {
-            *end = str+5;
-            res->d = b->core.mpos+1;
-            return 0;
-        }
-        break;
-
-    case 'q':
-        if (memcmp(str, "qlen", 4) == 0) {
-            *end = str+4;
-            res->d = bam_cigar2qlen(b->core.n_cigar, bam_get_cigar(b));
-            return 0;
-        } else if (memcmp(str, "qname", 5) == 0) {
-            *end = str+5;
-            res->is_str = 1;
-            kputs(bam_get_qname(b), ks_clear(&res->s));
-            return 0;
-        } else if (memcmp(str, "qual", 4) == 0) {
-            *end = str+4;
-            ks_clear(&res->s);
-            if (ks_resize(&res->s, b->core.l_qseq+1) < 0)
-                return -1;
-            memcpy(res->s.s, bam_get_qual(b), b->core.l_qseq);
-            res->s.l = b->core.l_qseq;
-            res->is_str = 1;
-            return 0;
-        }
-        break;
-
-    case 'r':
-        if (memcmp(str, "rlen", 4) == 0) {
-            *end = str+4;
-            res->d = bam_cigar2rlen(b->core.n_cigar, bam_get_cigar(b));
-            return 0;
-        } else if (memcmp(str, "rname", 5) == 0) {
-            *end = str+5;
-            res->is_str = 1;
-            const char *rn = sam_hdr_tid2name(hb->h, b->core.tid);
-            kputs(rn ? rn : "*", ks_clear(&res->s));
-            return 0;
-        } else if (memcmp(str, "rnext", 5) == 0) {
-            *end = str+5;
-            res->is_str = 1;
-            const char *rn = sam_hdr_tid2name(hb->h, b->core.mtid);
-            kputs(rn ? rn : "*", ks_clear(&res->s));
-            return 0;
-        } else if (memcmp(str, "refid", 5) == 0) {
-            *end = str+5;
-            res->d = b->core.tid;
-            return 0;
-        }
-        break;
-
-    case 's':
-        if (memcmp(str, "seq", 3) == 0) {
-            *end = str+3;
-            ks_clear(&res->s);
-            if (ks_resize(&res->s, b->core.l_qseq+1) < 0)
-                return -1;
-            nibble2base(bam_get_seq(b), res->s.s, b->core.l_qseq);
-            res->s.s[b->core.l_qseq] = 0;
-            res->s.l = b->core.l_qseq;
-            res->is_str = 1;
-            return 0;
-        }
-        break;
-
-    case 't':
-        if (memcmp(str, "tlen", 4) == 0) {
-            *end = str+4;
-            res->d = b->core.isize;
-            return 0;
-        }
-        break;
-
-    case '[':
-        if (*str == '[' && str[1] && str[2] && str[3] == ']') {
-            /* aux tags */
-            *end = str+4;
-
-            uint8_t *aux = bam_aux_get(b, str+1);
-            if (aux) {
-                // we define the truth of a tag to be its presence, even if 0.
-                res->is_true = 1;
-                switch (*aux) {
-                case 'Z':
-                case 'H':
-                    res->is_str = 1;
-                    kputs((char *)aux+1, ks_clear(&res->s));
-                    break;
-
-                case 'A':
-                    res->is_str = 1;
-                    kputsn((char *)aux+1, 1, ks_clear(&res->s));
-                    break;
-
-                case 'i': case 'I':
-                case 's': case 'S':
-                case 'c': case 'C':
-                    res->is_str = 0;
-                    res->d = bam_aux2i(aux);
-                    break;
-
-                case 'f':
-                case 'd':
-                    res->is_str = 0;
-                    res->d = bam_aux2f(aux);
-                    break;
-
-                default:
-                    hts_log_error("Aux type '%c not yet supported by filters",
-                                  *aux);
-                    return -1;
-                }
-                return 0;
-
-            } else {
-                // hence absent tags are always false (and strings)
-                res->is_str = 1;
-                res->s.l = 0;
-                res->d = 0;
-                res->is_true = 0;
-                return 0;
-            }
-        }
-        break;
-    }
-
-    // All successful matches in switch should return 0.
-    // So if we didn't match, it's a parse error.
-    return -1;
-}
-
-// Returns 1 when accepted by the filter, 0 if not, -1 on error.
-int sam_passes_filter(const sam_hdr_t *h, const bam1_t *b, hts_filter_t *filt)
-{
-    hb_pair hb = {h, b};
-    hts_expr_val_t res;
-    if (hts_filter_eval(filt, &hb, bam_sym_lookup, &res)) {
-        hts_log_error("Couldn't process filter expression");
-        hts_expr_val_free(&res);
-        return -1;
-    }
-
-    int t = res.is_true;
-    hts_expr_val_free(&res);
-
-    return t;
-}
-
-static int cram_readrec(BGZF *ignored, void *fpv, void *bv, int *tid, hts_pos_t *beg, hts_pos_t *end)
-{
-    htsFile *fp = fpv;
-    bam1_t *b = bv;
-    int pass_filter, ret;
-
-    do {
-        ret = cram_get_bam_seq(fp->fp.cram, &b);
-        if (ret < 0)
-            return cram_eof(fp->fp.cram) ? -1 : -2;
-
-        if (bam_tag2cigar(b, 1, 1) < 0)
-            return -2;
-
-        *tid = b->core.tid;
-        *beg = b->core.pos;
-        *end = bam_endpos(b);
-
-        if (fp->filter) {
-            pass_filter = sam_passes_filter(fp->bam_header, b, fp->filter);
-            if (pass_filter < 0)
-                return -2;
-        } else {
-            pass_filter = 1;
-        }
-    } while (pass_filter == 0);
-
-    return ret;
-}
-
-static int cram_pseek(void *fp, int64_t offset, int whence)
-{
-    cram_fd *fd =  (cram_fd *)fp;
-
-    if ((0 != cram_seek(fd, offset, SEEK_SET))
-     && (0 != cram_seek(fd, offset - fd->first_container, SEEK_CUR)))
-        return -1;
-
-    fd->curr_position = offset;
-
-    if (fd->ctr) {
-        cram_free_container(fd->ctr);
-        if (fd->ctr_mt && fd->ctr_mt != fd->ctr)
-            cram_free_container(fd->ctr_mt);
-
-        fd->ctr = NULL;
-        fd->ctr_mt = NULL;
-        fd->ooc = 0;
-    }
-
-    return 0;
-}
-
-/*
- * cram_ptell is a pseudo-tell function, because it matches the position of the disk cursor only
- *   after a fresh seek call. Otherwise it indicates that the read takes place inside the buffered
- *   container previously fetched. It was designed like this to integrate with the functionality
- *   of the iterator stepping logic.
- */
-
-static int64_t cram_ptell(void *fp)
-{
-    cram_fd *fd = (cram_fd *)fp;
-    cram_container *c;
-    cram_slice *s;
-    int64_t ret = -1L;
-
-    if (fd) {
-        if ((c = fd->ctr) != NULL) {
-            if ((s = c->slice) != NULL && s->max_rec) {
-                if ((c->curr_slice + s->curr_rec/s->max_rec) >= (c->max_slice + 1))
-                    fd->curr_position += c->offset + c->length;
-            }
-        }
-        ret = fd->curr_position;
-    }
-
-    return ret;
-}
-
-static int bam_pseek(void *fp, int64_t offset, int whence)
-{
-    BGZF *fd = (BGZF *)fp;
-
-    return bgzf_seek(fd, offset, whence);
-}
-
-static int64_t bam_ptell(void *fp)
-{
-    BGZF *fd = (BGZF *)fp;
-    if (!fd)
-        return -1L;
-
-    return bgzf_tell(fd);
-}
-
-
-
-static hts_idx_t *index_load(htsFile *fp, const char *fn, const char *fnidx, int flags)
-{
-    switch (fp->format.format) {
-    case bam:
-    case sam:
-        return hts_idx_load3(fn, fnidx, HTS_FMT_BAI, flags);
-
-    case cram: {
-        if (cram_index_load(fp->fp.cram, fn, fnidx) < 0) return NULL;
-
-        // Cons up a fake "index" just pointing at the associated cram_fd:
-        hts_cram_idx_t *idx = malloc(sizeof (hts_cram_idx_t));
-        if (idx == NULL) return NULL;
-        idx->fmt = HTS_FMT_CRAI;
-        idx->cram = fp->fp.cram;
-        return (hts_idx_t *) idx;
-        }
-
-    default:
-        return NULL; // TODO Would use tbx_index_load if it returned hts_idx_t
-    }
-}
-
-hts_idx_t *sam_index_load3(htsFile *fp, const char *fn, const char *fnidx, int flags)
-{
-    return index_load(fp, fn, fnidx, flags);
-}
-
-hts_idx_t *sam_index_load2(htsFile *fp, const char *fn, const char *fnidx) {
-    return index_load(fp, fn, fnidx, HTS_IDX_SAVE_REMOTE);
-}
-
-hts_idx_t *sam_index_load(htsFile *fp, const char *fn)
-{
-    return index_load(fp, fn, NULL, HTS_IDX_SAVE_REMOTE);
-}
-
-static hts_itr_t *cram_itr_query(const hts_idx_t *idx, int tid, hts_pos_t beg, hts_pos_t end, hts_readrec_func *readrec)
-{
-    const hts_cram_idx_t *cidx = (const hts_cram_idx_t *) idx;
-    hts_itr_t *iter = (hts_itr_t *) calloc(1, sizeof(hts_itr_t));
-    if (iter == NULL) return NULL;
-
-    // Cons up a dummy iterator for which hts_itr_next() will simply invoke
-    // the readrec function:
-    iter->is_cram = 1;
-    iter->read_rest = 1;
-    iter->off = NULL;
-    iter->bins.a = NULL;
-    iter->readrec = readrec;
-
-    if (tid >= 0 || tid == HTS_IDX_NOCOOR || tid == HTS_IDX_START) {
-        cram_range r = { tid, beg+1, end };
-        int ret = cram_set_option(cidx->cram, CRAM_OPT_RANGE, &r);
-
-        iter->curr_off = 0;
-        // The following fields are not required by hts_itr_next(), but are
-        // filled in in case user code wants to look at them.
-        iter->tid = tid;
-        iter->beg = beg;
-        iter->end = end;
-
-        switch (ret) {
-        case 0:
-            break;
-
-        case -2:
-            // No data vs this ref, so mark iterator as completed.
-            // Same as HTS_IDX_NONE.
-            iter->finished = 1;
-            break;
-
-        default:
-            free(iter);
-            return NULL;
-        }
-    }
-    else switch (tid) {
-    case HTS_IDX_REST:
-        iter->curr_off = 0;
-        break;
-    case HTS_IDX_NONE:
-        iter->curr_off = 0;
-        iter->finished = 1;
-        break;
-    default:
-        hts_log_error("Query with tid=%d not implemented for CRAM files", tid);
-        abort();
-        break;
-    }
-
-    return iter;
-}
-
-hts_itr_t *sam_itr_queryi(const hts_idx_t *idx, int tid, hts_pos_t beg, hts_pos_t end)
-{
-    const hts_cram_idx_t *cidx = (const hts_cram_idx_t *) idx;
-    if (idx == NULL)
-        return hts_itr_query(NULL, tid, beg, end, sam_readrec_rest);
-    else if (cidx->fmt == HTS_FMT_CRAI)
-        return cram_itr_query(idx, tid, beg, end, sam_readrec);
-    else
-        return hts_itr_query(idx, tid, beg, end, sam_readrec);
-}
-
-static int cram_name2id(void *fdv, const char *ref)
-{
-    cram_fd *fd = (cram_fd *) fdv;
-    return sam_hdr_name2tid(fd->header, ref);
-}
-
-hts_itr_t *sam_itr_querys(const hts_idx_t *idx, sam_hdr_t *hdr, const char *region)
-{
-    const hts_cram_idx_t *cidx = (const hts_cram_idx_t *) idx;
-    return hts_itr_querys(idx, region, (hts_name2id_f)(bam_name2id), hdr,
-                          cidx->fmt == HTS_FMT_CRAI ? cram_itr_query : hts_itr_query,
-                          sam_readrec);
-}
-
-hts_itr_t *sam_itr_regarray(const hts_idx_t *idx, sam_hdr_t *hdr, char **regarray, unsigned int regcount)
-{
-    const hts_cram_idx_t *cidx = (const hts_cram_idx_t *) idx;
-    hts_reglist_t *r_list = NULL;
-    int r_count = 0;
-
-    if (!cidx || !hdr)
-        return NULL;
-
-    hts_itr_t *itr = NULL;
-    if (cidx->fmt == HTS_FMT_CRAI) {
-        r_list = hts_reglist_create(regarray, regcount, &r_count, cidx->cram, cram_name2id);
-        if (!r_list)
-            return NULL;
-        itr = hts_itr_regions(idx, r_list, r_count, cram_name2id, cidx->cram,
-                   hts_itr_multi_cram, cram_readrec, cram_pseek, cram_ptell);
-    } else {
-        r_list = hts_reglist_create(regarray, regcount, &r_count, hdr, (hts_name2id_f)(bam_name2id));
-        if (!r_list)
-            return NULL;
-        itr = hts_itr_regions(idx, r_list, r_count, (hts_name2id_f)(bam_name2id), hdr,
-                   hts_itr_multi_bam, sam_readrec, bam_pseek, bam_ptell);
-    }
-
-    if (!itr)
-        hts_reglist_free(r_list, r_count);
-
-    return itr;
-}
-
-hts_itr_t *sam_itr_regions(const hts_idx_t *idx, sam_hdr_t *hdr, hts_reglist_t *reglist, unsigned int regcount)
-{
-    const hts_cram_idx_t *cidx = (const hts_cram_idx_t *) idx;
-
-    if(!cidx || !hdr || !reglist)
-        return NULL;
-
-    if (cidx->fmt == HTS_FMT_CRAI)
-        return hts_itr_regions(idx, reglist, regcount, cram_name2id, cidx->cram,
-                   hts_itr_multi_cram, cram_readrec, cram_pseek, cram_ptell);
-    else
-        return hts_itr_regions(idx, reglist, regcount, (hts_name2id_f)(bam_name2id), hdr,
-                   hts_itr_multi_bam, sam_readrec, bam_pseek, bam_ptell);
-}
-
-/**********************
- *** SAM header I/O ***
- **********************/
-
-#include "htslib/kseq.h"
-#include "htslib/kstring.h"
-
-sam_hdr_t *sam_hdr_parse(size_t l_text, const char *text)
-{
-    sam_hdr_t *bh = sam_hdr_init();
-    if (!bh) return NULL;
-
-    if (sam_hdr_add_lines(bh, text, l_text) != 0) {
-        sam_hdr_destroy(bh);
-        return NULL;
-    }
-
-    return bh;
-}
-
-// Minimal sanitisation of a header to ensure.
-// - null terminated string.
-// - all lines start with @ (also implies no blank lines).
-//
-// Much more could be done, but currently is not, including:
-// - checking header types are known (HD, SQ, etc).
-// - syntax (eg checking tab separated fields).
-// - validating n_targets matches @SQ records.
-// - validating target lengths against @SQ records.
-static sam_hdr_t *sam_hdr_sanitise(sam_hdr_t *h) {
-    if (!h)
-        return NULL;
-
-    // Special case for empty headers.
-    if (h->l_text == 0)
-        return h;
-
-    size_t i;
-    unsigned int lnum = 0;
-    char *cp = h->text, last = '\n';
-    for (i = 0; i < h->l_text; i++) {
-        // NB: l_text excludes terminating nul.  This finds early ones.
-        if (cp[i] == 0)
-            break;
-
-        // Error on \n[^@], including duplicate newlines
-        if (last == '\n') {
-            lnum++;
-            if (cp[i] != '@') {
-                hts_log_error("Malformed SAM header at line %u", lnum);
-                sam_hdr_destroy(h);
-                return NULL;
-            }
-        }
-
-        last = cp[i];
-    }
-
-    if (i < h->l_text) { // Early nul found.  Complain if not just padding.
-        size_t j = i;
-        while (j < h->l_text && cp[j] == '\0') j++;
-        if (j < h->l_text)
-            hts_log_warning("Unexpected NUL character in header. Possibly truncated");
-    }
-
-    // Add trailing newline and/or trailing nul if required.
-    if (last != '\n') {
-        hts_log_warning("Missing trailing newline on SAM header. Possibly truncated");
-
-        if (h->l_text < 2 || i >= h->l_text - 2) {
-            if (h->l_text >= SIZE_MAX - 2) {
-                hts_log_error("No room for extra newline");
-                sam_hdr_destroy(h);
-                return NULL;
-            }
-
-            cp = realloc(h->text, (size_t) h->l_text+2);
-            if (!cp) {
-                sam_hdr_destroy(h);
-                return NULL;
-            }
-            h->text = cp;
-        }
-        cp[i++] = '\n';
-
-        // l_text may be larger already due to multiple nul padding
-        if (h->l_text < i)
-            h->l_text = i;
-        cp[h->l_text] = '\0';
-    }
-
-    return h;
-}
-
-static sam_hdr_t *sam_hdr_create(htsFile* fp) {
-    kstring_t str = { 0, 0, NULL };
-    khint_t k;
-    sam_hdr_t* h = sam_hdr_init();
-    const char *q, *r;
-    char* sn = NULL;
-    khash_t(s2i) *d = kh_init(s2i);
-    khash_t(s2i) *long_refs = NULL;
-    if (!h || !d)
-        goto error;
-
-    int ret, has_SQ = 0;
-    int next_c = '@';
-    while (next_c == '@' && (ret = hts_getline(fp, KS_SEP_LINE, &fp->line)) >= 0) {
-        if (fp->line.s[0] != '@')
-            break;
-
-        if (fp->line.l > 3 && strncmp(fp->line.s, "@SQ", 3) == 0) {
-            has_SQ = 1;
-            hts_pos_t ln = -1;
-            for (q = fp->line.s + 4;; ++q) {
-                if (strncmp(q, "SN:", 3) == 0) {
-                    q += 3;
-                    for (r = q;*r != '\t' && *r != '\n' && *r != '\0';++r);
-
-                    if (sn) {
-                        hts_log_warning("SQ header line has more than one SN: tag");
-                        free(sn);
-                    }
-                    sn = (char*)calloc(r - q + 1, 1);
-                    if (!sn)
-                        goto error;
-
-                    strncpy(sn, q, r - q);
-                    q = r;
-                } else {
-                    if (strncmp(q, "LN:", 3) == 0)
-                        ln = strtoll(q + 3, (char**)&q, 10);
-                }
-
-                while (*q != '\t' && *q != '\n' && *q != '\0')
-                    ++q;
-                if (*q == '\0' || *q == '\n')
-                    break;
-            }
-            if (sn) {
-                if (ln >= 0) {
-                    int absent;
-                    k = kh_put(s2i, d, sn, &absent);
-                    if (absent < 0)
-                        goto error;
-
-                    if (!absent) {
-                        hts_log_warning("Duplicated sequence '%s'", sn);
-                        free(sn);
-                    } else {
-                        if (ln >= UINT32_MAX) {
-                            // Stash away ref length that
-                            // doesn't fit in target_len array
-                            int k2;
-                            if (!long_refs) {
-                                long_refs = kh_init(s2i);
-                                if (!long_refs)
-                                    goto error;
-                            }
-                            k2 = kh_put(s2i, long_refs, sn, &absent);
-                            if (absent < 0)
-                                goto error;
-                            kh_val(long_refs, k2) = ln;
-                            kh_val(d, k) = ((int64_t) (kh_size(d) - 1) << 32
-                                            | UINT32_MAX);
-                        } else {
-                            kh_val(d, k) = (int64_t) (kh_size(d) - 1) << 32 | ln;
-                        }
-                    }
-                } else {
-                    hts_log_warning("Ignored @SQ SN:%s : bad or missing LN tag", sn);
-                    free(sn);
-                }
-            } else {
-                hts_log_warning("Ignored @SQ line with missing SN: tag");
-            }
-            sn = NULL;
-        }
-        if (kputsn(fp->line.s, fp->line.l, &str) < 0)
-            goto error;
-
-        if (kputc('\n', &str) < 0)
-            goto error;
-
-        if (fp->is_bgzf) {
-            next_c = bgzf_peek(fp->fp.bgzf);
-        } else {
-            unsigned char nc;
-            ssize_t pret = hpeek(fp->fp.hfile, &nc, 1);
-            next_c = pret > 0 ? nc : pret - 1;
-        }
-        if (next_c < -1)
-            goto error;
-    }
-    if (next_c != '@')
-        fp->line.l = 0;
-
-    if (ret < -1)
-        goto error;
-
-    if (!has_SQ && fp->fn_aux) {
-        kstring_t line = { 0, 0, NULL };
-
-        /* The reference index (.fai) is actually needed here */
-        char *fai_fn = fp->fn_aux;
-        char *fn_delim = strstr(fp->fn_aux, HTS_IDX_DELIM);
-        if (fn_delim)
-            fai_fn = fn_delim + strlen(HTS_IDX_DELIM);
-
-        hFILE* f = hopen(fai_fn, "r");
-        int e = 0, absent;
-        if (f == NULL)
-            goto error;
-
-        while (line.l = 0, kgetline(&line, (kgets_func*) hgets, f) >= 0) {
-            char* tab = strchr(line.s, '\t');
-            hts_pos_t ln;
-
-            if (tab == NULL)
-                continue;
-
-            sn = (char*)calloc(tab-line.s+1, 1);
-            if (!sn)
-                break;
-            memcpy(sn, line.s, tab-line.s);
-            k = kh_put(s2i, d, sn, &absent);
-            if (absent < 0)
-                break;
-
-            ln = strtoll(tab, NULL, 10);
-
-            if (!absent) {
-                hts_log_warning("Duplicated sequence '%s'", sn);
-                free(sn);
-            } else {
-                if (ln >= UINT32_MAX) {
-                    // Stash away ref length that
-                    // doesn't fit in target_len array
-                    khint_t k2;
-                    int absent = -1;
-                    if (!long_refs) {
-                        long_refs = kh_init(s2i);
-                        if (!long_refs)
-                            goto error;
-                    }
-                    k2 = kh_put(s2i, long_refs, sn, &absent);
-                    if (absent < 0)
-                        goto error;
-                    kh_val(long_refs, k2) = ln;
-                    kh_val(d, k) = ((int64_t) (kh_size(d) - 1) << 32
-                                    | UINT32_MAX);
-                } else {
-                    kh_val(d, k) = (int64_t) (kh_size(d) - 1) << 32 | ln;
-                }
-                has_SQ = 1;
-            }
-
-            e |= kputs("@SQ\tSN:", &str) < 0;
-            e |= kputsn(line.s, tab - line.s, &str) < 0;
-            e |= kputs("\tLN:", &str) < 0;
-            e |= kputll(ln, &str) < 0;
-            e |= kputc('\n', &str) < 0;
-            if (e)
-                break;
-        }
-
-        ks_free(&line);
-        if (hclose(f) != 0) {
-            hts_log_error("Error on closing %s", fai_fn);
-            e = 1;
-        }
-        if (e)
-            goto error;
-    }
-
-    if (has_SQ) {
-        // Populate the targets array
-        h->n_targets = kh_size(d);
-
-        h->target_name = (char**) malloc(sizeof(char*) * h->n_targets);
-        if (!h->target_name) {
-            h->n_targets = 0;
-            goto error;
-        }
-
-        h->target_len = (uint32_t*) malloc(sizeof(uint32_t) * h->n_targets);
-        if (!h->target_len) {
-            h->n_targets = 0;
-            goto error;
-        }
-
-        for (k = kh_begin(d); k != kh_end(d); ++k) {
-            if (!kh_exist(d, k))
-                continue;
-
-            h->target_name[kh_val(d, k) >> 32] = (char*) kh_key(d, k);
-            h->target_len[kh_val(d, k) >> 32] = kh_val(d, k) & 0xffffffffUL;
-            kh_val(d, k) >>= 32;
-        }
-    }
-
-    // Repurpose sdict to hold any references longer than UINT32_MAX
-    h->sdict = long_refs;
-
-    kh_destroy(s2i, d);
-
-    if (str.l == 0)
-        kputsn("", 0, &str);
-    h->l_text = str.l;
-    h->text = ks_release(&str);
-    fp->bam_header = sam_hdr_sanitise(h);
-    fp->bam_header->ref_count = 1;
-
-    return fp->bam_header;
-
- error:
-    if (h && d && (!h->target_name || !h->target_len)) {
-        for (k = kh_begin(d); k != kh_end(d); ++k)
-            if (kh_exist(d, k)) free((void *)kh_key(d, k));
-    }
-    sam_hdr_destroy(h);
-    ks_free(&str);
-    kh_destroy(s2i, d);
-    kh_destroy(s2i, long_refs);
-    if (sn) free(sn);
-    return NULL;
-}
-
-sam_hdr_t *sam_hdr_read(htsFile *fp)
-{
-    if (!fp) {
-        errno = EINVAL;
-        return NULL;
-    }
-
-    switch (fp->format.format) {
-    case bam:
-        return sam_hdr_sanitise(bam_hdr_read(fp->fp.bgzf));
-
-    case cram:
-        return sam_hdr_sanitise(sam_hdr_dup(fp->fp.cram->header));
-
-    case sam:
-        return sam_hdr_create(fp);
-
-    case empty_format:
-        errno = EPIPE;
-        return NULL;
-
-    default:
-        errno = EFTYPE;
-        return NULL;
-    }
-}
-
-int sam_hdr_write(htsFile *fp, const sam_hdr_t *h)
-{
-    if (!fp || !h) {
-        errno = EINVAL;
-        return -1;
-    }
-
-    if (!h->hrecs && !h->text)
-        return 0;
-
-    switch (fp->format.format) {
-    case binary_format:
-        fp->format.category = sequence_data;
-        fp->format.format = bam;
-        /* fall-through */
-    case bam:
-        if (bam_hdr_write(fp->fp.bgzf, h) < 0) return -1;
-        break;
-
-    case cram: {
-        cram_fd *fd = fp->fp.cram;
-        if (cram_set_header2(fd, h) < 0) return -1;
-        if (fp->fn_aux)
-            cram_load_reference(fd, fp->fn_aux);
-        if (cram_write_SAM_hdr(fd, fd->header) < 0) return -1;
-        }
-        break;
-
-    case text_format:
-        fp->format.category = sequence_data;
-        fp->format.format = sam;
-        /* fall-through */
-    case sam: {
-        char *text;
-        kstring_t hdr_ks = { 0, 0, NULL };
-        size_t l_text;
-        ssize_t bytes;
-        int r = 0, no_sq = 0;
-
-        if (h->hrecs) {
-            if (sam_hrecs_rebuild_text(h->hrecs, &hdr_ks) != 0)
-                return -1;
-            text = hdr_ks.s;
-            l_text = hdr_ks.l;
-        } else {
-            const char *p = NULL;
-            do {
-                const char *q = p == NULL ? h->text : p + 4;
-                p = strstr(q, "@SQ\t");
-            } while (!(p == NULL || p == h->text || *(p - 1) == '\n'));
-            no_sq = p == NULL;
-            text = h->text;
-            l_text = h->l_text;
-        }
-
-        if (fp->is_bgzf) {
-            bytes = bgzf_write(fp->fp.bgzf, text, l_text);
-        } else {
-            bytes = hwrite(fp->fp.hfile, text, l_text);
-        }
-        free(hdr_ks.s);
-        if (bytes != l_text)
-            return -1;
-
-        if (no_sq) {
-            int i;
-            for (i = 0; i < h->n_targets; ++i) {
-                fp->line.l = 0;
-                r |= kputsn("@SQ\tSN:", 7, &fp->line) < 0;
-                r |= kputs(h->target_name[i], &fp->line) < 0;
-                r |= kputsn("\tLN:", 4, &fp->line) < 0;
-                r |= kputw(h->target_len[i], &fp->line) < 0;
-                r |= kputc('\n', &fp->line) < 0;
-                if (r != 0)
-                    return -1;
-
-                if (fp->is_bgzf) {
-                    bytes = bgzf_write(fp->fp.bgzf, fp->line.s, fp->line.l);
-                } else {
-                    bytes = hwrite(fp->fp.hfile, fp->line.s, fp->line.l);
-                }
-                if (bytes != fp->line.l)
-                    return -1;
-            }
-        }
-        if (fp->is_bgzf) {
-            if (bgzf_flush(fp->fp.bgzf) != 0) return -1;
-        } else {
-            if (hflush(fp->fp.hfile) != 0) return -1;
-        }
-        }
-        break;
-
-    default:
-        errno = EBADF;
-        return -1;
-    }
-    return 0;
-}
-
-static int old_sam_hdr_change_HD(sam_hdr_t *h, const char *key, const char *val)
-{
-    char *p, *q, *beg = NULL, *end = NULL, *newtext;
-    size_t new_l_text;
-    if (!h || !key)
-        return -1;
-
-    if (h->l_text > 3) {
-        if (strncmp(h->text, "@HD", 3) == 0) { //@HD line exists
-            if ((p = strchr(h->text, '\n')) == 0) return -1;
-            *p = '\0'; // for strstr call
-
-            char tmp[5] = { '\t', key[0], key[0] ? key[1] : '\0', ':', '\0' };
-
-            if ((q = strstr(h->text, tmp)) != 0) { // key exists
-                *p = '\n'; // change back
-
-                // mark the key:val
-                beg = q;
-                for (q += 4; *q != '\n' && *q != '\t'; ++q);
-                end = q;
-
-                if (val && (strncmp(beg + 4, val, end - beg - 4) == 0)
-                    && strlen(val) == end - beg - 4)
-                     return 0; // val is the same, no need to change
-
-            } else {
-                beg = end = p;
-                *p = '\n';
-            }
-        }
-    }
-    if (beg == NULL) { // no @HD
-        new_l_text = h->l_text;
-        if (new_l_text > SIZE_MAX - strlen(SAM_FORMAT_VERSION) - 9)
-            return -1;
-        new_l_text += strlen(SAM_FORMAT_VERSION) + 8;
-        if (val) {
-            if (new_l_text > SIZE_MAX - strlen(val) - 5)
-                return -1;
-            new_l_text += strlen(val) + 4;
-        }
-        newtext = (char*)malloc(new_l_text + 1);
-        if (!newtext) return -1;
-
-        if (val)
-            snprintf(newtext, new_l_text + 1,
-                    "@HD\tVN:%s\t%s:%s\n%s", SAM_FORMAT_VERSION, key, val, h->text);
-        else
-            snprintf(newtext, new_l_text + 1,
-                    "@HD\tVN:%s\n%s", SAM_FORMAT_VERSION, h->text);
-    } else { // has @HD but different or no key
-        new_l_text = (beg - h->text) + (h->text + h->l_text - end);
-        if (val) {
-            if (new_l_text > SIZE_MAX - strlen(val) - 5)
-                return -1;
-            new_l_text += strlen(val) + 4;
-        }
-        newtext = (char*)malloc(new_l_text + 1);
-        if (!newtext) return -1;
-
-        if (val) {
-            snprintf(newtext, new_l_text + 1, "%.*s\t%s:%s%s",
-                    (int) (beg - h->text), h->text, key, val, end);
-        } else { //delete key
-            snprintf(newtext, new_l_text + 1, "%.*s%s",
-                    (int) (beg - h->text), h->text, end);
-        }
-    }
-    free(h->text);
-    h->text = newtext;
-    h->l_text = new_l_text;
-    return 0;
-}
-
-
-int sam_hdr_change_HD(sam_hdr_t *h, const char *key, const char *val)
-{
-    if (!h || !key)
-        return -1;
-
-    if (!h->hrecs)
-        return old_sam_hdr_change_HD(h, key, val);
-
-    if (val) {
-        if (sam_hdr_update_line(h, "HD", NULL, NULL, key, val, NULL) != 0)
-            return -1;
-    } else {
-        if (sam_hdr_remove_tag_id(h, "HD", NULL, NULL, key) != 0)
-            return -1;
-    }
-    return sam_hdr_rebuild(h);
-}
-/**********************
- *** SAM record I/O ***
- **********************/
-
-static int sam_parse_B_vals(char type, uint32_t n, char *in, char **end,
-                            char *r, bam1_t *b)
-{
-    int orig_l = b->l_data;
-    char *q = in;
-    int32_t size;
-    size_t bytes;
-    int overflow = 0;
-
-    size = aux_type2size(type);
-    if (size <= 0 || size > 4) {
-        hts_log_error("Unrecognized type B:%c", type);
-        return -1;
-    }
-
-    // Ensure space for type + values
-    bytes = (size_t) n * (size_t) size;
-    if (bytes / size != n
-        || possibly_expand_bam_data(b, bytes + 2 + sizeof(uint32_t))) {
-        hts_log_error("Out of memory");
-        return -1;
-    }
-
-    b->data[b->l_data++] = 'B';
-    b->data[b->l_data++] = type;
-    i32_to_le(n, b->data + b->l_data);
-    b->l_data += sizeof(uint32_t);
-    // This ensures that q always ends up at the next comma after
-    // reading a number even if it's followed by junk.  It
-    // prevents the possibility of trying to read more than n items.
-#define skip_to_comma_(q) do { while (*(q) > '\t' && *(q) != ',') (q)++; } while (0)
-    if (type == 'c') {
-        while (q < r) {
-            *(b->data + b->l_data) = hts_str2int(q + 1, &q, 8, &overflow);
-            b->l_data++;
-            skip_to_comma_(q);
-        }
-    } else if (type == 'C') {
-        while (q < r) {
-            if (*q != '-') {
-                *(b->data + b->l_data) = hts_str2uint(q + 1, &q, 8, &overflow);
-                b->l_data++;
-            } else {
-                overflow = 1;
-            }
-            skip_to_comma_(q);
-        }
-    } else if (type == 's') {
-        while (q < r) {
-            i16_to_le(hts_str2int(q + 1, &q, 16, &overflow), b->data + b->l_data);
-            b->l_data += 2;
-            skip_to_comma_(q);
-        }
-    } else if (type == 'S') {
-        while (q < r) {
-            if (*q != '-') {
-                u16_to_le(hts_str2uint(q + 1, &q, 16, &overflow), b->data + b->l_data);
-                b->l_data += 2;
-            } else {
-                overflow = 1;
-            }
-            skip_to_comma_(q);
-        }
-    } else if (type == 'i') {
-        while (q < r) {
-            i32_to_le(hts_str2int(q + 1, &q, 32, &overflow), b->data + b->l_data);
-            b->l_data += 4;
-            skip_to_comma_(q);
-        }
-    } else if (type == 'I') {
-        while (q < r) {
-            if (*q != '-') {
-                u32_to_le(hts_str2uint(q + 1, &q, 32, &overflow), b->data + b->l_data);
-                b->l_data += 4;
-            } else {
-                overflow = 1;
-            }
-            skip_to_comma_(q);
-        }
-    } else if (type == 'f') {
-        while (q < r) {
-            float_to_le(strtod(q + 1, &q), b->data + b->l_data);
-            b->l_data += 4;
-            skip_to_comma_(q);
-        }
-    } else {
-        hts_log_error("Unrecognized type B:%c", type);
-        return -1;
-    }
-
-    if (!overflow) {
-        *end = q;
-        return 0;
-    } else {
-        int64_t max = 0, min = 0, val;
-        // Given type was incorrect.  Try to rescue the situation.
-        q = in;
-        overflow = 0;
-        b->l_data = orig_l;
-        // Find out what range of values is present
-        while (q < r) {
-            val = hts_str2int(q + 1, &q, 64, &overflow);
-            if (max < val) max = val;
-            if (min > val) min = val;
-            skip_to_comma_(q);
-        }
-        // Retry with appropriate type
-        if (!overflow) {
-            if (min < 0) {
-                if (min >= INT8_MIN && max <= INT8_MAX) {
-                    return sam_parse_B_vals('c', n, in, end, r, b);
-                } else if (min >= INT16_MIN && max <= INT16_MAX) {
-                    return sam_parse_B_vals('s', n, in, end, r, b);
-                } else if (min >= INT32_MIN && max <= INT32_MAX) {
-                    return sam_parse_B_vals('i', n, in, end, r, b);
-                }
-            } else {
-                if (max < UINT8_MAX) {
-                    return sam_parse_B_vals('C', n, in, end, r, b);
-                } else if (max <= UINT16_MAX) {
-                    return sam_parse_B_vals('S', n, in, end, r, b);
-                } else if (max <= UINT32_MAX) {
-                    return sam_parse_B_vals('I', n, in, end, r, b);
-                }
-            }
-        }
-        // If here then at least one of the values is too big to store
-        hts_log_error("Numeric value in B array out of allowed range");
-        return -1;
-    }
-#undef skip_to_comma_
-}
-
-static inline unsigned int parse_sam_flag(char *v, char **rv, int *overflow) {
-    if (*v >= '1' && *v <= '9') {
-        return hts_str2uint(v, rv, 16, overflow);
-    }
-    else if (*v == '0') {
-        // handle single-digit "0" directly; otherwise it's hex or octal
-        if (v[1] == '\t') { *rv = v+1; return 0; }
-        else {
-            unsigned long val = strtoul(v, rv, 0);
-            if (val > 65535) { *overflow = 1; return 65535; }
-            return val;
-        }
-    }
-    else {
-        // TODO implement symbolic flag letters
-        *rv = v;
-        return 0;
-    }
-}
-
-int sam_parse1(kstring_t *s, sam_hdr_t *h, bam1_t *b)
-{
-#define _read_token(_p) (_p); do { char *tab = strchr((_p), '\t'); if (!tab) goto err_ret; *tab = '\0'; (_p) = tab + 1; } while (0)
-
-#if HTS_ALLOW_UNALIGNED != 0 && ULONG_MAX == 0xffffffffffffffff
-
-// Macro that operates on 64-bits at a time.
-#define COPY_MINUS_N(to,from,n,l,failed)                        \
-    do {                                                        \
-        uint64_u *from8 = (uint64_u *)(from);                   \
-        uint64_u *to8 = (uint64_u *)(to);                       \
-        uint64_t uflow = 0;                                     \
-        size_t l8 = (l)>>3, i;                                  \
-        for (i = 0; i < l8; i++) {                              \
-            to8[i] = from8[i] - (n)*0x0101010101010101UL;       \
-            uflow |= to8[i];                                    \
-        }                                                       \
-        for (i<<=3; i < (l); ++i) {                             \
-            to[i] = from[i] - (n);                              \
-            uflow |= to[i];                                     \
-        }                                                       \
-        failed = (uflow & 0x8080808080808080UL) > 0;            \
-    } while (0)
-
-#else
-
-// Basic version which operates a byte at a time
-#define COPY_MINUS_N(to,from,n,l,failed) do {                \
-        uint8_t uflow = 0;                                   \
-        for (i = 0; i < (l); ++i) {                          \
-            (to)[i] = (from)[i] - (n);                       \
-            uflow |= (uint8_t) (to)[i];                      \
-        }                                                    \
-        failed = (uflow & 0x80) > 0;                         \
-    } while (0)
-
-#endif
-
-#define _get_mem(type_t, x, b, l) if (possibly_expand_bam_data((b), (l)) < 0) goto err_ret; *(x) = (type_t*)((b)->data + (b)->l_data); (b)->l_data += (l)
-#define _parse_err(cond, ...) do { if (cond) { hts_log_error(__VA_ARGS__); goto err_ret; } } while (0)
-#define _parse_warn(cond, ...) do { if (cond) { hts_log_warning(__VA_ARGS__); } } while (0)
-
-    uint8_t *t;
-
-    char *p = s->s, *q;
-    int i, overflow = 0;
-    char logbuf[40];
-    hts_pos_t cigreflen;
-    bam1_core_t *c = &b->core;
-
-    b->l_data = 0;
-    memset(c, 0, 32);
-
-    // qname
-    q = _read_token(p);
-
-    _parse_warn(p - q <= 1, "empty query name");
-    _parse_err(p - q > 255, "query name too long");
-    // resize large enough for name + extranul
-    if (possibly_expand_bam_data(b, (p - q) + 4) < 0) goto err_ret;
-    memcpy(b->data + b->l_data, q, p-q); b->l_data += p-q;
-
-    c->l_extranul = (4 - (b->l_data & 3)) & 3;
-    memcpy(b->data + b->l_data, "\0\0\0\0", c->l_extranul);
-    b->l_data += c->l_extranul;
-
-    c->l_qname = p - q + c->l_extranul;
-
-    // flag
-    c->flag = parse_sam_flag(p, &p, &overflow);
-    if (*p++ != '\t') goto err_ret; // malformated flag
-
-    // chr
-    q = _read_token(p);
-    if (strcmp(q, "*")) {
-        _parse_err(h->n_targets == 0, "no SQ lines present in the header");
-        c->tid = bam_name2id(h, q);
-        _parse_err(c->tid < -1, "failed to parse header");
-        _parse_warn(c->tid < 0, "unrecognized reference name %s; treated as unmapped", hts_strprint(logbuf, sizeof logbuf, '"', q, SIZE_MAX));
-    } else c->tid = -1;
-
-    // pos
-    c->pos = hts_str2uint(p, &p, 63, &overflow) - 1;
-    if (*p++ != '\t') goto err_ret;
-    if (c->pos < 0 && c->tid >= 0) {
-        _parse_warn(1, "mapped query cannot have zero coordinate; treated as unmapped");
-        c->tid = -1;
-    }
-    if (c->tid < 0) c->flag |= BAM_FUNMAP;
-
-    // mapq
-    c->qual = hts_str2uint(p, &p, 8, &overflow);
-    if (*p++ != '\t') goto err_ret;
-    // cigar
-    if (*p != '*') {
-        uint32_t *cigar = NULL;
-        int old_l_data = b->l_data;
-        int n_cigar = bam_parse_cigar(p, &p, b);
-        if (n_cigar < 1 || *p++ != '\t') goto err_ret;
-        cigar = (uint32_t *)(b->data + old_l_data);
-        c->n_cigar = n_cigar;
-
-        // can't use bam_endpos() directly as some fields not yet set up
-        cigreflen = (!(c->flag&BAM_FUNMAP))? bam_cigar2rlen(c->n_cigar, cigar) : 1;
-        if (cigreflen == 0) cigreflen = 1;
-    } else {
-        _parse_warn(!(c->flag&BAM_FUNMAP), "mapped query must have a CIGAR; treated as unmapped");
-        c->flag |= BAM_FUNMAP;
-        q = _read_token(p);
-        cigreflen = 1;
-    }
-    _parse_err(HTS_POS_MAX - cigreflen <= c->pos,
-               "read ends beyond highest supported position");
-    c->bin = hts_reg2bin(c->pos, c->pos + cigreflen, 14, 5);
-    // mate chr
-    q = _read_token(p);
-    if (strcmp(q, "=") == 0) {
-        c->mtid = c->tid;
-    } else if (strcmp(q, "*") == 0) {
-        c->mtid = -1;
-    } else {
-        c->mtid = bam_name2id(h, q);
-        _parse_err(c->mtid < -1, "failed to parse header");
-        _parse_warn(c->mtid < 0, "unrecognized mate reference name %s; treated as unmapped", hts_strprint(logbuf, sizeof logbuf, '"', q, SIZE_MAX));
-    }
-    // mpos
-    c->mpos = hts_str2uint(p, &p, 63, &overflow) - 1;
-    if (*p++ != '\t') goto err_ret;
-    if (c->mpos < 0 && c->mtid >= 0) {
-        _parse_warn(1, "mapped mate cannot have zero coordinate; treated as unmapped");
-        c->mtid = -1;
-    }
-    // tlen
-    c->isize = hts_str2int(p, &p, 64, &overflow);
-    if (*p++ != '\t') goto err_ret;
-    // seq
-    q = _read_token(p);
-    if (strcmp(q, "*")) {
-        _parse_err(p - q - 1 > INT32_MAX, "read sequence is too long");
-        c->l_qseq = p - q - 1;
-        hts_pos_t ql = bam_cigar2qlen(c->n_cigar, (uint32_t*)(b->data + c->l_qname));
-        _parse_err(c->n_cigar && ql != c->l_qseq, "CIGAR and query sequence are of different length");
-        i = (c->l_qseq + 1) >> 1;
-        _get_mem(uint8_t, &t, b, i);
-
-        unsigned int lqs2 = c->l_qseq&~1, i;
-        for (i = 0; i < lqs2; i+=2)
-            t[i>>1] = (seq_nt16_table[(unsigned char)q[i]] << 4) | seq_nt16_table[(unsigned char)q[i+1]];
-        for (; i < c->l_qseq; ++i)
-            t[i>>1] = seq_nt16_table[(unsigned char)q[i]] << ((~i&1)<<2);
-    } else c->l_qseq = 0;
-    // qual
-    _get_mem(uint8_t, &t, b, c->l_qseq);
-    if (p[0] == '*' && (p[1] == '\t' || p[1] == '\0')) {
-        memset(t, 0xff, c->l_qseq);
-        p += 2;
-    } else {
-        int failed = 0;
-        _parse_err(s->l - (p - s->s) < c->l_qseq
-                   || (p[c->l_qseq] != '\t' && p[c->l_qseq] != '\0'),
-                   "SEQ and QUAL are of different length");
-        COPY_MINUS_N(t, p, 33, c->l_qseq, failed);
-        _parse_err(failed, "invalid QUAL character");
-        p += c->l_qseq + 1;
-    }
-    // aux
-    q = p;
-    p = s->s + s->l;
-    while (q < p) {
-        char type;
-        _parse_err(p - q < 5, "incomplete aux field");
-        _parse_err(q[0] < '!' || q[1] < '!', "invalid aux tag id");
-        // Copy over id
-        if (possibly_expand_bam_data(b, 2) < 0) goto err_ret;
-        memcpy(b->data + b->l_data, q, 2); b->l_data += 2;
-        q += 3; type = *q++; ++q; // q points to value
-        if (type != 'Z' && type != 'H') // the only zero length acceptable fields
-            _parse_err(*q <= '\t', "incomplete aux field");
-
-        // Ensure enough space for a double + type allocated.
-        if (possibly_expand_bam_data(b, 16) < 0) goto err_ret;
-
-        if (type == 'A' || type == 'a' || type == 'c' || type == 'C') {
-            b->data[b->l_data++] = 'A';
-            b->data[b->l_data++] = *q++;
-        } else if (type == 'i' || type == 'I') {
-            if (*q == '-') {
-                int32_t x = hts_str2int(q, &q, 32, &overflow);
-                if (x >= INT8_MIN) {
-                    b->data[b->l_data++] = 'c';
-                    b->data[b->l_data++] = x;
-                } else if (x >= INT16_MIN) {
-                    b->data[b->l_data++] = 's';
-                    i16_to_le(x, b->data + b->l_data);
-                    b->l_data += 2;
-                } else {
-                    b->data[b->l_data++] = 'i';
-                    i32_to_le(x, b->data + b->l_data);
-                    b->l_data += 4;
-                }
-            } else {
-                uint32_t x = hts_str2uint(q, &q, 32, &overflow);
-                if (x <= UINT8_MAX) {
-                    b->data[b->l_data++] = 'C';
-                    b->data[b->l_data++] = x;
-                } else if (x <= UINT16_MAX) {
-                    b->data[b->l_data++] = 'S';
-                    u16_to_le(x, b->data + b->l_data);
-                    b->l_data += 2;
-                } else {
-                    b->data[b->l_data++] = 'I';
-                    u32_to_le(x, b->data + b->l_data);
-                    b->l_data += 4;
-                }
-            }
-        } else if (type == 'f') {
-            b->data[b->l_data++] = 'f';
-            float_to_le(strtod(q, &q), b->data + b->l_data);
-            b->l_data += sizeof(float);
-        } else if (type == 'd') {
-            b->data[b->l_data++] = 'd';
-            double_to_le(strtod(q, &q), b->data + b->l_data);
-            b->l_data += sizeof(double);
-        } else if (type == 'Z' || type == 'H') {
-            char *end = strchr(q, '\t');
-            if (!end) end = q + strlen(q);
-            _parse_err(type == 'H' && ((end-q)&1) != 0,
-                       "hex field does not have an even number of digits");
-            b->data[b->l_data++] = type;
-            if (possibly_expand_bam_data(b, end - q + 1) < 0) goto err_ret;
-            memcpy(b->data + b->l_data, q, end - q);
-            b->l_data += end - q;
-            b->data[b->l_data++] = '\0';
-            q = end;
-        } else if (type == 'B') {
-            uint32_t n;
-            char *r;
-            type = *q++; // q points to the first ',' following the typing byte
-            _parse_err(*q && *q != ',' && *q != '\t',
-                       "B aux field type not followed by ','");
-
-            for (r = q, n = 0; *r > '\t'; ++r)
-                if (*r == ',') ++n;
-
-            if (sam_parse_B_vals(type, n, q, &q, r, b) < 0)
-                goto err_ret;
-        } else _parse_err(1, "unrecognized type %s", hts_strprint(logbuf, sizeof logbuf, '\'', &type, 1));
-
-        while (*q > '\t') { q++; } // Skip any junk to next tab
-        q++;
-    }
-
-    _parse_err(overflow != 0, "numeric value out of allowed range");
-
-    if (bam_tag2cigar(b, 1, 1) < 0)
-        return -2;
-    return 0;
-
-#undef _parse_warn
-#undef _parse_err
-#undef _get_mem
-#undef _read_token
-err_ret:
-    return -2;
-}
-
-static uint32_t read_ncigar(const char *q) {
-    uint32_t n_cigar = 0;
-    for (; *q && *q != '\t'; ++q)
-        if (!isdigit_c(*q)) ++n_cigar;
-    if (!n_cigar) {
-        hts_log_error("No CIGAR operations");
-        return 0;
-    }
-    if (n_cigar >= 2147483647) {
-        hts_log_error("Too many CIGAR operations");
-        return 0;
-    }
-
-    return n_cigar;
-}
-
-/*! @function
- @abstract  Parse a CIGAR string into preallocated a uint32_t array
- @param  in      [in]  pointer to the source string
- @param  a_cigar [out]  address of the destination uint32_t buffer
- @return         number of processed input characters; 0 on error
- */
-static int parse_cigar(const char *in, uint32_t *a_cigar, uint32_t n_cigar) {
-    int i, overflow = 0;
-    const char *p = in;
-    for (i = 0; i < n_cigar; i++) {
-        uint32_t len;
-        int op;
-        char *q;
-        len = hts_str2uint(p, &q, 28, &overflow)<<BAM_CIGAR_SHIFT;
-        if (q == p) {
-            hts_log_error("CIGAR length invalid at position %d (%s)", (int)(i+1), p);
-            return 0;
-        }
-        if (overflow) {
-            hts_log_error("CIGAR length too long at position %d (%.*s)", (int)(i+1), (int)(q-p+1), p);
-            return 0;
-        }
-        p = q;
-        op = bam_cigar_table[(unsigned char)*p++];
-        if (op < 0) {
-            hts_log_error("Unrecognized CIGAR operator");
-            return 0;
-        }
-        a_cigar[i] = len;
-        a_cigar[i] |= op;
-    }
-
-    return p-in;
-}
-
-ssize_t sam_parse_cigar(const char *in, char **end, uint32_t **a_cigar, size_t *a_mem) {
-    size_t n_cigar = 0;
-    int diff;
-
-    if (!in || !a_cigar || !a_mem) {
-        hts_log_error("NULL pointer arguments");
-        return -1;
-    }
-    if (end) *end = (char *)in;
-
-    if (*in == '*') {
-        if (end) (*end)++;
-        return 0;
-    }
-    n_cigar = read_ncigar(in);
-    if (!n_cigar) return 0;
-    if (n_cigar > *a_mem) {
-        uint32_t *a_tmp = realloc(*a_cigar, n_cigar*sizeof(**a_cigar));
-        if (a_tmp) {
-            *a_cigar = a_tmp;
-            *a_mem = n_cigar;
-        } else {
-            hts_log_error("Memory allocation error");
-            return -1;
-        }
-    }
-
-    if (!(diff = parse_cigar(in, *a_cigar, n_cigar))) return -1;
-    if (end) *end = (char *)in+diff;
-
-    return n_cigar;
-}
-
-ssize_t bam_parse_cigar(const char *in, char **end, bam1_t *b) {
-    size_t n_cigar = 0;
-    int diff;
-
-    if (!in || !b) {
-        hts_log_error("NULL pointer arguments");
-        return -1;
-    }
-    if (end) *end = (char *)in;
-
-    if (*in == '*') {
-        if (end) (*end)++;
-        return 0;
-    }
-    n_cigar = read_ncigar(in);
-    if (!n_cigar) return 0;
-    if (possibly_expand_bam_data(b, n_cigar * sizeof(uint32_t)) < 0) {
-        hts_log_error("Memory allocation error");
-        return -1;
-    }
-
-    if (!(diff = parse_cigar(in, (uint32_t *)(b->data + b->l_data), n_cigar))) return -1;
-    b->l_data += (n_cigar * sizeof(uint32_t));
-    if (end) *end = (char *)in+diff;
-
-    return n_cigar;
-}
-
-/*
- * -----------------------------------------------------------------------------
- * SAM threading
- */
-// Size of SAM text block (reading)
-#define NM 240000
-// Number of BAM records (writing)
-#define NB 1000
-
-struct SAM_state;
-
-// Output job - a block of BAM records
-typedef struct sp_bams {
-    struct sp_bams *next;
-    int serial;
-
-    bam1_t *bams;
-    int nbams, abams; // used and alloc
-
-    struct SAM_state *fd;
-} sp_bams;
-
-// Input job - a block of SAM text
-typedef struct sp_lines {
-    struct sp_lines *next;
-    int serial;
-
-    char *data;
-    int data_size;
-    int alloc;
-
-    struct SAM_state *fd;
-    sp_bams *bams;
-} sp_lines;
-
-enum sam_cmd {
-    SAM_NONE = 0,
-    SAM_CLOSE,
-    SAM_CLOSE_DONE,
-};
-
-typedef struct SAM_state {
-    sam_hdr_t *h;
-
-    hts_tpool *p;
-    int own_pool;
-    pthread_mutex_t lines_m;
-    hts_tpool_process *q;
-    pthread_t dispatcher;
-    int dispatcher_set;
-
-    sp_lines *lines;
-    sp_bams *bams;
-
-    sp_bams *curr_bam;
-    int curr_idx;
-    int serial;
-
-    // Be warned: moving these mutexes around in this struct can reduce
-    // threading performance by up to 70%!
-    pthread_mutex_t command_m;
-    pthread_cond_t command_c;
-    enum sam_cmd command;
-
-    // One of the E* errno codes
-    int errcode;
-
-    htsFile *fp;
-} SAM_state;
-
-// Returns a SAM_state struct from a generic hFILE.
-//
-// Returns NULL on failure.
-static SAM_state *sam_state_create(htsFile *fp) {
-    // Ideally sam_open wouldn't be a #define to hts_open but instead would
-    // be a redirect call with an additional 'S' mode.  This in turn would
-    // correctly set the designed format to sam instead of a generic
-    // text_format.
-    if (fp->format.format != sam && fp->format.format != text_format)
-        return NULL;
-
-    SAM_state *fd = calloc(1, sizeof(*fd));
-    if (!fd)
-        return NULL;
-
-    fp->state = fd;
-    fd->fp = fp;
-
-    return fd;
-}
-
-static int sam_format1_append(const bam_hdr_t *h, const bam1_t *b, kstring_t *str);
-static void *sam_format_worker(void *arg);
-
-static void sam_state_err(SAM_state *fd, int errcode) {
-    pthread_mutex_lock(&fd->command_m);
-    if (!fd->errcode)
-        fd->errcode = errcode;
-    pthread_mutex_unlock(&fd->command_m);
-}
-
-static void sam_free_sp_bams(sp_bams *b) {
-    if (!b)
-        return;
-
-    if (b->bams) {
-        int i;
-        for (i = 0; i < b->abams; i++) {
-            if (b->bams[i].data)
-                free(b->bams[i].data);
-        }
-        free(b->bams);
-    }
-    free(b);
-}
-
-// Destroys the state produce by sam_state_create.
-int sam_state_destroy(htsFile *fp) {
-    int ret = 0;
-
-    if (!fp->state)
-        return 0;
-
-    SAM_state *fd = fp->state;
-    if (fd->p) {
-        if (fd->h) {
-            // Notify sam_dispatcher we're closing
-            pthread_mutex_lock(&fd->command_m);
-            if (fd->command != SAM_CLOSE_DONE)
-                fd->command = SAM_CLOSE;
-            pthread_cond_signal(&fd->command_c);
-            ret = -fd->errcode;
-            if (fd->q)
-                hts_tpool_wake_dispatch(fd->q); // unstick the reader
-
-            if (!fp->is_write && fd->q && fd->dispatcher_set) {
-                for (;;) {
-                    // Avoid deadlocks with dispatcher
-                    if (fd->command == SAM_CLOSE_DONE)
-                        break;
-                    hts_tpool_wake_dispatch(fd->q);
-                    pthread_mutex_unlock(&fd->command_m);
-                    usleep(10000);
-                    pthread_mutex_lock(&fd->command_m);
-                }
-            }
-            pthread_mutex_unlock(&fd->command_m);
-
-            if (fp->is_write) {
-                // Dispatch the last partial block.
-                sp_bams *gb = fd->curr_bam;
-                if (!ret && gb && gb->nbams > 0 && fd->q)
-                    ret = hts_tpool_dispatch(fd->p, fd->q, sam_format_worker, gb);
-
-                // Flush and drain output
-                if (fd->q)
-                    hts_tpool_process_flush(fd->q);
-                pthread_mutex_lock(&fd->command_m);
-                if (!ret) ret = -fd->errcode;
-                pthread_mutex_unlock(&fd->command_m);
-
-                while (!ret && fd->q && !hts_tpool_process_empty(fd->q)) {
-                    usleep(10000);
-                    pthread_mutex_lock(&fd->command_m);
-                    ret = -fd->errcode;
-                    // not empty but shutdown implies error
-                    if (hts_tpool_process_is_shutdown(fd->q) && !ret)
-                        ret = EIO;
-                    pthread_mutex_unlock(&fd->command_m);
-                }
-                if (fd->q)
-                    hts_tpool_process_shutdown(fd->q);
-            }
-
-            // Wait for it to acknowledge
-            if (fd->dispatcher_set)
-                pthread_join(fd->dispatcher, NULL);
-            if (!ret) ret = -fd->errcode;
-        }
-
-        // Tidy up memory
-        if (fd->q)
-            hts_tpool_process_destroy(fd->q);
-
-        if (fd->own_pool && fp->format.compression == no_compression) {
-            hts_tpool_destroy(fd->p);
-            fd->p = NULL;
-        }
-        pthread_mutex_destroy(&fd->lines_m);
-        pthread_mutex_destroy(&fd->command_m);
-        pthread_cond_destroy(&fd->command_c);
-
-        sp_lines *l = fd->lines;
-        while (l) {
-            sp_lines *n = l->next;
-            free(l->data);
-            free(l);
-            l = n;
-        }
-
-        sp_bams *b = fd->bams;
-        while (b) {
-            if (fd->curr_bam == b)
-                fd->curr_bam = NULL;
-            sp_bams *n = b->next;
-            sam_free_sp_bams(b);
-            b = n;
-        }
-
-        if (fd->curr_bam)
-            sam_free_sp_bams(fd->curr_bam);
-
-        // Decrement counter by one, maybe destroying too.
-        // This is to permit the caller using bam_hdr_destroy
-        // before sam_close without triggering decode errors
-        // in the background threads.
-        bam_hdr_destroy(fd->h);
-    }
-
-    free(fp->state);
-    fp->state = NULL;
-    return ret;
-}
-
-// Cleanup function - job for sam_parse_worker; result for sam_format_worker
-static void cleanup_sp_lines(void *arg) {
-    sp_lines *gl = (sp_lines *)arg;
-    if (!gl) return;
-
-    // Should always be true for lines passed to / from thread workers.
-    assert(gl->next == NULL);
-
-    free(gl->data);
-    sam_free_sp_bams(gl->bams);
-    free(gl);
-}
-
-// Run from one of the worker threads.
-// Convert a passed in array of lines to array of BAMs, returning
-// the result back to the thread queue.
-static void *sam_parse_worker(void *arg) {
-    sp_lines *gl = (sp_lines *)arg;
-    sp_bams *gb = NULL;
-    char *lines = gl->data;
-    int i;
-    bam1_t *b;
-    SAM_state *fd = gl->fd;
-
-    // Use a block of BAM structs we had earlier if available.
-    pthread_mutex_lock(&fd->lines_m);
-    if (fd->bams) {
-        gb = fd->bams;
-        fd->bams = gb->next;
-    }
-    pthread_mutex_unlock(&fd->lines_m);
-
-    if (gb == NULL) {
-        gb = calloc(1, sizeof(*gb));
-        if (!gb) {
-            return NULL;
-        }
-        gb->abams = 100;
-        gb->bams = b = calloc(gb->abams, sizeof(*b));
-        if (!gb->bams) {
-            sam_state_err(fd, ENOMEM);
-            goto err;
-        }
-        gb->nbams = 0;
-    }
-    gb->serial = gl->serial;
-    gb->next = NULL;
-
-    b = (bam1_t *)gb->bams;
-    if (!b) {
-        sam_state_err(fd, ENOMEM);
-        goto err;
-    }
-
-    i = 0;
-    char *cp = lines, *cp_end = lines + gl->data_size;
-    while (cp < cp_end) {
-        if (i >= gb->abams) {
-            int old_abams = gb->abams;
-            gb->abams *= 2;
-            b = (bam1_t *)realloc(gb->bams, gb->abams*sizeof(bam1_t));
-            if (!b) {
-                gb->abams /= 2;
-                sam_state_err(fd, ENOMEM);
-                goto err;
-            }
-            memset(&b[old_abams], 0, (gb->abams - old_abams)*sizeof(*b));
-            gb->bams = b;
-        }
-
-        // Ideally we'd get sam_parse1 to return the number of
-        // bytes decoded and to be able to stop on newline as
-        // well as \0.
-        //
-        // We can then avoid the additional strchr loop.
-        // It's around 6% of our CPU cost, albeit threadable.
-        //
-        // However this is an API change so for now we copy.
-
-        char *nl = strchr(cp, '\n');
-        char *line_end;
-        if (nl) {
-            line_end = nl;
-            if (line_end > cp && *(line_end - 1) == '\r')
-                line_end--;
-            nl++;
-        } else {
-            nl = line_end = cp_end;
-        }
-        *line_end = '\0';
-        kstring_t ks = { line_end - cp, gl->alloc, cp };
-        if (sam_parse1(&ks, fd->h, &b[i]) < 0) {
-            sam_state_err(fd, errno ? errno : EIO);
-            cleanup_sp_lines(gl);
-            goto err;
-        }
-        cp = nl;
-        i++;
-    }
-    gb->nbams = i;
-
-    pthread_mutex_lock(&fd->lines_m);
-    gl->next = fd->lines;
-    fd->lines = gl;
-    pthread_mutex_unlock(&fd->lines_m);
-    return gb;
-
- err:
-    sam_free_sp_bams(gb);
-    return NULL;
-}
-
-static void *sam_parse_eof(void *arg) {
-    return NULL;
-}
-
-// Cleanup function - result for sam_parse_worker; job for sam_format_worker
-static void cleanup_sp_bams(void *arg) {
-    sam_free_sp_bams((sp_bams *) arg);
-}
-
-// Runs in its own thread.
-// Reads a block of text (SAM) and sends a new job to the thread queue to
-// translate this to BAM.
-static void *sam_dispatcher_read(void *vp) {
-    htsFile *fp = vp;
-    kstring_t line = {0};
-    int line_frag = 0;
-    SAM_state *fd = fp->state;
-    sp_lines *l = NULL;
-
-    // Pre-allocate buffer for left-over bits of line (exact size doesn't
-    // matter as it will grow if necessary).
-    if (ks_resize(&line, 1000) < 0)
-        goto err;
-
-    for (;;) {
-        // Check for command
-        pthread_mutex_lock(&fd->command_m);
-        switch (fd->command) {
-
-        case SAM_CLOSE:
-            pthread_cond_signal(&fd->command_c);
-            pthread_mutex_unlock(&fd->command_m);
-            hts_tpool_process_shutdown(fd->q);
-            goto tidyup;
-
-        default:
-            break;
-        }
-        pthread_mutex_unlock(&fd->command_m);
-
-        pthread_mutex_lock(&fd->lines_m);
-        if (fd->lines) {
-            // reuse existing line buffer
-            l = fd->lines;
-            fd->lines = l->next;
-        }
-        pthread_mutex_unlock(&fd->lines_m);
-
-        if (l == NULL) {
-            // none to reuse, to create a new one
-            l = calloc(1, sizeof(*l));
-            if (!l)
-                goto err;
-            l->alloc = NM;
-            l->data = malloc(l->alloc+8); // +8 for optimisation in sam_parse1
-            if (!l->data) {
-                free(l);
-                l = NULL;
-                goto err;
-            }
-            l->fd = fd;
-        }
-        l->next = NULL;
-
-        if (l->alloc < line_frag+NM/2) {
-            char *rp = realloc(l->data, line_frag+NM/2 +8);
-            if (!rp)
-                goto err;
-            l->alloc = line_frag+NM/2;
-            l->data = rp;
-        }
-        memcpy(l->data, line.s, line_frag);
-
-        l->data_size = line_frag;
-        ssize_t nbytes;
-    longer_line:
-        if (fp->is_bgzf)
-            nbytes = bgzf_read(fp->fp.bgzf, l->data + line_frag, l->alloc - line_frag);
-        else
-            nbytes = hread(fp->fp.hfile, l->data + line_frag, l->alloc - line_frag);
-        if (nbytes < 0) {
-            sam_state_err(fd, errno ? errno : EIO);
-            goto err;
-        } else if (nbytes == 0)
-            break; // EOF
-        l->data_size += nbytes;
-
-        // trim to last \n. Maybe \r\n, but that's still fine
-        if (nbytes == l->alloc - line_frag) {
-            char *cp_end = l->data + l->data_size;
-            char *cp = cp_end-1;
-
-            while (cp > (char *)l->data && *cp != '\n')
-                cp--;
-
-            // entire buffer is part of a single line
-            if (cp == l->data) {
-                line_frag = l->data_size;
-                char *rp = realloc(l->data, l->alloc * 2 + 8);
-                if (!rp)
-                    goto err;
-                l->alloc *= 2;
-                l->data = rp;
-                assert(l->alloc >= l->data_size);
-                assert(l->alloc >= line_frag);
-                assert(l->alloc >= l->alloc - line_frag);
-                goto longer_line;
-            }
-            cp++;
-
-            // line holds the remainder of our line.
-            if (ks_resize(&line, cp_end - cp) < 0)
-                goto err;
-            memcpy(line.s, cp, cp_end - cp);
-            line_frag = cp_end - cp;
-            l->data_size = l->alloc - line_frag;
-        } else {
-            // out of buffer
-            line_frag = 0;
-        }
-
-        l->serial = fd->serial++;
-        //fprintf(stderr, "Dispatching %p, %d bytes, serial %d\n", l, l->data_size, l->serial);
-        if (hts_tpool_dispatch3(fd->p, fd->q, sam_parse_worker, l,
-                                cleanup_sp_lines, cleanup_sp_bams, 0) < 0)
-            goto err;
-        pthread_mutex_lock(&fd->command_m);
-        if (fd->command == SAM_CLOSE) {
-            pthread_mutex_unlock(&fd->command_m);
-            l = NULL;
-            goto tidyup;
-        }
-        l = NULL;  // Now "owned" by sam_parse_worker()
-        pthread_mutex_unlock(&fd->command_m);
-    }
-
-    if (hts_tpool_dispatch(fd->p, fd->q, sam_parse_eof, NULL) < 0)
-        goto err;
-
-    // At EOF, wait for close request.
-    // (In future if we add support for seek, this is where we need to catch it.)
-    for (;;) {
-        pthread_mutex_lock(&fd->command_m);
-        if (fd->command == SAM_NONE)
-            pthread_cond_wait(&fd->command_c, &fd->command_m);
-        switch (fd->command) {
-        case SAM_CLOSE:
-            pthread_cond_signal(&fd->command_c);
-            pthread_mutex_unlock(&fd->command_m);
-            hts_tpool_process_shutdown(fd->q);
-            goto tidyup;
-
-        default:
-            pthread_mutex_unlock(&fd->command_m);
-            break;
-        }
-    }
-
- tidyup:
-    pthread_mutex_lock(&fd->command_m);
-    fd->command = SAM_CLOSE_DONE;
-    pthread_cond_signal(&fd->command_c);
-    pthread_mutex_unlock(&fd->command_m);
-
-    if (l) {
-        pthread_mutex_lock(&fd->lines_m);
-        l->next = fd->lines;
-        fd->lines = l;
-        pthread_mutex_unlock(&fd->lines_m);
-    }
-    free(line.s);
-
-    return NULL;
-
- err:
-    sam_state_err(fd, errno ? errno : ENOMEM);
-    hts_tpool_process_shutdown(fd->q);
-    goto tidyup;
-}
-
-// Runs in its own thread.
-// Takes encoded blocks of SAM off the thread results queue and writes them
-// to our output stream.
-static void *sam_dispatcher_write(void *vp) {
-    htsFile *fp = vp;
-    SAM_state *fd = fp->state;
-    hts_tpool_result *r;
-
-    // Iterates until result queue is shutdown, where it returns NULL.
-    while ((r = hts_tpool_next_result_wait(fd->q))) {
-        sp_lines *gl = (sp_lines *)hts_tpool_result_data(r);
-        if (!gl) {
-            sam_state_err(fd, ENOMEM);
-            goto err;
-        }
-
-        if (fp->idx) {
-            sp_bams *gb = gl->bams;
-            int i = 0, count = 0;
-            while (i < gl->data_size) {
-                int j = i;
-                while (i < gl->data_size && gl->data[i] != '\n')
-                    i++;
-                if (i < gl->data_size)
-                    i++;
-
-                if (fp->is_bgzf) {
-                    if (bgzf_write(fp->fp.bgzf, &gl->data[j], i-j) != i-j)
-                        goto err;
-                } else {
-                    if (hwrite(fp->fp.hfile, &gl->data[j], i-j) != i-j)
-                        goto err;
-                }
-
-                bam1_t *b = &gb->bams[count++];
-                if (fp->format.compression == bgzf) {
-                    if (bgzf_idx_push(fp->fp.bgzf, fp->idx,
-                                      b->core.tid, b->core.pos, bam_endpos(b),
-                                      bgzf_tell(fp->fp.bgzf),
-                                      !(b->core.flag&BAM_FUNMAP)) < 0) {
-                        sam_state_err(fd, errno ? errno : ENOMEM);
-                        hts_log_error("Read '%s' with ref_name='%s', ref_length=%"PRIhts_pos", flags=%d, pos=%"PRIhts_pos" cannot be indexed",
-                                bam_get_qname(b), sam_hdr_tid2name(fd->h, b->core.tid), sam_hdr_tid2len(fd->h, b->core.tid), b->core.flag, b->core.pos+1);
-                        goto err;
-                    }
-                } else {
-                    if (hts_idx_push(fp->idx, b->core.tid, b->core.pos, bam_endpos(b),
-                                     bgzf_tell(fp->fp.bgzf), !(b->core.flag&BAM_FUNMAP)) < 0) {
-                        sam_state_err(fd, errno ? errno : ENOMEM);
-                        hts_log_error("Read '%s' with ref_name='%s', ref_length=%"PRIhts_pos", flags=%d, pos=%"PRIhts_pos" cannot be indexed",
-                                bam_get_qname(b), sam_hdr_tid2name(fd->h, b->core.tid), sam_hdr_tid2len(fd->h, b->core.tid), b->core.flag, b->core.pos+1);
-                        goto err;
-                    }
-                }
-            }
-
-            assert(count == gb->nbams);
-
-            // Add bam array to free-list
-            pthread_mutex_lock(&fd->lines_m);
-            gb->next = fd->bams;
-            fd->bams = gl->bams;
-            gl->bams = NULL;
-            pthread_mutex_unlock(&fd->lines_m);
-        } else {
-            if (fp->is_bgzf) {
-                if (bgzf_write(fp->fp.bgzf, gl->data, gl->data_size) != gl->data_size)
-                    goto err;
-            } else {
-                if (hwrite(fp->fp.hfile, gl->data, gl->data_size) != gl->data_size)
-                    goto err;
-            }
-        }
-
-        hts_tpool_delete_result(r, 0);
-
-        // Also updated by main thread
-        pthread_mutex_lock(&fd->lines_m);
-        gl->next = fd->lines;
-        fd->lines = gl;
-        pthread_mutex_unlock(&fd->lines_m);
-    }
-
-    sam_state_err(fd, 0); // success
-    hts_tpool_process_shutdown(fd->q);
-    return NULL;
-
- err:
-    sam_state_err(fd, errno ? errno : EIO);
-    return (void *)-1;
-}
-
-// Run from one of the worker threads.
-// Convert a passed in array of BAMs (sp_bams) and converts to a block
-// of text SAM records (sp_lines).
-static void *sam_format_worker(void *arg) {
-    sp_bams *gb = (sp_bams *)arg;
-    sp_lines *gl = NULL;
-    int i;
-    SAM_state *fd = gb->fd;
-    htsFile *fp = fd->fp;
-
-    // Use a block of SAM strings we had earlier if available.
-    pthread_mutex_lock(&fd->lines_m);
-    if (fd->lines) {
-        gl = fd->lines;
-        fd->lines = gl->next;
-    }
-    pthread_mutex_unlock(&fd->lines_m);
-
-    if (gl == NULL) {
-        gl = calloc(1, sizeof(*gl));
-        if (!gl) {
-            sam_state_err(fd, ENOMEM);
-            return NULL;
-        }
-        gl->alloc = gl->data_size = 0;
-        gl->data = NULL;
-    }
-    gl->serial = gb->serial;
-    gl->next = NULL;
-
-    kstring_t ks = {0, gl->alloc, gl->data};
-
-    for (i = 0; i < gb->nbams; i++) {
-        if (sam_format1_append(fd->h, &gb->bams[i], &ks) < 0) {
-            sam_state_err(fd, errno ? errno : EIO);
-            goto err;
-        }
-        kputc('\n', &ks);
-    }
-
-    pthread_mutex_lock(&fd->lines_m);
-    gl->data_size = ks.l;
-    gl->alloc = ks.m;
-    gl->data = ks.s;
-
-    if (fp->idx) {
-        // Keep hold of the bam array a little longer as
-        // sam_dispatcher_write needs to use them for building the index.
-        gl->bams = gb;
-    } else {
-        // Add bam array to free-list
-        gb->next = fd->bams;
-        fd->bams = gb;
-    }
-    pthread_mutex_unlock(&fd->lines_m);
-
-    return gl;
-
- err:
-    // Possible race between this and fd->curr_bam.
-    // Easier to not free and leave it on the input list so it
-    // gets freed there instead?
-    // sam_free_sp_bams(gb);
-    if (gl) {
-        free(gl->data);
-        free(gl);
-    }
-    return NULL;
-}
-
-int sam_set_thread_pool(htsFile *fp, htsThreadPool *p) {
-    if (fp->state)
-        return 0;
-
-    if (!(fp->state = sam_state_create(fp)))
-        return -1;
-    SAM_state *fd = (SAM_state *)fp->state;
-
-    pthread_mutex_init(&fd->lines_m, NULL);
-    pthread_mutex_init(&fd->command_m, NULL);
-    pthread_cond_init(&fd->command_c, NULL);
-    fd->p = p->pool;
-    int qsize = p->qsize;
-    if (!qsize)
-        qsize = 2*hts_tpool_size(fd->p);
-    fd->q = hts_tpool_process_init(fd->p, qsize, 0);
-    if (!fd->q) {
-        sam_state_destroy(fp);
-        return -1;
-    }
-
-    if (fp->format.compression == bgzf)
-        return bgzf_thread_pool(fp->fp.bgzf, p->pool, p->qsize);
-
-    return 0;
-}
-
-int sam_set_threads(htsFile *fp, int nthreads) {
-    if (nthreads <= 0)
-        return 0;
-
-    htsThreadPool p;
-    p.pool = hts_tpool_init(nthreads);
-    p.qsize = nthreads*2;
-
-    int ret = sam_set_thread_pool(fp, &p);
-    if (ret < 0)
-        return ret;
-
-    SAM_state *fd = (SAM_state *)fp->state;
-    fd->own_pool = 1;
-
-    return 0;
-}
-
-// Internal component of sam_read1 below
-static inline int sam_read1_bam(htsFile *fp, sam_hdr_t *h, bam1_t *b) {
-    int ret = bam_read1(fp->fp.bgzf, b);
-    if (h && ret >= 0) {
-        if (b->core.tid  >= h->n_targets || b->core.tid  < -1 ||
-            b->core.mtid >= h->n_targets || b->core.mtid < -1) {
-            errno = ERANGE;
-            return -3;
-        }
-    }
-    return ret;
-}
-
-// Internal component of sam_read1 below
-static inline int sam_read1_cram(htsFile *fp, sam_hdr_t *h, bam1_t **b) {
-    int ret = cram_get_bam_seq(fp->fp.cram, b);
-    if (ret < 0)
-        return cram_eof(fp->fp.cram) ? -1 : -2;
-
-    if (bam_tag2cigar(*b, 1, 1) < 0)
-        return -2;
-
-    return ret;
-}
-
-// Internal component of sam_read1 below
-static inline int sam_read1_sam(htsFile *fp, sam_hdr_t *h, bam1_t *b) {
-    int ret;
-
-    // Consume 1st line after header parsing as it wasn't using peek
-    if (fp->line.l != 0) {
-        ret = sam_parse1(&fp->line, h, b);
-        fp->line.l = 0;
-        return ret;
-    }
-
-    if (fp->state) {
-        SAM_state *fd = (SAM_state *)fp->state;
-
-        if (fp->format.compression == bgzf && fp->fp.bgzf->seeked) {
-            // We don't support multi-threaded SAM parsing with seeks yet.
-            int ret;
-            if ((ret = sam_state_destroy(fp)) < 0) {
-                errno = -ret;
-                return -2;
-            }
-            if (bgzf_seek(fp->fp.bgzf, fp->fp.bgzf->seeked, SEEK_SET) < 0)
-                return -1;
-            fp->fp.bgzf->seeked = 0;
-            goto err_recover;
-        }
-
-        if (!fd->h) {
-            fd->h = h;
-            fd->h->ref_count++;
-            // Ensure hrecs is initialised now as we don't want multiple
-            // threads trying to do this simultaneously.
-            if (!fd->h->hrecs && sam_hdr_fill_hrecs(fd->h) < 0)
-                return -2;
-
-            // We can only do this once we've got a header
-            if (pthread_create(&fd->dispatcher, NULL, sam_dispatcher_read,
-                               fp) != 0)
-                return -2;
-            fd->dispatcher_set = 1;
-        }
-
-        if (fd->h != h) {
-            hts_log_error("SAM multi-threaded decoding does not support changing header");
-            return -1;
-        }
-
-        sp_bams *gb = fd->curr_bam;
-        if (!gb) {
-            if (fd->errcode) {
-                // In case reader failed
-                errno = fd->errcode;
-                return -2;
-            }
-            hts_tpool_result *r = hts_tpool_next_result_wait(fd->q);
-            if (!r)
-                return -2;
-            fd->curr_bam = gb = (sp_bams *)hts_tpool_result_data(r);
-            hts_tpool_delete_result(r, 0);
-        }
-        if (!gb)
-            return fd->errcode ? -2 : -1;
-        bam1_t *b_array = (bam1_t *)gb->bams;
-        if (fd->curr_idx < gb->nbams)
-            if (!bam_copy1(b, &b_array[fd->curr_idx++]))
-                return -2;
-        if (fd->curr_idx == gb->nbams) {
-            pthread_mutex_lock(&fd->lines_m);
-            gb->next = fd->bams;
-            fd->bams = gb;
-            pthread_mutex_unlock(&fd->lines_m);
-
-            fd->curr_bam = NULL;
-            fd->curr_idx = 0;
-        }
-
-        ret = 0;
-
-    } else  {
-    err_recover:
-        ret = hts_getline(fp, KS_SEP_LINE, &fp->line);
-        if (ret < 0) return ret;
-
-        ret = sam_parse1(&fp->line, h, b);
-        fp->line.l = 0;
-        if (ret < 0) {
-            hts_log_warning("Parse error at line %lld", (long long)fp->lineno);
-            if (h->ignore_sam_err) goto err_recover;
-        }
-    }
-
-    return ret;
-}
-
-// Returns 0 on success,
-//        -1 on EOF,
-//       <-1 on error
-int sam_read1(htsFile *fp, sam_hdr_t *h, bam1_t *b)
-{
-    int ret, pass_filter;
-
-    do {
-        switch (fp->format.format) {
-        case bam:
-            ret = sam_read1_bam(fp, h, b);
-            break;
-
-        case cram:
-            ret = sam_read1_cram(fp, h, &b);
-            break;
-
-        case sam:
-            ret = sam_read1_sam(fp, h, b);
-            break;
-
-        case empty_format:
-            errno = EPIPE;
-            return -3;
-
-        default:
-            errno = EFTYPE;
-            return -3;
-        }
-
-        pass_filter = (ret >= 0 && fp->filter)
-            ? sam_passes_filter(h, b, fp->filter)
-            : 1;
-    } while (pass_filter == 0);
-
-    return pass_filter < 0 ? -2 : ret;
-}
-
-
-static int sam_format1_append(const bam_hdr_t *h, const bam1_t *b, kstring_t *str)
-{
-    int i, r = 0;
-    uint8_t *s, *end;
-    const bam1_core_t *c = &b->core;
-
-    if (c->l_qname == 0)
-        return -1;
-    r |= kputsn_(bam_get_qname(b), c->l_qname-1-c->l_extranul, str);
-    r |= kputc_('\t', str); // query name
-    r |= kputw(c->flag, str); r |= kputc_('\t', str); // flag
-    if (c->tid >= 0) { // chr
-        r |= kputs(h->target_name[c->tid] , str);
-        r |= kputc_('\t', str);
-    } else r |= kputsn_("*\t", 2, str);
-    r |= kputll(c->pos + 1, str); r |= kputc_('\t', str); // pos
-    r |= kputw(c->qual, str); r |= kputc_('\t', str); // qual
-    if (c->n_cigar) { // cigar
-        uint32_t *cigar = bam_get_cigar(b);
-        for (i = 0; i < c->n_cigar; ++i) {
-            r |= kputw(bam_cigar_oplen(cigar[i]), str);
-            r |= kputc_(bam_cigar_opchr(cigar[i]), str);
-        }
-    } else r |= kputc_('*', str);
-    r |= kputc_('\t', str);
-    if (c->mtid < 0) r |= kputsn_("*\t", 2, str); // mate chr
-    else if (c->mtid == c->tid) r |= kputsn_("=\t", 2, str);
-    else {
-        r |= kputs(h->target_name[c->mtid], str);
-        r |= kputc_('\t', str);
-    }
-    r |= kputll(c->mpos + 1, str); r |= kputc_('\t', str); // mate pos
-    r |= kputll(c->isize, str); r |= kputc_('\t', str); // template len
-    if (c->l_qseq) { // seq and qual
-        uint8_t *s = bam_get_seq(b);
-        if (ks_resize(str, str->l+2+2*c->l_qseq) < 0) goto mem_err;
-        char *cp = str->s + str->l;
-
-        // Sequence, 2 bases at a time
-        nibble2base(s, cp, c->l_qseq);
-        cp[c->l_qseq] = '\t';
-        cp += c->l_qseq+1;
-
-        // Quality
-        s = bam_get_qual(b);
-        i = 0;
-        if (s[0] == 0xff) {
-            cp[i++] = '*';
-        } else {
-            // local copy of c->l_qseq to aid unrolling
-            uint32_t lqseq = c->l_qseq;
-            for (i = 0; i < lqseq; ++i)
-                cp[i]=s[i]+33;
-        }
-        cp[i] = 0;
-        cp += i;
-        str->l = cp - str->s;
-    } else r |= kputsn_("*\t*", 3, str);
-
-    s = bam_get_aux(b); // aux
-    end = b->data + b->l_data;
-
-    while (end - s >= 4) {
-        r |= kputc_('\t', str);
-        if ((s = (uint8_t *)sam_format_aux1(s, s[2], s+3, end, str)) == NULL)
-            goto bad_aux;
-    }
-    r |= kputsn("", 0, str); // nul terminate
-    if (r < 0) goto mem_err;
-
-    return str->l;
-
- bad_aux:
-    hts_log_error("Corrupted aux data for read %.*s",
-                  b->core.l_qname, bam_get_qname(b));
-    errno = EINVAL;
-    return -1;
-
- mem_err:
-    hts_log_error("Out of memory");
-    errno = ENOMEM;
-    return -1;
-}
-
-int sam_format1(const bam_hdr_t *h, const bam1_t *b, kstring_t *str)
-{
-    str->l = 0;
-    return sam_format1_append(h, b, str);
-}
-
-// Sadly we need to be able to modify the bam_hdr here so we can
-// reference count the structure.
-int sam_write1(htsFile *fp, const sam_hdr_t *h, const bam1_t *b)
-{
-    switch (fp->format.format) {
-    case binary_format:
-        fp->format.category = sequence_data;
-        fp->format.format = bam;
-        /* fall-through */
-    case bam:
-        return bam_write_idx1(fp, h, b);
-
-    case cram:
-        return cram_put_bam_seq(fp->fp.cram, (bam1_t *)b);
-
-    case text_format:
-        fp->format.category = sequence_data;
-        fp->format.format = sam;
-        /* fall-through */
-    case sam:
-        if (fp->state) {
-            SAM_state *fd = (SAM_state *)fp->state;
-
-            // Threaded output
-            if (!fd->h) {
-                // NB: discard const.  We don't actually modify sam_hdr_t here,
-                // just data pointed to by it (which is a bit weasely still),
-                // but out cached pointer must be non-const as we want to
-                // destroy it later on and sam_hdr_destroy takes non-const.
-                //
-                // We do this because some tools do sam_hdr_destroy; sam_close
-                // while others do sam_close; sam_hdr_destroy.  The former is
-                // an issue as we need the header still when flushing.
-                fd->h = (sam_hdr_t *)h;
-                fd->h->ref_count++;
-
-                if (pthread_create(&fd->dispatcher, NULL, sam_dispatcher_write,
-                                   fp) != 0)
-                    return -2;
-                fd->dispatcher_set = 1;
-            }
-
-            if (fd->h != h) {
-                hts_log_error("SAM multi-threaded decoding does not support changing header");
-                return -2;
-            }
-
-            // Find a suitable BAM array to copy to
-            sp_bams *gb = fd->curr_bam;
-            if (!gb) {
-                pthread_mutex_lock(&fd->lines_m);
-                if (fd->bams) {
-                    fd->curr_bam = gb = fd->bams;
-                    fd->bams = gb->next;
-                    gb->next = NULL;
-                    gb->nbams = 0;
-                    pthread_mutex_unlock(&fd->lines_m);
-                } else {
-                    pthread_mutex_unlock(&fd->lines_m);
-                    if (!(gb = calloc(1, sizeof(*gb)))) return -1;
-                    if (!(gb->bams = calloc(NB, sizeof(*gb->bams)))) {
-                        free(gb);
-                        return -1;
-                    }
-                    gb->nbams = 0;
-                    gb->abams = NB;
-                    gb->fd = fd;
-                    fd->curr_idx = 0;
-                    fd->curr_bam = gb;
-                }
-            }
-
-            if (!bam_copy1(&gb->bams[gb->nbams++], b))
-                return -2;
-
-            // Dispatch if full
-            if (gb->nbams == NB) {
-                gb->serial = fd->serial++;
-                //fprintf(stderr, "Dispatch another %d bams\n", NB);
-                pthread_mutex_lock(&fd->command_m);
-                if (fd->errcode != 0) {
-                    pthread_mutex_unlock(&fd->command_m);
-                    return -fd->errcode;
-                }
-                if (hts_tpool_dispatch3(fd->p, fd->q, sam_format_worker, gb,
-                                        cleanup_sp_bams,
-                                        cleanup_sp_lines, 0) < 0) {
-                    pthread_mutex_unlock(&fd->command_m);
-                    return -1;
-                }
-                pthread_mutex_unlock(&fd->command_m);
-                fd->curr_bam = NULL;
-            }
-
-            // Dummy value as we don't know how long it really is.
-            // We could track file sizes via a SAM_state field, but I don't think
-            // it is necessary.
-            return 1;
-        } else {
-            if (sam_format1(h, b, &fp->line) < 0) return -1;
-            kputc('\n', &fp->line);
-            if (fp->is_bgzf) {
-                if ( bgzf_write(fp->fp.bgzf, fp->line.s, fp->line.l) != fp->line.l ) return -1;
-            } else {
-                if ( hwrite(fp->fp.hfile, fp->line.s, fp->line.l) != fp->line.l ) return -1;
-            }
-
-            if (fp->idx) {
-                if (fp->format.compression == bgzf) {
-                    if (bgzf_idx_push(fp->fp.bgzf, fp->idx, b->core.tid, b->core.pos, bam_endpos(b),
-                                      bgzf_tell(fp->fp.bgzf), !(b->core.flag&BAM_FUNMAP)) < 0) {
-                        hts_log_error("Read '%s' with ref_name='%s', ref_length=%"PRIhts_pos", flags=%d, pos=%"PRIhts_pos" cannot be indexed",
-                                bam_get_qname(b), sam_hdr_tid2name(h, b->core.tid), sam_hdr_tid2len(h, b->core.tid), b->core.flag, b->core.pos+1);
-                        return -1;
-                    }
-                } else {
-                    if (hts_idx_push(fp->idx, b->core.tid, b->core.pos, bam_endpos(b),
-                                     bgzf_tell(fp->fp.bgzf), !(b->core.flag&BAM_FUNMAP)) < 0) {
-                        hts_log_error("Read '%s' with ref_name='%s', ref_length=%"PRIhts_pos", flags=%d, pos=%"PRIhts_pos" cannot be indexed",
-                                bam_get_qname(b), sam_hdr_tid2name(h, b->core.tid), sam_hdr_tid2len(h, b->core.tid), b->core.flag, b->core.pos+1);
-                        return -1;
-                    }
-                }
-            }
-
-            return fp->line.l;
-        }
-
-    default:
-        errno = EBADF;
-        return -1;
-    }
-}
-
-/************************
- *** Auxiliary fields ***
- ************************/
-#ifndef HTS_LITTLE_ENDIAN
-static int aux_to_le(char type, uint8_t *out, const uint8_t *in, size_t len) {
-    int tsz = aux_type2size(type);
-
-    if (tsz >= 2 && tsz <= 8 && (len & (tsz - 1)) != 0) return -1;
-
-    switch (tsz) {
-        case 'H': case 'Z': case 1:  // Trivial
-            memcpy(out, in, len);
-            break;
-
-#define aux_val_to_le(type_t, store_le) do {                            \
-        type_t v;                                                       \
-        size_t i;                                                       \
-        for (i = 0; i < len; i += sizeof(type_t), out += sizeof(type_t)) { \
-            memcpy(&v, in + i, sizeof(type_t));                         \
-            store_le(v, out);                                           \
-        }                                                               \
-    } while (0)
-
-        case 2: aux_val_to_le(uint16_t, u16_to_le); break;
-        case 4: aux_val_to_le(uint32_t, u32_to_le); break;
-        case 8: aux_val_to_le(uint64_t, u64_to_le); break;
-
-#undef aux_val_to_le
-
-        case 'B': { // Recurse!
-            uint32_t n;
-            if (len < 5) return -1;
-            memcpy(&n, in + 1, 4);
-            out[0] = in[0];
-            u32_to_le(n, out + 1);
-            return aux_to_le(in[0], out + 5, in + 5, len - 5);
-        }
-
-        default: // Unknown type code
-            return -1;
-    }
-
-
-
-    return 0;
-}
-#endif
-
-int bam_aux_append(bam1_t *b, const char tag[2], char type, int len, const uint8_t *data)
-{
-    uint32_t new_len;
-
-    assert(b->l_data >= 0);
-    new_len = b->l_data + 3 + len;
-    if (new_len > INT32_MAX || new_len < b->l_data) goto nomem;
-
-    if (realloc_bam_data(b, new_len) < 0) return -1;
-
-    b->data[b->l_data] = tag[0];
-    b->data[b->l_data + 1] = tag[1];
-    b->data[b->l_data + 2] = type;
-
-#ifdef HTS_LITTLE_ENDIAN
-    memcpy(b->data + b->l_data + 3, data, len);
-#else
-    if (aux_to_le(type, b->data + b->l_data + 3, data, len) != 0) {
-        errno = EINVAL;
-        return -1;
-    }
-#endif
-
-    b->l_data = new_len;
-
-    return 0;
-
- nomem:
-    errno = ENOMEM;
-    return -1;
-}
-
-static inline uint8_t *skip_aux(uint8_t *s, uint8_t *end)
-{
-    int size;
-    uint32_t n;
-    if (s >= end) return end;
-    size = aux_type2size(*s); ++s; // skip type
-    switch (size) {
-    case 'Z':
-    case 'H':
-        while (s < end && *s) ++s;
-        return s < end ? s + 1 : end;
-    case 'B':
-        if (end - s < 5) return NULL;
-        size = aux_type2size(*s); ++s;
-        n = le_to_u32(s);
-        s += 4;
-        if (size == 0 || end - s < size * n) return NULL;
-        return s + size * n;
-    case 0:
-        return NULL;
-    default:
-        if (end - s < size) return NULL;
-        return s + size;
-    }
-}
-
-uint8_t *bam_aux_get(const bam1_t *b, const char tag[2])
-{
-    uint8_t *s, *end, *t = (uint8_t *) tag;
-    uint16_t y = (uint16_t) t[0]<<8 | t[1];
-    s = bam_get_aux(b);
-    end = b->data + b->l_data;
-    while (s != NULL && end - s >= 3) {
-        uint16_t x = (uint16_t) s[0]<<8 | s[1];
-        s += 2;
-        if (x == y) {
-            // Check the tag value is valid and complete
-            uint8_t *e = skip_aux(s, end);
-            if ((*s == 'Z' || *s == 'H') && *(e - 1) != '\0') {
-                goto bad_aux;  // Unterminated string
-            }
-            if (e != NULL) {
-                return s;
-            } else {
-                goto bad_aux;
-            }
-        }
-        s = skip_aux(s, end);
-    }
-    if (s == NULL) goto bad_aux;
-    errno = ENOENT;
-    return NULL;
-
- bad_aux:
-    hts_log_error("Corrupted aux data for read %s", bam_get_qname(b));
-    errno = EINVAL;
-    return NULL;
-}
-
-// s MUST BE returned by bam_aux_get()
-int bam_aux_del(bam1_t *b, uint8_t *s)
-{
-    uint8_t *p, *aux;
-    int l_aux = bam_get_l_aux(b);
-    aux = bam_get_aux(b);
-    p = s - 2;
-    s = skip_aux(s, aux + l_aux);
-    if (s == NULL) goto bad_aux;
-    memmove(p, s, l_aux - (s - aux));
-    b->l_data -= s - p;
-    return 0;
-
- bad_aux:
-    hts_log_error("Corrupted aux data for read %s", bam_get_qname(b));
-    errno = EINVAL;
-    return -1;
-}
-
-int bam_aux_update_str(bam1_t *b, const char tag[2], int len, const char *data)
-{
-    // FIXME: This is not at all efficient!
-    size_t ln = len >= 0 ? len : strlen(data) + 1;
-    size_t old_ln = 0;
-    int need_nul = ln == 0 || data[ln - 1] != '\0';
-    int save_errno = errno;
-    int new_tag = 0;
-    uint8_t *s = bam_aux_get(b,tag), *e;
-
-    if (s) {  // Replacing existing tag
-        char type = *s;
-        if (type != 'Z') {
-            hts_log_error("Called bam_aux_update_str for type '%c' instead of 'Z'", type);
-            errno = EINVAL;
-            return -1;
-        }
-        s++;
-        e = memchr(s, '\0', b->data + b->l_data - s);
-        old_ln = (e ? e - s : b->data + b->l_data - s) + 1;
-        s -= 3;
-    } else {
-        if (errno != ENOENT) { // Invalid aux data, give up
-            return -1;
-        } else { // Tag doesn't exist - put it on the end
-            errno = save_errno;
-            s = b->data + b->l_data;
-            new_tag = 3;
-        }
-    }
-
-    if (old_ln < ln + need_nul + new_tag) {
-        ptrdiff_t s_offset = s - b->data;
-        if (possibly_expand_bam_data(b, ln + need_nul + new_tag - old_ln) < 0)
-            return -1;
-        s = b->data + s_offset;
-    }
-    if (!new_tag) {
-        memmove(s + 3 + ln + need_nul,
-                s + 3 + old_ln,
-                b->l_data - (s + 3 - b->data) - old_ln);
-    }
-    b->l_data += new_tag + ln + need_nul - old_ln;
-
-    s[0] = tag[0];
-    s[1] = tag[1];
-    s[2] = 'Z';
-    memmove(s+3,data,ln);
-    if (need_nul) s[3 + ln] = '\0';
-    return 0;
-}
-
-int bam_aux_update_int(bam1_t *b, const char tag[2], int64_t val)
-{
-    uint32_t sz, old_sz = 0, new = 0;
-    uint8_t *s, type;
-
-    if (val < INT32_MIN || val > UINT32_MAX) {
-        errno = EOVERFLOW;
-        return -1;
-    }
-    if (val < INT16_MIN)       { type = 'i'; sz = 4; }
-    else if (val < INT8_MIN)   { type = 's'; sz = 2; }
-    else if (val < 0)          { type = 'c'; sz = 1; }
-    else if (val < UINT8_MAX)  { type = 'C'; sz = 1; }
-    else if (val < UINT16_MAX) { type = 'S'; sz = 2; }
-    else                       { type = 'I'; sz = 4; }
-
-    s = bam_aux_get(b, tag);
-    if (s) {  // Tag present - how big was the old one?
-        switch (*s) {
-            case 'c': case 'C': old_sz = 1; break;
-            case 's': case 'S': old_sz = 2; break;
-            case 'i': case 'I': old_sz = 4; break;
-            default: errno = EINVAL; return -1;  // Not an integer
-        }
-    } else {
-        if (errno == ENOENT) {  // Tag doesn't exist - add a new one
-            s = b->data + b->l_data;
-            new = 1;
-        }  else { // Invalid aux data, give up.
-            return -1;
-        }
-    }
-
-    if (new || old_sz < sz) {
-        // Make room for new tag
-        ptrdiff_t s_offset = s - b->data;
-        if (possibly_expand_bam_data(b, (new ? 3 : 0) + sz - old_sz) < 0)
-            return -1;
-        s =  b->data + s_offset;
-        if (new) { // Add tag id
-            *s++ = tag[0];
-            *s++ = tag[1];
-        } else {   // Shift following data so we have space
-            memmove(s + sz, s + old_sz, b->l_data - s_offset - old_sz);
-        }
-    } else {
-        // Reuse old space.  Data value may be bigger than necessary but
-        // we avoid having to move everything else
-        sz = old_sz;
-        type = (val < 0 ? "\0cs\0i" : "\0CS\0I")[old_sz];
-        assert(type > 0);
-    }
-    *s++ = type;
-#ifdef HTS_LITTLE_ENDIAN
-    memcpy(s, &val, sz);
-#else
-    switch (sz) {
-        case 4:  u32_to_le(val, s); break;
-        case 2:  u16_to_le(val, s); break;
-        default: *s = val; break;
-    }
-#endif
-    b->l_data += (new ? 3 : 0) + sz - old_sz;
-    return 0;
-}
-
-int bam_aux_update_float(bam1_t *b, const char tag[2], float val)
-{
-    uint8_t *s = bam_aux_get(b, tag);
-    int shrink = 0, new = 0;
-
-    if (s) { // Tag present - what was it?
-        switch (*s) {
-            case 'f': break;
-            case 'd': shrink = 1; break;
-            default: errno = EINVAL; return -1;  // Not a float
-        }
-    } else {
-        if (errno == ENOENT) {  // Tag doesn't exist - add a new one
-            new = 1;
-        }  else { // Invalid aux data, give up.
-            return -1;
-        }
-    }
-
-    if (new) { // Ensure there's room
-        if (possibly_expand_bam_data(b, 3 + 4) < 0)
-            return -1;
-        s = b->data + b->l_data;
-        *s++ = tag[0];
-        *s++ = tag[1];
-    } else if (shrink) { // Convert non-standard double tag to float
-        memmove(s + 5, s + 9, b->l_data - ((s + 9) - b->data));
-        b->l_data -= 4;
-    }
-    *s++ = 'f';
-    float_to_le(val, s);
-    if (new) b->l_data += 7;
-
-    return 0;
-}
-
-int bam_aux_update_array(bam1_t *b, const char tag[2],
-                         uint8_t type, uint32_t items, void *data)
-{
-    uint8_t *s = bam_aux_get(b, tag);
-    size_t old_sz = 0, new_sz;
-    int new = 0;
-
-    if (s) { // Tag present
-        if (*s != 'B') { errno = EINVAL; return -1; }
-        old_sz = aux_type2size(s[1]);
-        if (old_sz < 1 || old_sz > 4) { errno = EINVAL; return -1; }
-        old_sz *= le_to_u32(s + 2);
-    } else {
-        if (errno == ENOENT) {  // Tag doesn't exist - add a new one
-            s = b->data + b->l_data;
-            new = 1;
-        }  else { // Invalid aux data, give up.
-            return -1;
-        }
-    }
-
-    new_sz = aux_type2size(type);
-    if (new_sz < 1 || new_sz > 4) { errno = EINVAL; return -1; }
-    if (items > INT32_MAX / new_sz) { errno = ENOMEM; return -1; }
-    new_sz *= items;
-
-    if (new || old_sz < new_sz) {
-        // Make room for new tag
-        ptrdiff_t s_offset = s - b->data;
-        if (possibly_expand_bam_data(b, (new ? 8 : 0) + new_sz - old_sz) < 0)
-            return -1;
-        s =  b->data + s_offset;
-    }
-    if (new) { // Add tag id and type
-        *s++ = tag[0];
-        *s++ = tag[1];
-        *s = 'B';
-        b->l_data += 8 + new_sz;
-    } else if (old_sz != new_sz) { // shift following data if necessary
-        memmove(s + 6 + new_sz, s + 6 + old_sz,
-                b->l_data - ((s + 6 + old_sz) - b->data));
-        b->l_data -= old_sz;
-        b->l_data += new_sz;
-    }
-
-    s[1] = type;
-    u32_to_le(items, s + 2);
-#ifdef HTS_LITTLE_ENDIAN
-    memcpy(s + 6, data, new_sz);
-    return 0;
-#else
-    return aux_to_le(type, s + 6, data, new_sz);
-#endif
-}
-
-static inline int64_t get_int_aux_val(uint8_t type, const uint8_t *s,
-                                      uint32_t idx)
-{
-    switch (type) {
-        case 'c': return le_to_i8(s + idx);
-        case 'C': return s[idx];
-        case 's': return le_to_i16(s + 2 * idx);
-        case 'S': return le_to_u16(s + 2 * idx);
-        case 'i': return le_to_i32(s + 4 * idx);
-        case 'I': return le_to_u32(s + 4 * idx);
-        default:
-            errno = EINVAL;
-            return 0;
-    }
-}
-
-int64_t bam_aux2i(const uint8_t *s)
-{
-    int type;
-    type = *s++;
-    return get_int_aux_val(type, s, 0);
-}
-
-double bam_aux2f(const uint8_t *s)
-{
-    int type;
-    type = *s++;
-    if (type == 'd') return le_to_double(s);
-    else if (type == 'f') return le_to_float(s);
-    else return get_int_aux_val(type, s, 0);
-}
-
-char bam_aux2A(const uint8_t *s)
-{
-    int type;
-    type = *s++;
-    if (type == 'A') return *(char*)s;
-    errno = EINVAL;
-    return 0;
-}
-
-char *bam_aux2Z(const uint8_t *s)
-{
-    int type;
-    type = *s++;
-    if (type == 'Z' || type == 'H') return (char*)s;
-    errno = EINVAL;
-    return 0;
-}
-
-uint32_t bam_auxB_len(const uint8_t *s)
-{
-    if (s[0] != 'B') {
-        errno = EINVAL;
-        return 0;
-    }
-    return le_to_u32(s + 2);
-}
-
-int64_t bam_auxB2i(const uint8_t *s, uint32_t idx)
-{
-    uint32_t len = bam_auxB_len(s);
-    if (idx >= len) {
-        errno = ERANGE;
-        return 0;
-    }
-    return get_int_aux_val(s[1], s + 6, idx);
-}
-
-double bam_auxB2f(const uint8_t *s, uint32_t idx)
-{
-    uint32_t len = bam_auxB_len(s);
-    if (idx >= len) {
-        errno = ERANGE;
-        return 0.0;
-    }
-    if (s[1] == 'f') return le_to_float(s + 6 + 4 * idx);
-    else return get_int_aux_val(s[1], s + 6, idx);
-}
-
-int sam_open_mode(char *mode, const char *fn, const char *format)
-{
-    // TODO Parse "bam5" etc for compression level
-    if (format == NULL) {
-        // Try to pick a format based on the filename extension
-        char extension[HTS_MAX_EXT_LEN];
-        if (find_file_extension(fn, extension) < 0) return -1;
-        return sam_open_mode(mode, fn, extension);
-    }
-    else if (strcasecmp(format, "bam") == 0) strcpy(mode, "b");
-    else if (strcasecmp(format, "cram") == 0) strcpy(mode, "c");
-    else if (strcasecmp(format, "sam") == 0) strcpy(mode, "");
-    else if (strcasecmp(format, "sam.gz") == 0) strcpy(mode, "z");
-    else return -1;
-
-    return 0;
-}
-
-// A version of sam_open_mode that can handle ,key=value options.
-// The format string is allocated and returned, to be freed by the caller.
-// Prefix should be "r" or "w",
-char *sam_open_mode_opts(const char *fn,
-                         const char *mode,
-                         const char *format)
-{
-    char *mode_opts = malloc((format ? strlen(format) : 1) +
-                             (mode   ? strlen(mode)   : 1) + 12);
-    char *opts, *cp;
-    int format_len;
-
-    if (!mode_opts)
-        return NULL;
-
-    strcpy(mode_opts, mode ? mode : "r");
-    cp = mode_opts + strlen(mode_opts);
-
-    if (format == NULL) {
-        // Try to pick a format based on the filename extension
-        char extension[HTS_MAX_EXT_LEN];
-        if (find_file_extension(fn, extension) < 0) {
-            free(mode_opts);
-            return NULL;
-        }
-        if (sam_open_mode(cp, fn, extension) == 0) {
-            return mode_opts;
-        } else {
-            free(mode_opts);
-            return NULL;
-        }
-    }
-
-    if ((opts = strchr(format, ','))) {
-        format_len = opts-format;
-    } else {
-        opts="";
-        format_len = strlen(format);
-    }
-
-    if (strncmp(format, "bam", format_len) == 0) {
-        *cp++ = 'b';
-    } else if (strncmp(format, "cram", format_len) == 0) {
-        *cp++ = 'c';
-    } else if (strncmp(format, "cram2", format_len) == 0) {
-        *cp++ = 'c';
-        strcpy(cp, ",VERSION=2.1");
-        cp += 12;
-    } else if (strncmp(format, "cram3", format_len) == 0) {
-        *cp++ = 'c';
-        strcpy(cp, ",VERSION=3.0");
-        cp += 12;
-    } else if (strncmp(format, "sam", format_len) == 0) {
-        ; // format mode=""
-    } else if (strncmp(format, "sam.gz", format_len) == 0) {
-        *cp++ = 'z';
-    } else {
-        free(mode_opts);
-        return NULL;
-    }
-
-    strcpy(cp, opts);
-
-    return mode_opts;
-}
-
-#define STRNCMP(a,b,n) (strncasecmp((a),(b),(n)) || strlen(a)!=(n))
-int bam_str2flag(const char *str)
-{
-    char *end, *beg = (char*) str;
-    long int flag = strtol(str, &end, 0);
-    if ( end!=str ) return flag;    // the conversion was successful
-    flag = 0;
-    while ( *str )
-    {
-        end = beg;
-        while ( *end && *end!=',' ) end++;
-        if ( !STRNCMP("PAIRED",beg,end-beg) ) flag |= BAM_FPAIRED;
-        else if ( !STRNCMP("PROPER_PAIR",beg,end-beg) ) flag |= BAM_FPROPER_PAIR;
-        else if ( !STRNCMP("UNMAP",beg,end-beg) ) flag |= BAM_FUNMAP;
-        else if ( !STRNCMP("MUNMAP",beg,end-beg) ) flag |= BAM_FMUNMAP;
-        else if ( !STRNCMP("REVERSE",beg,end-beg) ) flag |= BAM_FREVERSE;
-        else if ( !STRNCMP("MREVERSE",beg,end-beg) ) flag |= BAM_FMREVERSE;
-        else if ( !STRNCMP("READ1",beg,end-beg) ) flag |= BAM_FREAD1;
-        else if ( !STRNCMP("READ2",beg,end-beg) ) flag |= BAM_FREAD2;
-        else if ( !STRNCMP("SECONDARY",beg,end-beg) ) flag |= BAM_FSECONDARY;
-        else if ( !STRNCMP("QCFAIL",beg,end-beg) ) flag |= BAM_FQCFAIL;
-        else if ( !STRNCMP("DUP",beg,end-beg) ) flag |= BAM_FDUP;
-        else if ( !STRNCMP("SUPPLEMENTARY",beg,end-beg) ) flag |= BAM_FSUPPLEMENTARY;
-        else return -1;
-        if ( !*end ) break;
-        beg = end + 1;
-    }
-    return flag;
-}
-
-char *bam_flag2str(int flag)
-{
-    kstring_t str = {0,0,0};
-    if ( flag&BAM_FPAIRED ) ksprintf(&str,"%s%s", str.l?",":"","PAIRED");
-    if ( flag&BAM_FPROPER_PAIR ) ksprintf(&str,"%s%s", str.l?",":"","PROPER_PAIR");
-    if ( flag&BAM_FUNMAP ) ksprintf(&str,"%s%s", str.l?",":"","UNMAP");
-    if ( flag&BAM_FMUNMAP ) ksprintf(&str,"%s%s", str.l?",":"","MUNMAP");
-    if ( flag&BAM_FREVERSE ) ksprintf(&str,"%s%s", str.l?",":"","REVERSE");
-    if ( flag&BAM_FMREVERSE ) ksprintf(&str,"%s%s", str.l?",":"","MREVERSE");
-    if ( flag&BAM_FREAD1 ) ksprintf(&str,"%s%s", str.l?",":"","READ1");
-    if ( flag&BAM_FREAD2 ) ksprintf(&str,"%s%s", str.l?",":"","READ2");
-    if ( flag&BAM_FSECONDARY ) ksprintf(&str,"%s%s", str.l?",":"","SECONDARY");
-    if ( flag&BAM_FQCFAIL ) ksprintf(&str,"%s%s", str.l?",":"","QCFAIL");
-    if ( flag&BAM_FDUP ) ksprintf(&str,"%s%s", str.l?",":"","DUP");
-    if ( flag&BAM_FSUPPLEMENTARY ) ksprintf(&str,"%s%s", str.l?",":"","SUPPLEMENTARY");
-    if ( str.l == 0 ) kputsn("", 0, &str);
-    return str.s;
-}
-
-
-/**************************
- *** Pileup and Mpileup ***
- **************************/
-
-#if !defined(BAM_NO_PILEUP)
-
-#include <assert.h>
-
-/*******************
- *** Memory pool ***
- *******************/
-
-typedef struct {
-    int k, y;
-    hts_pos_t x, end;
-} cstate_t;
-
-static cstate_t g_cstate_null = { -1, 0, 0, 0 };
-
-typedef struct __linkbuf_t {
-    bam1_t b;
-    hts_pos_t beg, end;
-    cstate_t s;
-    struct __linkbuf_t *next;
-    bam_pileup_cd cd;
-} lbnode_t;
-
-typedef struct {
-    int cnt, n, max;
-    lbnode_t **buf;
-} mempool_t;
-
-static mempool_t *mp_init(void)
-{
-    mempool_t *mp;
-    mp = (mempool_t*)calloc(1, sizeof(mempool_t));
-    return mp;
-}
-static void mp_destroy(mempool_t *mp)
-{
-    int k;
-    for (k = 0; k < mp->n; ++k) {
-        free(mp->buf[k]->b.data);
-        free(mp->buf[k]);
-    }
-    free(mp->buf);
-    free(mp);
-}
-static inline lbnode_t *mp_alloc(mempool_t *mp)
-{
-    ++mp->cnt;
-    if (mp->n == 0) return (lbnode_t*)calloc(1, sizeof(lbnode_t));
-    else return mp->buf[--mp->n];
-}
-static inline void mp_free(mempool_t *mp, lbnode_t *p)
-{
-    --mp->cnt; p->next = 0; // clear lbnode_t::next here
-    if (mp->n == mp->max) {
-        mp->max = mp->max? mp->max<<1 : 256;
-        mp->buf = (lbnode_t**)realloc(mp->buf, sizeof(lbnode_t*) * mp->max);
-    }
-    mp->buf[mp->n++] = p;
-}
-
-/**********************
- *** CIGAR resolver ***
- **********************/
-
-/* s->k: the index of the CIGAR operator that has just been processed.
-   s->x: the reference coordinate of the start of s->k
-   s->y: the query coordinate of the start of s->k
- */
-static inline int resolve_cigar2(bam_pileup1_t *p, hts_pos_t pos, cstate_t *s)
-{
-#define _cop(c) ((c)&BAM_CIGAR_MASK)
-#define _cln(c) ((c)>>BAM_CIGAR_SHIFT)
-
-    bam1_t *b = p->b;
-    bam1_core_t *c = &b->core;
-    uint32_t *cigar = bam_get_cigar(b);
-    int k;
-    // determine the current CIGAR operation
-    //fprintf(stderr, "%s\tpos=%d\tend=%d\t(%d,%d,%d)\n", bam_get_qname(b), pos, s->end, s->k, s->x, s->y);
-    if (s->k == -1) { // never processed
-        p->qpos = 0;
-        if (c->n_cigar == 1) { // just one operation, save a loop
-          if (_cop(cigar[0]) == BAM_CMATCH || _cop(cigar[0]) == BAM_CEQUAL || _cop(cigar[0]) == BAM_CDIFF) s->k = 0, s->x = c->pos, s->y = 0;
-        } else { // find the first match or deletion
-            for (k = 0, s->x = c->pos, s->y = 0; k < c->n_cigar; ++k) {
-                int op = _cop(cigar[k]);
-                int l = _cln(cigar[k]);
-                if (op == BAM_CMATCH || op == BAM_CDEL || op == BAM_CREF_SKIP ||
-                    op == BAM_CEQUAL || op == BAM_CDIFF) break;
-                else if (op == BAM_CINS || op == BAM_CSOFT_CLIP) s->y += l;
-            }
-            assert(k < c->n_cigar);
-            s->k = k;
-        }
-    } else { // the read has been processed before
-        int op, l = _cln(cigar[s->k]);
-        if (pos - s->x >= l) { // jump to the next operation
-            assert(s->k < c->n_cigar); // otherwise a bug: this function should not be called in this case
-            op = _cop(cigar[s->k+1]);
-            if (op == BAM_CMATCH || op == BAM_CDEL || op == BAM_CREF_SKIP || op == BAM_CEQUAL || op == BAM_CDIFF) { // jump to the next without a loop
-              if (_cop(cigar[s->k]) == BAM_CMATCH|| _cop(cigar[s->k]) == BAM_CEQUAL || _cop(cigar[s->k]) == BAM_CDIFF) s->y += l;
-                s->x += l;
-                ++s->k;
-            } else { // find the next M/D/N/=/X
-              if (_cop(cigar[s->k]) == BAM_CMATCH|| _cop(cigar[s->k]) == BAM_CEQUAL || _cop(cigar[s->k]) == BAM_CDIFF) s->y += l;
-                s->x += l;
-                for (k = s->k + 1; k < c->n_cigar; ++k) {
-                    op = _cop(cigar[k]), l = _cln(cigar[k]);
-                    if (op == BAM_CMATCH || op == BAM_CDEL || op == BAM_CREF_SKIP || op == BAM_CEQUAL || op == BAM_CDIFF) break;
-                    else if (op == BAM_CINS || op == BAM_CSOFT_CLIP) s->y += l;
-                }
-                s->k = k;
-            }
-            assert(s->k < c->n_cigar); // otherwise a bug
-        } // else, do nothing
-    }
-    { // collect pileup information
-        int op, l;
-        op = _cop(cigar[s->k]); l = _cln(cigar[s->k]);
-        p->is_del = p->indel = p->is_refskip = 0;
-        if (s->x + l - 1 == pos && s->k + 1 < c->n_cigar) { // peek the next operation
-            int op2 = _cop(cigar[s->k+1]);
-            int l2 = _cln(cigar[s->k+1]);
-            if (op2 == BAM_CDEL) p->indel = -(int)l2;
-            else if (op2 == BAM_CINS) p->indel = l2;
-            else if (op2 == BAM_CPAD && s->k + 2 < c->n_cigar) { // no working for adjacent padding
-                int l3 = 0;
-                for (k = s->k + 2; k < c->n_cigar; ++k) {
-                    op2 = _cop(cigar[k]); l2 = _cln(cigar[k]);
-                    if (op2 == BAM_CINS) l3 += l2;
-                    else if (op2 == BAM_CDEL || op2 == BAM_CMATCH || op2 == BAM_CREF_SKIP || op2 == BAM_CEQUAL || op2 == BAM_CDIFF) break;
-                }
-                if (l3 > 0) p->indel = l3;
-            }
-        }
-        if (op == BAM_CMATCH || op == BAM_CEQUAL || op == BAM_CDIFF) {
-            p->qpos = s->y + (pos - s->x);
-        } else if (op == BAM_CDEL || op == BAM_CREF_SKIP) {
-            p->is_del = 1; p->qpos = s->y; // FIXME: distinguish D and N!!!!!
-            p->is_refskip = (op == BAM_CREF_SKIP);
-        } // cannot be other operations; otherwise a bug
-        p->is_head = (pos == c->pos); p->is_tail = (pos == s->end);
-    }
-    p->cigar_ind = s->k;
-    return 1;
-}
-
-/*******************************
- *** Expansion of insertions ***
- *******************************/
-
-/*
- * Fills out the kstring with the padded insertion sequence for the current
- * location in 'p'.  If this is not an insertion site, the string is blank.
- *
- * Returns the length of insertion string on success;
- *        -1 on failure.
- */
-int bam_plp_insertion(const bam_pileup1_t *p, kstring_t *ins, int *del_len) {
-    int j, k, indel;
-    uint32_t *cigar;
-
-    if (p->indel <= 0) {
-        if (ks_resize(ins, 1) < 0)
-            return -1;
-        ins->l = 0;
-        ins->s[0] = '\0';
-        return 0;
-    }
-
-    if (del_len)
-        *del_len = 0;
-
-    // Measure indel length including pads
-    indel = 0;
-    k = p->cigar_ind+1;
-    cigar = bam_get_cigar(p->b);
-    while (k < p->b->core.n_cigar) {
-        switch (cigar[k] & BAM_CIGAR_MASK) {
-        case BAM_CPAD:
-        case BAM_CINS:
-            indel += (cigar[k] >> BAM_CIGAR_SHIFT);
-            break;
-        default:
-            k = p->b->core.n_cigar;
-            break;
-        }
-        k++;
-    }
-    ins->l = indel;
-
-    // Produce sequence
-    if (ks_resize(ins, indel+1) < 0)
-        return -1;
-    indel = 0;
-    k = p->cigar_ind+1;
-    j = 1;
-    while (k < p->b->core.n_cigar) {
-        int l, c;
-        switch (cigar[k] & BAM_CIGAR_MASK) {
-        case BAM_CPAD:
-            for (l = 0; l < (cigar[k]>>BAM_CIGAR_SHIFT); l++)
-                ins->s[indel++] = '*';
-            break;
-        case BAM_CINS:
-            for (l = 0; l < (cigar[k]>>BAM_CIGAR_SHIFT); l++, j++) {
-                c = seq_nt16_str[bam_seqi(bam_get_seq(p->b),
-                                          p->qpos + j - p->is_del)];
-                ins->s[indel++] = c;
-            }
-            break;
-        case BAM_CDEL:
-            // eg cigar 1M2I1D gives mpileup output in T+2AA-1C style
-            if (del_len)
-                *del_len = cigar[k]>>BAM_CIGAR_SHIFT;
-            // fall through
-        default:
-            k = p->b->core.n_cigar;
-            break;
-        }
-        k++;
-    }
-    ins->s[indel] = '\0';
-
-    return indel;
-}
-
-/***********************
- *** Pileup iterator ***
- ***********************/
-
-// Dictionary of overlapping reads
-KHASH_MAP_INIT_STR(olap_hash, lbnode_t *)
-typedef khash_t(olap_hash) olap_hash_t;
-
-struct bam_plp_s {
-    mempool_t *mp;
-    lbnode_t *head, *tail;
-    int32_t tid, max_tid;
-    hts_pos_t pos, max_pos;
-    int is_eof, max_plp, error, maxcnt;
-    uint64_t id;
-    bam_pileup1_t *plp;
-    // for the "auto" interface only
-    bam1_t *b;
-    bam_plp_auto_f func;
-    void *data;
-    olap_hash_t *overlaps;
-
-    // For notification of creation and destruction events
-    // and associated client-owned pointer.
-    int (*plp_construct)(void *data, const bam1_t *b, bam_pileup_cd *cd);
-    int (*plp_destruct )(void *data, const bam1_t *b, bam_pileup_cd *cd);
-};
-
-bam_plp_t bam_plp_init(bam_plp_auto_f func, void *data)
-{
-    bam_plp_t iter;
-    iter = (bam_plp_t)calloc(1, sizeof(struct bam_plp_s));
-    iter->mp = mp_init();
-    iter->head = iter->tail = mp_alloc(iter->mp);
-    iter->max_tid = iter->max_pos = -1;
-    iter->maxcnt = 8000;
-    if (func) {
-        iter->func = func;
-        iter->data = data;
-        iter->b = bam_init1();
-    }
-    return iter;
-}
-
-int bam_plp_init_overlaps(bam_plp_t iter)
-{
-    iter->overlaps = kh_init(olap_hash);  // hash for tweaking quality of bases in overlapping reads
-    return iter->overlaps ? 0 : -1;
-}
-
-void bam_plp_destroy(bam_plp_t iter)
-{
-    lbnode_t *p, *pnext;
-    if ( iter->overlaps ) kh_destroy(olap_hash, iter->overlaps);
-    for (p = iter->head; p != NULL; p = pnext) {
-        pnext = p->next;
-        mp_free(iter->mp, p);
-    }
-    mp_destroy(iter->mp);
-    if (iter->b) bam_destroy1(iter->b);
-    free(iter->plp);
-    free(iter);
-}
-
-void bam_plp_constructor(bam_plp_t plp,
-                         int (*func)(void *data, const bam1_t *b, bam_pileup_cd *cd)) {
-    plp->plp_construct = func;
-}
-
-void bam_plp_destructor(bam_plp_t plp,
-                        int (*func)(void *data, const bam1_t *b, bam_pileup_cd *cd)) {
-    plp->plp_destruct = func;
-}
-
-//---------------------------------
-//---  Tweak overlapping reads
-//---------------------------------
-
-/**
- *  cigar_iref2iseq_set()  - find the first CMATCH setting the ref and the read index
- *  cigar_iref2iseq_next() - get the next CMATCH base
- *  @cigar:       pointer to current cigar block (rw)
- *  @cigar_max:   pointer just beyond the last cigar block
- *  @icig:        position within the current cigar block (rw)
- *  @iseq:        position in the sequence (rw)
- *  @iref:        position with respect to the beginning of the read (iref_pos - b->core.pos) (rw)
- *
- *  Returns BAM_CMATCH, -1 when there is no more cigar to process or the requested position is not covered,
- *  or -2 on error.
- */
-static inline int cigar_iref2iseq_set(const uint32_t **cigar,
-                                      const uint32_t *cigar_max,
-                                      hts_pos_t *icig,
-                                      hts_pos_t *iseq,
-                                      hts_pos_t *iref)
-{
-    hts_pos_t pos = *iref;
-    if ( pos < 0 ) return -1;
-    *icig = 0;
-    *iseq = 0;
-    *iref = 0;
-    while ( *cigar<cigar_max )
-    {
-        int cig  = (**cigar) & BAM_CIGAR_MASK;
-        int ncig = (**cigar) >> BAM_CIGAR_SHIFT;
-
-        if ( cig==BAM_CSOFT_CLIP ) { (*cigar)++; *iseq += ncig; *icig = 0; continue; }
-        if ( cig==BAM_CHARD_CLIP || cig==BAM_CPAD ) { (*cigar)++; *icig = 0; continue; }
-        if ( cig==BAM_CMATCH || cig==BAM_CEQUAL || cig==BAM_CDIFF )
-        {
-            pos -= ncig;
-            if ( pos < 0 ) { *icig = ncig + pos; *iseq += *icig; *iref += *icig; return BAM_CMATCH; }
-            (*cigar)++; *iseq += ncig; *icig = 0; *iref += ncig;
-            continue;
-        }
-        if ( cig==BAM_CINS ) { (*cigar)++; *iseq += ncig; *icig = 0; continue; }
-        if ( cig==BAM_CDEL || cig==BAM_CREF_SKIP )
-        {
-            pos -= ncig;
-            if ( pos<0 ) pos = 0;
-            (*cigar)++; *icig = 0; *iref += ncig;
-            continue;
-        }
-        hts_log_error("Unexpected cigar %d", cig);
-        return -2;
-    }
-    *iseq = -1;
-    return -1;
-}
-static inline int cigar_iref2iseq_next(const uint32_t **cigar,
-                                       const uint32_t *cigar_max,
-                                       hts_pos_t *icig,
-                                       hts_pos_t *iseq,
-                                       hts_pos_t *iref)
-{
-    while ( *cigar < cigar_max )
-    {
-        int cig  = (**cigar) & BAM_CIGAR_MASK;
-        int ncig = (**cigar) >> BAM_CIGAR_SHIFT;
-
-        if ( cig==BAM_CMATCH || cig==BAM_CEQUAL || cig==BAM_CDIFF )
-        {
-            if ( *icig >= ncig - 1 ) { *icig = -1;  (*cigar)++; continue; }
-            (*iseq)++; (*icig)++; (*iref)++;
-            return BAM_CMATCH;
-        }
-        if ( cig==BAM_CDEL || cig==BAM_CREF_SKIP ) { (*cigar)++; (*iref) += ncig; *icig = -1; continue; }
-        if ( cig==BAM_CINS ) { (*cigar)++; *iseq += ncig; *icig = -1; continue; }
-        if ( cig==BAM_CSOFT_CLIP ) { (*cigar)++; *iseq += ncig; *icig = -1; continue; }
-        if ( cig==BAM_CHARD_CLIP || cig==BAM_CPAD ) { (*cigar)++; *icig = -1; continue; }
-        hts_log_error("Unexpected cigar %d", cig);
-        return -2;
-    }
-    *iseq = -1;
-    *iref = -1;
-    return -1;
-}
-
-static int tweak_overlap_quality(bam1_t *a, bam1_t *b)
-{
-    const uint32_t *a_cigar = bam_get_cigar(a), *a_cigar_max = a_cigar + a->core.n_cigar;
-    const uint32_t *b_cigar = bam_get_cigar(b), *b_cigar_max = b_cigar + b->core.n_cigar;
-    hts_pos_t a_icig = 0, a_iseq = 0;
-    hts_pos_t b_icig = 0, b_iseq = 0;
-    uint8_t *a_qual = bam_get_qual(a), *b_qual = bam_get_qual(b);
-    uint8_t *a_seq  = bam_get_seq(a), *b_seq = bam_get_seq(b);
-
-    hts_pos_t iref   = b->core.pos;
-    hts_pos_t a_iref = iref - a->core.pos;
-    hts_pos_t b_iref = iref - b->core.pos;
-    int a_ret = cigar_iref2iseq_set(&a_cigar, a_cigar_max, &a_icig, &a_iseq, &a_iref);
-    if ( a_ret<0 ) return a_ret<-1 ? -1:0;  // no overlap or error
-    int b_ret = cigar_iref2iseq_set(&b_cigar, b_cigar_max, &b_icig, &b_iseq, &b_iref);
-    if ( b_ret<0 ) return b_ret<-1 ? -1:0;  // no overlap or error
-
-    #if DBG
-        fprintf(stderr,"tweak %s  n_cigar=%d %d  .. %d-%d vs %"PRIhts_pos"-%"PRIhts_pos"\n", bam_get_qname(a), a->core.n_cigar, b->core.n_cigar,
-            a->core.pos+1,a->core.pos+bam_cigar2rlen(a->core.n_cigar,bam_get_cigar(a)), b->core.pos+1, b->core.pos+bam_cigar2rlen(b->core.n_cigar,bam_get_cigar(b)));
-    #endif
-
-    int err = 0;
-    while ( 1 )
-    {
-        // Increment reference position
-        while ( a_ret >= 0 && a_iref>=0 && a_iref < iref - a->core.pos )
-            a_ret = cigar_iref2iseq_next(&a_cigar, a_cigar_max, &a_icig, &a_iseq, &a_iref);
-        if ( a_ret<0 ) { err = a_ret<-1?-1:0; break; }   // done
-        if ( iref < a_iref + a->core.pos ) iref = a_iref + a->core.pos;
-
-        while ( b_ret >= 0 && b_iref>=0 && b_iref < iref - b->core.pos )
-            b_ret = cigar_iref2iseq_next(&b_cigar, b_cigar_max, &b_icig, &b_iseq, &b_iref);
-        if ( b_ret<0 ) { err = b_ret<-1?-1:0; break; }  // done
-        if ( iref < b_iref + b->core.pos ) iref = b_iref + b->core.pos;
-
-        iref++;
-        if ( a_iref+a->core.pos != b_iref+b->core.pos ) continue;   // only CMATCH positions, don't know what to do with indels
-
-        if (a_iseq > a->core.l_qseq || b_iseq > b->core.l_qseq)
-            return -1;  // Fell off end of sequence, bad CIGAR?
-
-        if ( bam_seqi(a_seq,a_iseq) == bam_seqi(b_seq,b_iseq) )
-        {
-            #if DBG
-                fprintf(stderr,"%c",seq_nt16_str[bam_seqi(a_seq,a_iseq)]);
-            #endif
-            // we are very confident about this base
-            int qual = a_qual[a_iseq] + b_qual[b_iseq];
-            a_qual[a_iseq] = qual>200 ? 200 : qual;
-            b_qual[b_iseq] = 0;
-        }
-        else
-        {
-            if ( a_qual[a_iseq] >= b_qual[b_iseq] )
-            {
-                #if DBG
-                    fprintf(stderr,"[%c/%c]",seq_nt16_str[bam_seqi(a_seq,a_iseq)],tolower_c(seq_nt16_str[bam_seqi(b_seq,b_iseq)]));
-                #endif
-                a_qual[a_iseq] = 0.8 * a_qual[a_iseq];  // not so confident about a_qual anymore given the mismatch
-                b_qual[b_iseq] = 0;
-            }
-            else
-            {
-                #if DBG
-                    fprintf(stderr,"[%c/%c]",tolower_c(seq_nt16_str[bam_seqi(a_seq,a_iseq)]),seq_nt16_str[bam_seqi(b_seq,b_iseq)]);
-                #endif
-                b_qual[b_iseq] = 0.8 * b_qual[b_iseq];
-                a_qual[a_iseq] = 0;
-            }
-        }
-    }
-    #if DBG
-        fprintf(stderr,"\n");
-    #endif
-    return err;
-}
-
-// Fix overlapping reads. Simple soft-clipping did not give good results.
-// Lowering qualities of unwanted bases is more selective and works better.
-//
-// Returns 0 on success, -1 on failure
-static int overlap_push(bam_plp_t iter, lbnode_t *node)
-{
-    if ( !iter->overlaps ) return 0;
-
-    // mapped mates and paired reads only
-    if ( node->b.core.flag&BAM_FMUNMAP || !(node->b.core.flag&BAM_FPROPER_PAIR) ) return 0;
-
-    // no overlap possible, unless some wild cigar
-    if ( (node->b.core.mtid >= 0 && node->b.core.tid != node->b.core.mtid)
-         || (llabs(node->b.core.isize) >= 2*node->b.core.l_qseq
-         && node->b.core.mpos >= node->end) // for those wild cigars
-       ) return 0;
-
-    khiter_t kitr = kh_get(olap_hash, iter->overlaps, bam_get_qname(&node->b));
-    if ( kitr==kh_end(iter->overlaps) )
-    {
-        // Only add reads where the mate is still to arrive
-        if (node->b.core.mpos >= node->b.core.pos ||
-            ((node->b.core.flag & BAM_FPAIRED) && node->b.core.mpos == -1)) {
-            int ret;
-            kitr = kh_put(olap_hash, iter->overlaps, bam_get_qname(&node->b), &ret);
-            if (ret < 0) return -1;
-            kh_value(iter->overlaps, kitr) = node;
-        }
-    }
-    else
-    {
-        lbnode_t *a = kh_value(iter->overlaps, kitr);
-        int err = tweak_overlap_quality(&a->b, &node->b);
-        kh_del(olap_hash, iter->overlaps, kitr);
-        assert(a->end-1 == a->s.end);
-        return err;
-    }
-    return 0;
-}
-
-static void overlap_remove(bam_plp_t iter, const bam1_t *b)
-{
-    if ( !iter->overlaps ) return;
-
-    khiter_t kitr;
-    if ( b )
-    {
-        kitr = kh_get(olap_hash, iter->overlaps, bam_get_qname(b));
-        if ( kitr!=kh_end(iter->overlaps) )
-            kh_del(olap_hash, iter->overlaps, kitr);
-    }
-    else
-    {
-        // remove all
-        for (kitr = kh_begin(iter->overlaps); kitr<kh_end(iter->overlaps); kitr++)
-            if ( kh_exist(iter->overlaps, kitr) ) kh_del(olap_hash, iter->overlaps, kitr);
-    }
-}
-
-
-
-// Prepares next pileup position in bam records collected by bam_plp_auto -> user func -> bam_plp_push. Returns
-// pointer to the piled records if next position is ready or NULL if there is not enough records in the
-// buffer yet (the current position is still the maximum position across all buffered reads).
-const bam_pileup1_t *bam_plp64_next(bam_plp_t iter, int *_tid, hts_pos_t *_pos, int *_n_plp)
-{
-    if (iter->error) { *_n_plp = -1; return NULL; }
-    *_n_plp = 0;
-    if (iter->is_eof && iter->head == iter->tail) return NULL;
-    while (iter->is_eof || iter->max_tid > iter->tid || (iter->max_tid == iter->tid && iter->max_pos > iter->pos)) {
-        int n_plp = 0;
-        // write iter->plp at iter->pos
-        lbnode_t **pptr = &iter->head;
-        while (*pptr != iter->tail) {
-            lbnode_t *p = *pptr;
-            if (p->b.core.tid < iter->tid || (p->b.core.tid == iter->tid && p->end <= iter->pos)) { // then remove
-                overlap_remove(iter, &p->b);
-                if (iter->plp_destruct)
-                    iter->plp_destruct(iter->data, &p->b, &p->cd);
-                *pptr = p->next; mp_free(iter->mp, p);
-            }
-            else {
-                if (p->b.core.tid == iter->tid && p->beg <= iter->pos) { // here: p->end > pos; then add to pileup
-                    if (n_plp == iter->max_plp) { // then double the capacity
-                        iter->max_plp = iter->max_plp? iter->max_plp<<1 : 256;
-                        iter->plp = (bam_pileup1_t*)realloc(iter->plp, sizeof(bam_pileup1_t) * iter->max_plp);
-                    }
-                    iter->plp[n_plp].b = &p->b;
-                    iter->plp[n_plp].cd = p->cd;
-                    if (resolve_cigar2(iter->plp + n_plp, iter->pos, &p->s)) ++n_plp; // actually always true...
-                }
-                pptr = &(*pptr)->next;
-            }
-        }
-        *_n_plp = n_plp; *_tid = iter->tid; *_pos = iter->pos;
-        // update iter->tid and iter->pos
-        if (iter->head != iter->tail) {
-            if (iter->tid > iter->head->b.core.tid) {
-                hts_log_error("Unsorted input. Pileup aborts");
-                iter->error = 1;
-                *_n_plp = -1;
-                return NULL;
-            }
-        }
-        if (iter->tid < iter->head->b.core.tid) { // come to a new reference sequence
-            iter->tid = iter->head->b.core.tid; iter->pos = iter->head->beg; // jump to the next reference
-        } else if (iter->pos < iter->head->beg) { // here: tid == head->b.core.tid
-            iter->pos = iter->head->beg; // jump to the next position
-        } else ++iter->pos; // scan contiguously
-        // return
-        if (n_plp) return iter->plp;
-        if (iter->is_eof && iter->head == iter->tail) break;
-    }
-    return NULL;
-}
-
-const bam_pileup1_t *bam_plp_next(bam_plp_t iter, int *_tid, int *_pos, int *_n_plp)
-{
-    hts_pos_t pos64 = 0;
-    const bam_pileup1_t *p = bam_plp64_next(iter, _tid, &pos64, _n_plp);
-    if (pos64 < INT_MAX) {
-        *_pos = pos64;
-    } else {
-        hts_log_error("Position %"PRId64" too large", pos64);
-        *_pos = INT_MAX;
-        iter->error = 1;
-        *_n_plp = -1;
-        return NULL;
-    }
-    return p;
-}
-
-int bam_plp_push(bam_plp_t iter, const bam1_t *b)
-{
-    if (iter->error) return -1;
-    if (b) {
-        if (b->core.tid < 0) { overlap_remove(iter, b); return 0; }
-        // Skip only unmapped reads here, any additional filtering must be done in iter->func
-        if (b->core.flag & BAM_FUNMAP) { overlap_remove(iter, b); return 0; }
-        if (iter->tid == b->core.tid && iter->pos == b->core.pos && iter->mp->cnt > iter->maxcnt)
-        {
-            overlap_remove(iter, b);
-            return 0;
-        }
-        if (bam_copy1(&iter->tail->b, b) == NULL)
-            return -1;
-        iter->tail->b.id = iter->id++;
-        iter->tail->beg = b->core.pos;
-        // Use raw rlen rather than bam_endpos() which adjusts rlen=0 to rlen=1
-        iter->tail->end = b->core.pos + bam_cigar2rlen(b->core.n_cigar, bam_get_cigar(b));
-        iter->tail->s = g_cstate_null; iter->tail->s.end = iter->tail->end - 1; // initialize cstate_t
-        if (b->core.tid < iter->max_tid) {
-            hts_log_error("The input is not sorted (chromosomes out of order)");
-            iter->error = 1;
-            return -1;
-        }
-        if ((b->core.tid == iter->max_tid) && (iter->tail->beg < iter->max_pos)) {
-            hts_log_error("The input is not sorted (reads out of order)");
-            iter->error = 1;
-            return -1;
-        }
-        iter->max_tid = b->core.tid; iter->max_pos = iter->tail->beg;
-        if (iter->tail->end > iter->pos || iter->tail->b.core.tid > iter->tid) {
-            lbnode_t *next = mp_alloc(iter->mp);
-            if (!next) {
-                iter->error = 1;
-                return -1;
-            }
-            if (iter->plp_construct)
-                iter->plp_construct(iter->data, &iter->tail->b,
-                                    &iter->tail->cd);
-            if (overlap_push(iter, iter->tail) < 0) {
-                mp_free(iter->mp, next);
-                iter->error = 1;
-                return -1;
-            }
-            iter->tail->next = next;
-            iter->tail = iter->tail->next;
-        }
-    } else iter->is_eof = 1;
-    return 0;
-}
-
-const bam_pileup1_t *bam_plp64_auto(bam_plp_t iter, int *_tid, hts_pos_t *_pos, int *_n_plp)
-{
-    const bam_pileup1_t *plp;
-    if (iter->func == 0 || iter->error) { *_n_plp = -1; return 0; }
-    if ((plp = bam_plp64_next(iter, _tid, _pos, _n_plp)) != 0) return plp;
-    else { // no pileup line can be obtained; read alignments
-        *_n_plp = 0;
-        if (iter->is_eof) return 0;
-        int ret;
-        while ( (ret=iter->func(iter->data, iter->b)) >= 0) {
-            if (bam_plp_push(iter, iter->b) < 0) {
-                *_n_plp = -1;
-                return 0;
-            }
-            if ((plp = bam_plp64_next(iter, _tid, _pos, _n_plp)) != 0) return plp;
-            // otherwise no pileup line can be returned; read the next alignment.
-        }
-        if ( ret < -1 ) { iter->error = ret; *_n_plp = -1; return 0; }
-        if (bam_plp_push(iter, 0) < 0) {
-            *_n_plp = -1;
-            return 0;
-        }
-        if ((plp = bam_plp64_next(iter, _tid, _pos, _n_plp)) != 0) return plp;
-        return 0;
-    }
-}
-
-const bam_pileup1_t *bam_plp_auto(bam_plp_t iter, int *_tid, int *_pos, int *_n_plp)
-{
-    hts_pos_t pos64 = 0;
-    const bam_pileup1_t *p = bam_plp64_auto(iter, _tid, &pos64, _n_plp);
-    if (pos64 < INT_MAX) {
-        *_pos = pos64;
-    } else {
-        hts_log_error("Position %"PRId64" too large", pos64);
-        *_pos = INT_MAX;
-        iter->error = 1;
-        *_n_plp = -1;
-        return NULL;
-    }
-    return p;
-}
-
-void bam_plp_reset(bam_plp_t iter)
-{
-    overlap_remove(iter, NULL);
-    iter->max_tid = iter->max_pos = -1;
-    iter->tid = iter->pos = 0;
-    iter->is_eof = 0;
-    while (iter->head != iter->tail) {
-        lbnode_t *p = iter->head;
-        iter->head = p->next;
-        mp_free(iter->mp, p);
-    }
-}
-
-void bam_plp_set_maxcnt(bam_plp_t iter, int maxcnt)
-{
-    iter->maxcnt = maxcnt;
-}
-
-/************************
- *** Mpileup iterator ***
- ************************/
-
-struct bam_mplp_s {
-    int n;
-    int32_t min_tid, *tid;
-    hts_pos_t min_pos, *pos;
-    bam_plp_t *iter;
-    int *n_plp;
-    const bam_pileup1_t **plp;
-};
-
-bam_mplp_t bam_mplp_init(int n, bam_plp_auto_f func, void **data)
-{
-    int i;
-    bam_mplp_t iter;
-    iter = (bam_mplp_t)calloc(1, sizeof(struct bam_mplp_s));
-    iter->pos = (hts_pos_t*)calloc(n, sizeof(hts_pos_t));
-    iter->tid = (int32_t*)calloc(n, sizeof(int32_t));
-    iter->n_plp = (int*)calloc(n, sizeof(int));
-    iter->plp = (const bam_pileup1_t**)calloc(n, sizeof(bam_pileup1_t*));
-    iter->iter = (bam_plp_t*)calloc(n, sizeof(bam_plp_t));
-    iter->n = n;
-    iter->min_pos = HTS_POS_MAX;
-    iter->min_tid = (uint32_t)-1;
-    for (i = 0; i < n; ++i) {
-        iter->iter[i] = bam_plp_init(func, data[i]);
-        iter->pos[i] = iter->min_pos;
-        iter->tid[i] = iter->min_tid;
-    }
-    return iter;
-}
-
-int bam_mplp_init_overlaps(bam_mplp_t iter)
-{
-    int i, r = 0;
-    for (i = 0; i < iter->n; ++i)
-        r |= bam_plp_init_overlaps(iter->iter[i]);
-    return r == 0 ? 0 : -1;
-}
-
-void bam_mplp_set_maxcnt(bam_mplp_t iter, int maxcnt)
-{
-    int i;
-    for (i = 0; i < iter->n; ++i)
-        iter->iter[i]->maxcnt = maxcnt;
-}
-
-void bam_mplp_destroy(bam_mplp_t iter)
-{
-    int i;
-    for (i = 0; i < iter->n; ++i) bam_plp_destroy(iter->iter[i]);
-    free(iter->iter); free(iter->pos); free(iter->tid);
-    free(iter->n_plp); free(iter->plp);
-    free(iter);
-}
-
-int bam_mplp64_auto(bam_mplp_t iter, int *_tid, hts_pos_t *_pos, int *n_plp, const bam_pileup1_t **plp)
-{
-    int i, ret = 0;
-    hts_pos_t new_min_pos = HTS_POS_MAX;
-    uint32_t new_min_tid = (uint32_t)-1;
-    for (i = 0; i < iter->n; ++i) {
-        if (iter->pos[i] == iter->min_pos && iter->tid[i] == iter->min_tid) {
-            int tid;
-            hts_pos_t pos;
-            iter->plp[i] = bam_plp64_auto(iter->iter[i], &tid, &pos, &iter->n_plp[i]);
-            if ( iter->iter[i]->error ) return -1;
-            if (iter->plp[i]) {
-                iter->tid[i] = tid;
-                iter->pos[i] = pos;
-            } else {
-                iter->tid[i] = 0;
-                iter->pos[i] = 0;
-            }
-        }
-        if (iter->plp[i]) {
-            if (iter->tid[i] < new_min_tid) {
-                new_min_tid = iter->tid[i];
-                new_min_pos = iter->pos[i];
-            } else if (iter->tid[i] == new_min_tid && iter->pos[i] < new_min_pos) {
-                new_min_pos = iter->pos[i];
-            }
-        }
-    }
-    iter->min_pos = new_min_pos;
-    iter->min_tid = new_min_tid;
-    if (new_min_pos == HTS_POS_MAX) return 0;
-    *_tid = new_min_tid; *_pos = new_min_pos;
-    for (i = 0; i < iter->n; ++i) {
-        if (iter->pos[i] == iter->min_pos && iter->tid[i] == iter->min_tid) {
-            n_plp[i] = iter->n_plp[i], plp[i] = iter->plp[i];
-            ++ret;
-        } else n_plp[i] = 0, plp[i] = 0;
-    }
-    return ret;
-}
-
-int bam_mplp_auto(bam_mplp_t iter, int *_tid, int *_pos, int *n_plp, const bam_pileup1_t **plp)
-{
-    hts_pos_t pos64 = 0;
-    int ret = bam_mplp64_auto(iter, _tid, &pos64, n_plp, plp);
-    if (ret >= 0) {
-        if (pos64 < INT_MAX) {
-            *_pos = pos64;
-        } else {
-            hts_log_error("Position %"PRId64" too large", pos64);
-            *_pos = INT_MAX;
-            return -1;
-        }
-    }
-    return ret;
-}
-
-void bam_mplp_reset(bam_mplp_t iter)
-{
-    int i;
-    iter->min_pos = HTS_POS_MAX;
-    iter->min_tid = (uint32_t)-1;
-    for (i = 0; i < iter->n; ++i) {
-        bam_plp_reset(iter->iter[i]);
-        iter->pos[i] = HTS_POS_MAX;
-        iter->tid[i] = (uint32_t)-1;
-        iter->n_plp[i] = 0;
-        iter->plp[i] = NULL;
-    }
-}
-
-void bam_mplp_constructor(bam_mplp_t iter,
-                          int (*func)(void *arg, const bam1_t *b, bam_pileup_cd *cd)) {
-    int i;
-    for (i = 0; i < iter->n; ++i)
-        bam_plp_constructor(iter->iter[i], func);
-}
-
-void bam_mplp_destructor(bam_mplp_t iter,
-                         int (*func)(void *arg, const bam1_t *b, bam_pileup_cd *cd)) {
-    int i;
-    for (i = 0; i < iter->n; ++i)
-        bam_plp_destructor(iter->iter[i], func);
-}
-
-#endif // ~!defined(BAM_NO_PILEUP)
diff -ruN stringtie.orig/htslib/sam_internal.h stringtie/htslib/sam_internal.h
--- stringtie.orig/htslib/sam_internal.h	2024-02-28 13:57:39.701246126 +0100
+++ stringtie/htslib/sam_internal.h	1970-01-01 01:00:00.000000000 +0100
@@ -1,101 +0,0 @@
-/*  sam_internal.h -- internal functions; not part of the public API.
-
-    Copyright (C) 2019-2020 Genome Research Ltd.
-
-Permission is hereby granted, free of charge, to any person obtaining a copy
-of this software and associated documentation files (the "Software"), to deal
-in the Software without restriction, including without limitation the rights
-to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
-copies of the Software, and to permit persons to whom the Software is
-furnished to do so, subject to the following conditions:
-
-The above copyright notice and this permission notice shall be included in
-all copies or substantial portions of the Software.
-
-THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
-IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
-FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
-THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
-LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
-FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
-DEALINGS IN THE SOFTWARE.  */
-
-#ifndef HTSLIB_SAM_INTERNAL_H
-#define HTSLIB_SAM_INTERNAL_H
-
-#include <errno.h>
-#include <stdint.h>
-#include "htslib/sam.h"
-
-#ifdef __cplusplus
-extern "C" {
-#endif
-
-// Used internally in the SAM format multi-threading.
-int sam_state_destroy(samFile *fp);
-int sam_set_thread_pool(htsFile *fp, htsThreadPool *p);
-int sam_set_threads(htsFile *fp, int nthreads);
-
-// bam1_t data (re)allocation
-int sam_realloc_bam_data(bam1_t *b, size_t desired);
-
-static inline int realloc_bam_data(bam1_t *b, size_t desired)
-{
-    if (desired <= b->m_data) return 0;
-    return sam_realloc_bam_data(b, desired);
-}
-
-static inline int possibly_expand_bam_data(bam1_t *b, size_t bytes) {
-    size_t new_len = (size_t) b->l_data + bytes;
-
-    if (new_len > INT32_MAX || new_len < bytes) { // Too big or overflow
-        errno = ENOMEM;
-        return -1;
-    }
-    if (new_len <= b->m_data) return 0;
-    return sam_realloc_bam_data(b, new_len);
-}
-
-/*
- * Convert a nibble encoded BAM sequence to a string of bases.
- *
- * We do this 2 bp at a time for speed. Equiv to:
- *
- * for (i = 0; i < len; i++)
- *    seq[i] = seq_nt16_str[bam_seqi(nib, i)];
- */
-static inline void nibble2base(uint8_t *nib, char *seq, int len) {
-    static const char code2base[512] =
-        "===A=C=M=G=R=S=V=T=W=Y=H=K=D=B=N"
-        "A=AAACAMAGARASAVATAWAYAHAKADABAN"
-        "C=CACCCMCGCRCSCVCTCWCYCHCKCDCBCN"
-        "M=MAMCMMMGMRMSMVMTMWMYMHMKMDMBMN"
-        "G=GAGCGMGGGRGSGVGTGWGYGHGKGDGBGN"
-        "R=RARCRMRGRRRSRVRTRWRYRHRKRDRBRN"
-        "S=SASCSMSGSRSSSVSTSWSYSHSKSDSBSN"
-        "V=VAVCVMVGVRVSVVVTVWVYVHVKVDVBVN"
-        "T=TATCTMTGTRTSTVTTTWTYTHTKTDTBTN"
-        "W=WAWCWMWGWRWSWVWTWWWYWHWKWDWBWN"
-        "Y=YAYCYMYGYRYSYVYTYWYYYHYKYDYBYN"
-        "H=HAHCHMHGHRHSHVHTHWHYHHHKHDHBHN"
-        "K=KAKCKMKGKRKSKVKTKWKYKHKKKDKBKN"
-        "D=DADCDMDGDRDSDVDTDWDYDHDKDDDBDN"
-        "B=BABCBMBGBRBSBVBTBWBYBHBKBDBBBN"
-        "N=NANCNMNGNRNSNVNTNWNYNHNKNDNBNN";
-
-    int i, len2 = len/2;
-    seq[0] = 0;
-
-    for (i = 0; i < len2; i++)
-        // Note size_t cast helps gcc optimiser.
-        memcpy(&seq[i*2], &code2base[(size_t)nib[i]*2], 2);
-
-    if ((i *= 2) < len)
-        seq[i] = seq_nt16_str[bam_seqi(nib, i)];
-}
-
-#ifdef __cplusplus
-}
-#endif
-
-#endif
diff -ruN stringtie.orig/htslib/synced_bcf_reader.c stringtie/htslib/synced_bcf_reader.c
--- stringtie.orig/htslib/synced_bcf_reader.c	2024-02-28 13:57:39.701246126 +0100
+++ stringtie/htslib/synced_bcf_reader.c	1970-01-01 01:00:00.000000000 +0100
@@ -1,1357 +0,0 @@
-/*  synced_bcf_reader.c -- stream through multiple VCF files.
-
-    Copyright (C) 2012-2020 Genome Research Ltd.
-
-    Author: Petr Danecek <pd3@sanger.ac.uk>
-
-Permission is hereby granted, free of charge, to any person obtaining a copy
-of this software and associated documentation files (the "Software"), to deal
-in the Software without restriction, including without limitation the rights
-to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
-copies of the Software, and to permit persons to whom the Software is
-furnished to do so, subject to the following conditions:
-
-The above copyright notice and this permission notice shall be included in
-all copies or substantial portions of the Software.
-
-THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
-IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
-FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
-THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
-LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
-FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
-DEALINGS IN THE SOFTWARE.  */
-
-#define HTS_BUILDING_LIBRARY // Enables HTSLIB_EXPORT, see htslib/hts_defs.h
-#include <config.h>
-
-#include <assert.h>
-#include <stdio.h>
-#include <unistd.h>
-#include <string.h>
-#include <strings.h>
-#include <limits.h>
-#include <inttypes.h>
-#include <errno.h>
-#include <sys/stat.h>
-#include "htslib/synced_bcf_reader.h"
-#include "htslib/kseq.h"
-#include "htslib/khash_str2int.h"
-#include "htslib/bgzf.h"
-#include "htslib/thread_pool.h"
-#include "bcf_sr_sort.h"
-
-#define REQUIRE_IDX_      1
-#define ALLOW_NO_IDX_     2
-
-// Maximum indexable coordinate of .csi, for default min_shift of 14.
-// This comes out to about 17 Tbp.  Limiting factor is the bin number,
-// which is a uint32_t in CSI.  The highest number of levels compatible
-// with this is 10 (needs 31 bits).
-#define MAX_CSI_COOR ((1LL << (14 + 30)) - 1)
-
-typedef struct
-{
-    hts_pos_t start, end;   // records are marked for skipping have start>end
-}
-region1_t;
-
-typedef struct bcf_sr_region_t
-{
-    region1_t *regs;            // regions will sorted and merged, redundant records marked for skipping have start>end
-    int nregs, mregs, creg;     // creg: the current active region
-}
-region_t;
-
-#define BCF_SR_AUX(x) ((aux_t*)((x)->aux))
-typedef struct
-{
-    sr_sort_t sort;
-}
-aux_t;
-
-static int _regions_add(bcf_sr_regions_t *reg, const char *chr, hts_pos_t start, hts_pos_t end);
-static bcf_sr_regions_t *_regions_init_string(const char *str);
-static int _regions_match_alleles(bcf_sr_regions_t *reg, int als_idx, bcf1_t *rec);
-static void _regions_sort_and_merge(bcf_sr_regions_t *reg);
-
-char *bcf_sr_strerror(int errnum)
-{
-    switch (errnum)
-    {
-        case open_failed:
-            return strerror(errno);
-        case not_bgzf:
-            return "not compressed with bgzip";
-        case idx_load_failed:
-            return "could not load index";
-        case file_type_error:
-            return "unknown file type";
-        case api_usage_error:
-            return "API usage error";
-        case header_error:
-            return "could not parse header";
-        case no_eof:
-            return "no BGZF EOF marker; file may be truncated";
-        case no_memory:
-            return "Out of memory";
-        case vcf_parse_error:
-            return "VCF parse error";
-        case bcf_read_error:
-            return "BCF read error";
-        case noidx_error:
-            return "merge of unindexed files failed";
-        default: return "";
-    }
-}
-
-int bcf_sr_set_opt(bcf_srs_t *readers, bcf_sr_opt_t opt, ...)
-{
-    va_list args;
-    switch (opt)
-    {
-        case BCF_SR_REQUIRE_IDX:
-            readers->require_index = REQUIRE_IDX_;
-            return 0;
-
-        case BCF_SR_ALLOW_NO_IDX:
-            readers->require_index = ALLOW_NO_IDX_;
-            return 0;
-
-        case BCF_SR_PAIR_LOGIC:
-            va_start(args, opt);
-            BCF_SR_AUX(readers)->sort.pair = va_arg(args, int);
-            return 0;
-
-        default:
-            break;
-    }
-    return 1;
-}
-
-static int *init_filters(bcf_hdr_t *hdr, const char *filters, int *nfilters)
-{
-    kstring_t str = {0,0,0};
-    const char *tmp = filters, *prev = filters;
-    int nout = 0, *out = NULL;
-    while ( 1 )
-    {
-        if ( *tmp==',' || !*tmp )
-        {
-            int *otmp = (int*) realloc(out, (nout+1)*sizeof(int));
-            if (!otmp)
-                goto err;
-            out = otmp;
-            if ( tmp-prev==1 && *prev=='.' )
-            {
-                out[nout] = -1;
-                nout++;
-            }
-            else
-            {
-                str.l = 0;
-                kputsn(prev, tmp-prev, &str);
-                out[nout] = bcf_hdr_id2int(hdr, BCF_DT_ID, str.s);
-                if ( out[nout]>=0 ) nout++;
-            }
-            if ( !*tmp ) break;
-            prev = tmp+1;
-        }
-        tmp++;
-    }
-    if ( str.m ) free(str.s);
-    *nfilters = nout;
-    return out;
-
- err:
-    if (str.m) free(str.s);
-    free(out);
-    return NULL;
-}
-
-int bcf_sr_set_regions(bcf_srs_t *readers, const char *regions, int is_file)
-{
-    assert( !readers->regions );
-    if ( readers->nreaders )
-    {
-        hts_log_error("Must call bcf_sr_set_regions() before bcf_sr_add_reader()");
-        return -1;
-    }
-    readers->regions = bcf_sr_regions_init(regions,is_file,0,1,-2);
-    if ( !readers->regions ) return -1;
-    readers->explicit_regs = 1;
-    readers->require_index = REQUIRE_IDX_;
-    return 0;
-}
-int bcf_sr_set_targets(bcf_srs_t *readers, const char *targets, int is_file, int alleles)
-{
-    assert( !readers->targets );
-    if ( targets[0]=='^' )
-    {
-        readers->targets_exclude = 1;
-        targets++;
-    }
-    readers->targets = bcf_sr_regions_init(targets,is_file,0,1,-2);
-    if ( !readers->targets ) return -1;
-    readers->targets_als = alleles;
-    return 0;
-}
-
-int bcf_sr_set_threads(bcf_srs_t *files, int n_threads)
-{
-    if (!(files->n_threads = n_threads))
-        return 0;
-
-    files->p = calloc(1, sizeof(*files->p));
-    if (!files->p) {
-        files->errnum = no_memory;
-        return -1;
-    }
-    if (!(files->p->pool = hts_tpool_init(n_threads)))
-        return -1;
-
-    return 0;
-}
-
-void bcf_sr_destroy_threads(bcf_srs_t *files) {
-    if (!files->p)
-        return;
-
-    if (files->p->pool)
-        hts_tpool_destroy(files->p->pool);
-    free(files->p);
-}
-
-int bcf_sr_add_reader(bcf_srs_t *files, const char *fname)
-{
-    char fmode[5];
-    strcpy(fmode, "r");
-    vcf_open_mode(fmode+1, fname, NULL);
-    htsFile* file_ptr = hts_open(fname, fmode);
-    if ( ! file_ptr ) {
-        files->errnum = open_failed;
-        return 0;
-    }
-
-    files->has_line = (int*) realloc(files->has_line, sizeof(int)*(files->nreaders+1));
-    files->has_line[files->nreaders] = 0;
-    files->readers  = (bcf_sr_t*) realloc(files->readers, sizeof(bcf_sr_t)*(files->nreaders+1));
-    bcf_sr_t *reader = &files->readers[files->nreaders++];
-    memset(reader,0,sizeof(bcf_sr_t));
-
-    reader->file = file_ptr;
-
-    files->errnum = 0;
-
-    if ( reader->file->format.compression==bgzf )
-    {
-        BGZF *bgzf = hts_get_bgzfp(reader->file);
-        if ( bgzf && bgzf_check_EOF(bgzf) == 0 ) {
-            files->errnum = no_eof;
-            hts_log_warning("No BGZF EOF marker; file '%s' may be truncated", fname);
-        }
-        if (files->p)
-            bgzf_thread_pool(bgzf, files->p->pool, files->p->qsize);
-    }
-
-    if ( files->require_index==REQUIRE_IDX_ )
-    {
-        if ( reader->file->format.format==vcf )
-        {
-            if ( reader->file->format.compression!=bgzf )
-            {
-                files->errnum = not_bgzf;
-                return 0;
-            }
-
-            reader->tbx_idx = tbx_index_load(fname);
-            if ( !reader->tbx_idx )
-            {
-                files->errnum = idx_load_failed;
-                return 0;
-            }
-
-            reader->header = bcf_hdr_read(reader->file);
-        }
-        else if ( reader->file->format.format==bcf )
-        {
-            if ( reader->file->format.compression!=bgzf )
-            {
-                files->errnum = not_bgzf;
-                return 0;
-            }
-
-            reader->header = bcf_hdr_read(reader->file);
-
-            reader->bcf_idx = bcf_index_load(fname);
-            if ( !reader->bcf_idx )
-            {
-                files->errnum = idx_load_failed;
-                return 0;
-            }
-        }
-        else
-        {
-            files->errnum = file_type_error;
-            return 0;
-        }
-    }
-    else
-    {
-        if ( reader->file->format.format==bcf || reader->file->format.format==vcf )
-        {
-            reader->header = bcf_hdr_read(reader->file);
-        }
-        else
-        {
-            files->errnum = file_type_error;
-            return 0;
-        }
-        files->streaming = 1;
-    }
-    if ( files->streaming && files->nreaders>1 )
-    {
-        static int no_index_warned = 0;
-        if ( files->require_index==ALLOW_NO_IDX_ && !no_index_warned )
-        {
-            hts_log_warning("Using multiple unindexed files may produce errors, make sure chromosomes are in the same order!");
-            no_index_warned = 1;
-        }
-        if ( files->require_index!=ALLOW_NO_IDX_ )
-        {
-            files->errnum = api_usage_error;
-            hts_log_error("Must set require_index when the number of readers is greater than one");
-            return 0;
-        }
-    }
-    if ( files->streaming && files->regions )
-    {
-        files->errnum = api_usage_error;
-        hts_log_error("Cannot tabix-jump in streaming mode");
-        return 0;
-    }
-    if ( !reader->header )
-    {
-        files->errnum = header_error;
-        return 0;
-    }
-
-    reader->fname = strdup(fname);
-    if ( files->apply_filters )
-        reader->filter_ids = init_filters(reader->header, files->apply_filters, &reader->nfilter_ids);
-
-    // Update list of chromosomes
-    if ( !files->explicit_regs && !files->streaming )
-    {
-        int n = 0, i;
-        const char **names = reader->tbx_idx ? tbx_seqnames(reader->tbx_idx, &n) : bcf_hdr_seqnames(reader->header, &n);
-        for (i=0; i<n; i++)
-        {
-            if ( !files->regions )
-                files->regions = _regions_init_string(names[i]);
-            else
-                _regions_add(files->regions, names[i], -1, -1);
-        }
-        free(names);
-        _regions_sort_and_merge(files->regions);
-    }
-
-    if ( files->require_index==ALLOW_NO_IDX_ && files->nreaders > 1 )
-    {
-        bcf_hdr_t *hdr0 = files->readers[0].header;
-        bcf_hdr_t *hdr1 = reader->header;
-        if ( hdr0->n[BCF_DT_CTG]!=hdr1->n[BCF_DT_CTG] )
-        {
-            files->errnum = noidx_error;
-            hts_log_error("Different number of sequences in the header, refusing to stream multiple unindexed files");
-            return 0;
-        }
-        int i;
-        for (i=0; i<hdr0->n[BCF_DT_CTG]; i++)
-        {
-            if ( strcmp(bcf_hdr_id2name(hdr0,i),bcf_hdr_id2name(hdr1,i)) )
-            {
-                files->errnum = noidx_error;
-                hts_log_error("Sequences in the header appear in different order, refusing to stream multiple unindexed files");
-                return 0;
-            }
-        }
-    }
-
-    return 1;
-}
-
-bcf_srs_t *bcf_sr_init(void)
-{
-    bcf_srs_t *files = (bcf_srs_t*) calloc(1,sizeof(bcf_srs_t));
-    files->aux = (aux_t*) calloc(1,sizeof(aux_t));
-    bcf_sr_sort_init(&BCF_SR_AUX(files)->sort);
-    return files;
-}
-
-static void bcf_sr_destroy1(bcf_sr_t *reader)
-{
-    free(reader->fname);
-    if ( reader->tbx_idx ) tbx_destroy(reader->tbx_idx);
-    if ( reader->bcf_idx ) hts_idx_destroy(reader->bcf_idx);
-    bcf_hdr_destroy(reader->header);
-    hts_close(reader->file);
-    if ( reader->itr ) tbx_itr_destroy(reader->itr);
-    int j;
-    for (j=0; j<reader->mbuffer; j++)
-        bcf_destroy1(reader->buffer[j]);
-    free(reader->buffer);
-    free(reader->samples);
-    free(reader->filter_ids);
-}
-
-void bcf_sr_destroy(bcf_srs_t *files)
-{
-    int i;
-    for (i=0; i<files->nreaders; i++)
-        bcf_sr_destroy1(&files->readers[i]);
-    free(files->has_line);
-    free(files->readers);
-    for (i=0; i<files->n_smpl; i++) free(files->samples[i]);
-    free(files->samples);
-    if (files->targets) bcf_sr_regions_destroy(files->targets);
-    if (files->regions) bcf_sr_regions_destroy(files->regions);
-    if (files->tmps.m) free(files->tmps.s);
-    if (files->n_threads) bcf_sr_destroy_threads(files);
-    bcf_sr_sort_destroy(&BCF_SR_AUX(files)->sort);
-    free(files->aux);
-    free(files);
-}
-
-void bcf_sr_remove_reader(bcf_srs_t *files, int i)
-{
-    assert( !files->samples );  // not ready for this yet
-    bcf_sr_sort_remove_reader(files, &BCF_SR_AUX(files)->sort, i);
-    bcf_sr_destroy1(&files->readers[i]);
-    if ( i+1 < files->nreaders )
-    {
-        memmove(&files->readers[i], &files->readers[i+1], (files->nreaders-i-1)*sizeof(bcf_sr_t));
-        memmove(&files->has_line[i], &files->has_line[i+1], (files->nreaders-i-1)*sizeof(int));
-    }
-    files->nreaders--;
-}
-
-#if DEBUG_SYNCED_READER
-void debug_buffer(FILE *fp, bcf_sr_t *reader)
-{
-    int j;
-    for (j=0; j<=reader->nbuffer; j++)
-    {
-        bcf1_t *line = reader->buffer[j];
-        fprintf(fp,"\t%p\t%s%s\t%s:%"PRIhts_pos"\t%s ", (void*)line,reader->fname,j==0?"*":" ",reader->header->id[BCF_DT_CTG][line->rid].key,line->pos+1,line->n_allele?line->d.allele[0]:"");
-        int k;
-        for (k=1; k<line->n_allele; k++) fprintf(fp," %s", line->d.allele[k]);
-        fprintf(fp,"\n");
-    }
-}
-
-void debug_buffers(FILE *fp, bcf_srs_t *files)
-{
-    int i;
-    for (i=0; i<files->nreaders; i++)
-    {
-        fprintf(fp, "has_line: %d\t%s\n", bcf_sr_has_line(files,i),files->readers[i].fname);
-        debug_buffer(fp, &files->readers[i]);
-    }
-    fprintf(fp,"\n");
-}
-#endif
-
-static inline int has_filter(bcf_sr_t *reader, bcf1_t *line)
-{
-    int i, j;
-    if ( !line->d.n_flt )
-    {
-        for (j=0; j<reader->nfilter_ids; j++)
-            if ( reader->filter_ids[j]<0 ) return 1;
-        return 0;
-    }
-    for (i=0; i<line->d.n_flt; i++)
-    {
-        for (j=0; j<reader->nfilter_ids; j++)
-            if ( line->d.flt[i]==reader->filter_ids[j] ) return 1;
-    }
-    return 0;
-}
-
-static int _reader_seek(bcf_sr_t *reader, const char *seq, hts_pos_t start, hts_pos_t end)
-{
-    if ( end>=MAX_CSI_COOR )
-    {
-        hts_log_error("The coordinate is out of csi index limit: %"PRIhts_pos, end+1);
-        exit(1);
-    }
-    if ( reader->itr )
-    {
-        hts_itr_destroy(reader->itr);
-        reader->itr = NULL;
-    }
-    reader->nbuffer = 0;
-    if ( reader->tbx_idx )
-    {
-        int tid = tbx_name2id(reader->tbx_idx, seq);
-        if ( tid==-1 ) return -1;    // the sequence not present in this file
-        reader->itr = tbx_itr_queryi(reader->tbx_idx,tid,start,end+1);
-    }
-    else
-    {
-        int tid = bcf_hdr_name2id(reader->header, seq);
-        if ( tid==-1 ) return -1;    // the sequence not present in this file
-        reader->itr = bcf_itr_queryi(reader->bcf_idx,tid,start,end+1);
-    }
-    if (!reader->itr) {
-        hts_log_error("Could not seek: %s:%"PRIhts_pos"-%"PRIhts_pos, seq, start + 1, end + 1);
-        assert(0);
-    }
-    return 0;
-}
-
-/*
- *  _readers_next_region() - jumps to next region if necessary
- *  Returns 0 on success or -1 when there are no more regions left
- */
-static int _readers_next_region(bcf_srs_t *files)
-{
-    // Need to open new chromosome? Check number of lines in all readers' buffers
-    int i, eos = 0;
-    for (i=0; i<files->nreaders; i++)
-        if ( !files->readers[i].itr && !files->readers[i].nbuffer ) eos++;
-
-    if ( eos!=files->nreaders )
-    {
-        // Some of the readers still has buffered lines
-        return 0;
-    }
-
-    // No lines in the buffer, need to open new region or quit.
-    int prev_iseq = files->regions->iseq;
-    hts_pos_t prev_end = files->regions->end;
-    if ( bcf_sr_regions_next(files->regions)<0 ) return -1;
-    files->regions->prev_end = prev_iseq==files->regions->iseq ? prev_end : -1;
-
-    for (i=0; i<files->nreaders; i++)
-        _reader_seek(&files->readers[i],files->regions->seq_names[files->regions->iseq],files->regions->start,files->regions->end);
-
-    return 0;
-}
-
-/*
- *  _reader_fill_buffer() - buffers all records with the same coordinate
- */
-static int _reader_fill_buffer(bcf_srs_t *files, bcf_sr_t *reader)
-{
-    // Return if the buffer is full: the coordinate of the last buffered record differs
-    if ( reader->nbuffer && reader->buffer[reader->nbuffer]->pos != reader->buffer[1]->pos ) return 0;
-
-    // No iterator (sequence not present in this file) and not streaming
-    if ( !reader->itr && !files->streaming ) return 0;
-
-    // Fill the buffer with records starting at the same position
-    int i, ret = 0;
-    while (1)
-    {
-        if ( reader->nbuffer+1 >= reader->mbuffer )
-        {
-            // Increase buffer size
-            reader->mbuffer += 8;
-            reader->buffer = (bcf1_t**) realloc(reader->buffer, sizeof(bcf1_t*)*reader->mbuffer);
-            for (i=8; i>0; i--)     // initialize
-            {
-                reader->buffer[reader->mbuffer-i] = bcf_init1();
-                reader->buffer[reader->mbuffer-i]->max_unpack = files->max_unpack;
-                reader->buffer[reader->mbuffer-i]->pos = -1;    // for rare cases when VCF starts from 1
-            }
-        }
-        if ( files->streaming )
-        {
-            if ( reader->file->format.format==vcf )
-            {
-                if ( (ret=hts_getline(reader->file, KS_SEP_LINE, &files->tmps)) < 0 ) break;   // no more lines
-                ret = vcf_parse1(&files->tmps, reader->header, reader->buffer[reader->nbuffer+1]);
-                if ( ret<0 ) { files->errnum = vcf_parse_error; break; }
-            }
-            else if ( reader->file->format.format==bcf )
-            {
-                ret = bcf_read1(reader->file, reader->header, reader->buffer[reader->nbuffer+1]);
-                if ( ret < -1 ) files->errnum = bcf_read_error;
-                if ( ret < 0 ) break; // no more lines or an error
-            }
-            else
-            {
-                hts_log_error("Fixme: not ready for this");
-                exit(1);
-            }
-        }
-        else if ( reader->tbx_idx )
-        {
-            if ( (ret=tbx_itr_next(reader->file, reader->tbx_idx, reader->itr, &files->tmps)) < 0 ) break;  // no more lines
-            ret = vcf_parse1(&files->tmps, reader->header, reader->buffer[reader->nbuffer+1]);
-            if ( ret<0 ) { files->errnum = vcf_parse_error; break; }
-        }
-        else
-        {
-            ret = bcf_itr_next(reader->file, reader->itr, reader->buffer[reader->nbuffer+1]);
-            if ( ret < -1 ) files->errnum = bcf_read_error;
-            if ( ret < 0 ) break; // no more lines or an error
-            bcf_subset_format(reader->header,reader->buffer[reader->nbuffer+1]);
-        }
-
-        // prevent creation of duplicates from records overlapping multiple regions
-        if ( files->regions && reader->buffer[reader->nbuffer+1]->pos <= files->regions->prev_end ) continue;
-
-        // apply filter
-        if ( !reader->nfilter_ids )
-            bcf_unpack(reader->buffer[reader->nbuffer+1], BCF_UN_STR);
-        else
-        {
-            bcf_unpack(reader->buffer[reader->nbuffer+1], BCF_UN_STR|BCF_UN_FLT);
-            if ( !has_filter(reader, reader->buffer[reader->nbuffer+1]) ) continue;
-        }
-        reader->nbuffer++;
-
-        if ( reader->buffer[reader->nbuffer]->rid != reader->buffer[1]->rid ) break;
-        if ( reader->buffer[reader->nbuffer]->pos != reader->buffer[1]->pos ) break;    // the buffer is full
-    }
-    if ( ret<0 )
-    {
-        // done for this region
-        tbx_itr_destroy(reader->itr);
-        reader->itr = NULL;
-    }
-    if ( files->require_index==ALLOW_NO_IDX_ && reader->buffer[reader->nbuffer]->rid < reader->buffer[1]->rid )
-    {
-         hts_log_error("Sequences out of order, cannot stream multiple unindexed files: %s", reader->fname);
-         exit(1);
-    }
-    return 0; // FIXME: Check for more errs in this function
-}
-
-/*
- *  _readers_shift_buffer() - removes the first line and all subsequent lines with the same position
- */
-static void _reader_shift_buffer(bcf_sr_t *reader)
-{
-    int i;
-    for (i=2; i<=reader->nbuffer; i++)
-        if ( reader->buffer[i]->rid!=reader->buffer[1]->rid || reader->buffer[i]->pos!=reader->buffer[1]->pos ) break;
-    if ( i<=reader->nbuffer )
-    {
-        // A record with a different position follows, swap it. Because of the reader's logic,
-        // only one such line can be present.
-        assert( i==reader->nbuffer );
-        bcf1_t *tmp = reader->buffer[1]; reader->buffer[1] = reader->buffer[i]; reader->buffer[i] = tmp;
-        reader->nbuffer = 1;
-    }
-    else
-        reader->nbuffer = 0;    // no other line
-}
-
-static int next_line(bcf_srs_t *files)
-{
-    const char *chr = NULL;
-    hts_pos_t min_pos = HTS_POS_MAX;
-
-    // Loop until next suitable line is found or all readers have finished
-    while ( 1 )
-    {
-        // Get all readers ready for the next region.
-        if ( files->regions && _readers_next_region(files)<0 ) break;
-
-        // Fill buffers and find the minimum chromosome
-        int i, min_rid = INT32_MAX;
-        for (i=0; i<files->nreaders; i++)
-        {
-            _reader_fill_buffer(files, &files->readers[i]);
-            if ( files->require_index==ALLOW_NO_IDX_ )
-            {
-                if ( !files->readers[i].nbuffer ) continue;
-                if ( min_rid > files->readers[i].buffer[1]->rid ) min_rid = files->readers[i].buffer[1]->rid;
-            }
-        }
-
-        for (i=0; i<files->nreaders; i++)
-        {
-            if ( !files->readers[i].nbuffer ) continue;
-            if ( files->require_index==ALLOW_NO_IDX_ && min_rid != files->readers[i].buffer[1]->rid ) continue;
-
-            // Update the minimum coordinate
-            if ( min_pos > files->readers[i].buffer[1]->pos )
-            {
-                min_pos = files->readers[i].buffer[1]->pos;
-                chr = bcf_seqname(files->readers[i].header, files->readers[i].buffer[1]);
-                assert(chr);
-                bcf_sr_sort_set_active(&BCF_SR_AUX(files)->sort, i);
-            }
-            else if ( min_pos==files->readers[i].buffer[1]->pos )
-                bcf_sr_sort_add_active(&BCF_SR_AUX(files)->sort, i);
-        }
-        if ( min_pos==HTS_POS_MAX )
-        {
-            if ( !files->regions ) break;
-            continue;
-        }
-
-        // Skip this position if not present in targets
-        if ( files->targets )
-        {
-            int ret = bcf_sr_regions_overlap(files->targets, chr, min_pos, min_pos);
-            if ( (!files->targets_exclude && ret<0) || (files->targets_exclude && !ret) )
-            {
-                // Remove all lines with this position from the buffer
-                for (i=0; i<files->nreaders; i++)
-                    if ( files->readers[i].nbuffer && files->readers[i].buffer[1]->pos==min_pos )
-                        _reader_shift_buffer(&files->readers[i]);
-                min_pos = HTS_POS_MAX;
-                chr = NULL;
-                continue;
-            }
-        }
-
-        break;  // done: chr and min_pos are set
-    }
-    if ( !chr ) return 0;
-
-    return bcf_sr_sort_next(files, &BCF_SR_AUX(files)->sort, chr, min_pos);
-}
-
-int bcf_sr_next_line(bcf_srs_t *files)
-{
-    if ( !files->targets_als )
-        return next_line(files);
-
-    while (1)
-    {
-        int i, ret = next_line(files);
-        if ( !ret ) return ret;
-
-        for (i=0; i<files->nreaders; i++)
-            if ( files->has_line[i] ) break;
-
-        if ( _regions_match_alleles(files->targets, files->targets_als-1, files->readers[i].buffer[0]) ) return ret;
-
-        // Check if there are more duplicate lines in the buffers. If not, return this line as if it
-        // matched the targets, even if there is a type mismatch
-        for (i=0; i<files->nreaders; i++)
-        {
-            if ( !files->has_line[i] ) continue;
-            if ( files->readers[i].nbuffer==0 || files->readers[i].buffer[1]->pos!=files->readers[i].buffer[0]->pos ) continue;
-            break;
-        }
-        if ( i==files->nreaders ) return ret;   // no more lines left, output even if target alleles are not of the same type
-    }
-}
-
-static void bcf_sr_seek_start(bcf_srs_t *readers)
-{
-    bcf_sr_regions_t *reg = readers->regions;
-    int i;
-    for (i=0; i<reg->nseqs; i++)
-        reg->regs[i].creg = -1;
-    reg->iseq = 0;
-}
-
-
-int bcf_sr_seek(bcf_srs_t *readers, const char *seq, hts_pos_t pos)
-{
-    if ( !readers->regions ) return 0;
-    bcf_sr_sort_reset(&BCF_SR_AUX(readers)->sort);
-    if ( !seq && !pos )
-    {
-        // seek to start
-        bcf_sr_seek_start(readers);
-        return 0;
-    }
-    bcf_sr_regions_overlap(readers->regions, seq, pos, pos);
-    int i, nret = 0;
-    for (i=0; i<readers->nreaders; i++)
-    {
-        nret += _reader_seek(&readers->readers[i],seq,pos,MAX_CSI_COOR-1);
-    }
-    return nret;
-}
-
-int bcf_sr_set_samples(bcf_srs_t *files, const char *fname, int is_file)
-{
-    int i, j, nsmpl, free_smpl = 0;
-    char **smpl = NULL;
-
-    void *exclude = (fname[0]=='^') ? khash_str2int_init() : NULL;
-    if ( exclude || strcmp("-",fname) ) // "-" stands for all samples
-    {
-        smpl = hts_readlist(fname, is_file, &nsmpl);
-        if ( !smpl )
-        {
-            hts_log_error("Could not read the file: \"%s\"", fname);
-            return 0;
-        }
-        if ( exclude )
-        {
-            for (i=0; i<nsmpl; i++)
-                khash_str2int_inc(exclude, smpl[i]);
-        }
-        free_smpl = 1;
-    }
-    if ( !smpl )
-    {
-        smpl  = files->readers[0].header->samples;   // intersection of all samples
-        nsmpl = bcf_hdr_nsamples(files->readers[0].header);
-    }
-
-    files->samples = NULL;
-    files->n_smpl  = 0;
-    for (i=0; i<nsmpl; i++)
-    {
-        if ( exclude && khash_str2int_has_key(exclude,smpl[i])  ) continue;
-
-        int n_isec = 0;
-        for (j=0; j<files->nreaders; j++)
-        {
-            if ( bcf_hdr_id2int(files->readers[j].header, BCF_DT_SAMPLE, smpl[i])<0 ) break;
-            n_isec++;
-        }
-        if ( n_isec!=files->nreaders )
-        {
-            hts_log_warning("The sample \"%s\" was not found in %s, skipping",
-                smpl[i], files->readers[n_isec].fname);
-            continue;
-        }
-
-        files->samples = (char**) realloc(files->samples, (files->n_smpl+1)*sizeof(const char*));
-        files->samples[files->n_smpl++] = strdup(smpl[i]);
-    }
-
-    if ( exclude ) khash_str2int_destroy(exclude);
-    if ( free_smpl )
-    {
-        for (i=0; i<nsmpl; i++) free(smpl[i]);
-        free(smpl);
-    }
-
-    if ( !files->n_smpl )
-    {
-        if ( files->nreaders>1 )
-            hts_log_warning("No samples in common");
-        return 0;
-    }
-    for (i=0; i<files->nreaders; i++)
-    {
-        bcf_sr_t *reader = &files->readers[i];
-        reader->samples  = (int*) malloc(sizeof(int)*files->n_smpl);
-        reader->n_smpl   = files->n_smpl;
-        for (j=0; j<files->n_smpl; j++)
-            reader->samples[j] = bcf_hdr_id2int(reader->header, BCF_DT_SAMPLE, files->samples[j]);
-    }
-    return 1;
-}
-
-// Add a new region into a list. On input the coordinates are 1-based, inclusive, then stored 0-based,
-// inclusive. Sorting and merging step needed afterwards: qsort(..,cmp_regions) and merge_regions().
-static int _regions_add(bcf_sr_regions_t *reg, const char *chr, hts_pos_t start, hts_pos_t end)
-{
-    if ( start==-1 && end==-1 )
-    {
-        start = 0; end = MAX_CSI_COOR-1;
-    }
-    else
-    {
-        start--; end--; // store 0-based coordinates
-    }
-
-    if ( !reg->seq_hash )
-         reg->seq_hash = khash_str2int_init();
-
-    int iseq;
-    if ( khash_str2int_get(reg->seq_hash, chr, &iseq)<0 )
-    {
-        // the chromosome block does not exist
-        iseq = reg->nseqs++;
-        reg->seq_names = (char**) realloc(reg->seq_names,sizeof(char*)*reg->nseqs);
-        reg->regs = (region_t*) realloc(reg->regs,sizeof(region_t)*reg->nseqs);
-        memset(&reg->regs[reg->nseqs-1],0,sizeof(region_t));
-        reg->seq_names[iseq] = strdup(chr);
-        reg->regs[iseq].creg = -1;
-        khash_str2int_set(reg->seq_hash,reg->seq_names[iseq],iseq);
-    }
-
-    region_t *creg = &reg->regs[iseq];
-    hts_expand(region1_t,creg->nregs+1,creg->mregs,creg->regs);
-    creg->regs[creg->nregs].start = start;
-    creg->regs[creg->nregs].end   = end;
-    creg->nregs++;
-
-    return 0; // FIXME: check for errs in this function
-}
-
-static int regions_cmp(const void *aptr, const void *bptr)
-{
-    region1_t *a = (region1_t*)aptr;
-    region1_t *b = (region1_t*)bptr;
-    if ( a->start < b->start ) return -1;
-    if ( a->start > b->start ) return 1;
-    if ( a->end < b->end ) return -1;
-    if ( a->end > b->end ) return 1;
-    return 0;
-}
-static void regions_merge(region_t *reg)
-{
-    int i = 0, j;
-    while ( i<reg->nregs )
-    {
-        j = i + 1;
-        while ( j<reg->nregs && reg->regs[i].end >= reg->regs[j].start )
-        {
-            if ( reg->regs[i].end < reg->regs[j].end ) reg->regs[i].end = reg->regs[j].end;
-            reg->regs[j].start = 1;  reg->regs[j].end = 0;  // if beg>end, this region marked for skipping
-            j++;
-        }
-        i = j;
-    }
-}
-void _regions_sort_and_merge(bcf_sr_regions_t *reg)
-{
-    if ( !reg ) return;
-
-    int i;
-    for (i=0; i<reg->nseqs; i++)
-    {
-        qsort(reg->regs[i].regs, reg->regs[i].nregs, sizeof(*reg->regs[i].regs), regions_cmp);
-        regions_merge(&reg->regs[i]);
-    }
-}
-
-// File name or a list of genomic locations. If file name, NULL is returned.
-static bcf_sr_regions_t *_regions_init_string(const char *str)
-{
-    bcf_sr_regions_t *reg = (bcf_sr_regions_t *) calloc(1, sizeof(bcf_sr_regions_t));
-    reg->start = reg->end = -1;
-    reg->prev_start = reg->prev_end = reg->prev_seq = -1;
-
-    kstring_t tmp = {0,0,0};
-    const char *sp = str, *ep = str;
-    hts_pos_t from, to;
-    while ( 1 )
-    {
-        while ( *ep && *ep!=',' && *ep!=':' ) ep++;
-        tmp.l = 0;
-        kputsn(sp,ep-sp,&tmp);
-        if ( *ep==':' )
-        {
-            sp = ep+1;
-            from = hts_parse_decimal(sp,(char**)&ep,0);
-            if ( sp==ep )
-            {
-                hts_log_error("Could not parse the region(s): %s", str);
-                free(reg); free(tmp.s); return NULL;
-            }
-            if ( !*ep || *ep==',' )
-            {
-                _regions_add(reg, tmp.s, from, from);
-                sp = ep;
-                continue;
-            }
-            if ( *ep!='-' )
-            {
-                hts_log_error("Could not parse the region(s): %s", str);
-                free(reg); free(tmp.s); return NULL;
-            }
-            ep++;
-            sp = ep;
-            to = hts_parse_decimal(sp,(char**)&ep,0);
-            if ( *ep && *ep!=',' )
-            {
-                hts_log_error("Could not parse the region(s): %s", str);
-                free(reg); free(tmp.s); return NULL;
-            }
-            if ( sp==ep ) to = MAX_CSI_COOR-1;
-            _regions_add(reg, tmp.s, from, to);
-            if ( !*ep ) break;
-            sp = ep;
-        }
-        else
-        {
-            if ( tmp.l ) _regions_add(reg, tmp.s, -1, -1);
-            if ( !*ep ) break;
-            sp = ++ep;
-        }
-    }
-    free(tmp.s);
-    return reg;
-}
-
-// ichr,ifrom,ito are 0-based;
-// returns -1 on error, 0 if the line is a comment line, 1 on success
-static int _regions_parse_line(char *line, int ichr, int ifrom, int ito, char **chr, char **chr_end, hts_pos_t *from, hts_pos_t *to)
-{
-    if (ifrom < 0 || ito < 0) return -1;
-    *chr_end = NULL;
-
-    if ( line[0]=='#' ) return 0;
-
-    int k,l;    // index of the start and end column of the tab-delimited file
-    if ( ifrom <= ito )
-        k = ifrom, l = ito;
-    else
-        l = ifrom, k = ito;
-
-    int i;
-    char *se = line, *ss = NULL; // start and end
-    char *tmp;
-    for (i=0; i<=k && *se; i++)
-    {
-        ss = i==0 ? se++ : ++se;
-        while (*se && *se!='\t') se++;
-    }
-    if ( i<=k ) return -1;
-    if ( k==l )
-    {
-        *from = *to = hts_parse_decimal(ss, &tmp, 0);
-        if ( tmp==ss ) return -1;
-    }
-    else
-    {
-        if ( k==ifrom )
-            *from = hts_parse_decimal(ss, &tmp, 0);
-        else
-            *to = hts_parse_decimal(ss, &tmp, 0);
-        if ( ss==tmp ) return -1;
-
-        for (i=k; i<l && *se; i++)
-        {
-            ss = ++se;
-            while (*se && *se!='\t') se++;
-        }
-        if ( i<l ) return -1;
-        if ( k==ifrom )
-            *to = hts_parse_decimal(ss, &tmp, 0);
-        else
-            *from = hts_parse_decimal(ss, &tmp, 0);
-        if ( ss==tmp ) return -1;
-    }
-
-    ss = se = line;
-    for (i=0; i<=ichr && *se; i++)
-    {
-        if ( i>0 ) ss = ++se;
-        while (*se && *se!='\t') se++;
-    }
-    if ( i<=ichr ) return -1;
-    *chr_end = se;
-    *chr = ss;
-    return 1;
-}
-
-bcf_sr_regions_t *bcf_sr_regions_init(const char *regions, int is_file, int ichr, int ifrom, int ito)
-{
-    bcf_sr_regions_t *reg;
-    if ( !is_file )
-    {
-        reg = _regions_init_string(regions);
-        _regions_sort_and_merge(reg);
-        return reg;
-    }
-
-    reg = (bcf_sr_regions_t *) calloc(1, sizeof(bcf_sr_regions_t));
-    reg->start = reg->end = -1;
-    reg->prev_start = reg->prev_end = reg->prev_seq = -1;
-
-    reg->file = hts_open(regions, "rb");
-    if ( !reg->file )
-    {
-        hts_log_error("Could not open file: %s", regions);
-        free(reg);
-        return NULL;
-    }
-
-    reg->tbx = tbx_index_load3(regions, NULL, HTS_IDX_SAVE_REMOTE|HTS_IDX_SILENT_FAIL);
-    if ( !reg->tbx )
-    {
-        size_t iline = 0;
-        int len = strlen(regions);
-        int is_bed  = strcasecmp(".bed",regions+len-4) ? 0 : 1;
-        if ( !is_bed && !strcasecmp(".bed.gz",regions+len-7) ) is_bed = 1;
-
-        if ( reg->file->format.format==vcf ) ito = 1;
-
-        // read the whole file, tabix index is not present
-        while ( hts_getline(reg->file, KS_SEP_LINE, &reg->line) > 0 )
-        {
-            iline++;
-            char *chr, *chr_end;
-            hts_pos_t from, to;
-            int ret;
-            ret = _regions_parse_line(reg->line.s, ichr,ifrom,abs(ito), &chr,&chr_end,&from,&to);
-            if ( ret < 0 )
-            {
-                if ( ito<0 )
-                    ret = _regions_parse_line(reg->line.s, ichr,ifrom,ifrom, &chr,&chr_end,&from,&to);
-                if ( ret<0 )
-                {
-                    hts_log_error("Could not parse %zu-th line of file %s, using the columns %d,%d[,%d]",
-                        iline, regions,ichr+1,ifrom+1,ito+1);
-                    hts_close(reg->file); reg->file = NULL; free(reg);
-                    return NULL;
-                }
-            }
-            if ( !ret ) continue;
-            if ( is_bed ) from++;
-            *chr_end = 0;
-            _regions_add(reg, chr, from, to);
-            *chr_end = '\t';
-        }
-        hts_close(reg->file); reg->file = NULL;
-        if ( !reg->nseqs ) { free(reg); return NULL; }
-        _regions_sort_and_merge(reg);
-        return reg;
-    }
-
-    reg->seq_names = (char**) tbx_seqnames(reg->tbx, &reg->nseqs);
-    if ( !reg->seq_hash )
-        reg->seq_hash = khash_str2int_init();
-    int i;
-    for (i=0; i<reg->nseqs; i++)
-    {
-        khash_str2int_set(reg->seq_hash,reg->seq_names[i],i);
-    }
-    reg->fname  = strdup(regions);
-    reg->is_bin = 1;
-    return reg;
-}
-
-void bcf_sr_regions_destroy(bcf_sr_regions_t *reg)
-{
-    int i;
-    free(reg->fname);
-    if ( reg->itr ) tbx_itr_destroy(reg->itr);
-    if ( reg->tbx ) tbx_destroy(reg->tbx);
-    if ( reg->file ) hts_close(reg->file);
-    if ( reg->als ) free(reg->als);
-    if ( reg->als_str.s ) free(reg->als_str.s);
-    free(reg->line.s);
-    if ( reg->regs )
-    {
-         // free only in-memory names, tbx names are const
-        for (i=0; i<reg->nseqs; i++)
-        {
-            free(reg->seq_names[i]);
-            free(reg->regs[i].regs);
-        }
-    }
-    free(reg->regs);
-    free(reg->seq_names);
-    khash_str2int_destroy(reg->seq_hash);
-    free(reg);
-}
-
-int bcf_sr_regions_seek(bcf_sr_regions_t *reg, const char *seq)
-{
-    reg->iseq = reg->start = reg->end = -1;
-    if ( khash_str2int_get(reg->seq_hash, seq, &reg->iseq) < 0 ) return -1;  // sequence seq not in regions
-
-    // using in-memory regions
-    if ( reg->regs )
-    {
-        reg->regs[reg->iseq].creg = -1;
-        return 0;
-    }
-
-    // reading regions from tabix
-    if ( reg->itr ) tbx_itr_destroy(reg->itr);
-    reg->itr = tbx_itr_querys(reg->tbx, seq);
-    if ( reg->itr ) return 0;
-
-    return -1;
-}
-
-// Returns 0 on success, -1 when done
-static int advance_creg(region_t *reg)
-{
-    int i = reg->creg + 1;
-    while ( i<reg->nregs && reg->regs[i].start > reg->regs[i].end ) i++;    // regions with start>end are marked to skip by merge_regions()
-    reg->creg = i;
-    if ( i>=reg->nregs ) return -1;
-    return 0;
-}
-
-int bcf_sr_regions_next(bcf_sr_regions_t *reg)
-{
-    if ( reg->iseq<0 ) return -1;
-    reg->start = reg->end = -1;
-    reg->nals = 0;
-
-    // using in-memory regions
-    if ( reg->regs )
-    {
-        while ( reg->iseq < reg->nseqs )
-        {
-            if ( advance_creg(&reg->regs[reg->iseq])==0 ) break;    // a valid record was found
-            reg->iseq++;
-        }
-        if ( reg->iseq >= reg->nseqs ) { reg->iseq = -1; return -1; } // no more regions left
-        region1_t *creg = &reg->regs[reg->iseq].regs[reg->regs[reg->iseq].creg];
-        reg->start = creg->start;
-        reg->end   = creg->end;
-        return 0;
-    }
-
-    // reading from tabix
-    char *chr, *chr_end;
-    int ichr = 0, ifrom = 1, ito = 2, is_bed = 0;
-    hts_pos_t from, to;
-    if ( reg->tbx )
-    {
-        ichr   = reg->tbx->conf.sc-1;
-        ifrom  = reg->tbx->conf.bc-1;
-        ito    = reg->tbx->conf.ec-1;
-        if ( ito<0 ) ito = ifrom;
-        is_bed = reg->tbx->conf.preset==TBX_UCSC ? 1 : 0;
-    }
-
-    int ret = 0;
-    while ( !ret )
-    {
-        if ( reg->itr )
-        {
-            // tabix index present, reading a chromosome block
-            ret = tbx_itr_next(reg->file, reg->tbx, reg->itr, &reg->line);
-            if ( ret<0 ) { reg->iseq = -1; return -1; }
-        }
-        else
-        {
-            if ( reg->is_bin )
-            {
-                // Waited for seek which never came. Reopen in text mode and stream
-                // through the regions, otherwise hts_getline would fail
-                hts_close(reg->file);
-                reg->file = hts_open(reg->fname, "r");
-                if ( !reg->file )
-                {
-                    hts_log_error("Could not open file: %s", reg->fname);
-                    reg->file = NULL;
-                    bcf_sr_regions_destroy(reg);
-                    return -1;
-                }
-                reg->is_bin = 0;
-            }
-
-            // tabix index absent, reading the whole file
-            ret = hts_getline(reg->file, KS_SEP_LINE, &reg->line);
-            if ( ret<0 ) { reg->iseq = -1; return -1; }
-        }
-        ret = _regions_parse_line(reg->line.s, ichr,ifrom,ito, &chr,&chr_end,&from,&to);
-        if ( ret<0 )
-        {
-            hts_log_error("Could not parse the file %s, using the columns %d,%d,%d",
-                reg->fname,ichr+1,ifrom+1,ito+1);
-            return -1;
-        }
-    }
-    if ( is_bed ) from++;
-
-    *chr_end = 0;
-    if ( khash_str2int_get(reg->seq_hash, chr, &reg->iseq)<0 )
-    {
-        hts_log_error("Broken tabix index? The sequence \"%s\" not in dictionary [%s]",
-            chr, reg->line.s);
-        exit(1);
-    }
-    *chr_end = '\t';
-
-    reg->start = from - 1;
-    reg->end   = to - 1;
-    return 0;
-}
-
-static int _regions_match_alleles(bcf_sr_regions_t *reg, int als_idx, bcf1_t *rec)
-{
-    if ( reg->regs )
-    {
-        // payload is not supported for in-memory regions, switch to regidx instead in future
-        hts_log_error("Compressed and indexed targets file is required");
-        exit(1);
-    }
-
-    int i = 0, max_len = 0;
-    if ( !reg->nals )
-    {
-        char *ss = reg->line.s;
-        while ( i<als_idx && *ss )
-        {
-            if ( *ss=='\t' ) i++;
-            ss++;
-        }
-        char *se = ss;
-        reg->nals = 1;
-        while ( *se && *se!='\t' )
-        {
-            if ( *se==',' ) reg->nals++;
-            se++;
-        }
-        ks_resize(&reg->als_str, se-ss+1+reg->nals);
-        reg->als_str.l = 0;
-        hts_expand(char*,reg->nals,reg->mals,reg->als);
-        reg->nals = 0;
-
-        se = ss;
-        while ( *(++se) )
-        {
-            if ( *se=='\t' ) break;
-            if ( *se!=',' ) continue;
-            reg->als[reg->nals] = &reg->als_str.s[reg->als_str.l];
-            kputsn(ss,se-ss,&reg->als_str);
-            if ( &reg->als_str.s[reg->als_str.l] - reg->als[reg->nals] > max_len ) max_len = &reg->als_str.s[reg->als_str.l] - reg->als[reg->nals];
-            reg->als_str.l++;
-            reg->nals++;
-            ss = ++se;
-        }
-        reg->als[reg->nals] = &reg->als_str.s[reg->als_str.l];
-        kputsn(ss,se-ss,&reg->als_str);
-        if ( &reg->als_str.s[reg->als_str.l] - reg->als[reg->nals] > max_len ) max_len = &reg->als_str.s[reg->als_str.l] - reg->als[reg->nals];
-        reg->nals++;
-        reg->als_type = max_len > 1 ? VCF_INDEL : VCF_SNP;  // this is a simplified check, see vcf.c:bcf_set_variant_types
-    }
-    int type = bcf_get_variant_types(rec);
-    if ( reg->als_type & VCF_INDEL )
-        return type & VCF_INDEL ? 1 : 0;
-    return !(type & VCF_INDEL) ? 1 : 0;
-}
-
-int bcf_sr_regions_overlap(bcf_sr_regions_t *reg, const char *seq, hts_pos_t start, hts_pos_t end)
-{
-    int iseq;
-    if ( khash_str2int_get(reg->seq_hash, seq, &iseq)<0 ) return -1;    // no such sequence
-
-    if ( reg->prev_seq==-1 || iseq!=reg->prev_seq || reg->prev_start > start ) // new chromosome or after a seek
-    {
-        // flush regions left on previous chromosome
-        if ( reg->missed_reg_handler && reg->prev_seq!=-1 && reg->iseq!=-1 )
-            bcf_sr_regions_flush(reg);
-
-        bcf_sr_regions_seek(reg, seq);
-        reg->start = reg->end = -1;
-    }
-    if ( reg->prev_seq==iseq && reg->iseq!=iseq ) return -2;    // no more regions on this chromosome
-    reg->prev_seq = reg->iseq;
-    reg->prev_start = start;
-
-    while ( iseq==reg->iseq && reg->end < start )
-    {
-        if ( bcf_sr_regions_next(reg) < 0 ) return -2;  // no more regions left
-        if ( reg->iseq != iseq ) return -1; // does not overlap any regions
-        if ( reg->missed_reg_handler && reg->end < start ) reg->missed_reg_handler(reg, reg->missed_reg_data);
-    }
-    if ( reg->start <= end ) return 0;    // region overlap
-    return -1;  // no overlap
-}
-
-int bcf_sr_regions_flush(bcf_sr_regions_t *reg)
-{
-    if ( !reg->missed_reg_handler || reg->prev_seq==-1 ) return 0;
-    while ( !bcf_sr_regions_next(reg) ) reg->missed_reg_handler(reg, reg->missed_reg_data);
-    return 0; // FIXME: check for errs in this function
-}
-
diff -ruN stringtie.orig/htslib/tbx.c stringtie/htslib/tbx.c
--- stringtie.orig/htslib/tbx.c	2024-02-28 13:57:39.701246126 +0100
+++ stringtie/htslib/tbx.c	1970-01-01 01:00:00.000000000 +0100
@@ -1,481 +0,0 @@
-/*  tbx.c -- tabix API functions.
-
-    Copyright (C) 2009, 2010, 2012-2015, 2017-2020 Genome Research Ltd.
-    Copyright (C) 2010-2012 Broad Institute.
-
-    Author: Heng Li <lh3@sanger.ac.uk>
-
-Permission is hereby granted, free of charge, to any person obtaining a copy
-of this software and associated documentation files (the "Software"), to deal
-in the Software without restriction, including without limitation the rights
-to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
-copies of the Software, and to permit persons to whom the Software is
-furnished to do so, subject to the following conditions:
-
-The above copyright notice and this permission notice shall be included in
-all copies or substantial portions of the Software.
-
-THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
-IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
-FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
-THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
-LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
-FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
-DEALINGS IN THE SOFTWARE.  */
-
-#define HTS_BUILDING_LIBRARY // Enables HTSLIB_EXPORT, see htslib/hts_defs.h
-#include <config.h>
-
-#include <stdlib.h>
-#include <string.h>
-#include <stdio.h>
-#include <assert.h>
-#include <errno.h>
-#include "htslib/tbx.h"
-#include "htslib/bgzf.h"
-#include "htslib/hts_endian.h"
-#include "hts_internal.h"
-
-#include "htslib/khash.h"
-KHASH_DECLARE(s2i, kh_cstr_t, int64_t)
-
-HTSLIB_EXPORT
-const tbx_conf_t tbx_conf_gff = { 0, 1, 4, 5, '#', 0 };
-
-HTSLIB_EXPORT
-const tbx_conf_t tbx_conf_bed = { TBX_UCSC, 1, 2, 3, '#', 0 };
-
-HTSLIB_EXPORT
-const tbx_conf_t tbx_conf_psltbl = { TBX_UCSC, 15, 17, 18, '#', 0 };
-
-HTSLIB_EXPORT
-const tbx_conf_t tbx_conf_sam = { TBX_SAM, 3, 4, 0, '@', 0 };
-
-HTSLIB_EXPORT
-const tbx_conf_t tbx_conf_vcf = { TBX_VCF, 1, 2, 0, '#', 0 };
-
-typedef struct {
-    int64_t beg, end;
-    char *ss, *se;
-    int tid;
-} tbx_intv_t;
-
-static inline int get_tid(tbx_t *tbx, const char *ss, int is_add)
-{
-    khint_t k;
-    khash_t(s2i) *d;
-    if (tbx->dict == 0) tbx->dict = kh_init(s2i);
-    if (!tbx->dict) return -1; // Out of memory
-    d = (khash_t(s2i)*)tbx->dict;
-    if (is_add) {
-        int absent;
-        k = kh_put(s2i, d, ss, &absent);
-        if (absent < 0) {
-            return -1; // Out of memory
-        } else if (absent) {
-            char *ss_dup = strdup(ss);
-            if (ss_dup) {
-                kh_key(d, k) = ss_dup;
-                kh_val(d, k) = kh_size(d) - 1;
-            } else {
-                kh_del(s2i, d, k);
-                return -1; // Out of memory
-            }
-        }
-    } else k = kh_get(s2i, d, ss);
-    return k == kh_end(d)? -1 : kh_val(d, k);
-}
-
-int tbx_name2id(tbx_t *tbx, const char *ss)
-{
-    return get_tid(tbx, ss, 0);
-}
-
-int tbx_parse1(const tbx_conf_t *conf, int len, char *line, tbx_intv_t *intv)
-{
-    int i, b = 0, id = 1, ncols = 0;
-    char *s;
-    intv->ss = intv->se = 0; intv->beg = intv->end = -1;
-    for (i = 0; i <= len; ++i) {
-        if (line[i] == '\t' || line[i] == 0) {
-            ++ncols;
-            if (id == conf->sc) {
-                intv->ss = line + b; intv->se = line + i;
-            } else if (id == conf->bc) {
-                // here ->beg is 0-based.
-                intv->beg = intv->end = strtoll(line + b, &s, 0);
-                if ( s==line+b ) return -1; // expected int
-                if (!(conf->preset&TBX_UCSC)) --intv->beg;
-                else ++intv->end;
-                if (intv->beg < 0) intv->beg = 0;
-                if (intv->end < 1) intv->end = 1;
-            } else {
-                if ((conf->preset&0xffff) == TBX_GENERIC) {
-                    if (id == conf->ec)
-                    {
-                        intv->end = strtoll(line + b, &s, 0);
-                        if ( s==line+b ) return -1; // expected int
-                    }
-                } else if ((conf->preset&0xffff) == TBX_SAM) {
-                    if (id == 6) { // CIGAR
-                        int l = 0;
-                        char *t;
-                        for (s = line + b; s < line + i;) {
-                            long x = strtol(s, &t, 10);
-                            char op = toupper_c(*t);
-                            if (op == 'M' || op == 'D' || op == 'N') l += x;
-                            s = t + 1;
-                        }
-                        if (l == 0) l = 1;
-                        intv->end = intv->beg + l;
-                    }
-                } else if ((conf->preset&0xffff) == TBX_VCF) {
-                    if (id == 4) {
-                        if (b < i) intv->end = intv->beg + (i - b);
-                    } else if (id == 8) { // look for "END="
-                        int c = line[i];
-                        line[i] = 0;
-                        s = strstr(line + b, "END=");
-                        if (s == line + b) s += 4;
-                        else if (s) {
-                            s = strstr(line + b, ";END=");
-                            if (s) s += 5;
-                        }
-                        if (s && *s != '.') {
-                            long long end = strtoll(s, &s, 0);
-                            if (end <= intv->beg) {
-                                static int reported = 0;
-                                if (!reported) {
-                                    int l = intv->ss ? (int) (intv->se - intv->ss) : 0;
-                                    hts_log_warning("VCF INFO/END=%lld is smaller than POS at %.*s:%"PRIhts_pos"\n"
-                                                    "This tag will be ignored. "
-                                                    "Note: only one invalid END tag will be reported.",
-                                                    end, l >= 0 ? l : 0,
-                                                    intv->ss ? intv->ss : "",
-                                                    intv->beg);
-                                    reported = 1;
-                                }
-                            } else {
-                                intv->end = end;
-                            }
-                        }
-                        line[i] = c;
-                    }
-                }
-            }
-            b = i + 1;
-            ++id;
-        }
-    }
-    if (intv->ss == 0 || intv->se == 0 || intv->beg < 0 || intv->end < 0) return -1;
-    return 0;
-}
-
-static inline int get_intv(tbx_t *tbx, kstring_t *str, tbx_intv_t *intv, int is_add)
-{
-    if (tbx_parse1(&tbx->conf, str->l, str->s, intv) == 0) {
-        int c = *intv->se;
-        *intv->se = '\0'; intv->tid = get_tid(tbx, intv->ss, is_add); *intv->se = c;
-        if (intv->tid < 0) return -2;  // get_tid out of memory
-        return (intv->beg >= 0 && intv->end >= 0)? 0 : -1;
-    } else {
-        char *type = NULL;
-        switch (tbx->conf.preset&0xffff)
-        {
-            case TBX_SAM: type = "TBX_SAM"; break;
-            case TBX_VCF: type = "TBX_VCF"; break;
-            case TBX_UCSC: type = "TBX_UCSC"; break;
-            default: type = "TBX_GENERIC"; break;
-        }
-        hts_log_error("Failed to parse %s, was wrong -p [type] used?\nThe offending line was: \"%s\"",
-            type, str->s);
-        return -1;
-    }
-}
-
-/*
- * Called by tabix iterator to read the next record.
- * Returns    >=  0 on success
- *               -1 on EOF
- *            <= -2 on error
- */
-int tbx_readrec(BGZF *fp, void *tbxv, void *sv, int *tid, hts_pos_t *beg, hts_pos_t *end)
-{
-    tbx_t *tbx = (tbx_t *) tbxv;
-    kstring_t *s = (kstring_t *) sv;
-    int ret;
-    if ((ret = bgzf_getline(fp, '\n', s)) >= 0) {
-        tbx_intv_t intv;
-        if (get_intv(tbx, s, &intv, 0) < 0)
-            return -2;
-        *tid = intv.tid; *beg = intv.beg; *end = intv.end;
-    }
-    return ret;
-}
-
-static int tbx_set_meta(tbx_t *tbx)
-{
-    int i, l = 0, l_nm;
-    uint32_t x[7];
-    char **name;
-    uint8_t *meta;
-    khint_t k;
-    khash_t(s2i) *d = (khash_t(s2i)*)tbx->dict;
-
-    memcpy(x, &tbx->conf, 24);
-    name = (char**)malloc(sizeof(char*) * kh_size(d));
-    if (!name) return -1;
-    for (k = kh_begin(d), l = 0; k != kh_end(d); ++k) {
-        if (!kh_exist(d, k)) continue;
-        name[kh_val(d, k)] = (char*)kh_key(d, k);
-        l += strlen(kh_key(d, k)) + 1; // +1 to include '\0'
-    }
-    l_nm = x[6] = l;
-    meta = (uint8_t*)malloc(l_nm + 28);
-    if (!meta) { free(name); return -1; }
-    if (ed_is_big())
-        for (i = 0; i < 7; ++i)
-            x[i] = ed_swap_4(x[i]);
-    memcpy(meta, x, 28);
-    for (l = 28, i = 0; i < (int)kh_size(d); ++i) {
-        int x = strlen(name[i]) + 1;
-        memcpy(meta + l, name[i], x);
-        l += x;
-    }
-    free(name);
-    hts_idx_set_meta(tbx->idx, l, meta, 0);
-    return 0;
-}
-
-// Minimal effort parser to extract reference length out of VCF header line
-// This is used only used to adjust the number of levels if necessary,
-// so not a major problem if it doesn't always work.
-static void adjust_max_ref_len_vcf(const char *str, int64_t *max_ref_len)
-{
-    const char *ptr;
-    int64_t len;
-    if (strncmp(str, "##contig", 8) != 0) return;
-    ptr = strstr(str + 8, "length");
-    if (!ptr) return;
-    for (ptr += 6; *ptr == ' ' || *ptr == '='; ptr++) {}
-    len = strtoll(ptr, NULL, 10);
-    if (*max_ref_len < len) *max_ref_len = len;
-}
-
-// Same for sam files
-static void adjust_max_ref_len_sam(const char *str, int64_t *max_ref_len)
-{
-    const char *ptr;
-    int64_t len;
-    if (strncmp(str, "@SQ", 3) != 0) return;
-    ptr = strstr(str + 3, "\tLN:");
-    if (!ptr) return;
-    ptr += 4;
-    len = strtoll(ptr, NULL, 10);
-    if (*max_ref_len < len) *max_ref_len = len;
-}
-
-// Adjusts number of levels if not big enough.  This can happen for
-// files with very large contigs.
-static int adjust_n_lvls(int min_shift, int n_lvls, int64_t max_len)
-{
-    int64_t s = 1LL << (min_shift + n_lvls * 3);
-    max_len += 256;
-    for (; max_len > s; ++n_lvls, s <<= 3) {}
-    return n_lvls;
-}
-
-tbx_t *tbx_index(BGZF *fp, int min_shift, const tbx_conf_t *conf)
-{
-    tbx_t *tbx;
-    kstring_t str;
-    int ret, first = 0, n_lvls, fmt;
-    int64_t lineno = 0;
-    uint64_t last_off = 0;
-    tbx_intv_t intv;
-    int64_t max_ref_len = 0;
-
-    str.s = 0; str.l = str.m = 0;
-    tbx = (tbx_t*)calloc(1, sizeof(tbx_t));
-    if (!tbx) return NULL;
-    tbx->conf = *conf;
-    if (min_shift > 0) n_lvls = (TBX_MAX_SHIFT - min_shift + 2) / 3, fmt = HTS_FMT_CSI;
-    else min_shift = 14, n_lvls = 5, fmt = HTS_FMT_TBI;
-    while ((ret = bgzf_getline(fp, '\n', &str)) >= 0) {
-        ++lineno;
-        if (str.s[0] == tbx->conf.meta_char && fmt == HTS_FMT_CSI) {
-            switch (tbx->conf.preset) {
-                case TBX_SAM:
-                    adjust_max_ref_len_sam(str.s, &max_ref_len); break;
-                case TBX_VCF:
-                    adjust_max_ref_len_vcf(str.s, &max_ref_len); break;
-                default:
-                    break;
-            }
-        }
-        if (lineno <= tbx->conf.line_skip || str.s[0] == tbx->conf.meta_char) {
-            last_off = bgzf_tell(fp);
-            continue;
-        }
-        if (first == 0) {
-            if (fmt == HTS_FMT_CSI)
-                n_lvls = adjust_n_lvls(min_shift, n_lvls, max_ref_len);
-            tbx->idx = hts_idx_init(0, fmt, last_off, min_shift, n_lvls);
-            if (!tbx->idx) goto fail;
-            first = 1;
-        }
-        ret = get_intv(tbx, &str, &intv, 1);
-        if (ret < -1) goto fail;  // Out of memory
-        if (ret < 0) continue; // Skip unparsable lines
-        if (hts_idx_push(tbx->idx, intv.tid, intv.beg, intv.end,
-                         bgzf_tell(fp), 1) < 0) {
-            goto fail;
-        }
-    }
-    if (ret < -1) goto fail;
-    if ( !tbx->idx ) tbx->idx = hts_idx_init(0, fmt, last_off, min_shift, n_lvls);   // empty file
-    if (!tbx->idx) goto fail;
-    if ( !tbx->dict ) tbx->dict = kh_init(s2i);
-    if (!tbx->dict) goto fail;
-    if (hts_idx_finish(tbx->idx, bgzf_tell(fp)) != 0) goto fail;
-    if (tbx_set_meta(tbx) != 0) goto fail;
-    free(str.s);
-    return tbx;
-
- fail:
-    free(str.s);
-    tbx_destroy(tbx);
-    return NULL;
-}
-
-void tbx_destroy(tbx_t *tbx)
-{
-    khash_t(s2i) *d = (khash_t(s2i)*)tbx->dict;
-    if (d != NULL)
-    {
-        khint_t k;
-        for (k = kh_begin(d); k != kh_end(d); ++k)
-            if (kh_exist(d, k)) free((char*)kh_key(d, k));
-    }
-    hts_idx_destroy(tbx->idx);
-    kh_destroy(s2i, d);
-    free(tbx);
-}
-
-int tbx_index_build3(const char *fn, const char *fnidx, int min_shift, int n_threads, const tbx_conf_t *conf)
-{
-    tbx_t *tbx;
-    BGZF *fp;
-    int ret;
-    if ((fp = bgzf_open(fn, "r")) == 0) return -1;
-    if ( n_threads ) bgzf_mt(fp, n_threads, 256);
-    if ( bgzf_compression(fp) != bgzf ) { bgzf_close(fp); return -2; }
-    tbx = tbx_index(fp, min_shift, conf);
-    bgzf_close(fp);
-    if ( !tbx ) return -1;
-    ret = hts_idx_save_as(tbx->idx, fn, fnidx, min_shift > 0? HTS_FMT_CSI : HTS_FMT_TBI);
-    tbx_destroy(tbx);
-    return ret;
-}
-
-int tbx_index_build2(const char *fn, const char *fnidx, int min_shift, const tbx_conf_t *conf)
-{
-    return tbx_index_build3(fn, fnidx, min_shift, 0, conf);
-}
-
-int tbx_index_build(const char *fn, int min_shift, const tbx_conf_t *conf)
-{
-    return tbx_index_build3(fn, NULL, min_shift, 0, conf);
-}
-
-static tbx_t *index_load(const char *fn, const char *fnidx, int flags)
-{
-    tbx_t *tbx;
-    uint8_t *meta;
-    char *nm, *p;
-    uint32_t l_meta, l_nm;
-    tbx = (tbx_t*)calloc(1, sizeof(tbx_t));
-    if (!tbx)
-        return NULL;
-    tbx->idx = hts_idx_load3(fn, fnidx, HTS_FMT_TBI, flags);
-    if ( !tbx->idx )
-    {
-        free(tbx);
-        return NULL;
-    }
-    meta = hts_idx_get_meta(tbx->idx, &l_meta);
-    if ( !meta || l_meta < 28) goto invalid;
-
-    tbx->conf.preset = le_to_i32(&meta[0]);
-    tbx->conf.sc = le_to_i32(&meta[4]);
-    tbx->conf.bc = le_to_i32(&meta[8]);
-    tbx->conf.ec = le_to_i32(&meta[12]);
-    tbx->conf.meta_char = le_to_i32(&meta[16]);
-    tbx->conf.line_skip = le_to_i32(&meta[20]);
-    l_nm = le_to_u32(&meta[24]);
-    if (l_nm > l_meta - 28) goto invalid;
-
-    p = nm = (char*)meta + 28;
-    // This assumes meta is NUL-terminated, so we can merrily strlen away.
-    // hts_idx_load_local() assures this for us by adding a NUL on the end
-    // of whatever it reads.
-    for (; p - nm < l_nm; p += strlen(p) + 1) {
-        if (get_tid(tbx, p, 1) < 0) {
-            hts_log_error("%s", strerror(errno));
-            goto fail;
-        }
-    }
-    return tbx;
-
- invalid:
-    hts_log_error("Invalid index header for %s", fnidx ? fnidx : fn);
-
- fail:
-    tbx_destroy(tbx);
-    return NULL;
-}
-
-tbx_t *tbx_index_load3(const char *fn, const char *fnidx, int flags)
-{
-    return index_load(fn, fnidx, flags);
-}
-
-tbx_t *tbx_index_load2(const char *fn, const char *fnidx)
-{
-    return index_load(fn, fnidx, 1);
-}
-
-tbx_t *tbx_index_load(const char *fn)
-{
-    return index_load(fn, NULL, 1);
-}
-
-const char **tbx_seqnames(tbx_t *tbx, int *n)
-{
-    khash_t(s2i) *d = (khash_t(s2i)*)tbx->dict;
-    if (d == NULL)
-    {
-        *n = 0;
-        return calloc(1, sizeof(char *));
-    }
-    int tid, m = kh_size(d);
-    const char **names = (const char**) calloc(m,sizeof(const char*));
-    khint_t k;
-    if (!names) {
-        *n = 0;
-        return NULL;
-    }
-    for (k=kh_begin(d); k<kh_end(d); k++)
-    {
-        if ( !kh_exist(d,k) ) continue;
-        tid = kh_val(d,k);
-        assert( tid<m );
-        names[tid] = kh_key(d,k);
-    }
-    // sanity check: there should be no gaps
-    for (tid=0; tid<m; tid++)
-        assert(names[tid]);
-    *n = m;
-    return names;
-}
-
diff -ruN stringtie.orig/htslib/textutils.c stringtie/htslib/textutils.c
--- stringtie.orig/htslib/textutils.c	2024-02-28 13:57:39.701246126 +0100
+++ stringtie/htslib/textutils.c	1970-01-01 01:00:00.000000000 +0100
@@ -1,497 +0,0 @@
-/*  textutils.c -- non-bioinformatics utility routines for text etc.
-
-    Copyright (C) 2016, 2018-2020 Genome Research Ltd.
-
-    Author: John Marshall <jm18@sanger.ac.uk>
-
-Permission is hereby granted, free of charge, to any person obtaining a copy
-of this software and associated documentation files (the "Software"), to deal
-in the Software without restriction, including without limitation the rights
-to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
-copies of the Software, and to permit persons to whom the Software is
-furnished to do so, subject to the following conditions:
-
-The above copyright notice and this permission notice shall be included in
-all copies or substantial portions of the Software.
-
-THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
-IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
-FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
-THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
-LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
-FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
-DEALINGS IN THE SOFTWARE.  */
-
-#define HTS_BUILDING_LIBRARY // Enables HTSLIB_EXPORT, see htslib/hts_defs.h
-#include <config.h>
-
-#include <stdio.h>
-#include <string.h>
-
-#include "htslib/hfile.h"
-#include "htslib/kstring.h"
-#include "htslib/sam.h"  // For stringify_argv() declaration
-
-#include "hts_internal.h"
-
-static int dehex(char c)
-{
-    if (c >= 'a' && c <= 'f') return c - 'a' + 10;
-    else if (c >= 'A' && c <= 'F') return c - 'A' + 10;
-    else if (c >= '0' && c <= '9') return c - '0';
-    else return -1;  // Hence dehex('\0') = -1
-}
-
-int hts_decode_percent(char *dest, size_t *destlen, const char *s)
-{
-    char *d = dest;
-    int hi, lo;
-
-    while (*s) {
-        if (*s == '%' && (hi = dehex(s[1])) >= 0 && (lo = dehex(s[2])) >= 0) {
-            *d++ = (hi << 4) | lo;
-            s += 3;
-        }
-        else *d++ = *s++;
-    }
-
-    *d = '\0';
-    *destlen = d - dest;
-    return 0;
-}
-
-static int debase64(char c)
-{
-    if (c >= 'a' && c <= 'z') return c - 'a' + 26;
-    else if (c >= 'A' && c <= 'Z') return c - 'A';
-    else if (c >= '0' && c <= '9') return c - '0' + 52;
-    else if (c == '/') return 63;
-    else if (c == '+') return 62;
-    else return -1;  // Hence debase64('\0') = -1
-}
-
-size_t hts_base64_decoded_length(size_t len)
-{
-    size_t nquartets = (len + 2) / 4;
-    return 3 * nquartets;
-}
-
-int hts_decode_base64(char *dest, size_t *destlen, const char *s)
-{
-    char *d = dest;
-    int x0, x1, x2, x3;
-
-    while (1) {
-        x0 = debase64(*s++);
-        x1 = (x0 >= 0)? debase64(*s++) : -1;
-        x2 = (x1 >= 0)? debase64(*s++) : -1;
-        x3 = (x2 >= 0)? debase64(*s++) : -1;
-        if (x3 < 0) break;
-
-        *d++ = (x0 << 2) | (x1 >> 4);
-        *d++ = (x1 << 4) | (x2 >> 2);
-        *d++ = (x2 << 6) | x3;
-    }
-
-    if (x1 >= 0) *d++ = (x0 << 2) | (x1 >> 4);
-    if (x2 >= 0) *d++ = (x1 << 4) | (x2 >> 2);
-
-    *destlen = d - dest;
-    return 0;
-}
-
-static char *encode_utf8(char *s, unsigned x)
-{
-    if (x >= 0x10000) {
-        *s++ = 0xF0 | (x >> 18);
-        *s++ = 0x80 | ((x >> 12) & 0x3F);
-        *s++ = 0x80 | ((x >> 6) & 0x3F);
-        *s++ = 0x80 | (x & 0x3F);
-    }
-    else if (x >= 0x800) {
-        *s++ = 0xE0 | (x >> 12);
-        *s++ = 0x80 | ((x >> 6) & 0x3F);
-        *s++ = 0x80 | (x & 0x3F);
-    }
-    else if (x >= 0x80) {
-        *s++ = 0xC0 | (x >> 6);
-        *s++ = 0x80 | (x & 0x3F);
-    }
-    else *s++ = x;
-
-    return s;
-}
-
-static char *sscan_string(char *s)
-{
-    char *d = s;
-    int d1, d2, d3, d4;
-
-    for (;;) switch (*s) {
-    case '\\':
-        switch (s[1]) {
-        case '\0': *d = '\0'; return s+1;
-        case 'b': *d++ = '\b'; s += 2; break;
-        case 'f': *d++ = '\f'; s += 2; break;
-        case 'n': *d++ = '\n'; s += 2; break;
-        case 'r': *d++ = '\r'; s += 2; break;
-        case 't': *d++ = '\t'; s += 2; break;
-        default:  *d++ = s[1]; s += 2; break;
-        case 'u':
-            if ((d1 = dehex(s[2])) >= 0 && (d2 = dehex(s[3])) >= 0 &&
-                (d3 = dehex(s[4])) >= 0 && (d4 = dehex(s[5])) >= 0) {
-                d = encode_utf8(d, d1 << 12 | d2 << 8 | d3 << 4 | d4);
-                s += 6;
-            }
-            break;
-        }
-        break;
-
-    case '"':
-        *d = '\0';
-        return s+1;
-
-    case '\0':
-        *d = '\0';
-        return s;
-
-    default:
-        *d++ = *s++;
-        break;
-    }
-}
-
-static int fscan_string(hFILE *fp, kstring_t *d)
-{
-    int c, d1, d2, d3, d4;
-    uint32_t e = 0;
-
-    while ((c = hgetc(fp)) != EOF) switch (c) {
-    case '\\':
-        if ((c = hgetc(fp)) == EOF) return e == 0 ? 0 : -1;
-        switch (c) {
-        case 'b': e |= kputc('\b', d) < 0; break;
-        case 'f': e |= kputc('\f', d) < 0; break;
-        case 'n': e |= kputc('\n', d) < 0; break;
-        case 'r': e |= kputc('\r', d) < 0; break;
-        case 't': e |= kputc('\t', d) < 0; break;
-        default:  e |= kputc(c,    d) < 0; break;
-        case 'u':
-            if ((c = hgetc(fp)) != EOF && (d1 = dehex(c)) >= 0 &&
-                (c = hgetc(fp)) != EOF && (d2 = dehex(c)) >= 0 &&
-                (c = hgetc(fp)) != EOF && (d3 = dehex(c)) >= 0 &&
-                (c = hgetc(fp)) != EOF && (d4 = dehex(c)) >= 0) {
-                char buf[8];
-                char *lim = encode_utf8(buf, d1 << 12 | d2 << 8 | d3 << 4 | d4);
-                e |= kputsn(buf, lim - buf, d) < 0;
-            }
-            break;
-        }
-        break;
-
-    case '"':
-        return e == 0 ? 0 : -1;
-
-    default:
-        e |= kputc(c, d) < 0;
-        break;
-    }
-    return e == 0 ? 0 : -1;
-}
-
-static char token_type(hts_json_token *token)
-{
-    const char *s = token->str;
-
-    switch (*s) {
-    case 'f':
-        return (strcmp(s, "false") == 0)? 'b' : '?';
-    case 'n':
-        return (strcmp(s, "null") == 0)? '.' : '?';
-    case 't':
-        return (strcmp(s, "true") == 0)? 'b' : '?';
-    case '-':
-    case '0': case '1': case '2': case '3': case '4':
-    case '5': case '6': case '7': case '8': case '9':
-        return 'n';
-    default:
-        return '?';
-    }
-}
-
-HTSLIB_EXPORT
-hts_json_token * hts_json_alloc_token() {
-    return calloc(1, sizeof(hts_json_token));
-}
-
-HTSLIB_EXPORT
-char hts_json_token_type(hts_json_token *token) {
-    return token->type;
-}
-
-HTSLIB_EXPORT
-void hts_json_free_token(hts_json_token *token) {
-    free(token);
-}
-
-HTSLIB_EXPORT
-char *hts_json_token_str(hts_json_token *token) {
-    return token->str;
-}
-
-HTSLIB_EXPORT
-char hts_json_snext(char *str, size_t *state, hts_json_token *token)
-{
-    char *s = &str[*state >> 2];
-    int hidden = *state & 3;
-
-    if (hidden) {
-        *state &= ~3;
-        return token->type = "?}]?"[hidden];
-    }
-
-#define STATE(s,h)  (((s) - str) << 2 | (h))
-
-    for (;;) switch (*s) {
-    case ' ':
-    case '\t':
-    case '\r':
-    case '\n':
-    case ',':
-    case ':':
-        s++;
-        continue;
-
-    case '\0':
-        return token->type = '\0';
-
-    case '{':
-    case '[':
-    case '}':
-    case ']':
-        *state = STATE(s+1, 0);
-        return token->type = *s;
-
-    case '"':
-        token->str = s+1;
-        *state = STATE(sscan_string(s+1), 0);
-        return token->type = 's';
-
-    default:
-        token->str = s;
-        s += strcspn(s, " \t\r\n,]}");
-        hidden = (*s == '}')? 1 : (*s == ']')? 2 : 0;
-        if (*s != '\0') *s++ = '\0';
-        *state = STATE(s, hidden);
-        return token->type = token_type(token);
-    }
-
-#undef STATE
-}
-
-HTSLIB_EXPORT
-char hts_json_fnext(struct hFILE *fp, hts_json_token *token, kstring_t *kstr)
-{
-    char peek;
-    int c;
-
-    for (;;) switch (c = hgetc(fp)) {
-    case ' ':
-    case '\t':
-    case '\r':
-    case '\n':
-    case ',':
-    case ':':
-        continue;
-
-    case EOF:
-        return token->type = '\0';
-
-    case '{':
-    case '[':
-    case '}':
-    case ']':
-        return token->type = c;
-
-    case '"':
-        kstr->l = 0;
-        fscan_string(fp, kstr);
-        if (kstr->l == 0) kputsn("", 0, kstr);
-        token->str = kstr->s;
-        return token->type = 's';
-
-    default:
-        kstr->l = 0;
-        kputc(c, kstr);
-        while (hpeek(fp, &peek, 1) == 1 && !strchr(" \t\r\n,]}", peek)) {
-            if ((c = hgetc(fp)) == EOF) break;
-            kputc(c, kstr);
-        }
-        token->str = kstr->s;
-        return token->type = token_type(token);
-    }
-}
-
-
-typedef char hts_json_nextfn(void *arg1, void *arg2, hts_json_token *token);
-
-static char skip_value(char type, hts_json_nextfn *next, void *arg1, void *arg2)
-{
-    hts_json_token token;
-    int level;
-
-    switch (type? type : next(arg1, arg2, &token)) {
-    case '\0':
-        return '\0';
-
-    case '?':
-    case '}':
-    case ']':
-        return '?';
-
-    case '{':
-    case '[':
-        level = 1;
-        break;
-
-    default:
-        return 'v';
-    }
-
-    while (level > 0)
-        switch (next(arg1, arg2, &token)) {
-        case '\0':
-            return '\0';
-
-        case '?':
-            return '?';
-
-        case '{':
-        case '[':
-            level++;
-            break;
-
-        case '}':
-        case ']':
-            --level;
-            break;
-
-        default:
-            break;
-        }
-
-    return 'v';
-}
-
-static char snext(void *arg1, void *arg2, hts_json_token *token)
-{
-    return hts_json_snext(arg1, arg2, token);
-}
-
-HTSLIB_EXPORT
-char hts_json_sskip_value(char *str, size_t *state, char type)
-{
-    return skip_value(type, snext, str, state);
-}
-
-static char fnext(void *arg1, void *arg2, hts_json_token *token)
-{
-    return hts_json_fnext(arg1, token, arg2);
-}
-
-HTSLIB_EXPORT
-char hts_json_fskip_value(struct hFILE *fp, char type)
-{
-    kstring_t str = { 0, 0, NULL };
-    char ret = skip_value(type, fnext, fp, &str);
-    free(str.s);
-    return ret;
-}
-
-/*
- * A function to help with construction of CL tags in @PG records.
- * Takes an argc, argv pair and returns a single space-separated string.
- * This string should be deallocated by the calling function.
- *
- * Returns malloced char * on success
- *         NULL on failure
- */
-char *stringify_argv(int argc, char *argv[]) {
-    char *str, *cp;
-    size_t nbytes = 1;
-    int i, j;
-
-    /* Allocate */
-    for (i = 0; i < argc; i++) {
-        if (i > 0) nbytes += 1;
-        nbytes += strlen(argv[i]);
-    }
-    if (!(str = malloc(nbytes)))
-        return NULL;
-
-    /* Copy */
-    cp = str;
-    for (i = 0; i < argc; i++) {
-        if (i > 0) *cp++ = ' ';
-        j = 0;
-        while (argv[i][j]) {
-            if (argv[i][j] == '\t')
-                *cp++ = ' ';
-            else
-                *cp++ = argv[i][j];
-            j++;
-        }
-    }
-    *cp++ = 0;
-
-    return str;
-}
-
-/* Utility function for printing possibly malicious text data
- */
-const char *
-hts_strprint(char *buf, size_t buflen, char quote, const char *s, size_t len)
-{
-    const char *slim = (len < SIZE_MAX)? &s[len] : NULL;
-    char *t = buf;
-
-    size_t qlen = quote? 1 : 0;
-    if (quote) *t++ = quote;
-
-    for (; slim? (s < slim) : (*s); s++) {
-        char c;
-        size_t clen;
-        switch (*s) {
-        case '\n': c = 'n'; clen = 2; break;
-        case '\r': c = 'r'; clen = 2; break;
-        case '\t': c = 't'; clen = 2; break;
-        case '\0': c = '0'; clen = 2; break;
-        case '\\': c = '\\'; clen = 2; break;
-        default:
-            c = *s;
-            if (c == quote) clen = 2;
-            else clen = isprint_c(c)? 1 : 4;
-            break;
-        }
-
-        if (t-buf + clen + qlen >= buflen) {
-            while (t-buf + 3 + qlen >= buflen) t--;
-            if (quote) *t++ = quote;
-            strcpy(t, "...");
-            return buf;
-        }
-
-        if (clen == 4) {
-            sprintf(t, "\\x%02X", (unsigned char) c);
-            t += clen;
-        }
-        else {
-            if (clen == 2) *t++ = '\\';
-            *t++ = c;
-        }
-    }
-
-    if (quote) *t++ = quote;
-    *t = '\0';
-    return buf;
-}
diff -ruN stringtie.orig/htslib/textutils_internal.h stringtie/htslib/textutils_internal.h
--- stringtie.orig/htslib/textutils_internal.h	2024-02-28 13:57:39.701246126 +0100
+++ stringtie/htslib/textutils_internal.h	1970-01-01 01:00:00.000000000 +0100
@@ -1,402 +0,0 @@
-/* textutils_internal.h -- non-bioinformatics utility routines for text etc.
-
-   Copyright (C) 2016,2018-2020 Genome Research Ltd.
-
-   Author: John Marshall <jm18@sanger.ac.uk>
-
-Permission is hereby granted, free of charge, to any person obtaining a copy
-of this software and associated documentation files (the "Software"), to deal
-in the Software without restriction, including without limitation the rights
-to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
-copies of the Software, and to permit persons to whom the Software is
-furnished to do so, subject to the following conditions:
-
-The above copyright notice and this permission notice shall be included in
-all copies or substantial portions of the Software.
-
-THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
-IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
-FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
-THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
-LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
-FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
-DEALINGS IN THE SOFTWARE.  */
-
-#ifndef HTSLIB_TEXTUTILS_INTERNAL_H
-#define HTSLIB_TEXTUTILS_INTERNAL_H
-
-/* N.B. These interfaces may be used by plug-ins */
-
-#include <ctype.h>
-#include <stdlib.h>
-#include "htslib/kstring.h"
-
-#ifdef __cplusplus
-extern "C" {
-#endif
-
-/// Decode percent-encoded (URL-encoded) text
-/** On input, _dest_ should be a buffer at least the same size as _s_,
-    and may be equal to _s_ to decode in place.  On output, _dest_ will be
-    NUL-terminated and the number of characters written (not including the
-    NUL) is stored in _destlen_.
-*/
-int hts_decode_percent(char *dest, size_t *destlen, const char *s);
-
-/// Return decoded data length given length of base64-encoded text
-/** This gives an upper bound, as it overestimates by a byte or two when
-    the encoded text ends with (possibly omitted) `=` padding characters.
-*/
-size_t hts_base64_decoded_length(size_t len);
-
-/// Decode base64-encoded data
-/** On input, _dest_ should be a sufficient buffer (see `hts_base64_length()`),
-    and may be equal to _s_ to decode in place.  On output, the number of
-    bytes written is stored in _destlen_.
-*/
-int hts_decode_base64(char *dest, size_t *destlen, const char *s);
-
-/// Token structure returned by JSON lexing functions
-/** Structure is defined in hts_internal.h
- */
-
-typedef struct hts_json_token hts_json_token;
-
-/// Allocate an empty JSON token structure, for use with hts_json_* functions
-/** @return An empty token on success; NULL on failure
- */
-hts_json_token *hts_json_alloc_token(void);
-
-/// Free a JSON token
-void hts_json_free_token(hts_json_token *token);
-
-/// Accessor function to get JSON token type
-/** @param  token Pointer to JSON token
-    @return Character indicating the token type
-
-Token types correspond to scalar JSON values and selected punctuation
-as follows:
-  - `s` string
-  - `n` number
-  - `b` boolean literal
-  - `.` null literal
-  - `{`, `}`, `[`, `]` object and array delimiters
-  - `?` lexing error
-  - `!` other errors (e.g. out of memory)
-  - `\0` terminator at end of input
-*/
-char hts_json_token_type(hts_json_token *token);
-
-/// Accessor function to get JSON token in string form
-/** @param  token Pointer to JSON token
-    @return String representation of the JSON token; NULL if unset
-
-If the token was parsed from a string using hts_json_snext(), the return value
-will point into the string passed as the first parameter to hts_json_snext().
-If the token was parsed from a file using hts_json_fnext(), the return value
-will point at the kstring_t buffer passed as the third parameter to
-hts_json_fnext().  In that case, the value will only be valid until the
-next call to hts_json_fnext().
- */
-char *hts_json_token_str(hts_json_token *token);
-
-/// Read one JSON token from a string
-/** @param str    The input C string
-    @param state  The input string state
-    @param token  On return, filled in with the token read
-    @return  The type of the token read
-
-On return, `token->str` points into the supplied input string, which
-is modified by having token-terminating characters overwritten as NULs.
-The `state` argument records the current position within `str` after each
-`hts_json_snext()` call, and should be set to 0 before the first call.
-*/
-char hts_json_snext(char *str, size_t *state, hts_json_token *token);
-
-/// Read and discard a complete JSON value from a string
-/** @param str    The input C string
-    @param state  The input string state, as per `hts_json_snext()`
-    @param type   If the first token of the value to be discarded has already
-                  been read, provide its type; otherwise `'\0'`
-    @return  One of `v` (success), `\0` (end of string), and `?` (lexing error)
-
-Skips a complete JSON value, which may be a single token or an entire object
-or array.
-*/
-char hts_json_sskip_value(char *str, size_t *state, char type);
-
-struct hFILE;
-
-/// Read one JSON token from a file
-/** @param fp     The file stream
-    @param token  On return, filled in with the token read
-    @param kstr   Buffer used to store the token string returned
-    @return  The type of the token read
-
-The `kstr` buffer is used to store the string value of the token read,
-so `token->str` is only valid until the next time `hts_json_fnext()` is
-called with the same `kstr` argument.
-*/
-char hts_json_fnext(struct hFILE *fp, hts_json_token *token, kstring_t *kstr);
-
-/// Read and discard a complete JSON value from a file
-/** @param fp    The file stream
-    @param type  If the first token of the value to be discarded has already
-                 been read, provide its type; otherwise `'\0'`
-    @return  One of `v` (success), `\0` (EOF), and `?` (lexing error)
-
-Skips a complete JSON value, which may be a single token or an entire object
-or array.
-*/
-char hts_json_fskip_value(struct hFILE *fp, char type);
-
-// The <ctype.h> functions operate on ints such as are returned by fgetc(),
-// i.e., characters represented as unsigned-char-valued ints, or EOF.
-// To operate on plain chars (and to avoid warnings on some platforms),
-// technically one must cast to unsigned char everywhere (see CERT STR37-C)
-// or less painfully use these *_c() functions that operate on plain chars
-// (but not EOF, which must be considered separately where it is applicable).
-// TODO We may eventually wish to implement these functions directly without
-// using their <ctype.h> equivalents, and thus make them immune to locales.
-static inline int isalnum_c(char c) { return isalnum((unsigned char) c); }
-static inline int isalpha_c(char c) { return isalpha((unsigned char) c); }
-static inline int isdigit_c(char c) { return isdigit((unsigned char) c); }
-static inline int isgraph_c(char c) { return isgraph((unsigned char) c); }
-static inline int islower_c(char c) { return islower((unsigned char) c); }
-static inline int isprint_c(char c) { return isprint((unsigned char) c); }
-static inline int ispunct_c(char c) { return ispunct((unsigned char) c); }
-static inline int isspace_c(char c) { return isspace((unsigned char) c); }
-static inline int isupper_c(char c) { return isupper((unsigned char) c); }
-static inline int isxdigit_c(char c) { return isxdigit((unsigned char) c); }
-static inline char tolower_c(char c) { return tolower((unsigned char) c); }
-static inline char toupper_c(char c) { return toupper((unsigned char) c); }
-
-/// Copy possibly malicious text data to a buffer
-/** @param buf     Destination buffer
-    @param buflen  Size of the destination buffer (>= 4; >= 6 when quotes used)
-    @param quote   Quote character (or '\0' for no quoting of the output)
-    @param s       String to be copied
-    @param len     Length of the input string, or SIZE_MAX to copy until '\0'
-    @return The destination buffer, @a buf.
-
-Copies the source text string (escaping any unprintable characters) to the
-destination buffer. The destination buffer will always be NUL-terminated;
-the text will be truncated (and "..." appended) if necessary to make it fit.
- */
-const char *hts_strprint(char *buf, size_t buflen, char quote,
-                         const char *s, size_t len);
-
-// Faster replacements for strtol, for use when parsing lots of numbers.
-// Note that these only handle base 10 and do not skip leading whitespace
-
-/// Convert a string to a signed integer, with overflow detection
-/** @param[in]  in     Input string
-    @param[out] end    Returned end pointer
-    @param[in]  bits   Bits available for the converted value
-    @param[out] failed Location of overflow flag
-    @return String value converted to an int64_t
-
-Converts a signed decimal string to an int64_t.  The string should
-consist of an optional '+' or '-' sign followed by one or more of
-the digits 0 to 9.  The output value will be limited to fit in the
-given number of bits (including the sign bit).  If the value is too big,
-the largest possible value will be returned and *failed will be set to 1.
-
-The address of the first character following the converted number will
-be stored in *end.
-
-Both end and failed must be non-NULL.
- */
-static inline int64_t hts_str2int(const char *in, char **end, int bits,
-                                    int *failed) {
-    uint64_t n = 0, limit = (1ULL << (bits - 1)) - 1;
-    uint32_t fast = (bits - 1) * 1000 / 3322 + 1; // log(10)/log(2) ~= 3.322
-    const unsigned char *v = (const unsigned char *) in;
-    const unsigned int ascii_zero = '0'; // Prevents conversion to signed
-    unsigned char d;
-    int neg = 1;
-
-    switch(*v) {
-    case '-':
-        neg=-1;
-        limit++; /* fall through */
-    case '+':
-        v++;
-        break;
-    default:
-        break;
-    }
-
-    while (--fast && *v>='0' && *v<='9')
-        n = n*10 + *v++ - ascii_zero;
-
-    if (!fast) {
-        uint64_t limit_d_10 = limit / 10;
-        uint64_t limit_m_10 = limit - 10 * limit_d_10;
-         while ((d = *v - ascii_zero) < 10) {
-            if (n < limit_d_10 || (n == limit_d_10 && d <= limit_m_10)) {
-                n = n*10 + d;
-                v++;
-            } else {
-                do { v++; } while (*v - ascii_zero < 10);
-                n = limit;
-                *failed = 1;
-                break;
-            }
-        }
-    }
-
-    *end = (char *)v;
-
-    return (n && neg < 0) ? -((int64_t) (n - 1)) - 1 : (int64_t) n;
-}
-
-/// Convert a string to an unsigned integer, with overflow detection
-/** @param[in]  in     Input string
-    @param[out] end    Returned end pointer
-    @param[in]  bits   Bits available for the converted value
-    @param[out] failed Location of overflow flag
-    @return String value converted to a uint64_t
-
-Converts an unsigned decimal string to a uint64_t.  The string should
-consist of an optional '+' sign followed by one or more of the digits 0
-to 9.  The output value will be limited to fit in the given number of bits.
-If the value is too big, the largest possible value will be returned
-and *failed will be set to 1.
-
-The address of the first character following the converted number will
-be stored in *end.
-
-Both end and failed must be non-NULL.
- */
-
-static inline uint64_t hts_str2uint(const char *in, char **end, int bits,
-                                      int *failed) {
-    uint64_t n = 0, limit = (bits < 64 ? (1ULL << bits) : 0) - 1;
-    const unsigned char *v = (const unsigned char *) in;
-    const unsigned int ascii_zero = '0'; // Prevents conversion to signed
-    uint32_t fast = bits * 1000 / 3322 + 1; // log(10)/log(2) ~= 3.322
-    unsigned char d;
-
-    if (*v == '+')
-        v++;
-
-    while (--fast && *v>='0' && *v<='9')
-        n = n*10 + *v++ - ascii_zero;
-
-    if (!fast) {
-        uint64_t limit_d_10 = limit / 10;
-        uint64_t limit_m_10 = limit - 10 * limit_d_10;
-        while ((d = *v - ascii_zero) < 10) {
-            if (n < limit_d_10 || (n == limit_d_10 && d <= limit_m_10)) {
-                n = n*10 + d;
-                v++;
-            } else {
-                do { v++; } while (*v - ascii_zero < 10);
-                n = limit;
-                *failed = 1;
-                break;
-            }
-        }
-    }
-
-    *end = (char *)v;
-    return n;
-}
-
-/// Convert a string to a double, with overflow detection
-/** @param[in]  in     Input string
-    @param[out] end    Returned end pointer
-    @param[out] failed Location of overflow flag
-    @return String value converted to a double
-
-Converts a floating point value string to a double.  The string should
-have the format [+-]?[0-9]*[.]?[0-9]* with at least one and no more than 15
-digits.  Strings that do not match (inf, nan, values with exponents) will
-be passed on to strtod() for processing.
-
-If the value is too big, the largest possible value will be returned;
-if it is too small to be represented in a double zero will be returned.
-In both cases errno will be set to ERANGE.
-
-If no characters could be converted, *failed will be set to 1.
-
-The address of the first character following the converted number will
-be stored in *end.
-
-Both end and failed must be non-NULL.
- */
-
-static inline double hts_str2dbl(const char *in, char **end, int *failed) {
-    uint64_t n = 0;
-    int max_len = 15;
-    const unsigned char *v = (const unsigned char *) in;
-    const unsigned int ascii_zero = '0'; // Prevents conversion to signed
-    int neg = 0, point = -1;
-    double d;
-    static double D[] = {1,1, 1e1, 1e2, 1e3, 1e4, 1e5, 1e6, 1e7,
-                         1e8, 1e9, 1e10,1e11,1e12,1e13,1e14,1e15,
-                         1e16,1e17,1e18,1e19,1e20};
-
-    while (isspace(*v))
-        v++;
-
-    if (*v == '-') {
-        neg = 1;
-        v++;
-    } else if (*v == '+') {
-        v++;
-    }
-
-    switch(*v) {
-    case '1': case '2': case '3': case '4':
-    case '5': case '6': case '7': case '8': case '9':
-        break;
-
-    case '0':
-        if (v[1] != 'x' && v[1] != 'X') break;
-        // else fall through - hex number
-
-    default:
-        // Non numbers, like NaN, Inf
-        d = strtod(in, end);
-        if (*end == in)
-            *failed = 1;
-        return d;
-    }
-
-    while (*v == '0') ++v;
-
-    const unsigned char *start = v;
-
-    while (--max_len && *v>='0' && *v<='9')
-        n = n*10 + *v++ - ascii_zero;
-    if (max_len && *v == '.') {
-        point = v - start;
-        v++;
-        while (--max_len && *v>='0' && *v<='9')
-            n = n*10 + *v++ - ascii_zero;
-    }
-    if (point < 0)
-        point = v - start;
-
-    // Outside the scope of this quick and dirty parser.
-    if (!max_len || *v == 'e' || *v == 'E') {
-        d = strtod(in, end);
-        if (*end == in)
-            *failed = 1;
-        return d;
-    }
-
-    *end = (char *)v;
-    d = n / D[v - start - point];
-
-    return neg ? -d : d;
-}
-
-
-#ifdef __cplusplus
-}
-#endif
-
-#endif
diff -ruN stringtie.orig/htslib/thread_pool.c stringtie/htslib/thread_pool.c
--- stringtie.orig/htslib/thread_pool.c	2024-02-28 13:57:39.701246126 +0100
+++ stringtie/htslib/thread_pool.c	1970-01-01 01:00:00.000000000 +0100
@@ -1,1533 +0,0 @@
-/*  thread_pool.c -- A pool of generic worker threads
-
-    Copyright (c) 2013-2020 Genome Research Ltd.
-
-    Author: James Bonfield <jkb@sanger.ac.uk>
-
-Permission is hereby granted, free of charge, to any person obtaining a copy
-of this software and associated documentation files (the "Software"), to deal
-in the Software without restriction, including without limitation the rights
-to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
-copies of the Software, and to permit persons to whom the Software is
-furnished to do so, subject to the following conditions:
-
-The above copyright notice and this permission notice shall be included in
-all copies or substantial portions of the Software.
-
-THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
-IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
-FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
-THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
-LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
-FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
-DEALINGS IN THE SOFTWARE.  */
-
-#ifndef TEST_MAIN
-#define HTS_BUILDING_LIBRARY // Enables HTSLIB_EXPORT, see htslib/hts_defs.h
-#include <config.h>
-#endif
-
-#include <stdlib.h>
-#include <inttypes.h>
-#include <signal.h>
-#include <errno.h>
-#include <stdio.h>
-#include <string.h>
-#include <sys/time.h>
-#include <assert.h>
-#include <stdarg.h>
-#include <unistd.h>
-#include <limits.h>
-
-#include "thread_pool_internal.h"
-#include "htslib/hts_log.h"
-
-// Minimum stack size for threads.  Required for some rANS codecs
-// that use over 2Mbytes of stack for encoder / decoder state
-#define HTS_MIN_THREAD_STACK (3 * 1024 * 1024)
-
-static void hts_tpool_process_detach_locked(hts_tpool *p,
-                                            hts_tpool_process *q);
-
-//#define DEBUG
-
-#ifdef DEBUG
-static int worker_id(hts_tpool *p) {
-    int i;
-    pthread_t s = pthread_self();
-    for (i = 0; i < p->tsize; i++) {
-        if (pthread_equal(s, p->t[i].tid))
-            return i;
-    }
-    return -1;
-}
-
-void DBG_OUT(FILE *fp, char *fmt, ...) {
-    va_list args;
-    va_start(args, fmt);
-    vfprintf(fp, fmt, args);
-    va_end(args);
-}
-#else
-#define DBG_OUT(...) do{}while(0)
-#endif
-
-/* ----------------------------------------------------------------------------
- * A process-queue to hold results from the thread pool.
- *
- * Each thread pool may have jobs of multiple types being queued up and
- * interleaved, so we attach several job process-queues to a single pool.
- *
- * The jobs themselves are expected to push their results onto their
- * appropriate results queue.
- */
-
-/*
- * Adds a result to the end of the process result queue.
- *
- * Returns 0 on success;
- *        -1 on failure
- */
-static int hts_tpool_add_result(hts_tpool_job *j, void *data) {
-    hts_tpool_process *q = j->q;
-    hts_tpool_result *r;
-
-    pthread_mutex_lock(&q->p->pool_m);
-
-    DBG_OUT(stderr, "%d: Adding result to queue %p, serial %"PRId64", %d of %d\n",
-            worker_id(j->p), q, j->serial, q->n_output+1, q->qsize);
-
-    if (--q->n_processing == 0)
-        pthread_cond_signal(&q->none_processing_c);
-
-    /* No results queue is fine if we don't want any results back */
-    if (q->in_only) {
-        pthread_mutex_unlock(&q->p->pool_m);
-        return 0;
-    }
-
-    if (!(r = malloc(sizeof(*r)))) {
-        pthread_mutex_unlock(&q->p->pool_m);
-        hts_tpool_process_shutdown(q);
-        return -1;
-    }
-
-    r->next = NULL;
-    r->data = data;
-    r->result_cleanup = j->result_cleanup;
-    r->serial = j->serial;
-
-    q->n_output++;
-    if (q->output_tail) {
-        q->output_tail->next = r;
-        q->output_tail = r;
-    } else {
-        q->output_head = q->output_tail = r;
-    }
-
-    assert(r->serial >= q->next_serial    // Or it will never be dequeued ...
-           || q->next_serial == INT_MAX); // ... unless flush in progress.
-    if (r->serial == q->next_serial) {
-        DBG_OUT(stderr, "%d: Broadcasting result_avail (id %"PRId64")\n",
-                worker_id(j->p), r->serial);
-        pthread_cond_broadcast(&q->output_avail_c);
-        DBG_OUT(stderr, "%d: Broadcast complete\n", worker_id(j->p));
-    }
-
-    pthread_mutex_unlock(&q->p->pool_m);
-
-    return 0;
-}
-
-static void wake_next_worker(hts_tpool_process *q, int locked);
-
-/* Core of hts_tpool_next_result() */
-static hts_tpool_result *hts_tpool_next_result_locked(hts_tpool_process *q) {
-    hts_tpool_result *r, *last;
-
-    if (q->shutdown)
-        return NULL;
-
-    for (last = NULL, r = q->output_head; r; last = r, r = r->next) {
-        if (r->serial == q->next_serial)
-            break;
-    }
-
-    if (r) {
-        // Remove r from out linked list
-        if (q->output_head == r)
-            q->output_head = r->next;
-        else
-            last->next = r->next;
-
-        if (q->output_tail == r)
-            q->output_tail = last;
-
-        if (!q->output_head)
-            q->output_tail = NULL;
-
-        q->next_serial++;
-        q->n_output--;
-
-        if (q->qsize && q->n_output < q->qsize) {
-            // Not technically input full, but can guarantee there is
-            // room for the input to go somewhere so we still signal.
-            // The waiting code will then check the condition again.
-            if (q->n_input < q->qsize)
-                pthread_cond_signal(&q->input_not_full_c);
-            if (!q->shutdown)
-                wake_next_worker(q, 1);
-        }
-    }
-
-    return r;
-}
-
-/*
- * Pulls the next item off the process result queue.  The caller should free
- * it (and any internals as appropriate) after use.  This doesn't wait for a
- * result to be present.
- *
- * Results will be returned in strict order.
- *
- * Returns hts_tpool_result pointer if a result is ready.
- *         NULL if not.
- */
-hts_tpool_result *hts_tpool_next_result(hts_tpool_process *q) {
-    hts_tpool_result *r;
-
-    DBG_OUT(stderr, "Requesting next result on queue %p\n", q);
-
-    pthread_mutex_lock(&q->p->pool_m);
-    r = hts_tpool_next_result_locked(q);
-    pthread_mutex_unlock(&q->p->pool_m);
-
-    DBG_OUT(stderr, "(q=%p) Found %p\n", q, r);
-
-    return r;
-}
-
-/*
- * Pulls the next item off the process result queue.  The caller should free
- * it (and any internals as appropriate) after use.  This will wait for
- * a result to be present if none are currently available.
- *
- * Results will be returned in strict order.
- *
- * Returns hts_tpool_result pointer if a result is ready.
- *         NULL on error or during shutdown.
- */
-hts_tpool_result *hts_tpool_next_result_wait(hts_tpool_process *q) {
-    hts_tpool_result *r;
-
-    pthread_mutex_lock(&q->p->pool_m);
-    while (!(r = hts_tpool_next_result_locked(q))) {
-        /* Possible race here now avoided via _locked() call, but in case... */
-        struct timeval now;
-        struct timespec timeout;
-
-        gettimeofday(&now, NULL);
-        timeout.tv_sec = now.tv_sec + 10;
-        timeout.tv_nsec = now.tv_usec * 1000;
-
-        q->ref_count++;
-        if (q->shutdown) {
-            int rc = --q->ref_count;
-            pthread_mutex_unlock(&q->p->pool_m);
-            if (rc == 0)
-                hts_tpool_process_destroy(q);
-            return NULL;
-        }
-        pthread_cond_timedwait(&q->output_avail_c, &q->p->pool_m, &timeout);
-
-        q->ref_count--;
-    }
-    pthread_mutex_unlock(&q->p->pool_m);
-
-    return r;
-}
-
-/*
- * Returns true if there are no items in the process results queue and
- * also none still pending.
- */
-int hts_tpool_process_empty(hts_tpool_process *q) {
-    int empty;
-
-    pthread_mutex_lock(&q->p->pool_m);
-    empty = q->n_input == 0 && q->n_processing == 0 && q->n_output == 0;
-    pthread_mutex_unlock(&q->p->pool_m);
-
-    return empty;
-}
-
-void hts_tpool_process_ref_incr(hts_tpool_process *q) {
-    pthread_mutex_lock(&q->p->pool_m);
-    q->ref_count++;
-    pthread_mutex_unlock(&q->p->pool_m);
-}
-
-void hts_tpool_process_ref_decr(hts_tpool_process *q) {
-    pthread_mutex_lock(&q->p->pool_m);
-    if (--q->ref_count <= 0) {
-        pthread_mutex_unlock(&q->p->pool_m);
-        hts_tpool_process_destroy(q);
-        return;
-    }
-
-    // maybe also call destroy here if needed?
-    pthread_mutex_unlock(&q->p->pool_m);
-}
-
-/*
- * Returns the number of completed jobs in the process results queue.
- */
-int hts_tpool_process_len(hts_tpool_process *q) {
-    int len;
-
-    pthread_mutex_lock(&q->p->pool_m);
-    len = q->n_output;
-    pthread_mutex_unlock(&q->p->pool_m);
-
-    return len;
-}
-
-/*
- * Returns the number of completed jobs in the process results queue plus the
- * number running and queued up to run.
- */
-int hts_tpool_process_sz(hts_tpool_process *q) {
-    int len;
-
-    pthread_mutex_lock(&q->p->pool_m);
-    len = q->n_output + q->n_input + q->n_processing;
-    pthread_mutex_unlock(&q->p->pool_m);
-
-    return len;
-}
-
-/*
- * Shutdown a process.
- *
- * This sets the shutdown flag and wakes any threads waiting on process
- * condition variables.
- */
-static void hts_tpool_process_shutdown_locked(hts_tpool_process *q) {
-    q->shutdown = 1;
-    pthread_cond_broadcast(&q->output_avail_c);
-    pthread_cond_broadcast(&q->input_not_full_c);
-    pthread_cond_broadcast(&q->input_empty_c);
-    pthread_cond_broadcast(&q->none_processing_c);
-}
-
-void hts_tpool_process_shutdown(hts_tpool_process *q) {
-    pthread_mutex_lock(&q->p->pool_m);
-    hts_tpool_process_shutdown_locked(q);
-    pthread_mutex_unlock(&q->p->pool_m);
-}
-
-int hts_tpool_process_is_shutdown(hts_tpool_process *q) {
-    pthread_mutex_lock(&q->p->pool_m);
-    int r = q->shutdown;
-    pthread_mutex_unlock(&q->p->pool_m);
-    return r;
-}
-
-/*
- * Frees a result 'r' and if free_data is true also frees
- * the internal r->data result too.
- */
-void hts_tpool_delete_result(hts_tpool_result *r, int free_data) {
-    if (!r)
-        return;
-
-    if (free_data && r->data)
-        free(r->data);
-
-    free(r);
-}
-
-/*
- * Returns the data portion of a hts_tpool_result, corresponding
- * to the actual "result" itself.
- */
-void *hts_tpool_result_data(hts_tpool_result *r) {
-    return r->data;
-}
-
-/*
- * Initialises a thread process-queue.
- *
- * In_only, if true, indicates that the process generates does not need to
- * hold any output.  Otherwise an output queue is used to store the results
- * of processing each input job.
- *
- * Results hts_tpool_process pointer on success;
- *         NULL on failure
- */
-hts_tpool_process *hts_tpool_process_init(hts_tpool *p, int qsize, int in_only) {
-    hts_tpool_process *q = malloc(sizeof(*q));
-    if (!q)
-        return NULL;
-
-    pthread_cond_init(&q->output_avail_c,   NULL);
-    pthread_cond_init(&q->input_not_full_c, NULL);
-    pthread_cond_init(&q->input_empty_c,    NULL);
-    pthread_cond_init(&q->none_processing_c,NULL);
-
-    q->p           = p;
-    q->input_head  = NULL;
-    q->input_tail  = NULL;
-    q->output_head = NULL;
-    q->output_tail = NULL;
-    q->next_serial = 0;
-    q->curr_serial = 0;
-    q->no_more_input = 0;
-    q->n_input     = 0;
-    q->n_output    = 0;
-    q->n_processing= 0;
-    q->qsize       = qsize;
-    q->in_only     = in_only;
-    q->shutdown    = 0;
-    q->wake_dispatch = 0;
-    q->ref_count   = 1;
-
-    q->next        = NULL;
-    q->prev        = NULL;
-
-    hts_tpool_process_attach(p, q);
-
-    return q;
-}
-
-/* Deallocates memory for a thread process-queue.
- * Must be called before the thread pool is destroyed.
- */
-void hts_tpool_process_destroy(hts_tpool_process *q) {
-    DBG_OUT(stderr, "Destroying results queue %p\n", q);
-
-    if (!q)
-        return;
-
-    // Prevent dispatch from queuing up any more jobs.
-    // We want to reset (and flush) the queue here, before
-    // we set the shutdown flag, but we need to avoid races
-    // with queue more input during reset.
-    pthread_mutex_lock(&q->p->pool_m);
-    q->no_more_input = 1;
-    pthread_mutex_unlock(&q->p->pool_m);
-
-    // Ensure it's fully drained before destroying the queue
-    hts_tpool_process_reset(q, 0);
-    pthread_mutex_lock(&q->p->pool_m);
-    hts_tpool_process_detach_locked(q->p, q);
-    hts_tpool_process_shutdown_locked(q);
-
-    // Maybe a worker is scanning this queue, so delay destruction
-    if (--q->ref_count > 0) {
-        pthread_mutex_unlock(&q->p->pool_m);
-        return;
-    }
-
-    pthread_cond_destroy(&q->output_avail_c);
-    pthread_cond_destroy(&q->input_not_full_c);
-    pthread_cond_destroy(&q->input_empty_c);
-    pthread_cond_destroy(&q->none_processing_c);
-    pthread_mutex_unlock(&q->p->pool_m);
-
-    free(q);
-
-    DBG_OUT(stderr, "Destroyed results queue %p\n", q);
-}
-
-
-/*
- * Attach and detach a thread process-queue with / from the thread pool
- * scheduler.
- *
- * We need to do attach after making a thread process, but may also wish
- * to temporarily detach if we wish to stop running jobs on a specific
- * process while permitting other process to continue.
- */
-void hts_tpool_process_attach(hts_tpool *p, hts_tpool_process *q) {
-    pthread_mutex_lock(&p->pool_m);
-    if (p->q_head) {
-        q->next = p->q_head;
-        q->prev = p->q_head->prev;
-        p->q_head->prev->next = q;
-        p->q_head->prev = q;
-    } else {
-        q->next = q;
-        q->prev = q;
-    }
-    p->q_head = q;
-    assert(p->q_head && p->q_head->prev && p->q_head->next);
-    pthread_mutex_unlock(&p->pool_m);
-}
-
-static void hts_tpool_process_detach_locked(hts_tpool *p,
-                                            hts_tpool_process *q) {
-    if (!p->q_head || !q->prev || !q->next)
-        return;
-
-    hts_tpool_process *curr = p->q_head, *first = curr;
-    do {
-        if (curr == q) {
-            q->next->prev = q->prev;
-            q->prev->next = q->next;
-            p->q_head = q->next;
-            q->next = q->prev = NULL;
-
-            // Last one
-            if (p->q_head == q)
-                p->q_head = NULL;
-            break;
-        }
-
-        curr = curr->next;
-    } while (curr != first);
-}
-
-void hts_tpool_process_detach(hts_tpool *p, hts_tpool_process *q) {
-    pthread_mutex_lock(&p->pool_m);
-    hts_tpool_process_detach_locked(p, q);
-    pthread_mutex_unlock(&p->pool_m);
-}
-
-
-/* ----------------------------------------------------------------------------
- * The thread pool.
- */
-
-#define TDIFF(t2,t1) ((t2.tv_sec-t1.tv_sec)*1000000 + t2.tv_usec-t1.tv_usec)
-
-/*
- * A worker thread.
- *
- * Once woken, each thread checks each process-queue in the pool in turn,
- * looking for input jobs that also have room for the output (if it requires
- * storing).  If found, we execute it and repeat.
- *
- * If we checked all input queues and find no such job, then we wait until we
- * are signalled to check again.
- */
-static void *tpool_worker(void *arg) {
-    hts_tpool_worker *w = (hts_tpool_worker *)arg;
-    hts_tpool *p = w->p;
-    hts_tpool_job *j;
-
-    pthread_mutex_lock(&p->pool_m);
-    while (!p->shutdown) {
-        // Pop an item off the pool queue
-
-        assert(p->q_head == 0 || (p->q_head->prev && p->q_head->next));
-
-        int work_to_do = 0;
-        hts_tpool_process *first = p->q_head, *q = first;
-        do {
-            // Iterate over queues, finding one with jobs and also
-            // room to put the result.
-            //if (q && q->input_head && !hts_tpool_process_output_full(q)) {
-            if (q && q->input_head
-                && q->qsize - q->n_output > p->tsize - p->nwaiting
-                && !q->shutdown) {
-                work_to_do = 1;
-                break;
-            }
-
-            if (q) q = q->next;
-        } while (q && q != first);
-
-        if (!work_to_do) {
-            // We scanned all queues and cannot process any, so we wait.
-            p->nwaiting++;
-
-            // Push this thread to the top of the waiting stack
-            if (p->t_stack_top == -1 || p->t_stack_top > w->idx)
-                p->t_stack_top = w->idx;
-
-            p->t_stack[w->idx] = 1;
-//            printf("%2d: no work.  In=%d Proc=%d Out=%d  full=%d\n",
-//                   w->idx, p->q_head->n_input, p->q_head->n_processing, p->q_head->n_output,
-//                   hts_tpool_process_output_full(p->q_head));
-            pthread_cond_wait(&w->pending_c, &p->pool_m);
-            p->t_stack[w->idx] = 0;
-
-            /* Find new t_stack_top */
-            int i;
-            p->t_stack_top = -1;
-            for (i = 0; i < p->tsize; i++) {
-                if (p->t_stack[i]) {
-                    p->t_stack_top = i;
-                    break;
-                }
-            }
-
-            p->nwaiting--;
-            continue; // To outer loop.
-        }
-
-        // Otherwise work_to_do, so process as many items in this queue as
-        // possible before switching to another queue.  This means threads
-        // often end up being dedicated to one type of work.
-        q->ref_count++;
-        while (q->input_head && q->qsize - q->n_output > q->n_processing) {
-            if (p->shutdown)
-                goto shutdown;
-
-            if (q->shutdown)
-                // Queue shutdown, but there may be other queues
-                break;
-
-            j = q->input_head;
-            assert(j->p == p);
-
-            if (!(q->input_head = j->next))
-                q->input_tail = NULL;
-
-            // Transitioning from full queue to not-full means we can wake up
-            // any blocked dispatch threads.  We broadcast this as it's only
-            // happening once (on the transition) rather than every time we
-            // are below qsize.
-            // (I wish I could remember why io_lib rev 3660 changed this from
-            //  == to >=, but keeping it just in case!)
-            q->n_processing++;
-            if (q->n_input-- >= q->qsize)
-                pthread_cond_broadcast(&q->input_not_full_c);
-
-            if (q->n_input == 0)
-                pthread_cond_signal(&q->input_empty_c);
-
-            p->njobs--; // Total number of jobs; used to adjust to CPU scaling
-
-            pthread_mutex_unlock(&p->pool_m);
-
-            DBG_OUT(stderr, "%d: Processing queue %p, serial %"PRId64"\n",
-                    worker_id(j->p), q, j->serial);
-
-            if (hts_tpool_add_result(j, j->func(j->arg)) < 0)
-                goto err;
-            //memset(j, 0xbb, sizeof(*j));
-            free(j);
-
-            pthread_mutex_lock(&p->pool_m);
-        }
-        if (--q->ref_count == 0) { // we were the last user
-            hts_tpool_process_destroy(q);
-        } else {
-            // Out of jobs on this queue, so restart search from next one.
-            // This is equivalent to "work-stealing".
-            if (p->q_head)
-                p->q_head = p->q_head->next;
-        }
-    }
-
- shutdown:
-    pthread_mutex_unlock(&p->pool_m);
-#ifdef DEBUG
-    fprintf(stderr, "%d: Shutting down\n", worker_id(p));
-#endif
-    return NULL;
-
- err:
-#ifdef DEBUG
-    fprintf(stderr, "%d: Failed to add result\n", worker_id(p));
-#endif
-    // Hard failure, so shutdown all queues
-    pthread_mutex_lock(&p->pool_m);
-    hts_tpool_process *first = p->q_head, *q = first;
-    if (q) {
-        do {
-            hts_tpool_process_shutdown_locked(q);
-            q->shutdown = 2; // signify error.
-            q = q->next;
-        } while (q != first);
-    }
-    pthread_mutex_unlock(&p->pool_m);
-    return NULL;
-}
-
-static void wake_next_worker(hts_tpool_process *q, int locked) {
-    if (!q) return;
-    hts_tpool *p = q->p;
-    if (!locked)
-        pthread_mutex_lock(&p->pool_m);
-
-    // Update the q_head to be this queue so we'll start processing
-    // the queue we know to have results.
-    assert(q->prev && q->next); // attached
-    p->q_head = q;
-
-    // Wake up if we have more jobs waiting than CPUs. This partially combats
-    // CPU frequency scaling effects.  Starting too many threads and then
-    // running out of jobs can cause each thread to have lots of start/stop
-    // cycles, which then translates often to CPU frequency scaling
-    // adjustments.  Instead it is better to only start as many threads as we
-    // need to keep the throughput up, meaning some threads run flat out and
-    // others are idle.
-    //
-    // This isn't perfect as we need to know how many can actually start,
-    // rather than how many are waiting.  A limit on output queue size makes
-    // these two figures different.
-    assert(p->njobs >= q->n_input);
-
-    int running = p->tsize - p->nwaiting;
-    int sig = p->t_stack_top >= 0 && p->njobs > p->tsize - p->nwaiting
-        && (q->n_processing < q->qsize - q->n_output);
-
-//#define AVG_USAGE
-#ifdef AVG_USAGE
-    // Track average number of running threads and try to keep close.
-    // We permit this to change, but slowly.  This avoids "boom and bust" cycles
-    // where we read a lot of data, start a lot of jobs, then become idle again.
-    // This way some threads run steadily and others dormant, which is better
-    // for throughput.
-    //
-    // It's 50:50 if this is a good thing.  It helps some tasks quite significantly
-    // while slightly hindering other (perhaps more usual) jobs.
-
-    if (++p->n_count == 256) {
-        p->n_count >>= 1;
-        p->n_running >>= 1;
-    }
-    p->n_running += running;
-    // Built in lag to avoid see-sawing.  Is this safe in all cases?
-    if (sig && p->n_count >= 128 && running*p->n_count > p->n_running+1) sig=0;
-#endif
-
-    if (0) {
-        printf("%d waiting, %d running, %d output, %d, arun %d => %d\t", p->njobs,
-               running, q->n_output, q->qsize - q->n_output,
-               p->n_running/p->n_count, sig);
-        int i;
-        for (i = 0; i < p->tsize; i++)
-            putchar("x "[p->t_stack[i]]);
-        putchar('\n');
-    }
-
-    if (sig)
-        pthread_cond_signal(&p->t[p->t_stack_top].pending_c);
-
-    if (!locked)
-        pthread_mutex_unlock(&p->pool_m);
-}
-
-/*
- * Creates a worker pool with n worker threads.
- *
- * Returns pool pointer on success;
- *         NULL on failure
- */
-hts_tpool *hts_tpool_init(int n) {
-    int t_idx = 0;
-    size_t stack_size = 0;
-    pthread_attr_t pattr;
-    int pattr_init_done = 0;
-    hts_tpool *p = malloc(sizeof(*p));
-    if (!p)
-        return NULL;
-    p->tsize = n;
-    p->njobs = 0;
-    p->nwaiting = 0;
-    p->shutdown = 0;
-    p->q_head = NULL;
-    p->t_stack = NULL;
-    p->n_count = 0;
-    p->n_running = 0;
-    p->t = malloc(n * sizeof(p->t[0]));
-    if (!p->t) {
-        free(p);
-        return NULL;
-    }
-    p->t_stack = malloc(n * sizeof(*p->t_stack));
-    if (!p->t_stack) {
-        free(p->t);
-        free(p);
-        return NULL;
-    }
-    p->t_stack_top = -1;
-
-    pthread_mutexattr_t attr;
-    pthread_mutexattr_init(&attr);
-    pthread_mutexattr_settype(&attr, PTHREAD_MUTEX_RECURSIVE);
-    pthread_mutex_init(&p->pool_m, &attr);
-    pthread_mutexattr_destroy(&attr);
-
-    pthread_mutex_lock(&p->pool_m);
-
-    // Ensure new threads have a reasonably large stack.  On some platforms,
-    // for example MacOS which defaults to 512Kb, this is not big enough
-    // for some of the rANS codecs.
-
-    if (pthread_attr_init(&pattr) < 0)
-        goto cleanup;
-    pattr_init_done = 1;
-    if (pthread_attr_getstacksize(&pattr, &stack_size) < 0)
-        goto cleanup;
-    if (stack_size < HTS_MIN_THREAD_STACK) {
-        if (pthread_attr_setstacksize(&pattr, HTS_MIN_THREAD_STACK) < 0)
-            goto cleanup;
-    }
-
-    for (t_idx = 0; t_idx < n; t_idx++) {
-        hts_tpool_worker *w = &p->t[t_idx];
-        p->t_stack[t_idx] = 0;
-        w->p = p;
-        w->idx = t_idx;
-        pthread_cond_init(&w->pending_c, NULL);
-        if (0 != pthread_create(&w->tid, &pattr, tpool_worker, w))
-            goto cleanup;
-    }
-
-    pthread_mutex_unlock(&p->pool_m);
-    pthread_attr_destroy(&pattr);
-
-    return p;
-
- cleanup: {
-        // Any threads started will be waiting for p->pool_m, so we can
-        // stop them cleanly by setting p->shutdown, releasing the mutex and
-        // waiting for them to finish.
-        int j;
-        int save_errno = errno;
-        hts_log_error("Couldn't start thread pool worker : %s",
-                      strerror(errno));
-        p->shutdown = 1;
-        pthread_mutex_unlock(&p->pool_m);
-        for (j = 0; j < t_idx; j++) {
-            pthread_join(p->t[j].tid, NULL);
-            pthread_cond_destroy(&p->t[j].pending_c);
-        }
-        pthread_mutex_destroy(&p->pool_m);
-        if (pattr_init_done)
-            pthread_attr_destroy(&pattr);
-        free(p->t_stack);
-        free(p->t);
-        free(p);
-        errno = save_errno;
-        return NULL;
-    }
-}
-
-/*
- * Returns the number of requested threads for a pool.
- */
-int hts_tpool_size(hts_tpool *p) {
-    return p->tsize;
-}
-
-/*
- * Adds an item to the work pool.
- *
- * Returns 0 on success
- *        -1 on failure
- */
-int hts_tpool_dispatch(hts_tpool *p, hts_tpool_process *q,
-                    void *(*func)(void *arg), void *arg) {
-    return hts_tpool_dispatch3(p, q, func, arg, NULL, NULL, 0);
-}
-
-/*
- * As above but optional non-block flag.
- *
- * nonblock  0 => block if input queue is full
- * nonblock +1 => don't block if input queue is full, but do not add task
- * nonblock -1 => add task regardless of whether queue is full (over-size)
- */
-int hts_tpool_dispatch2(hts_tpool *p, hts_tpool_process *q,
-                        void *(*func)(void *arg), void *arg, int nonblock) {
-    return hts_tpool_dispatch3(p, q, func, arg, NULL, NULL, nonblock);
-}
-
-int hts_tpool_dispatch3(hts_tpool *p, hts_tpool_process *q,
-                        void *(*exec_func)(void *arg), void *arg,
-                        void (*job_cleanup)(void *arg),
-                        void (*result_cleanup)(void *data),
-                        int nonblock) {
-    hts_tpool_job *j;
-
-    pthread_mutex_lock(&p->pool_m);
-
-    DBG_OUT(stderr, "Dispatching job for queue %p, serial %"PRId64"\n",
-            q, q->curr_serial);
-
-    if ((q->no_more_input || q->n_input >= q->qsize) && nonblock == 1) {
-        pthread_mutex_unlock(&p->pool_m);
-        errno = EAGAIN;
-        return -1;
-    }
-
-    if (!(j = malloc(sizeof(*j)))) {
-        pthread_mutex_unlock(&p->pool_m);
-        return -1;
-    }
-    j->func = exec_func;
-    j->arg = arg;
-    j->job_cleanup = job_cleanup;
-    j->result_cleanup = result_cleanup;
-    j->next = NULL;
-    j->p = p;
-    j->q = q;
-    j->serial = q->curr_serial++;
-
-    if (nonblock == 0) {
-        while ((q->no_more_input || q->n_input >= q->qsize) &&
-               !q->shutdown && !q->wake_dispatch) {
-            pthread_cond_wait(&q->input_not_full_c, &q->p->pool_m);
-        }
-        if (q->no_more_input || q->shutdown) {
-            free(j);
-            pthread_mutex_unlock(&p->pool_m);
-            return -1;
-        }
-        if (q->wake_dispatch) {
-            //fprintf(stderr, "Wake => non-block for this operation\n");
-            q->wake_dispatch = 0;
-        }
-    }
-
-    p->njobs++;    // total across all queues
-    q->n_input++;  // queue specific
-
-    if (q->input_tail) {
-        q->input_tail->next = j;
-        q->input_tail = j;
-    } else {
-        q->input_head = q->input_tail = j;
-    }
-
-    DBG_OUT(stderr, "Dispatched (serial %"PRId64")\n", j->serial);
-
-    // Let a worker know we have data.
-    // Keep incoming queue at 1 per running thread, so there is always
-    // something waiting when they end their current task.  If we go above
-    // this signal to start more threads (if available). This has the effect
-    // of concentrating jobs to fewer cores when we are I/O bound, which in
-    // turn benefits systems with auto CPU frequency scaling.
-    if (!q->shutdown)
-        wake_next_worker(q, 1);
-
-    pthread_mutex_unlock(&p->pool_m);
-
-    return 0;
-}
-
-/*
- * Wakes up a single thread stuck in dispatch and make it return with
- * errno EAGAIN.
- */
-void hts_tpool_wake_dispatch(hts_tpool_process *q) {
-    pthread_mutex_lock(&q->p->pool_m);
-    q->wake_dispatch = 1;
-    pthread_cond_signal(&q->input_not_full_c);
-    pthread_mutex_unlock(&q->p->pool_m);
-}
-
-/*
- * Flushes the process-queue, but doesn't exit. This simply drains the queue
- * and ensures all worker threads have finished their current tasks
- * associated with this process.
- *
- * NOT: This does not mean the worker threads are not executing jobs in
- * another process-queue.
- *
- * Returns 0 on success;
- *        -1 on failure
- */
-int hts_tpool_process_flush(hts_tpool_process *q) {
-    int i;
-    hts_tpool *p = q->p;
-
-    DBG_OUT(stderr, "Flushing pool %p\n", p);
-
-    // Drains the queue
-    pthread_mutex_lock(&p->pool_m);
-
-    // Wake up everything for the final sprint!
-    for (i = 0; i < p->tsize; i++)
-        if (p->t_stack[i])
-            pthread_cond_signal(&p->t[i].pending_c);
-
-    // Ensure there is room for the final sprint.
-    // Shouldn't be possible to get here, but just in case.
-    if (q->qsize < q->n_output + q->n_input + q->n_processing)
-        q->qsize = q->n_output + q->n_input + q->n_processing;
-
-    // When shutdown, we won't be launching more, but we can still
-    // wait for any processing jobs complete.
-    if (q->shutdown) {
-        while (q->n_processing)
-            pthread_cond_wait(&q->none_processing_c, &p->pool_m);
-    }
-
-    // Wait for n_input and n_processing to hit zero.
-    while (!q->shutdown && (q->n_input || q->n_processing)) {
-        struct timeval now;
-        struct timespec timeout;
-
-        while (q->n_input && !q->shutdown) {
-            gettimeofday(&now, NULL);
-            timeout.tv_sec = now.tv_sec + 1;
-            timeout.tv_nsec = now.tv_usec * 1000;
-            pthread_cond_timedwait(&q->input_empty_c, &p->pool_m, &timeout);
-        }
-
-        // Note: even if q->shutdown is set, we still have to wait until
-        // q->n_processing is zero as we cannot terminate while things are
-        // running otherwise we free up the data being worked on.
-        while (q->n_processing) {
-            gettimeofday(&now, NULL);
-            timeout.tv_sec = now.tv_sec + 1;
-            timeout.tv_nsec = now.tv_usec * 1000;
-            pthread_cond_timedwait(&q->none_processing_c, &p->pool_m,
-                                   &timeout);
-        }
-        if (q->shutdown) break;
-    }
-
-    pthread_mutex_unlock(&p->pool_m);
-
-    DBG_OUT(stderr, "Flushed complete for pool %p, queue %p\n", p, q);
-
-    return 0;
-}
-
-/*
- * Resets a process to the initial state.
- *
- * This removes any queued up input jobs, disables any notification of
- * new results/output, flushes what is left and then discards any
- * queued output.  Anything consumer stuck in a wait on results to
- * appear should stay stuck and will only wake up when new data is
- * pushed through the queue.
- *
- * Returns 0 on success;
- *        -1 on failure
- */
-int hts_tpool_process_reset(hts_tpool_process *q, int free_results) {
-    hts_tpool_job *j, *jn, *j_head;
-    hts_tpool_result *r, *rn, *r_head;
-
-    pthread_mutex_lock(&q->p->pool_m);
-    // prevent next_result from returning data during our flush
-    q->next_serial = INT_MAX;
-
-    // Remove any queued input not yet being acted upon
-    j_head = q->input_head;
-    q->input_head = q->input_tail = NULL;
-    q->n_input = 0;
-
-    // Remove any queued output, thus ensuring we have room to flush.
-    r_head = q->output_head;
-    q->output_head = q->output_tail = NULL;
-    q->n_output = 0;
-    pthread_mutex_unlock(&q->p->pool_m);
-
-    // Release memory.  This can be done unlocked now the lists have been
-    // removed from the queue
-    for (j = j_head; j; j = jn) {
-        jn = j->next;
-        if (j->job_cleanup) j->job_cleanup(j->arg);
-        free(j);
-    }
-
-    for (r = r_head; r; r = rn) {
-        rn = r->next;
-        if (r->result_cleanup) {
-            r->result_cleanup(r->data);
-            r->data = NULL;
-        }
-        hts_tpool_delete_result(r, free_results);
-    }
-
-    // Wait for any jobs being processed to complete.
-    // (TODO: consider how to cancel any currently processing jobs.
-    // Probably this is too hard.)
-    if (hts_tpool_process_flush(q) != 0)
-        return -1;
-
-    // Remove any new output.
-    pthread_mutex_lock(&q->p->pool_m);
-    r_head = q->output_head;
-    q->output_head = q->output_tail = NULL;
-    q->n_output = 0;
-
-    // Finally reset the serial back to the starting point.
-    q->next_serial = q->curr_serial = 0;
-    pthread_cond_signal(&q->input_not_full_c);
-    pthread_mutex_unlock(&q->p->pool_m);
-
-    // Discard unwanted output
-    for (r = r_head; r; r = rn) {
-        //fprintf(stderr, "Discard output %d\n", r->serial);
-        rn = r->next;
-        if (r->result_cleanup) {
-            r->result_cleanup(r->data);
-            r->data = NULL;
-        }
-        hts_tpool_delete_result(r, free_results);
-    }
-
-    return 0;
-}
-
-/* Returns the process queue size */
-int hts_tpool_process_qsize(hts_tpool_process *q) {
-    return q->qsize;
-}
-
-/*
- * Destroys a thread pool.  The threads are joined into the main
- * thread so they will finish their current work load.
- */
-void hts_tpool_destroy(hts_tpool *p) {
-    int i;
-
-    DBG_OUT(stderr, "Destroying pool %p\n", p);
-
-    /* Send shutdown message to worker threads */
-    pthread_mutex_lock(&p->pool_m);
-    p->shutdown = 1;
-
-    DBG_OUT(stderr, "Sending shutdown request\n");
-
-    for (i = 0; i < p->tsize; i++)
-        pthread_cond_signal(&p->t[i].pending_c);
-
-    pthread_mutex_unlock(&p->pool_m);
-
-    DBG_OUT(stderr, "Shutdown complete\n");
-
-    for (i = 0; i < p->tsize; i++)
-        pthread_join(p->t[i].tid, NULL);
-
-    pthread_mutex_destroy(&p->pool_m);
-    for (i = 0; i < p->tsize; i++)
-        pthread_cond_destroy(&p->t[i].pending_c);
-
-    if (p->t_stack)
-        free(p->t_stack);
-
-    free(p->t);
-    free(p);
-
-    DBG_OUT(stderr, "Destroyed pool %p\n", p);
-}
-
-
-/*
- * Destroys a thread pool without waiting on jobs to complete.
- * Use hts_tpool_kill(p) to quickly exit after a fatal error.
- */
-void hts_tpool_kill(hts_tpool *p) {
-    int i;
-
-    DBG_OUT(stderr, "Destroying pool %p, kill=%d\n", p, kill);
-
-    for (i = 0; i < p->tsize; i++)
-        pthread_kill(p->t[i].tid, SIGINT);
-
-    pthread_mutex_destroy(&p->pool_m);
-    for (i = 0; i < p->tsize; i++)
-        pthread_cond_destroy(&p->t[i].pending_c);
-
-    if (p->t_stack)
-        free(p->t_stack);
-
-    free(p->t);
-    free(p);
-
-    DBG_OUT(stderr, "Destroyed pool %p\n", p);
-}
-
-
-/*=============================================================================
- * Test app.
- *
- * This can be considered both as a basic test and as a worked example for
- * various usage patterns.
- *=============================================================================
- */
-
-#ifdef TEST_MAIN
-
-#include <stdio.h>
-
-#ifndef TASK_SIZE
-#define TASK_SIZE 1000
-#endif
-
-/*-----------------------------------------------------------------------------
- * Unordered x -> x*x test.
- * Results arrive in order of completion.
- */
-void *doit_square_u(void *arg) {
-    int job = *(int *)arg;
-
-    usleep(random() % 100000); // to coerce job completion out of order
-
-    printf("RESULT: %d\n", job*job);
-
-    free(arg);
-    return NULL;
-}
-
-int test_square_u(int n) {
-    hts_tpool *p = hts_tpool_init(n);
-    hts_tpool_process *q = hts_tpool_process_init(p, n*2, 1);
-    int i;
-
-    // Dispatch jobs
-    for (i = 0; i < TASK_SIZE; i++) {
-        int *ip = malloc(sizeof(*ip));
-        *ip = i;
-        hts_tpool_dispatch(p, q, doit_square_u, ip);
-    }
-
-    hts_tpool_process_flush(q);
-    hts_tpool_process_destroy(q);
-    hts_tpool_destroy(p);
-
-    return 0;
-}
-
-
-/*-----------------------------------------------------------------------------
- * Ordered x -> x*x test.
- * Results arrive in numerical order.
- *
- * This implementation uses a non-blocking dispatch to avoid dead-locks
- * where one job takes too long to complete.
- */
-void *doit_square(void *arg) {
-    int job = *(int *)arg;
-    int *res;
-
-    // One excessively slow, to stress test output queue filling and
-    // excessive out of order scenarios.
-    usleep(500000 * ((job&31)==31) + random() % 10000);
-
-    res = malloc(sizeof(*res));
-    *res = (job<0) ? -job*job : job*job;
-
-    free(arg);
-    return res;
-}
-
-int test_square(int n) {
-    hts_tpool *p = hts_tpool_init(n);
-    hts_tpool_process *q = hts_tpool_process_init(p, n*2, 0);
-    int i;
-    hts_tpool_result *r;
-
-    // Dispatch jobs
-    for (i = 0; i < TASK_SIZE; i++) {
-        int *ip = malloc(sizeof(*ip));
-        *ip = i;
-        int blk;
-
-        do {
-            // In the situation where some jobs take much longer than
-            // others, we could end up blocking here as we haven't got
-            // any room in the output queue to place it. (We don't launch a
-            // job if the output queue is full.)
-
-            // This happens when the next serial number to fetch is, eg, 50
-            // but jobs 51-100 have all executed really fast and appeared in
-            // the output queue before 50.  A dispatch & check-results
-            // alternating loop can fail to find job 50 many times over until
-            // eventually the dispatch blocks before it arrives.
-
-            // Our solution is to dispatch in non-blocking mode so we are
-            // always to either dispatch or consume a result.
-            blk = hts_tpool_dispatch2(p, q, doit_square, ip, 1);
-
-            // Check for results.
-            if ((r = hts_tpool_next_result(q))) {
-                printf("RESULT: %d\n", *(int *)hts_tpool_result_data(r));
-                hts_tpool_delete_result(r, 1);
-            }
-            if (blk == -1) {
-                // The alternative is a separate thread for dispatching and/or
-                // consumption of results. See test_squareB.
-                putchar('.'); fflush(stdout);
-                usleep(10000);
-            }
-        } while (blk == -1);
-    }
-
-    // Wait for any input-queued up jobs or in-progress jobs to complete.
-    hts_tpool_process_flush(q);
-
-    while ((r = hts_tpool_next_result(q))) {
-        printf("RESULT: %d\n", *(int *)hts_tpool_result_data(r));
-        hts_tpool_delete_result(r, 1);
-    }
-
-    hts_tpool_process_destroy(q);
-    hts_tpool_destroy(p);
-
-    return 0;
-}
-
-/*-----------------------------------------------------------------------------
- * Ordered x -> x*x test.
- * Results arrive in numerical order.
- *
- * This implementation uses separate dispatching threads and job consumption
- * threads (main thread).  This means it can use a blocking calls for
- * simplicity elsewhere.
- */
-struct squareB_opt {
-    hts_tpool *p;
-    hts_tpool_process *q;
-    int n;
-};
-static void *test_squareB_dispatcher(void *arg) {
-    struct squareB_opt *o = (struct squareB_opt *)arg;
-    int i, *ip;
-
-    for (i = 0; i < o->n; i++) {
-        ip = malloc(sizeof(*ip));
-        *ip = i;
-
-        hts_tpool_dispatch(o->p, o->q, doit_square, ip);
-    }
-
-    // Dispatch an sentinel job to mark the end
-    *(ip = malloc(sizeof(*ip))) = -1;
-    hts_tpool_dispatch(o->p, o->q, doit_square, ip);
-    pthread_exit(NULL);
-}
-
-int test_squareB(int n) {
-    hts_tpool *p = hts_tpool_init(n);
-    hts_tpool_process *q = hts_tpool_process_init(p, n*2, 0);
-    struct squareB_opt o = {p, q, TASK_SIZE};
-    pthread_t tid;
-
-    // Launch our job creation thread.
-    pthread_create(&tid, NULL, test_squareB_dispatcher, &o);
-
-    // Consume all results until we find the end-of-job marker.
-    for(;;) {
-        hts_tpool_result *r = hts_tpool_next_result_wait(q);
-        int x = *(int *)hts_tpool_result_data(r);
-        hts_tpool_delete_result(r, 1);
-        if (x == -1)
-            break;
-        printf("RESULT: %d\n", x);
-    }
-
-    // Wait for any input-queued up jobs or in-progress jobs to complete.
-    // This should do nothing as we've been executing until the termination
-    // marker of -1.
-    hts_tpool_process_flush(q);
-    assert(hts_tpool_next_result(q) == NULL);
-
-    hts_tpool_process_destroy(q);
-    hts_tpool_destroy(p);
-    pthread_join(tid, NULL);
-
-    return 0;
-}
-
-
-/*-----------------------------------------------------------------------------
- * A simple pipeline test.
- * We use a dedicated input thread that does the initial generation of job
- * and dispatch, several execution steps running in a shared pool, and a
- * dedicated output thread that prints up the final result.  It's key that our
- * pipeline execution stages can run independently and don't themselves have
- * any waits.  To achieve this we therefore also use some dedicated threads
- * that take the output from one queue and resubmits the job as the input to
- * the next queue.
- *
- * More generally this could perhaps be a single pipeline thread that
- * marshalls multiple queues and their interactions, but this is simply a
- * demonstration of a single pipeline.
- *
- * Our process fills out the bottom byte of a 32-bit int and then shifts it
- * left one byte at a time.  Only the final stage needs to be ordered.  Each
- * stage uses its own queue.
- *
- * Possible improvement: we only need the last stage to be ordered.  By
- * allocating our own serial numbers for the first job and manually setting
- * these serials in the last job, perhaps we can permit out of order execution
- * of all the in-between stages.  (I doubt it'll affect speed much though.)
- */
-
-static void *pipe_input_thread(void *arg);
-static void *pipe_stage1(void *arg);
-static void *pipe_stage2(void *arg);
-static void *pipe_stage3(void *arg);
-static void *pipe_output_thread(void *arg);
-
-typedef struct {
-    hts_tpool *p;
-    hts_tpool_process *q1;
-    hts_tpool_process *q2;
-    hts_tpool_process *q3;
-    int n;
-} pipe_opt;
-
-typedef struct {
-    pipe_opt *o;
-    unsigned int x;
-    int eof; // set with last job.
-} pipe_job;
-
-static void *pipe_input_thread(void *arg) {
-    pipe_opt *o = (pipe_opt *)arg;
-
-    int i;
-    for (i = 1; i <= o->n; i++) {
-        pipe_job *j = malloc(sizeof(*j));
-        j->o = o;
-        j->x = i;
-        j->eof = (i == o->n);
-
-        printf("I  %08x\n", j->x);
-
-        if (hts_tpool_dispatch(o->p, o->q1, pipe_stage1, j) != 0) {
-            free(j);
-            pthread_exit((void *)1);
-        }
-    }
-
-    pthread_exit(NULL);
-}
-
-static void *pipe_stage1(void *arg) {
-    pipe_job *j = (pipe_job *)arg;
-
-    j->x <<= 8;
-    usleep(random() % 10000); // fast job
-    printf("1  %08x\n", j->x);
-
-    return j;
-}
-
-static void *pipe_stage1to2(void *arg) {
-    pipe_opt *o = (pipe_opt *)arg;
-    hts_tpool_result *r;
-
-    while ((r = hts_tpool_next_result_wait(o->q1))) {
-        pipe_job *j = (pipe_job *)hts_tpool_result_data(r);
-        hts_tpool_delete_result(r, 0);
-        if (hts_tpool_dispatch(j->o->p, j->o->q2, pipe_stage2, j) != 0)
-            pthread_exit((void *)1);
-        if (j->eof)
-            break;
-    }
-
-    pthread_exit(NULL);
-}
-
-static void *pipe_stage2(void *arg) {
-    pipe_job *j = (pipe_job *)arg;
-
-    j->x <<= 8;
-    usleep(random() % 100000); // slow job
-    printf("2  %08x\n", j->x);
-
-    return j;
-}
-
-static void *pipe_stage2to3(void *arg) {
-    pipe_opt *o = (pipe_opt *)arg;
-    hts_tpool_result *r;
-
-    while ((r = hts_tpool_next_result_wait(o->q2))) {
-        pipe_job *j = (pipe_job *)hts_tpool_result_data(r);
-        hts_tpool_delete_result(r, 0);
-        if (hts_tpool_dispatch(j->o->p, j->o->q3, pipe_stage3, j) != 0)
-            pthread_exit((void *)1);
-        if (j->eof)
-            break;
-    }
-
-    pthread_exit(NULL);
-}
-
-static void *pipe_stage3(void *arg) {
-    pipe_job *j = (pipe_job *)arg;
-
-    usleep(random() % 10000); // fast job
-    j->x <<= 8;
-    return j;
-}
-
-static void *pipe_output_thread(void *arg) {
-    pipe_opt *o = (pipe_opt *)arg;
-    hts_tpool_result *r;
-
-    while ((r = hts_tpool_next_result_wait(o->q3))) {
-        pipe_job *j = (pipe_job *)hts_tpool_result_data(r);
-        int eof = j->eof;
-        printf("O  %08x\n", j->x);
-        hts_tpool_delete_result(r, 1);
-        if (eof)
-            break;
-    }
-
-    pthread_exit(NULL);
-}
-
-int test_pipe(int n) {
-    hts_tpool *p = hts_tpool_init(n);
-    hts_tpool_process *q1 = hts_tpool_process_init(p, n*2, 0);
-    hts_tpool_process *q2 = hts_tpool_process_init(p, n*2, 0);
-    hts_tpool_process *q3 = hts_tpool_process_init(p, n*2, 0);
-    pipe_opt o = {p, q1, q2, q3, TASK_SIZE};
-    pthread_t tidIto1, tid1to2, tid2to3, tid3toO;
-    void *retv;
-    int ret;
-
-    // Launch our data source and sink threads.
-    pthread_create(&tidIto1, NULL, pipe_input_thread,  &o);
-    pthread_create(&tid1to2, NULL, pipe_stage1to2,     &o);
-    pthread_create(&tid2to3, NULL, pipe_stage2to3,     &o);
-    pthread_create(&tid3toO, NULL, pipe_output_thread, &o);
-
-    // Wait for tasks to finish.
-    ret = 0;
-    pthread_join(tidIto1, &retv); ret |= (retv != NULL);
-    pthread_join(tid1to2, &retv); ret |= (retv != NULL);
-    pthread_join(tid2to3, &retv); ret |= (retv != NULL);
-    pthread_join(tid3toO, &retv); ret |= (retv != NULL);
-    printf("Return value %d\n", ret);
-
-    hts_tpool_process_destroy(q1);
-    hts_tpool_process_destroy(q2);
-    hts_tpool_process_destroy(q3);
-    hts_tpool_destroy(p);
-
-    return 0;
-}
-
-/*-----------------------------------------------------------------------------*/
-int main(int argc, char **argv) {
-    int n;
-    srandom(0);
-
-    if (argc < 3) {
-        fprintf(stderr, "Usage: %s command n_threads\n", argv[0]);
-        fprintf(stderr, "Where commands are:\n\n");
-        fprintf(stderr, "unordered       # Unordered output\n");
-        fprintf(stderr, "ordered1        # Main thread with non-block API\n");
-        fprintf(stderr, "ordered2        # Dispatch thread, blocking API\n");
-        fprintf(stderr, "pipe            # Multi-stage pipeline, several queues\n");
-        exit(1);
-    }
-
-    n = atoi(argv[2]);
-    if (strcmp(argv[1], "unordered") == 0) return test_square_u(n);
-    if (strcmp(argv[1], "ordered1") == 0)  return test_square(n);
-    if (strcmp(argv[1], "ordered2") == 0)  return test_squareB(n);
-    if (strcmp(argv[1], "pipe") == 0)      return test_pipe(n);
-
-    fprintf(stderr, "Unknown sub-command\n");
-    exit(1);
-}
-#endif
diff -ruN stringtie.orig/htslib/thread_pool_internal.h stringtie/htslib/thread_pool_internal.h
--- stringtie.orig/htslib/thread_pool_internal.h	2024-02-28 13:57:39.701246126 +0100
+++ stringtie/htslib/thread_pool_internal.h	1970-01-01 01:00:00.000000000 +0100
@@ -1,169 +0,0 @@
-/*  thread_pool_internal.h -- Internal API for the thread pool.
-
-    Copyright (c) 2013-2016 Genome Research Ltd.
-
-    Author: James Bonfield <jkb@sanger.ac.uk>
-
-Permission is hereby granted, free of charge, to any person obtaining a copy
-of this software and associated documentation files (the "Software"), to deal
-in the Software without restriction, including without limitation the rights
-to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
-copies of the Software, and to permit persons to whom the Software is
-furnished to do so, subject to the following conditions:
-
-The above copyright notice and this permission notice shall be included in
-all copies or substantial portions of the Software.
-
-THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
-IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
-FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
-THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
-LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
-FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
-DEALINGS IN THE SOFTWARE.  */
-
-/*
- * This file implements a thread pool for multi-threading applications.
- * It consists of two distinct interfaces: thread pools an thread job queues.
- *
- * The pool of threads is given a function pointer and void* data to pass in.
- * This means the pool can run jobs of multiple types, albeit first come
- * first served with no job scheduling except to pick tasks from
- * queues that have room to store the result.
- *
- * Upon completion, the return value from the function pointer is
- * added to back to the queue if the result is required.  We may have
- * multiple queues in use for the one pool.
- *
- * To see example usage, please look at the #ifdef TEST_MAIN code in
- * thread_pool.c.
- */
-
-#ifndef THREAD_POOL_INTERNAL_H
-#define THREAD_POOL_INTERNAL_H
-
-#include <pthread.h>
-#include <stdint.h>
-#include "htslib/thread_pool.h"
-
-#ifdef __cplusplus
-extern "C" {
-#endif
-
-/*
- * An input job, before execution.
- */
-typedef struct hts_tpool_job {
-    void *(*func)(void *arg);
-    void *arg;
-    void (*job_cleanup)(void *arg);
-    void (*result_cleanup)(void *data);
-    struct hts_tpool_job *next;
-
-    struct hts_tpool *p;
-    struct hts_tpool_process *q;
-    uint64_t serial;
-} hts_tpool_job;
-
-/*
- * An output, after job has executed.
- */
-struct hts_tpool_result {
-    struct hts_tpool_result *next;
-    void (*result_cleanup)(void *data);
-    uint64_t serial; // sequential number for ordering
-    void *data;      // result itself
-};
-
-/*
- * A per-thread worker struct.
- */
-typedef struct {
-    struct hts_tpool *p;
-    int idx;
-    pthread_t tid;
-    pthread_cond_t  pending_c; // when waiting for a job
-} hts_tpool_worker;
-
-/*
- * An IO queue consists of a queue of jobs to execute
- * (the "input" side) and a queue of job results post-
- * execution (the "output" side).
- *
- * We have size limits to prevent either queue from
- * growing too large and serial numbers to ensure
- * sequential consumption of the output.
- *
- * The thread pool may have many hetergeneous tasks, each
- * using its own io_queue mixed into the same thread pool.
- */
-struct hts_tpool_process {
-    struct hts_tpool *p;             // thread pool
-    hts_tpool_job    *input_head;    // input list
-    hts_tpool_job    *input_tail;
-    hts_tpool_result *output_head;   // output list
-    hts_tpool_result *output_tail;
-    int qsize;                       // max size of i/o queues
-    uint64_t next_serial;            // next serial for output
-    uint64_t curr_serial;            // current serial (next input)
-
-    int no_more_input;               // disable dispatching of more jobs
-    int n_input;                     // no. items in input queue; was njobs
-    int n_output;                    // no. items in output queue
-    int n_processing;                // no. items being processed (executing)
-
-    int shutdown;                    // true if pool is being destroyed
-    int in_only;                     // if true, don't queue result up.
-    int wake_dispatch;               // unblocks waiting dispatchers
-
-    int ref_count;                   // used to track safe destruction
-
-    pthread_cond_t output_avail_c;   // Signalled on each new output
-    pthread_cond_t input_not_full_c; // Input queue is no longer full
-    pthread_cond_t input_empty_c;    // Input queue has become empty
-    pthread_cond_t none_processing_c;// n_processing has hit zero
-
-    struct hts_tpool_process *next, *prev;// to form circular linked list.
-};
-
-/*
- * The single pool structure itself.
- *
- * This knows nothing about the nature of the jobs or where their
- * output is going, but it maintains a list of queues associated with
- * this pool from which the jobs are taken.
- */
-struct hts_tpool {
-    int nwaiting; // how many workers waiting for new jobs
-    int njobs;    // how many total jobs are waiting in all queues
-    int shutdown; // true if pool is being destroyed
-
-    // I/O queues to check for jobs in and to put results.
-    // Forms a circular linked list.  (q_head may be amended
-    // to point to the most recently updated.)
-    hts_tpool_process *q_head;
-
-    // threads
-    int tsize;    // maximum number of jobs
-    hts_tpool_worker *t;
-    // array of worker IDs free
-    int *t_stack, t_stack_top;
-
-    // A single mutex used when updating this and any associated structure.
-    pthread_mutex_t pool_m;
-
-    // Tracking of average number of running jobs.
-    // This can be used to dampen any hysteresis caused by bursty
-    // input availability.
-    int n_count, n_running;
-
-    // Debugging to check wait time.
-    // FIXME: should we just delete these and cull the associated code?
-    long long total_time, wait_time;
-};
-
-#ifdef __cplusplus
-}
-#endif
-
-#endif
diff -ruN stringtie.orig/htslib/vcf.c stringtie/htslib/vcf.c
--- stringtie.orig/htslib/vcf.c	2024-02-28 13:57:39.701246126 +0100
+++ stringtie/htslib/vcf.c	1970-01-01 01:00:00.000000000 +0100
@@ -1,4796 +0,0 @@
-/*  vcf.c -- VCF/BCF API functions.
-
-    Copyright (C) 2012, 2013 Broad Institute.
-    Copyright (C) 2012-2020 Genome Research Ltd.
-    Portions copyright (C) 2014 Intel Corporation.
-
-    Author: Heng Li <lh3@sanger.ac.uk>
-
-Permission is hereby granted, free of charge, to any person obtaining a copy
-of this software and associated documentation files (the "Software"), to deal
-in the Software without restriction, including without limitation the rights
-to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
-copies of the Software, and to permit persons to whom the Software is
-furnished to do so, subject to the following conditions:
-
-The above copyright notice and this permission notice shall be included in
-all copies or substantial portions of the Software.
-
-THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
-IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
-FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
-THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
-LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
-FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
-DEALINGS IN THE SOFTWARE.  */
-
-#define HTS_BUILDING_LIBRARY // Enables HTSLIB_EXPORT, see htslib/hts_defs.h
-#include <config.h>
-
-#include <stdio.h>
-#include <assert.h>
-#include <string.h>
-#include <strings.h>
-#include <stdlib.h>
-#include <limits.h>
-#include <stdint.h>
-#include <inttypes.h>
-#include <errno.h>
-
-#include "htslib/vcf.h"
-#include "htslib/bgzf.h"
-#include "htslib/tbx.h"
-#include "htslib/hfile.h"
-#include "hts_internal.h"
-#include "htslib/hts_endian.h"
-#include "htslib/khash_str2int.h"
-#include "htslib/kstring.h"
-#include "htslib/sam.h"
-
-#include "htslib/khash.h"
-KHASH_MAP_INIT_STR(vdict, bcf_idinfo_t)
-typedef khash_t(vdict) vdict_t;
-
-#include "htslib/kseq.h"
-HTSLIB_EXPORT
-uint32_t bcf_float_missing    = 0x7F800001;
-
-HTSLIB_EXPORT
-uint32_t bcf_float_vector_end = 0x7F800002;
-
-HTSLIB_EXPORT
-uint8_t bcf_type_shift[] = { 0, 0, 1, 2, 3, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 };
-
-static bcf_idinfo_t bcf_idinfo_def = { .info = { 15, 15, 15 }, .hrec = { NULL, NULL, NULL}, .id = -1 };
-
-/*
-    Partial support for 64-bit POS and Number=1 INFO tags.
-    Notes:
-     - the support for 64-bit values is motivated by POS and INFO/END for large genomes
-     - the use of 64-bit values does not conform to the specification
-     - cannot output 64-bit BCF and if it does, it is not compatible with anything
-     - experimental, use at your risk
-*/
-#ifdef VCF_ALLOW_INT64
-    #define BCF_MAX_BT_INT64 (0x7fffffffffffffff)       /* INT64_MAX, for internal use only */
-    #define BCF_MIN_BT_INT64 -9223372036854775800LL     /* INT64_MIN + 8, for internal use only */
-#endif
-
-#define BCF_IS_64BIT (1<<30)
-
-
-static char *find_chrom_header_line(char *s)
-{
-    char *nl;
-    if (strncmp(s, "#CHROM\t", 7) == 0) return s;
-    else if ((nl = strstr(s, "\n#CHROM\t")) != NULL) return nl+1;
-    else return NULL;
-}
-
-/*************************
- *** VCF header parser ***
- *************************/
-
-static int bcf_hdr_add_sample_len(bcf_hdr_t *h, const char *s, size_t len)
-{
-    if ( !s ) return 0;
-    if (len == 0) len = strlen(s);
-
-    const char *ss = s;
-    while ( *ss && isspace_c(*ss) && ss - s < len) ss++;
-    if ( !*ss || ss - s == len)
-    {
-        hts_log_error("Empty sample name: trailing spaces/tabs in the header line?");
-        return -1;
-    }
-
-    vdict_t *d = (vdict_t*)h->dict[BCF_DT_SAMPLE];
-    int ret;
-    char *sdup = malloc(len + 1);
-    if (!sdup) return -1;
-    memcpy(sdup, s, len);
-    sdup[len] = 0;
-
-    // Ensure space is available in h->samples
-    size_t n = kh_size(d);
-    char **new_samples = realloc(h->samples, sizeof(char*) * (n + 1));
-    if (!new_samples) {
-        free(sdup);
-        return -1;
-    }
-    h->samples = new_samples;
-
-    int k = kh_put(vdict, d, sdup, &ret);
-    if (ret < 0) {
-        free(sdup);
-        return -1;
-    }
-    if (ret) { // absent
-        kh_val(d, k) = bcf_idinfo_def;
-        kh_val(d, k).id = n;
-    } else {
-        hts_log_error("Duplicated sample name '%s'", s);
-        free(sdup);
-        return -1;
-    }
-    h->samples[n] = sdup;
-    h->dirty = 1;
-    return 0;
-}
-
-int bcf_hdr_add_sample(bcf_hdr_t *h, const char *s)
-{
-    return bcf_hdr_add_sample_len(h, s, 0);
-}
-
-int HTS_RESULT_USED bcf_hdr_parse_sample_line(bcf_hdr_t *h, const char *str)
-{
-    int ret = 0;
-    int i = 0;
-    const char *p, *q;
-    // add samples
-    for (p = q = str;; ++q) {
-        if ((unsigned char) *q > '\n') continue;
-        if (++i > 9) {
-            if ( bcf_hdr_add_sample_len(h, p, q - p) < 0 ) ret = -1;
-        }
-        if (*q == 0 || *q == '\n' || ret < 0) break;
-        p = q + 1;
-    }
-
-    return ret;
-}
-
-int bcf_hdr_sync(bcf_hdr_t *h)
-{
-    int i;
-    for (i = 0; i < 3; i++)
-    {
-        vdict_t *d = (vdict_t*)h->dict[i];
-        khint_t k;
-        if ( h->n[i] < kh_size(d) )
-        {
-            bcf_idpair_t *new_idpair;
-            // this should be true only for i=2, BCF_DT_SAMPLE
-            new_idpair = (bcf_idpair_t*) realloc(h->id[i], kh_size(d)*sizeof(bcf_idpair_t));
-            if (!new_idpair) return -1;
-            h->n[i] = kh_size(d);
-            h->id[i] = new_idpair;
-        }
-        for (k=kh_begin(d); k<kh_end(d); k++)
-        {
-            if (!kh_exist(d,k)) continue;
-            h->id[i][kh_val(d,k).id].key = kh_key(d,k);
-            h->id[i][kh_val(d,k).id].val = &kh_val(d,k);
-        }
-    }
-    h->dirty = 0;
-    return 0;
-}
-
-void bcf_hrec_destroy(bcf_hrec_t *hrec)
-{
-    if (!hrec) return;
-    free(hrec->key);
-    if ( hrec->value ) free(hrec->value);
-    int i;
-    for (i=0; i<hrec->nkeys; i++)
-    {
-        free(hrec->keys[i]);
-        free(hrec->vals[i]);
-    }
-    free(hrec->keys);
-    free(hrec->vals);
-    free(hrec);
-}
-
-// Copies all fields except IDX.
-bcf_hrec_t *bcf_hrec_dup(bcf_hrec_t *hrec)
-{
-    int save_errno;
-    bcf_hrec_t *out = (bcf_hrec_t*) calloc(1,sizeof(bcf_hrec_t));
-    if (!out) return NULL;
-
-    out->type = hrec->type;
-    if ( hrec->key ) {
-        out->key = strdup(hrec->key);
-        if (!out->key) goto fail;
-    }
-    if ( hrec->value ) {
-        out->value = strdup(hrec->value);
-        if (!out->value) goto fail;
-    }
-    out->nkeys = hrec->nkeys;
-    out->keys = (char**) malloc(sizeof(char*)*hrec->nkeys);
-    if (!out->keys) goto fail;
-    out->vals = (char**) malloc(sizeof(char*)*hrec->nkeys);
-    if (!out->vals) goto fail;
-    int i, j = 0;
-    for (i=0; i<hrec->nkeys; i++)
-    {
-        if ( hrec->keys[i] && !strcmp("IDX",hrec->keys[i]) ) continue;
-        if ( hrec->keys[i] ) {
-            out->keys[j] = strdup(hrec->keys[i]);
-            if (!out->keys[j]) goto fail;
-        }
-        if ( hrec->vals[i] ) {
-            out->vals[j] = strdup(hrec->vals[i]);
-            if (!out->vals[j]) goto fail;
-        }
-        j++;
-    }
-    if ( i!=j ) out->nkeys -= i-j;   // IDX was omitted
-    return out;
-
- fail:
-    save_errno = errno;
-    hts_log_error("%s", strerror(errno));
-    bcf_hrec_destroy(out);
-    errno = save_errno;
-    return NULL;
-}
-
-void bcf_hrec_debug(FILE *fp, bcf_hrec_t *hrec)
-{
-    fprintf(fp, "key=[%s] value=[%s]", hrec->key, hrec->value?hrec->value:"");
-    int i;
-    for (i=0; i<hrec->nkeys; i++)
-        fprintf(fp, "\t[%s]=[%s]", hrec->keys[i],hrec->vals[i]);
-    fprintf(fp, "\n");
-}
-
-void bcf_header_debug(bcf_hdr_t *hdr)
-{
-    int i, j;
-    for (i=0; i<hdr->nhrec; i++)
-    {
-        if ( !hdr->hrec[i]->value )
-        {
-            fprintf(stderr, "##%s=<", hdr->hrec[i]->key);
-            fprintf(stderr,"%s=%s", hdr->hrec[i]->keys[0], hdr->hrec[i]->vals[0]);
-            for (j=1; j<hdr->hrec[i]->nkeys; j++)
-                fprintf(stderr,",%s=%s", hdr->hrec[i]->keys[j], hdr->hrec[i]->vals[j]);
-            fprintf(stderr,">\n");
-        }
-        else
-            fprintf(stderr,"##%s=%s\n", hdr->hrec[i]->key,hdr->hrec[i]->value);
-    }
-}
-
-int bcf_hrec_add_key(bcf_hrec_t *hrec, const char *str, size_t len)
-{
-    char **tmp;
-    size_t n = hrec->nkeys + 1;
-    assert(len > 0 && len < SIZE_MAX);
-    tmp = realloc(hrec->keys, sizeof(char*)*n);
-    if (!tmp) return -1;
-    hrec->keys = tmp;
-    tmp = realloc(hrec->vals, sizeof(char*)*n);
-    if (!tmp) return -1;
-    hrec->vals = tmp;
-
-    hrec->keys[hrec->nkeys] = (char*) malloc((len+1)*sizeof(char));
-    if (!hrec->keys[hrec->nkeys]) return -1;
-    memcpy(hrec->keys[hrec->nkeys],str,len);
-    hrec->keys[hrec->nkeys][len] = 0;
-    hrec->vals[hrec->nkeys] = NULL;
-    hrec->nkeys = n;
-    return 0;
-}
-
-int bcf_hrec_set_val(bcf_hrec_t *hrec, int i, const char *str, size_t len, int is_quoted)
-{
-    if ( hrec->vals[i] ) {
-        free(hrec->vals[i]);
-        hrec->vals[i] = NULL;
-    }
-    if ( !str ) return 0;
-    if ( is_quoted )
-    {
-        if (len >= SIZE_MAX - 3) {
-            errno = ENOMEM;
-            return -1;
-        }
-        hrec->vals[i] = (char*) malloc((len+3)*sizeof(char));
-        if (!hrec->vals[i]) return -1;
-        hrec->vals[i][0] = '"';
-        memcpy(&hrec->vals[i][1],str,len);
-        hrec->vals[i][len+1] = '"';
-        hrec->vals[i][len+2] = 0;
-    }
-    else
-    {
-        if (len == SIZE_MAX) {
-            errno = ENOMEM;
-            return -1;
-        }
-        hrec->vals[i] = (char*) malloc((len+1)*sizeof(char));
-        if (!hrec->vals[i]) return -1;
-        memcpy(hrec->vals[i],str,len);
-        hrec->vals[i][len] = 0;
-    }
-    return 0;
-}
-
-int hrec_add_idx(bcf_hrec_t *hrec, int idx)
-{
-    int n = hrec->nkeys + 1;
-    char **tmp = (char**) realloc(hrec->keys, sizeof(char*)*n);
-    if (!tmp) return -1;
-    hrec->keys = tmp;
-
-    tmp = (char**) realloc(hrec->vals, sizeof(char*)*n);
-    if (!tmp) return -1;
-    hrec->vals = tmp;
-
-    hrec->keys[hrec->nkeys] = strdup("IDX");
-    if (!hrec->keys[hrec->nkeys]) return -1;
-
-    kstring_t str = {0,0,0};
-    if (kputw(idx, &str) < 0) {
-        free(hrec->keys[hrec->nkeys]);
-        return -1;
-    }
-    hrec->vals[hrec->nkeys] = str.s;
-    hrec->nkeys = n;
-    return 0;
-}
-
-int bcf_hrec_find_key(bcf_hrec_t *hrec, const char *key)
-{
-    int i;
-    for (i=0; i<hrec->nkeys; i++)
-        if ( !strcasecmp(key,hrec->keys[i]) ) return i;
-    return -1;
-}
-
-static inline int is_escaped(const char *min, const char *str)
-{
-    int n = 0;
-    while ( --str>=min && *str=='\\' ) n++;
-    return n%2;
-}
-
-bcf_hrec_t *bcf_hdr_parse_line(const bcf_hdr_t *h, const char *line, int *len)
-{
-    bcf_hrec_t *hrec = NULL;
-    const char *p = line;
-    if (p[0] != '#' || p[1] != '#') { *len = 0; return NULL; }
-    p += 2;
-
-    const char *q = p;
-    while ( *q && *q!='=' && *q != '\n' ) q++;
-    ptrdiff_t n = q-p;
-    if ( *q!='=' || !n ) // wrong format
-        goto malformed_line;
-
-    hrec = (bcf_hrec_t*) calloc(1,sizeof(bcf_hrec_t));
-    if (!hrec) { *len = -1; return NULL; }
-    hrec->key = (char*) malloc(sizeof(char)*(n+1));
-    if (!hrec->key) goto fail;
-    memcpy(hrec->key,p,n);
-    hrec->key[n] = 0;
-
-    p = ++q;
-    if ( *p!='<' ) // generic field, e.g. ##samtoolsVersion=0.1.18-r579
-    {
-        while ( *q && *q!='\n' ) q++;
-        hrec->value = (char*) malloc((q-p+1)*sizeof(char));
-        if (!hrec->value) goto fail;
-        memcpy(hrec->value, p, q-p);
-        hrec->value[q-p] = 0;
-        *len = q - line + (*q ? 1 : 0); // Skip \n but not \0
-        return hrec;
-    }
-
-    // structured line, e.g.
-    // ##INFO=<ID=PV1,Number=1,Type=Float,Description="P-value for baseQ bias">
-    // ##PEDIGREE=<Name_0=G0-ID,Name_1=G1-ID,Name_3=GN-ID>
-    int nopen = 1;
-    while ( *q && *q!='\n' && nopen>0 )
-    {
-        p = ++q;
-        while ( *q && *q==' ' ) { p++; q++; }
-        // ^[A-Za-z_][0-9A-Za-z_.]*$
-        if (p==q && *q && (isalpha_c(*q) || *q=='_'))
-        {
-            q++;
-            while ( *q && (isalnum_c(*q) || *q=='_' || *q=='.') ) q++;
-        }
-        n = q-p;
-        int m = 0;
-        while ( *q && *q==' ' ) { q++; m++; }
-        if ( *q!='=' || !n )
-            goto malformed_line;
-
-        if (bcf_hrec_add_key(hrec, p, q-p-m) < 0) goto fail;
-        p = ++q;
-        while ( *q && *q==' ' ) { p++; q++; }
-        int quoted = *p=='"' ? 1 : 0;
-        if ( quoted ) p++, q++;
-        while ( *q && *q != '\n' )
-        {
-            if ( quoted ) { if ( *q=='"' && !is_escaped(p,q) ) break; }
-            else
-            {
-                if ( *q=='<' ) nopen++;
-                if ( *q=='>' ) nopen--;
-                if ( !nopen ) break;
-                if ( *q==',' && nopen==1 ) break;
-            }
-            q++;
-        }
-        const char *r = q;
-        while ( r > p && r[-1] == ' ' ) r--;
-        if (bcf_hrec_set_val(hrec, hrec->nkeys-1, p, r-p, quoted) < 0)
-            goto fail;
-        if ( quoted && *q=='"' ) q++;
-        if ( *q=='>' ) { nopen--; q++; }
-    }
-
-    // Skip to end of line
-    int nonspace = 0;
-    p = q;
-    while ( *q && *q!='\n' ) { nonspace |= !isspace_c(*q); q++; }
-    if (nonspace) {
-        char buffer[320];
-        hts_log_warning("Dropped trailing junk from header line '%s'",
-                        hts_strprint(buffer, sizeof(buffer),
-                                     '"', line, q - line));
-    }
-
-    *len = q - line + (*q ? 1 : 0);
-    return hrec;
-
- fail:
-    *len = -1;
-    bcf_hrec_destroy(hrec);
-    return NULL;
-
- malformed_line:
-    {
-        char buffer[320];
-        while ( *q && *q!='\n' ) q++;  // Ensure *len includes full line
-        hts_log_error("Could not parse the header line: %s",
-                      hts_strprint(buffer, sizeof(buffer),
-                                   '"', line, q - line));
-        *len = q - line + (*q ? 1 : 0);
-        bcf_hrec_destroy(hrec);
-        return NULL;
-    }
-}
-
-static int bcf_hdr_set_idx(bcf_hdr_t *hdr, int dict_type, const char *tag, bcf_idinfo_t *idinfo)
-{
-    size_t new_n;
-
-    // If available, preserve existing IDX
-    if ( idinfo->id==-1 )
-        idinfo->id = hdr->n[dict_type];
-    else if ( idinfo->id < hdr->n[dict_type] && hdr->id[dict_type][idinfo->id].key )
-    {
-        hts_log_error("Conflicting IDX=%d lines in the header dictionary, the new tag is %s",
-            idinfo->id, tag);
-        errno = EINVAL;
-        return -1;
-    }
-
-    new_n = idinfo->id >= hdr->n[dict_type] ? idinfo->id+1 : hdr->n[dict_type];
-    if (hts_resize(bcf_idpair_t, new_n, &hdr->m[dict_type],
-                   &hdr->id[dict_type], HTS_RESIZE_CLEAR)) {
-        return -1;
-    }
-    hdr->n[dict_type] = new_n;
-
-    // NB: the next kh_put call can invalidate the idinfo pointer, therefore
-    // we leave it unassigned here. It must be set explicitly in bcf_hdr_sync.
-    hdr->id[dict_type][idinfo->id].key = tag;
-
-    return 0;
-}
-
-// returns: 1 when hdr needs to be synced, -1 on error, 0 otherwise
-static int bcf_hdr_register_hrec(bcf_hdr_t *hdr, bcf_hrec_t *hrec)
-{
-    // contig
-    int i, ret, replacing = 0;
-    khint_t k;
-    char *str = NULL;
-
-    if ( !strcmp(hrec->key, "contig") )
-    {
-        hts_pos_t len = 0;
-        hrec->type = BCF_HL_CTG;
-
-        // Get the contig ID ($str) and length ($j)
-        i = bcf_hrec_find_key(hrec,"length");
-        if ( i<0 ) len = 0;
-        else {
-            char *end = hrec->vals[i];
-            len = strtoll(hrec->vals[i], &end, 10);
-            if (end == hrec->vals[i] || len < 0) return 0;
-        }
-
-        i = bcf_hrec_find_key(hrec,"ID");
-        if ( i<0 ) return 0;
-        str = strdup(hrec->vals[i]);
-        if (!str) return -1;
-
-        // Register in the dictionary
-        vdict_t *d = (vdict_t*)hdr->dict[BCF_DT_CTG];
-        khint_t k = kh_get(vdict, d, str);
-        if ( k != kh_end(d) ) { // already present
-            free(str); str=NULL;
-            if (kh_val(d, k).hrec[0] != NULL) // and not removed
-                return 0;
-            replacing = 1;
-        } else {
-            k = kh_put(vdict, d, str, &ret);
-            if (ret < 0) { free(str); return -1; }
-        }
-
-        int idx = bcf_hrec_find_key(hrec,"IDX");
-        if ( idx!=-1 )
-        {
-            char *tmp = hrec->vals[idx];
-            idx = strtol(hrec->vals[idx], &tmp, 10);
-            if ( *tmp || idx < 0 || idx >= INT_MAX - 1)
-            {
-                if (!replacing) {
-                    kh_del(vdict, d, k);
-                    free(str);
-                }
-                hts_log_warning("Error parsing the IDX tag, skipping");
-                return 0;
-            }
-        }
-
-        kh_val(d, k) = bcf_idinfo_def;
-        kh_val(d, k).id = idx;
-        kh_val(d, k).info[0] = len;
-        kh_val(d, k).hrec[0] = hrec;
-        if (bcf_hdr_set_idx(hdr, BCF_DT_CTG, kh_key(d,k), &kh_val(d,k)) < 0) {
-            if (!replacing) {
-                kh_del(vdict, d, k);
-                free(str);
-            }
-            return -1;
-        }
-        if ( idx==-1 ) {
-            if (hrec_add_idx(hrec, kh_val(d,k).id) < 0) {
-               return -1;
-            }
-        }
-
-        return 1;
-    }
-
-    if ( !strcmp(hrec->key, "INFO") ) hrec->type = BCF_HL_INFO;
-    else if ( !strcmp(hrec->key, "FILTER") ) hrec->type = BCF_HL_FLT;
-    else if ( !strcmp(hrec->key, "FORMAT") ) hrec->type = BCF_HL_FMT;
-    else if ( hrec->nkeys>0 ) { hrec->type = BCF_HL_STR; return 1; }
-    else return 0;
-
-    // INFO/FILTER/FORMAT
-    char *id = NULL;
-    uint32_t type = UINT32_MAX, var = UINT32_MAX;
-    int num = -1, idx = -1;
-    for (i=0; i<hrec->nkeys; i++)
-    {
-        if ( !strcmp(hrec->keys[i], "ID") ) id = hrec->vals[i];
-        else if ( !strcmp(hrec->keys[i], "IDX") )
-        {
-            char *tmp = hrec->vals[i];
-            idx = strtol(hrec->vals[i], &tmp, 10);
-            if ( *tmp || idx < 0 || idx >= INT_MAX - 1)
-            {
-                hts_log_warning("Error parsing the IDX tag, skipping");
-                return 0;
-            }
-        }
-        else if ( !strcmp(hrec->keys[i], "Type") )
-        {
-            if ( !strcmp(hrec->vals[i], "Integer") ) type = BCF_HT_INT;
-            else if ( !strcmp(hrec->vals[i], "Float") ) type = BCF_HT_REAL;
-            else if ( !strcmp(hrec->vals[i], "String") ) type = BCF_HT_STR;
-            else if ( !strcmp(hrec->vals[i], "Character") ) type = BCF_HT_STR;
-            else if ( !strcmp(hrec->vals[i], "Flag") ) type = BCF_HT_FLAG;
-            else
-            {
-                hts_log_warning("The type \"%s\" is not supported, assuming \"String\"", hrec->vals[i]);
-                type = BCF_HT_STR;
-            }
-        }
-        else if ( !strcmp(hrec->keys[i], "Number") )
-        {
-            if ( !strcmp(hrec->vals[i],"A") ) var = BCF_VL_A;
-            else if ( !strcmp(hrec->vals[i],"R") ) var = BCF_VL_R;
-            else if ( !strcmp(hrec->vals[i],"G") ) var = BCF_VL_G;
-            else if ( !strcmp(hrec->vals[i],".") ) var = BCF_VL_VAR;
-            else
-            {
-                sscanf(hrec->vals[i],"%d",&num);
-                var = BCF_VL_FIXED;
-            }
-            if (var != BCF_VL_FIXED) num = 0xfffff;
-        }
-    }
-    if (hrec->type == BCF_HL_INFO || hrec->type == BCF_HL_FMT) {
-        if (type == -1) {
-            hts_log_warning("%s %s field has no Type defined. Assuming String",
-                *hrec->key == 'I' ? "An" : "A", hrec->key);
-            type = BCF_HT_STR;
-        }
-        if (var == -1) {
-            hts_log_warning("%s %s field has no Number defined. Assuming '.'",
-                *hrec->key == 'I' ? "An" : "A", hrec->key);
-            var = BCF_VL_VAR;
-        }
-    }
-    uint32_t info = ((((uint32_t)num) & 0xfffff)<<12 |
-                     (var & 0xf) << 8 |
-                     (type & 0xf) << 4 |
-                     (((uint32_t) hrec->type) & 0xf));
-
-    if ( !id ) return 0;
-    str = strdup(id);
-    if (!str) return -1;
-
-    vdict_t *d = (vdict_t*)hdr->dict[BCF_DT_ID];
-    k = kh_get(vdict, d, str);
-    if ( k != kh_end(d) )
-    {
-        // already present
-        free(str);
-        if ( kh_val(d, k).hrec[info&0xf] ) return 0;
-        kh_val(d, k).info[info&0xf] = info;
-        kh_val(d, k).hrec[info&0xf] = hrec;
-        if ( idx==-1 ) {
-            if (hrec_add_idx(hrec, kh_val(d, k).id) < 0) {
-                return -1;
-            }
-        }
-        return 1;
-    }
-    k = kh_put(vdict, d, str, &ret);
-    if (ret < 0) {
-        free(str);
-        return -1;
-    }
-    kh_val(d, k) = bcf_idinfo_def;
-    kh_val(d, k).info[info&0xf] = info;
-    kh_val(d, k).hrec[info&0xf] = hrec;
-    kh_val(d, k).id = idx;
-    if (bcf_hdr_set_idx(hdr, BCF_DT_ID, kh_key(d,k), &kh_val(d,k)) < 0) {
-        kh_del(vdict, d, k);
-        free(str);
-        return -1;
-    }
-    if ( idx==-1 ) {
-        if (hrec_add_idx(hrec, kh_val(d,k).id) < 0) {
-            return -1;
-        }
-    }
-
-    return 1;
-}
-
-int bcf_hdr_add_hrec(bcf_hdr_t *hdr, bcf_hrec_t *hrec)
-{
-    int res;
-    if ( !hrec ) return 0;
-
-    hrec->type = BCF_HL_GEN;
-    res = bcf_hdr_register_hrec(hdr,hrec);
-    if (res < 0) return -1;
-    if ( !res )
-    {
-        // If one of the hashed field, then it is already present
-        if ( hrec->type != BCF_HL_GEN )
-        {
-            bcf_hrec_destroy(hrec);
-            return 0;
-        }
-
-        // Is one of the generic fields and already present?
-        int i;
-        for (i=0; i<hdr->nhrec; i++)
-        {
-            if ( hdr->hrec[i]->type!=BCF_HL_GEN ) continue;
-            if ( !strcmp(hdr->hrec[i]->key,hrec->key) && !strcmp(hrec->key,"fileformat") ) break;
-            if ( !strcmp(hdr->hrec[i]->key,hrec->key) && !strcmp(hdr->hrec[i]->value,hrec->value) ) break;
-        }
-        if ( i<hdr->nhrec )
-        {
-            bcf_hrec_destroy(hrec);
-            return 0;
-        }
-    }
-
-    // New record, needs to be added
-    int n = hdr->nhrec + 1;
-    bcf_hrec_t **new_hrec = realloc(hdr->hrec, n*sizeof(bcf_hrec_t*));
-    if (!new_hrec) return -1;
-    hdr->hrec = new_hrec;
-    hdr->hrec[hdr->nhrec] = hrec;
-    hdr->dirty = 1;
-    hdr->nhrec = n;
-
-    return hrec->type==BCF_HL_GEN ? 0 : 1;
-}
-
-/*
- *  Note that while querying of FLT,INFO,FMT,CTG lines is fast (the keys are hashed),
- *  the STR,GEN lines are searched for linearly in a linked list of all header lines.
- *  This may become a problem for VCFs with huge headers, we might need to build a
- *  dictionary for these lines as well.
- */
-bcf_hrec_t *bcf_hdr_get_hrec(const bcf_hdr_t *hdr, int type, const char *key, const char *value, const char *str_class)
-{
-    int i;
-    if ( type==BCF_HL_GEN )
-    {
-        for (i=0; i<hdr->nhrec; i++)
-        {
-            if ( hdr->hrec[i]->type!=type ) continue;
-            if ( strcmp(hdr->hrec[i]->key,key) ) continue;
-            if ( !value || !strcmp(hdr->hrec[i]->value,value) ) return hdr->hrec[i];
-        }
-        return NULL;
-    }
-    else if ( type==BCF_HL_STR )
-    {
-        for (i=0; i<hdr->nhrec; i++)
-        {
-            if ( hdr->hrec[i]->type!=type ) continue;
-            if ( strcmp(hdr->hrec[i]->key,str_class) ) continue;
-            int j = bcf_hrec_find_key(hdr->hrec[i],key);
-            if ( j>=0 && !strcmp(hdr->hrec[i]->vals[j],value) ) return hdr->hrec[i];
-        }
-        return NULL;
-    }
-    vdict_t *d = type==BCF_HL_CTG ? (vdict_t*)hdr->dict[BCF_DT_CTG] : (vdict_t*)hdr->dict[BCF_DT_ID];
-    khint_t k = kh_get(vdict, d, value);
-    if ( k == kh_end(d) ) return NULL;
-    return kh_val(d, k).hrec[type==BCF_HL_CTG?0:type];
-}
-
-void bcf_hdr_check_sanity(bcf_hdr_t *hdr)
-{
-    static int PL_warned = 0, GL_warned = 0;
-
-    if ( !PL_warned )
-    {
-        int id = bcf_hdr_id2int(hdr, BCF_DT_ID, "PL");
-        if ( bcf_hdr_idinfo_exists(hdr,BCF_HL_FMT,id) && bcf_hdr_id2length(hdr,BCF_HL_FMT,id)!=BCF_VL_G )
-        {
-            hts_log_warning("PL should be declared as Number=G");
-            PL_warned = 1;
-        }
-    }
-    if ( !GL_warned )
-    {
-        int id = bcf_hdr_id2int(hdr, BCF_DT_ID, "GL");
-        if ( bcf_hdr_idinfo_exists(hdr,BCF_HL_FMT,id) && bcf_hdr_id2length(hdr,BCF_HL_FMT,id)!=BCF_VL_G )
-        {
-            hts_log_warning("GL should be declared as Number=G");
-            GL_warned = 1;
-        }
-    }
-}
-
-int bcf_hdr_parse(bcf_hdr_t *hdr, char *htxt)
-{
-    int len, done = 0;
-    char *p = htxt;
-
-    // Check sanity: "fileformat" string must come as first
-    bcf_hrec_t *hrec = bcf_hdr_parse_line(hdr,p,&len);
-    if ( !hrec || !hrec->key || strcasecmp(hrec->key,"fileformat") )
-        hts_log_warning("The first line should be ##fileformat; is the VCF/BCF header broken?");
-    if (bcf_hdr_add_hrec(hdr, hrec) < 0) {
-        bcf_hrec_destroy(hrec);
-        return -1;
-    }
-
-    // The filter PASS must appear first in the dictionary
-    hrec = bcf_hdr_parse_line(hdr,"##FILTER=<ID=PASS,Description=\"All filters passed\">",&len);
-    if (!hrec || bcf_hdr_add_hrec(hdr, hrec) < 0) {
-        bcf_hrec_destroy(hrec);
-        return -1;
-    }
-
-    // Parse the whole header
-    do {
-        while (NULL != (hrec = bcf_hdr_parse_line(hdr, p, &len))) {
-            if (bcf_hdr_add_hrec(hdr, hrec) < 0) {
-                bcf_hrec_destroy(hrec);
-                return -1;
-            }
-            p += len;
-        }
-        assert(hrec == NULL);
-        if (len < 0) {
-            // len < 0 indicates out-of-memory, or similar error
-            hts_log_error("Could not parse header line: %s", strerror(errno));
-            return -1;
-        } else if (len > 0) {
-            // Bad header line.  bcf_hdr_parse_line() will have logged it.
-            // Skip and try again on the next line (p + len will be the start
-            // of the next one).
-            p += len;
-            continue;
-        }
-
-        // Next should be the sample line.  If not, it was a malformed
-        // header, in which case print a warning and skip (many VCF
-        // operations do not really care about a few malformed lines).
-        // In the future we may want to add a strict mode that errors in
-        // this case.
-        if ( strncmp("#CHROM\tPOS",p,10) != 0 ) {
-            char *eol = strchr(p, '\n');
-            if (*p != '\0') {
-                char buffer[320];
-                hts_log_warning("Could not parse header line: %s",
-                                hts_strprint(buffer, sizeof(buffer),
-                                               '"', p,
-                                               eol ? (eol - p) : SIZE_MAX));
-            }
-            if (eol) {
-                p = eol + 1; // Try from the next line.
-            } else {
-                done = -1; // No more lines left, give up.
-            }
-        } else {
-            done = 1; // Sample line found
-        }
-    } while (!done);
-
-    if (done < 0) {
-        // No sample line is fatal.
-        hts_log_error("Could not parse the header, sample line not found");
-        return -1;
-    }
-
-    if (bcf_hdr_parse_sample_line(hdr,p) < 0)
-        return -1;
-    if (bcf_hdr_sync(hdr) < 0)
-        return -1;
-    bcf_hdr_check_sanity(hdr);
-    return 0;
-}
-
-int bcf_hdr_append(bcf_hdr_t *hdr, const char *line)
-{
-    int len;
-    bcf_hrec_t *hrec = bcf_hdr_parse_line(hdr, (char*) line, &len);
-    if ( !hrec ) return -1;
-    if (bcf_hdr_add_hrec(hdr, hrec) < 0)
-        return -1;
-    return 0;
-}
-
-void bcf_hdr_remove(bcf_hdr_t *hdr, int type, const char *key)
-{
-    int i = 0;
-    bcf_hrec_t *hrec;
-    if ( !key )
-    {
-        while ( i<hdr->nhrec )
-        {
-            if ( hdr->hrec[i]->type!=type ) { i++; continue; }
-            hrec = hdr->hrec[i];
-
-            if ( type==BCF_HL_FLT || type==BCF_HL_INFO || type==BCF_HL_FMT || type== BCF_HL_CTG )
-            {
-                int j = bcf_hrec_find_key(hdr->hrec[i], "ID");
-                if ( j>=0 )
-                {
-                    vdict_t *d = type==BCF_HL_CTG ? (vdict_t*)hdr->dict[BCF_DT_CTG] : (vdict_t*)hdr->dict[BCF_DT_ID];
-                    khint_t k = kh_get(vdict, d, hdr->hrec[i]->vals[j]);
-                    kh_val(d, k).hrec[type==BCF_HL_CTG?0:type] = NULL;
-                }
-            }
-
-            hdr->dirty = 1;
-            hdr->nhrec--;
-            if ( i < hdr->nhrec )
-                memmove(&hdr->hrec[i],&hdr->hrec[i+1],(hdr->nhrec-i)*sizeof(bcf_hrec_t*));
-            bcf_hrec_destroy(hrec);
-        }
-        return;
-    }
-    while (1)
-    {
-        if ( type==BCF_HL_FLT || type==BCF_HL_INFO || type==BCF_HL_FMT || type== BCF_HL_CTG )
-        {
-            hrec = bcf_hdr_get_hrec(hdr, type, "ID", key, NULL);
-            if ( !hrec ) return;
-
-            for (i=0; i<hdr->nhrec; i++)
-                if ( hdr->hrec[i]==hrec ) break;
-            assert( i<hdr->nhrec );
-
-            vdict_t *d = type==BCF_HL_CTG ? (vdict_t*)hdr->dict[BCF_DT_CTG] : (vdict_t*)hdr->dict[BCF_DT_ID];
-            khint_t k = kh_get(vdict, d, key);
-            kh_val(d, k).hrec[type==BCF_HL_CTG?0:type] = NULL;
-        }
-        else
-        {
-            for (i=0; i<hdr->nhrec; i++)
-            {
-                if ( hdr->hrec[i]->type!=type ) continue;
-                if ( type==BCF_HL_GEN )
-                {
-                    if ( !strcmp(hdr->hrec[i]->key,key) ) break;
-                }
-                else
-                {
-                    // not all structured lines have ID, we could be more sophisticated as in bcf_hdr_get_hrec()
-                    int j = bcf_hrec_find_key(hdr->hrec[i], "ID");
-                    if ( j>=0 && !strcmp(hdr->hrec[i]->vals[j],key) ) break;
-                }
-            }
-            if ( i==hdr->nhrec ) return;
-            hrec = hdr->hrec[i];
-        }
-
-        hdr->nhrec--;
-        if ( i < hdr->nhrec )
-            memmove(&hdr->hrec[i],&hdr->hrec[i+1],(hdr->nhrec-i)*sizeof(bcf_hrec_t*));
-        bcf_hrec_destroy(hrec);
-        hdr->dirty = 1;
-    }
-}
-
-int bcf_hdr_printf(bcf_hdr_t *hdr, const char *fmt, ...)
-{
-    char tmp[256], *line = tmp;
-    va_list ap;
-    va_start(ap, fmt);
-    int n = vsnprintf(line, sizeof(tmp), fmt, ap);
-    va_end(ap);
-
-    if (n >= sizeof(tmp)) {
-        n++; // For trailing NUL
-        line = (char*)malloc(n);
-        if (!line)
-            return -1;
-
-        va_start(ap, fmt);
-        vsnprintf(line, n, fmt, ap);
-        va_end(ap);
-    }
-
-    int ret = bcf_hdr_append(hdr, line);
-
-    if (line != tmp) free(line);
-    return ret;
-}
-
-
-/**********************
- *** BCF header I/O ***
- **********************/
-
-const char *bcf_hdr_get_version(const bcf_hdr_t *hdr)
-{
-    bcf_hrec_t *hrec = bcf_hdr_get_hrec(hdr, BCF_HL_GEN, "fileformat", NULL, NULL);
-    if ( !hrec )
-    {
-        hts_log_warning("No version string found, assuming VCFv4.2");
-        return "VCFv4.2";
-    }
-    return hrec->value;
-}
-
-int bcf_hdr_set_version(bcf_hdr_t *hdr, const char *version)
-{
-    bcf_hrec_t *hrec = bcf_hdr_get_hrec(hdr, BCF_HL_GEN, "fileformat", NULL, NULL);
-    if ( !hrec )
-    {
-        int len;
-        kstring_t str = {0,0,0};
-        ksprintf(&str,"##fileformat=%s", version);
-        hrec = bcf_hdr_parse_line(hdr, str.s, &len);
-        free(str.s);
-    }
-    else
-    {
-        free(hrec->value);
-        hrec->value = strdup(version);
-    }
-    hdr->dirty = 1;
-    return 0; // FIXME: check for errs in this function (return < 0 if so)
-}
-
-bcf_hdr_t *bcf_hdr_init(const char *mode)
-{
-    int i;
-    bcf_hdr_t *h;
-    h = (bcf_hdr_t*)calloc(1, sizeof(bcf_hdr_t));
-    if (!h) return NULL;
-    for (i = 0; i < 3; ++i)
-        if ((h->dict[i] = kh_init(vdict)) == NULL) goto fail;
-    if ( strchr(mode,'w') )
-    {
-        bcf_hdr_append(h, "##fileformat=VCFv4.2");
-        // The filter PASS must appear first in the dictionary
-        bcf_hdr_append(h, "##FILTER=<ID=PASS,Description=\"All filters passed\">");
-    }
-    return h;
-
- fail:
-    for (i = 0; i < 3; ++i)
-        kh_destroy(vdict, h->dict[i]);
-    free(h);
-    return NULL;
-}
-
-void bcf_hdr_destroy(bcf_hdr_t *h)
-{
-    int i;
-    khint_t k;
-    if (!h) return;
-    for (i = 0; i < 3; ++i) {
-        vdict_t *d = (vdict_t*)h->dict[i];
-        if (d == 0) continue;
-        for (k = kh_begin(d); k != kh_end(d); ++k)
-            if (kh_exist(d, k)) free((char*)kh_key(d, k));
-        kh_destroy(vdict, d);
-        free(h->id[i]);
-    }
-    for (i=0; i<h->nhrec; i++)
-        bcf_hrec_destroy(h->hrec[i]);
-    if (h->nhrec) free(h->hrec);
-    if (h->samples) free(h->samples);
-    free(h->keep_samples);
-    free(h->transl[0]); free(h->transl[1]);
-    free(h->mem.s);
-    free(h);
-}
-
-bcf_hdr_t *bcf_hdr_read(htsFile *hfp)
-{
-    if (hfp->format.format == vcf)
-        return vcf_hdr_read(hfp);
-    if (hfp->format.format != bcf) {
-        hts_log_error("Input is not detected as bcf or vcf format");
-        return NULL;
-    }
-
-    assert(hfp->is_bgzf);
-
-    BGZF *fp = hfp->fp.bgzf;
-    uint8_t magic[5];
-    bcf_hdr_t *h;
-    h = bcf_hdr_init("r");
-    if (!h) {
-        hts_log_error("Failed to allocate bcf header");
-        return NULL;
-    }
-    if (bgzf_read(fp, magic, 5) != 5)
-    {
-        hts_log_error("Failed to read the header (reading BCF in text mode?)");
-        bcf_hdr_destroy(h);
-        return NULL;
-    }
-    if (strncmp((char*)magic, "BCF\2\2", 5) != 0)
-    {
-        if (!strncmp((char*)magic, "BCF", 3))
-            hts_log_error("Invalid BCF2 magic string: only BCFv2.2 is supported");
-        else
-            hts_log_error("Invalid BCF2 magic string");
-        bcf_hdr_destroy(h);
-        return NULL;
-    }
-    uint8_t buf[4];
-    size_t hlen;
-    char *htxt = NULL;
-    if (bgzf_read(fp, buf, 4) != 4) goto fail;
-    hlen = buf[0] | (buf[1] << 8) | (buf[2] << 16) | ((size_t) buf[3] << 24);
-    if (hlen >= SIZE_MAX) { errno = ENOMEM; goto fail; }
-    htxt = (char*)malloc(hlen + 1);
-    if (!htxt) goto fail;
-    if (bgzf_read(fp, htxt, hlen) != hlen) goto fail;
-    htxt[hlen] = '\0'; // Ensure htxt is terminated
-    if ( bcf_hdr_parse(h, htxt) < 0 ) goto fail;
-    free(htxt);
-    return h;
- fail:
-    hts_log_error("Failed to read BCF header");
-    free(htxt);
-    bcf_hdr_destroy(h);
-    return NULL;
-}
-
-int bcf_hdr_write(htsFile *hfp, bcf_hdr_t *h)
-{
-    if (!h) {
-        errno = EINVAL;
-        return -1;
-    }
-    if ( h->dirty ) {
-        if (bcf_hdr_sync(h) < 0) return -1;
-    }
-    hfp->format.category = variant_data;
-    if (hfp->format.format == vcf || hfp->format.format == text_format) {
-        hfp->format.format = vcf;
-        return vcf_hdr_write(hfp, h);
-    }
-
-    if (hfp->format.format == binary_format)
-        hfp->format.format = bcf;
-
-    kstring_t htxt = {0,0,0};
-    if (bcf_hdr_format(h, 1, &htxt) < 0) {
-        free(htxt.s);
-        return -1;
-    }
-    kputc('\0', &htxt); // include the \0 byte
-
-    BGZF *fp = hfp->fp.bgzf;
-    if ( bgzf_write(fp, "BCF\2\2", 5) !=5 ) return -1;
-    uint8_t hlen[4];
-    u32_to_le(htxt.l, hlen);
-    if ( bgzf_write(fp, hlen, 4) !=4 ) return -1;
-    if ( bgzf_write(fp, htxt.s, htxt.l) != htxt.l ) return -1;
-
-    free(htxt.s);
-    return 0;
-}
-
-/********************
- *** BCF site I/O ***
- ********************/
-
-bcf1_t *bcf_init()
-{
-    bcf1_t *v;
-    v = (bcf1_t*)calloc(1, sizeof(bcf1_t));
-    return v;
-}
-
-void bcf_clear(bcf1_t *v)
-{
-    int i;
-    for (i=0; i<v->d.m_info; i++)
-    {
-        if ( v->d.info[i].vptr_free )
-        {
-            free(v->d.info[i].vptr - v->d.info[i].vptr_off);
-            v->d.info[i].vptr_free = 0;
-        }
-    }
-    for (i=0; i<v->d.m_fmt; i++)
-    {
-        if ( v->d.fmt[i].p_free )
-        {
-            free(v->d.fmt[i].p - v->d.fmt[i].p_off);
-            v->d.fmt[i].p_free = 0;
-        }
-    }
-    v->rid = v->pos = v->rlen = v->unpacked = 0;
-    bcf_float_set_missing(v->qual);
-    v->n_info = v->n_allele = v->n_fmt = v->n_sample = 0;
-    v->shared.l = v->indiv.l = 0;
-    v->d.var_type = -1;
-    v->d.shared_dirty = 0;
-    v->d.indiv_dirty  = 0;
-    v->d.n_flt = 0;
-    v->errcode = 0;
-    if (v->d.m_als) v->d.als[0] = 0;
-    if (v->d.m_id) v->d.id[0] = 0;
-}
-
-void bcf_empty(bcf1_t *v)
-{
-    bcf_clear1(v);
-    free(v->d.id);
-    free(v->d.als);
-    free(v->d.allele); free(v->d.flt); free(v->d.info); free(v->d.fmt);
-    if (v->d.var ) free(v->d.var);
-    free(v->shared.s); free(v->indiv.s);
-    memset(&v->d,0,sizeof(v->d));
-    memset(&v->shared,0,sizeof(v->shared));
-    memset(&v->indiv,0,sizeof(v->indiv));
-}
-
-void bcf_destroy(bcf1_t *v)
-{
-    if (!v) return;
-    bcf_empty1(v);
-    free(v);
-}
-
-static inline int bcf_read1_core(BGZF *fp, bcf1_t *v)
-{
-    uint8_t x[32];
-    ssize_t ret;
-    uint32_t shared_len, indiv_len;
-    if ((ret = bgzf_read(fp, x, 32)) != 32) {
-        if (ret == 0) return -1;
-        return -2;
-    }
-    bcf_clear1(v);
-    shared_len = le_to_u32(x);
-    if (shared_len < 24) return -2;
-    shared_len -= 24; // to exclude six 32-bit integers
-    if (ks_resize(&v->shared, shared_len ? shared_len : 1) != 0) return -2;
-    indiv_len = le_to_u32(x + 4);
-    if (ks_resize(&v->indiv, indiv_len ? indiv_len : 1) != 0) return -2;
-    v->rid  = le_to_i32(x + 8);
-    v->pos  = le_to_u32(x + 12);
-    v->rlen = le_to_i32(x + 16);
-    v->qual = le_to_float(x + 20);
-    v->n_info = le_to_u16(x + 24);
-    v->n_allele = le_to_u16(x + 26);
-    v->n_sample = le_to_u32(x + 28) & 0xffffff;
-    v->n_fmt = x[31];
-    v->shared.l = shared_len;
-    v->indiv.l = indiv_len;
-    // silent fix of broken BCFs produced by earlier versions of bcf_subset, prior to and including bd6ed8b4
-    if ( (!v->indiv.l || !v->n_sample) && v->n_fmt ) v->n_fmt = 0;
-
-    if (bgzf_read(fp, v->shared.s, v->shared.l) != v->shared.l) return -2;
-    if (bgzf_read(fp, v->indiv.s, v->indiv.l) != v->indiv.l) return -2;
-    return 0;
-}
-
-#define bit_array_size(n) ((n)/8+1)
-#define bit_array_set(a,i)   ((a)[(i)/8] |=   1 << ((i)%8))
-#define bit_array_clear(a,i) ((a)[(i)/8] &= ~(1 << ((i)%8)))
-#define bit_array_test(a,i)  ((a)[(i)/8] &   (1 << ((i)%8)))
-
-static int bcf_dec_typed_int1_safe(uint8_t *p, uint8_t *end, uint8_t **q,
-                                   int32_t *val) {
-    uint32_t t;
-    if (end - p < 2) return -1;
-    t = *p++ & 0xf;
-    /* Use if .. else if ... else instead of switch to force order.  Assumption
-       is that small integers are more frequent than big ones. */
-    if (t == BCF_BT_INT8) {
-        *val = *(int8_t *) p++;
-    } else {
-        if (end - p < (1<<bcf_type_shift[t])) return -1;
-        if (t == BCF_BT_INT16) {
-            *val = le_to_i16(p);
-            p += 2;
-        } else if (t == BCF_BT_INT32) {
-            *val = le_to_i32(p);
-            p += 4;
-#ifdef VCF_ALLOW_INT64
-        } else if (t == BCF_BT_INT64) {
-            // This case should never happen because there should be no
-            // 64-bit BCFs at all, definitely not coming from htslib
-            *val = le_to_i64(p);
-            p += 8;
-#endif
-        } else {
-            return -1;
-        }
-    }
-    *q = p;
-    return 0;
-}
-
-static int bcf_dec_size_safe(uint8_t *p, uint8_t *end, uint8_t **q,
-                             int *num, int *type) {
-    int r;
-    if (p >= end) return -1;
-    *type = *p & 0xf;
-    if (*p>>4 != 15) {
-        *q = p + 1;
-        *num = *p >> 4;
-        return 0;
-    }
-    r = bcf_dec_typed_int1_safe(p + 1, end, q, num);
-    if (r) return r;
-    return *num >= 0 ? 0 : -1;
-}
-
-static const char *get_type_name(int type) {
-    const char *types[9] = {
-        "null", "int (8-bit)", "int (16 bit)", "int (32 bit)",
-        "unknown", "float", "unknown", "char", "unknown"
-    };
-    int t = (type >= 0 && type < 8) ? type : 8;
-    return types[t];
-}
-
-static void bcf_record_check_err(const bcf_hdr_t *hdr, bcf1_t *rec,
-                                 char *type, uint32_t *reports, int i) {
-    if (*reports == 0 || hts_verbose >= HTS_LOG_DEBUG)
-        hts_log_warning("Bad BCF record at %s:%"PRIhts_pos
-                        ": Invalid FORMAT %s %d",
-                        bcf_seqname_safe(hdr,rec), rec->pos+1, type, i);
-    (*reports)++;
-}
-
-static int bcf_record_check(const bcf_hdr_t *hdr, bcf1_t *rec) {
-    uint8_t *ptr, *end;
-    size_t bytes;
-    uint32_t err = 0;
-    int type = 0;
-    int num  = 0;
-    int reflen = 0;
-    uint32_t i, reports;
-    const uint32_t is_integer = ((1 << BCF_BT_INT8)  |
-                                 (1 << BCF_BT_INT16) |
-#ifdef VCF_ALLOW_INT64
-                                 (1 << BCF_BT_INT64) |
-#endif
-                                 (1 << BCF_BT_INT32));
-    const uint32_t is_valid_type = (is_integer          |
-                                    (1 << BCF_BT_NULL)  |
-                                    (1 << BCF_BT_FLOAT) |
-                                    (1 << BCF_BT_CHAR));
-    int32_t max_id = hdr ? hdr->n[BCF_DT_ID] : 0;
-
-    // Check for valid contig ID
-    if (rec->rid < 0
-        || (hdr && (rec->rid >= hdr->n[BCF_DT_CTG]
-                    || hdr->id[BCF_DT_CTG][rec->rid].key == NULL))) {
-        hts_log_warning("Bad BCF record at %"PRIhts_pos": Invalid %s id %d", rec->pos+1, "CONTIG", rec->rid);
-        err |= BCF_ERR_CTG_INVALID;
-    }
-
-    // Check ID
-    ptr = (uint8_t *) rec->shared.s;
-    end = ptr + rec->shared.l;
-    if (bcf_dec_size_safe(ptr, end, &ptr, &num, &type) != 0) goto bad_shared;
-    if (type != BCF_BT_CHAR) {
-        hts_log_warning("Bad BCF record at %s:%"PRIhts_pos": Invalid %s type %d (%s)", bcf_seqname_safe(hdr,rec), rec->pos+1, "ID", type, get_type_name(type));
-        err |= BCF_ERR_TAG_INVALID;
-    }
-    bytes = (size_t) num << bcf_type_shift[type];
-    if (end - ptr < bytes) goto bad_shared;
-    ptr += bytes;
-
-    // Check REF and ALT
-    if (rec->n_allele < 1) {
-        hts_log_warning("Bad BCF record at %s:%"PRIhts_pos": No REF allele",
-                        bcf_seqname_safe(hdr,rec), rec->pos+1);
-        err |= BCF_ERR_TAG_UNDEF;
-    }
-
-    reports = 0;
-    for (i = 0; i < rec->n_allele; i++) {
-        if (bcf_dec_size_safe(ptr, end, &ptr, &num, &type) != 0) goto bad_shared;
-        if (type != BCF_BT_CHAR) {
-            if (!reports++ || hts_verbose >= HTS_LOG_DEBUG)
-                hts_log_warning("Bad BCF record at %s:%"PRIhts_pos": Invalid %s type %d (%s)", bcf_seqname_safe(hdr,rec), rec->pos+1, "REF/ALT", type, get_type_name(type));
-            err |= BCF_ERR_CHAR;
-        }
-        if (i == 0) reflen = num;
-        bytes = (size_t) num << bcf_type_shift[type];
-        if (end - ptr < bytes) goto bad_shared;
-        ptr += bytes;
-    }
-
-    // Check FILTER
-    reports = 0;
-    if (bcf_dec_size_safe(ptr, end, &ptr, &num, &type) != 0) goto bad_shared;
-    if (num > 0) {
-        bytes = (size_t) num << bcf_type_shift[type];
-        if (((1 << type) & is_integer) == 0) {
-            hts_log_warning("Bad BCF record at %s:%"PRIhts_pos": Invalid %s type %d (%s)", bcf_seqname_safe(hdr,rec), rec->pos+1, "FILTER", type, get_type_name(type));
-            err |= BCF_ERR_TAG_INVALID;
-            if (end - ptr < bytes) goto bad_shared;
-            ptr += bytes;
-        } else {
-            if (end - ptr < bytes) goto bad_shared;
-            for (i = 0; i < num; i++) {
-                int32_t key = bcf_dec_int1(ptr, type, &ptr);
-                if (key < 0
-                    || (hdr && (key >= max_id
-                                || hdr->id[BCF_DT_ID][key].key == NULL))) {
-                    if (!reports++ || hts_verbose >= HTS_LOG_DEBUG)
-                        hts_log_warning("Bad BCF record at %s:%"PRIhts_pos": Invalid %s id %d", bcf_seqname_safe(hdr,rec), rec->pos+1, "FILTER", key);
-                    err |= BCF_ERR_TAG_UNDEF;
-                }
-            }
-        }
-    }
-
-    // Check INFO
-    reports = 0;
-    bcf_idpair_t *id_tmp = hdr ? hdr->id[BCF_DT_ID] : NULL;
-    for (i = 0; i < rec->n_info; i++) {
-        int32_t key = -1;
-        if (bcf_dec_typed_int1_safe(ptr, end, &ptr, &key) != 0) goto bad_shared;
-        if (key < 0 || (hdr && (key >= max_id
-                                || id_tmp[key].key == NULL))) {
-            if (!reports++ || hts_verbose >= HTS_LOG_DEBUG)
-                hts_log_warning("Bad BCF record at %s:%"PRIhts_pos": Invalid %s id %d", bcf_seqname_safe(hdr,rec), rec->pos+1, "INFO", key);
-            err |= BCF_ERR_TAG_UNDEF;
-        }
-        if (bcf_dec_size_safe(ptr, end, &ptr, &num, &type) != 0) goto bad_shared;
-        if (((1 << type) & is_valid_type) == 0) {
-            if (!reports++ || hts_verbose >= HTS_LOG_DEBUG)
-                hts_log_warning("Bad BCF record at %s:%"PRIhts_pos": Invalid %s type %d (%s)", bcf_seqname_safe(hdr,rec), rec->pos+1, "INFO", type, get_type_name(type));
-            err |= BCF_ERR_TAG_INVALID;
-        }
-        bytes = (size_t) num << bcf_type_shift[type];
-        if (end - ptr < bytes) goto bad_shared;
-        ptr += bytes;
-    }
-
-    // Check FORMAT and individual information
-    ptr = (uint8_t *) rec->indiv.s;
-    end = ptr + rec->indiv.l;
-    reports = 0;
-    for (i = 0; i < rec->n_fmt; i++) {
-        int32_t key = -1;
-        if (bcf_dec_typed_int1_safe(ptr, end, &ptr, &key) != 0) goto bad_indiv;
-        if (key < 0
-            || (hdr && (key >= max_id
-                        || id_tmp[key].key == NULL))) {
-            bcf_record_check_err(hdr, rec, "id", &reports, key);
-            err |= BCF_ERR_TAG_UNDEF;
-        }
-        if (bcf_dec_size_safe(ptr, end, &ptr, &num, &type) != 0) goto bad_indiv;
-        if (((1 << type) & is_valid_type) == 0) {
-            bcf_record_check_err(hdr, rec, "type", &reports, type);
-            err |= BCF_ERR_TAG_INVALID;
-        }
-        bytes = ((size_t) num << bcf_type_shift[type]) * rec->n_sample;
-        if (end - ptr < bytes) goto bad_indiv;
-        ptr += bytes;
-    }
-
-    if (!err && rec->rlen < 0) {
-        // Treat bad rlen as a warning instead of an error, and try to
-        // fix up by using the length of the stored REF allele.
-        static int warned = 0;
-        if (!warned) {
-            hts_log_warning("BCF record at %s:%"PRIhts_pos" has invalid RLEN (%"PRIhts_pos"). "
-                            "Only one invalid RLEN will be reported.",
-                            bcf_seqname_safe(hdr,rec), rec->pos+1, rec->rlen);
-            warned = 1;
-        }
-        rec->rlen = reflen >= 0 ? reflen : 0;
-    }
-
-    rec->errcode |= err;
-
-    return err ? -2 : 0; // Return -2 so bcf_read() reports an error
-
- bad_shared:
-    hts_log_error("Bad BCF record at %s:%"PRIhts_pos" - shared section malformed or too short", bcf_seqname_safe(hdr,rec), rec->pos+1);
-    return -2;
-
- bad_indiv:
-    hts_log_error("Bad BCF record at %s:%"PRIhts_pos" - individuals section malformed or too short", bcf_seqname_safe(hdr,rec), rec->pos+1);
-    return -2;
-}
-
-static inline uint8_t *bcf_unpack_fmt_core1(uint8_t *ptr, int n_sample, bcf_fmt_t *fmt);
-int bcf_subset_format(const bcf_hdr_t *hdr, bcf1_t *rec)
-{
-    if ( !hdr->keep_samples ) return 0;
-    if ( !bcf_hdr_nsamples(hdr) )
-    {
-        rec->indiv.l = rec->n_sample = 0;
-        return 0;
-    }
-
-    int i, j;
-    uint8_t *ptr = (uint8_t*)rec->indiv.s, *dst = NULL, *src;
-    bcf_dec_t *dec = &rec->d;
-    hts_expand(bcf_fmt_t, rec->n_fmt, dec->m_fmt, dec->fmt);
-    for (i=0; i<dec->m_fmt; ++i) dec->fmt[i].p_free = 0;
-
-    for (i=0; i<rec->n_fmt; i++)
-    {
-        ptr = bcf_unpack_fmt_core1(ptr, rec->n_sample, &dec->fmt[i]);
-        src = dec->fmt[i].p - dec->fmt[i].size;
-        if ( dst )
-        {
-            memmove(dec->fmt[i-1].p + dec->fmt[i-1].p_len, dec->fmt[i].p - dec->fmt[i].p_off, dec->fmt[i].p_off);
-            dec->fmt[i].p = dec->fmt[i-1].p + dec->fmt[i-1].p_len + dec->fmt[i].p_off;
-        }
-        dst = dec->fmt[i].p;
-        for (j=0; j<hdr->nsamples_ori; j++)
-        {
-            src += dec->fmt[i].size;
-            if ( !bit_array_test(hdr->keep_samples,j) ) continue;
-            memmove(dst, src, dec->fmt[i].size);
-            dst += dec->fmt[i].size;
-        }
-        rec->indiv.l -= dec->fmt[i].p_len - (dst - dec->fmt[i].p);
-        dec->fmt[i].p_len = dst - dec->fmt[i].p;
-    }
-    rec->unpacked |= BCF_UN_FMT;
-
-    rec->n_sample = bcf_hdr_nsamples(hdr);
-    return 0;
-}
-
-int bcf_read(htsFile *fp, const bcf_hdr_t *h, bcf1_t *v)
-{
-    if (fp->format.format == vcf) return vcf_read(fp,h,v);
-    int ret = bcf_read1_core(fp->fp.bgzf, v);
-    if (ret == 0) ret = bcf_record_check(h, v);
-    if ( ret!=0 || !h->keep_samples ) return ret;
-    return bcf_subset_format(h,v);
-}
-
-int bcf_readrec(BGZF *fp, void *null, void *vv, int *tid, hts_pos_t *beg, hts_pos_t *end)
-{
-    bcf1_t *v = (bcf1_t *) vv;
-    int ret = bcf_read1_core(fp, v);
-    if (ret == 0) ret = bcf_record_check(NULL, v);
-    if (ret  >= 0)
-        *tid = v->rid, *beg = v->pos, *end = v->pos + v->rlen;
-    return ret;
-}
-
-static inline int bcf1_sync_id(bcf1_t *line, kstring_t *str)
-{
-    // single typed string
-    if ( line->d.id && strcmp(line->d.id, ".") ) {
-        return bcf_enc_vchar(str, strlen(line->d.id), line->d.id);
-    } else {
-        return bcf_enc_size(str, 0, BCF_BT_CHAR);
-    }
-}
-static inline int bcf1_sync_alleles(bcf1_t *line, kstring_t *str)
-{
-    // list of typed strings
-    int i;
-    for (i=0; i<line->n_allele; i++) {
-        if (bcf_enc_vchar(str, strlen(line->d.allele[i]), line->d.allele[i]) < 0)
-            return -1;
-    }
-    if ( !line->rlen && line->n_allele ) line->rlen = strlen(line->d.allele[0]);
-    return 0;
-}
-static inline int bcf1_sync_filter(bcf1_t *line, kstring_t *str)
-{
-    // typed vector of integers
-    if ( line->d.n_flt ) {
-        return bcf_enc_vint(str, line->d.n_flt, line->d.flt, -1);
-    } else {
-        return bcf_enc_vint(str, 0, 0, -1);
-    }
-}
-
-static inline int bcf1_sync_info(bcf1_t *line, kstring_t *str)
-{
-    // pairs of typed vectors
-    int i, irm = -1, e = 0;
-    for (i=0; i<line->n_info; i++)
-    {
-        bcf_info_t *info = &line->d.info[i];
-        if ( !info->vptr )
-        {
-            // marked for removal
-            if ( irm < 0 ) irm = i;
-            continue;
-        }
-        e |= kputsn_(info->vptr - info->vptr_off, info->vptr_len + info->vptr_off, str) < 0;
-        if ( irm >=0 )
-        {
-            bcf_info_t tmp = line->d.info[irm]; line->d.info[irm] = line->d.info[i]; line->d.info[i] = tmp;
-            while ( irm<=i && line->d.info[irm].vptr ) irm++;
-        }
-    }
-    if ( irm>=0 ) line->n_info = irm;
-    return e == 0 ? 0 : -1;
-}
-
-static int bcf1_sync(bcf1_t *line)
-{
-    char *shared_ori = line->shared.s;
-    size_t prev_len;
-
-    kstring_t tmp = {0,0,0};
-    if ( !line->shared.l )
-    {
-        // New line created via API, BCF data blocks do not exist. Get it ready for BCF output
-        tmp = line->shared;
-        bcf1_sync_id(line, &tmp);
-        line->unpack_size[0] = tmp.l; prev_len = tmp.l;
-
-        bcf1_sync_alleles(line, &tmp);
-        line->unpack_size[1] = tmp.l - prev_len; prev_len = tmp.l;
-
-        bcf1_sync_filter(line, &tmp);
-        line->unpack_size[2] = tmp.l - prev_len;
-
-        bcf1_sync_info(line, &tmp);
-        line->shared = tmp;
-    }
-    else if ( line->d.shared_dirty )
-    {
-        // The line was edited, update the BCF data block.
-
-        if ( !(line->unpacked & BCF_UN_STR) ) bcf_unpack(line,BCF_UN_STR);
-
-        // ptr_ori points to the original unchanged BCF data.
-        uint8_t *ptr_ori = (uint8_t *) line->shared.s;
-
-        // ID: single typed string
-        if ( line->d.shared_dirty & BCF1_DIRTY_ID )
-            bcf1_sync_id(line, &tmp);
-        else
-            kputsn_(ptr_ori, line->unpack_size[0], &tmp);
-        ptr_ori += line->unpack_size[0];
-        line->unpack_size[0] = tmp.l; prev_len = tmp.l;
-
-        // REF+ALT: list of typed strings
-        if ( line->d.shared_dirty & BCF1_DIRTY_ALS )
-            bcf1_sync_alleles(line, &tmp);
-        else
-        {
-            kputsn_(ptr_ori, line->unpack_size[1], &tmp);
-            if ( !line->rlen && line->n_allele ) line->rlen = strlen(line->d.allele[0]);
-        }
-        ptr_ori += line->unpack_size[1];
-        line->unpack_size[1] = tmp.l - prev_len; prev_len = tmp.l;
-
-        if ( line->unpacked & BCF_UN_FLT )
-        {
-            // FILTER: typed vector of integers
-            if ( line->d.shared_dirty & BCF1_DIRTY_FLT )
-                bcf1_sync_filter(line, &tmp);
-            else if ( line->d.n_flt )
-                kputsn_(ptr_ori, line->unpack_size[2], &tmp);
-            else
-                bcf_enc_vint(&tmp, 0, 0, -1);
-            ptr_ori += line->unpack_size[2];
-            line->unpack_size[2] = tmp.l - prev_len;
-
-            if ( line->unpacked & BCF_UN_INFO )
-            {
-                // INFO: pairs of typed vectors
-                if ( line->d.shared_dirty & BCF1_DIRTY_INF )
-                {
-                    bcf1_sync_info(line, &tmp);
-                    ptr_ori = (uint8_t*)line->shared.s + line->shared.l;
-                }
-            }
-        }
-
-        int size = line->shared.l - (size_t)ptr_ori + (size_t)line->shared.s;
-        if ( size ) kputsn_(ptr_ori, size, &tmp);
-
-        free(line->shared.s);
-        line->shared = tmp;
-    }
-    if ( line->shared.s != shared_ori && line->unpacked & BCF_UN_INFO )
-    {
-        // Reallocated line->shared.s block invalidated line->d.info[].vptr pointers
-        size_t off_new = line->unpack_size[0] + line->unpack_size[1] + line->unpack_size[2];
-        int i;
-        for (i=0; i<line->n_info; i++)
-        {
-            uint8_t *vptr_free = line->d.info[i].vptr_free ? line->d.info[i].vptr - line->d.info[i].vptr_off : NULL;
-            line->d.info[i].vptr = (uint8_t*) line->shared.s + off_new + line->d.info[i].vptr_off;
-            off_new += line->d.info[i].vptr_len + line->d.info[i].vptr_off;
-            if ( vptr_free )
-            {
-                free(vptr_free);
-                line->d.info[i].vptr_free = 0;
-            }
-        }
-    }
-
-    if ( line->n_sample && line->n_fmt && (!line->indiv.l || line->d.indiv_dirty) )
-    {
-        // The genotype fields changed or are not present
-        tmp.l = tmp.m = 0; tmp.s = NULL;
-        int i, irm = -1;
-        for (i=0; i<line->n_fmt; i++)
-        {
-            bcf_fmt_t *fmt = &line->d.fmt[i];
-            if ( !fmt->p )
-            {
-                // marked for removal
-                if ( irm < 0 ) irm = i;
-                continue;
-            }
-            kputsn_(fmt->p - fmt->p_off, fmt->p_len + fmt->p_off, &tmp);
-            if ( irm >=0 )
-            {
-                bcf_fmt_t tfmt = line->d.fmt[irm]; line->d.fmt[irm] = line->d.fmt[i]; line->d.fmt[i] = tfmt;
-                while ( irm<=i && line->d.fmt[irm].p ) irm++;
-            }
-
-        }
-        if ( irm>=0 ) line->n_fmt = irm;
-        free(line->indiv.s);
-        line->indiv = tmp;
-
-        // Reallocated line->indiv.s block invalidated line->d.fmt[].p pointers
-        size_t off_new = 0;
-        for (i=0; i<line->n_fmt; i++)
-        {
-            uint8_t *p_free = line->d.fmt[i].p_free ? line->d.fmt[i].p - line->d.fmt[i].p_off : NULL;
-            line->d.fmt[i].p = (uint8_t*) line->indiv.s + off_new + line->d.fmt[i].p_off;
-            off_new += line->d.fmt[i].p_len + line->d.fmt[i].p_off;
-            if ( p_free )
-            {
-                free(p_free);
-                line->d.fmt[i].p_free = 0;
-            }
-        }
-    }
-    if ( !line->n_sample ) line->n_fmt = 0;
-    line->d.shared_dirty = line->d.indiv_dirty = 0;
-    return 0;
-}
-
-bcf1_t *bcf_copy(bcf1_t *dst, bcf1_t *src)
-{
-    bcf1_sync(src);
-
-    bcf_clear(dst);
-    dst->rid  = src->rid;
-    dst->pos  = src->pos;
-    dst->rlen = src->rlen;
-    dst->qual = src->qual;
-    dst->n_info = src->n_info; dst->n_allele = src->n_allele;
-    dst->n_fmt = src->n_fmt; dst->n_sample = src->n_sample;
-
-    if ( dst->shared.m < src->shared.l )
-    {
-        dst->shared.s = (char*) realloc(dst->shared.s, src->shared.l);
-        dst->shared.m = src->shared.l;
-    }
-    dst->shared.l = src->shared.l;
-    memcpy(dst->shared.s,src->shared.s,dst->shared.l);
-
-    if ( dst->indiv.m < src->indiv.l )
-    {
-        dst->indiv.s = (char*) realloc(dst->indiv.s, src->indiv.l);
-        dst->indiv.m = src->indiv.l;
-    }
-    dst->indiv.l = src->indiv.l;
-    memcpy(dst->indiv.s,src->indiv.s,dst->indiv.l);
-
-    return dst;
-}
-bcf1_t *bcf_dup(bcf1_t *src)
-{
-    bcf1_t *out = bcf_init1();
-    return bcf_copy(out, src);
-}
-
-int bcf_write(htsFile *hfp, bcf_hdr_t *h, bcf1_t *v)
-{
-    if ( h->dirty ) {
-        if (bcf_hdr_sync(h) < 0) return -1;
-    }
-    if ( bcf_hdr_nsamples(h)!=v->n_sample )
-    {
-        hts_log_error("Broken VCF record, the number of columns at %s:%"PRIhts_pos" does not match the number of samples (%d vs %d)",
-            bcf_seqname_safe(h,v), v->pos+1, v->n_sample, bcf_hdr_nsamples(h));
-        return -1;
-    }
-
-    if ( hfp->format.format == vcf || hfp->format.format == text_format )
-        return vcf_write(hfp,h,v);
-
-    if ( v->errcode )
-    {
-        // vcf_parse1() encountered a new contig or tag, undeclared in the
-        // header.  At this point, the header must have been printed,
-        // proceeding would lead to a broken BCF file. Errors must be checked
-        // and cleared by the caller before we can proceed.
-        hts_log_error("Unchecked error (%d) at %s:%"PRIhts_pos, v->errcode, bcf_seqname_safe(h,v), v->pos+1);
-        return -1;
-    }
-    bcf1_sync(v);   // check if the BCF record was modified
-
-    if ( v->unpacked & BCF_IS_64BIT )
-    {
-        hts_log_error("Data at %s:%"PRIhts_pos" contains 64-bit values not representable in BCF. Please use VCF instead", bcf_seqname_safe(h,v), v->pos+1);
-        return -1;
-    }
-
-    BGZF *fp = hfp->fp.bgzf;
-    uint8_t x[32];
-    u32_to_le(v->shared.l + 24, x); // to include six 32-bit integers
-    u32_to_le(v->indiv.l, x + 4);
-    i32_to_le(v->rid, x + 8);
-    u32_to_le(v->pos, x + 12);
-    u32_to_le(v->rlen, x + 16);
-    float_to_le(v->qual, x + 20);
-    u16_to_le(v->n_info, x + 24);
-    u16_to_le(v->n_allele, x + 26);
-    u32_to_le((uint32_t)v->n_fmt<<24 | (v->n_sample & 0xffffff), x + 28);
-    if ( bgzf_write(fp, x, 32) != 32 ) return -1;
-    if ( bgzf_write(fp, v->shared.s, v->shared.l) != v->shared.l ) return -1;
-    if ( bgzf_write(fp, v->indiv.s, v->indiv.l) != v->indiv.l ) return -1;
-
-    if (hfp->idx) {
-        if (hts_idx_push(hfp->idx, v->rid, v->pos, v->pos + v->rlen, bgzf_tell(fp), 1) < 0)
-            return -1;
-    }
-
-    return 0;
-}
-
-/**********************
- *** VCF header I/O ***
- **********************/
-
-static int add_missing_contig_hrec(bcf_hdr_t *h, const char *name) {
-    bcf_hrec_t *hrec = calloc(1, sizeof(bcf_hrec_t));
-    int save_errno;
-    if (!hrec) goto fail;
-
-    hrec->key = strdup("contig");
-    if (!hrec->key) goto fail;
-
-    if (bcf_hrec_add_key(hrec, "ID", strlen("ID")) < 0) goto fail;
-    if (bcf_hrec_set_val(hrec, hrec->nkeys-1, name, strlen(name), 0) < 0)
-        goto fail;
-    if (bcf_hdr_add_hrec(h, hrec) < 0)
-        goto fail;
-    return 0;
-
- fail:
-    save_errno = errno;
-    hts_log_error("%s", strerror(errno));
-    if (hrec) bcf_hrec_destroy(hrec);
-    errno = save_errno;
-    return -1;
-}
-
-bcf_hdr_t *vcf_hdr_read(htsFile *fp)
-{
-    kstring_t txt, *s = &fp->line;
-    int ret;
-    bcf_hdr_t *h;
-    tbx_t *idx = NULL;
-    const char **names = NULL;
-    h = bcf_hdr_init("r");
-    if (!h) {
-        hts_log_error("Failed to allocate bcf header");
-        return NULL;
-    }
-    txt.l = txt.m = 0; txt.s = 0;
-    while ((ret = hts_getline(fp, KS_SEP_LINE, s)) >= 0) {
-        int e = 0;
-        if (s->l == 0) continue;
-        if (s->s[0] != '#') {
-            hts_log_error("No sample line");
-            goto error;
-        }
-        if (s->s[1] != '#' && fp->fn_aux) { // insert contigs here
-            kstring_t tmp = { 0, 0, NULL };
-            hFILE *f = hopen(fp->fn_aux, "r");
-            if (f == NULL) {
-                hts_log_error("Couldn't open \"%s\"", fp->fn_aux);
-                goto error;
-            }
-            while (tmp.l = 0, kgetline(&tmp, (kgets_func *) hgets, f) >= 0) {
-                char *tab = strchr(tmp.s, '\t');
-                if (tab == NULL) continue;
-                e |= (kputs("##contig=<ID=", &txt) < 0);
-                e |= (kputsn(tmp.s, tab - tmp.s, &txt) < 0);
-                e |= (kputs(",length=", &txt) < 0);
-                e |= (kputl(atol(tab), &txt) < 0);
-                e |= (kputsn(">\n", 2, &txt) < 0);
-            }
-            free(tmp.s);
-            if (hclose(f) != 0) {
-                hts_log_error("Error on closing %s", fp->fn_aux);
-                goto error;
-            }
-            if (e) goto error;
-        }
-        if (kputsn(s->s, s->l, &txt) < 0) goto error;
-        if (kputc('\n', &txt) < 0) goto error;
-        if (s->s[1] != '#') break;
-    }
-    if ( ret < -1 ) goto error;
-    if ( !txt.s )
-    {
-        hts_log_error("Could not read the header");
-        goto error;
-    }
-    if ( bcf_hdr_parse(h, txt.s) < 0 ) goto error;
-
-    // check tabix index, are all contigs listed in the header? add the missing ones
-    idx = tbx_index_load3(fp->fn, NULL, HTS_IDX_SAVE_REMOTE|HTS_IDX_SILENT_FAIL);
-    if ( idx )
-    {
-        int i, n, need_sync = 0;
-        names = tbx_seqnames(idx, &n);
-        if (!names) goto error;
-        for (i=0; i<n; i++)
-        {
-            bcf_hrec_t *hrec = bcf_hdr_get_hrec(h, BCF_HL_CTG, "ID", (char*) names[i], NULL);
-            if ( hrec ) continue;
-            if (add_missing_contig_hrec(h, names[i]) < 0) goto error;
-            need_sync = 1;
-        }
-        if ( need_sync ) {
-            if (bcf_hdr_sync(h) < 0) goto error;
-        }
-        free(names);
-        tbx_destroy(idx);
-    }
-    free(txt.s);
-    return h;
-
- error:
-    if (idx) tbx_destroy(idx);
-    free(names);
-    free(txt.s);
-    if (h) bcf_hdr_destroy(h);
-    return NULL;
-}
-
-int bcf_hdr_set(bcf_hdr_t *hdr, const char *fname)
-{
-    int i = 0, n = 0, save_errno;
-    char **lines = hts_readlines(fname, &n);
-    if ( !lines ) return 1;
-    for (i=0; i<n-1; i++)
-    {
-        int k;
-        bcf_hrec_t *hrec = bcf_hdr_parse_line(hdr,lines[i],&k);
-        if (!hrec) goto fail;
-        if (bcf_hdr_add_hrec(hdr, hrec) < 0) {
-            bcf_hrec_destroy(hrec);
-            goto fail;
-        }
-        free(lines[i]);
-        lines[i] = NULL;
-    }
-    if (bcf_hdr_parse_sample_line(hdr, lines[n-1]) < 0) goto fail;
-    if (bcf_hdr_sync(hdr) < 0) goto fail;
-    free(lines[n-1]);
-    free(lines);
-    return 0;
-
- fail:
-    save_errno = errno;
-    for (; i < n; i++)
-        free(lines[i]);
-    free(lines);
-    errno = save_errno;
-    return 1;
-}
-
-static int _bcf_hrec_format(const bcf_hrec_t *hrec, int is_bcf, kstring_t *str)
-{
-    uint32_t e = 0;
-    if ( !hrec->value )
-    {
-        int j, nout = 0;
-        e |= ksprintf(str, "##%s=<", hrec->key) < 0;
-        for (j=0; j<hrec->nkeys; j++)
-        {
-            // do not output IDX if output is VCF
-            if ( !is_bcf && !strcmp("IDX",hrec->keys[j]) ) continue;
-            if ( nout ) e |= kputc(',',str) < 0;
-            e |= ksprintf(str,"%s=%s", hrec->keys[j], hrec->vals[j]) < 0;
-            nout++;
-        }
-        e |= ksprintf(str,">\n") < 0;
-    }
-    else
-        e |= ksprintf(str,"##%s=%s\n", hrec->key,hrec->value) < 0;
-
-    return e == 0 ? 0 : -1;
-}
-
-int bcf_hrec_format(const bcf_hrec_t *hrec, kstring_t *str)
-{
-    return _bcf_hrec_format(hrec,0,str);
-}
-
-int bcf_hdr_format(const bcf_hdr_t *hdr, int is_bcf, kstring_t *str)
-{
-    int i, r = 0;
-    for (i=0; i<hdr->nhrec; i++)
-        r |= _bcf_hrec_format(hdr->hrec[i], is_bcf, str) < 0;
-
-    r |= ksprintf(str, "#CHROM\tPOS\tID\tREF\tALT\tQUAL\tFILTER\tINFO") < 0;
-    if ( bcf_hdr_nsamples(hdr) )
-    {
-        r |= ksprintf(str, "\tFORMAT") < 0;
-        for (i=0; i<bcf_hdr_nsamples(hdr); i++)
-            r |= ksprintf(str, "\t%s", hdr->samples[i]) < 0;
-    }
-    r |= ksprintf(str, "\n") < 0;
-
-    return r ? -1 : 0;
-}
-
-char *bcf_hdr_fmt_text(const bcf_hdr_t *hdr, int is_bcf, int *len)
-{
-    kstring_t txt = {0,0,0};
-    if (bcf_hdr_format(hdr, is_bcf, &txt) < 0)
-        return NULL;
-    if ( len ) *len = txt.l;
-    return txt.s;
-}
-
-const char **bcf_hdr_seqnames(const bcf_hdr_t *h, int *n)
-{
-    vdict_t *d = (vdict_t*)h->dict[BCF_DT_CTG];
-    int tid, m = kh_size(d);
-    const char **names = (const char**) calloc(m,sizeof(const char*));
-    khint_t k;
-    for (k=kh_begin(d); k<kh_end(d); k++)
-    {
-        if ( !kh_exist(d,k) ) continue;
-        tid = kh_val(d,k).id;
-        assert( tid<m );
-        names[tid] = kh_key(d,k);
-    }
-    // sanity check: there should be no gaps
-    for (tid=0; tid<m; tid++)
-        assert(names[tid]);
-    *n = m;
-    return names;
-}
-
-int vcf_hdr_write(htsFile *fp, const bcf_hdr_t *h)
-{
-    kstring_t htxt = {0,0,0};
-    if (bcf_hdr_format(h, 0, &htxt) < 0) {
-        free(htxt.s);
-        return -1;
-    }
-    while (htxt.l && htxt.s[htxt.l-1] == '\0') --htxt.l; // kill trailing zeros
-    int ret;
-    if ( fp->format.compression!=no_compression )
-        ret = bgzf_write(fp->fp.bgzf, htxt.s, htxt.l);
-    else
-        ret = hwrite(fp->fp.hfile, htxt.s, htxt.l);
-    free(htxt.s);
-    return ret<0 ? -1 : 0;
-}
-
-/***********************
- *** Typed value I/O ***
- ***********************/
-
-int bcf_enc_vint(kstring_t *s, int n, int32_t *a, int wsize)
-{
-    int32_t max = INT32_MIN, min = INT32_MAX;
-    int i;
-    if (n <= 0) bcf_enc_size(s, 0, BCF_BT_NULL);
-    else if (n == 1) bcf_enc_int1(s, a[0]);
-    else {
-        if (wsize <= 0) wsize = n;
-        for (i = 0; i < n; ++i) {
-            if (a[i] == bcf_int32_missing || a[i] == bcf_int32_vector_end ) continue;
-            if (max < a[i]) max = a[i];
-            if (min > a[i]) min = a[i];
-        }
-        if (max <= BCF_MAX_BT_INT8 && min >= BCF_MIN_BT_INT8) {
-            bcf_enc_size(s, wsize, BCF_BT_INT8);
-            for (i = 0; i < n; ++i)
-                if ( a[i]==bcf_int32_vector_end ) kputc(bcf_int8_vector_end, s);
-                else if ( a[i]==bcf_int32_missing ) kputc(bcf_int8_missing, s);
-                else kputc(a[i], s);
-        } else if (max <= BCF_MAX_BT_INT16 && min >= BCF_MIN_BT_INT16) {
-            uint8_t *p;
-            bcf_enc_size(s, wsize, BCF_BT_INT16);
-            ks_resize(s, s->l + n * sizeof(int16_t));
-            p = (uint8_t *) s->s + s->l;
-            for (i = 0; i < n; ++i)
-            {
-                int16_t x;
-                if ( a[i]==bcf_int32_vector_end ) x = bcf_int16_vector_end;
-                else if ( a[i]==bcf_int32_missing ) x = bcf_int16_missing;
-                else x = a[i];
-                i16_to_le(x, p);
-                p += sizeof(int16_t);
-            }
-            s->l += n * sizeof(int16_t);
-        } else {
-            uint8_t *p;
-            bcf_enc_size(s, wsize, BCF_BT_INT32);
-            ks_resize(s, s->l + n * sizeof(int32_t));
-            p = (uint8_t *) s->s + s->l;
-            for (i = 0; i < n; ++i) {
-                i32_to_le(a[i], p);
-                p += sizeof(int32_t);
-            }
-            s->l += n * sizeof(int32_t);
-        }
-    }
-
-    return 0; // FIXME: check for errs in this function
-}
-
-#ifdef VCF_ALLOW_INT64
-static int bcf_enc_long1(kstring_t *s, int64_t x) {
-    uint32_t e = 0;
-    if (x <= BCF_MAX_BT_INT32 && x >= BCF_MIN_BT_INT32)
-        return bcf_enc_int1(s, x);
-    if (x == bcf_int64_vector_end) {
-        e |= bcf_enc_size(s, 1, BCF_BT_INT8);
-        e |= kputc(bcf_int8_vector_end, s) < 0;
-    } else if (x == bcf_int64_missing) {
-        e |= bcf_enc_size(s, 1, BCF_BT_INT8);
-        e |= kputc(bcf_int8_missing, s) < 0;
-    } else {
-        e |= bcf_enc_size(s, 1, BCF_BT_INT64);
-        e |= ks_expand(s, 8);
-        if (e == 0) { u64_to_le(x, (uint8_t *) s->s + s->l); s->l += 8; }
-    }
-    return e == 0 ? 0 : -1;
-}
-#endif
-
-static inline int serialize_float_array(kstring_t *s, size_t n, const float *a) {
-    uint8_t *p;
-    size_t i;
-    size_t bytes = n * sizeof(float);
-
-    if (bytes / sizeof(float) != n) return -1;
-    if (ks_resize(s, s->l + bytes) < 0) return -1;
-
-    p = (uint8_t *) s->s + s->l;
-    for (i = 0; i < n; i++) {
-        float_to_le(a[i], p);
-        p += sizeof(float);
-    }
-    s->l += bytes;
-
-    return 0;
-}
-
-int bcf_enc_vfloat(kstring_t *s, int n, float *a)
-{
-    assert(n >= 0);
-    bcf_enc_size(s, n, BCF_BT_FLOAT);
-    serialize_float_array(s, n, a);
-    return 0; // FIXME: check for errs in this function
-}
-
-int bcf_enc_vchar(kstring_t *s, int l, const char *a)
-{
-    bcf_enc_size(s, l, BCF_BT_CHAR);
-    kputsn(a, l, s);
-    return 0; // FIXME: check for errs in this function
-}
-
-int bcf_fmt_array(kstring_t *s, int n, int type, void *data)
-{
-    int j = 0;
-    uint32_t e = 0;
-    if (n == 0) {
-        return kputc('.', s) >= 0 ? 0 : -1;
-    }
-    if (type == BCF_BT_CHAR)
-    {
-        char *p = (char*)data;
-        for (j = 0; j < n && *p; ++j, ++p)
-        {
-            if ( *p==bcf_str_missing ) e |= kputc('.', s) < 0;
-            else e |= kputc(*p, s) < 0;
-        }
-    }
-    else
-    {
-        #define BRANCH(type_t, convert, is_missing, is_vector_end, kprint) { \
-            uint8_t *p = (uint8_t *) data; \
-            for (j=0; j<n; j++, p += sizeof(type_t))    \
-            { \
-                type_t v = convert(p); \
-                if ( is_vector_end ) break; \
-                if ( j ) kputc(',', s); \
-                if ( is_missing ) kputc('.', s); \
-                else e |= kprint < 0; \
-            } \
-        }
-        switch (type) {
-            case BCF_BT_INT8:  BRANCH(int8_t,  le_to_i8, v==bcf_int8_missing,  v==bcf_int8_vector_end,  kputw(v, s)); break;
-            case BCF_BT_INT16: BRANCH(int16_t, le_to_i16, v==bcf_int16_missing, v==bcf_int16_vector_end, kputw(v, s)); break;
-            case BCF_BT_INT32: BRANCH(int32_t, le_to_i32, v==bcf_int32_missing, v==bcf_int32_vector_end, kputw(v, s)); break;
-            case BCF_BT_FLOAT: BRANCH(uint32_t, le_to_u32, v==bcf_float_missing, v==bcf_float_vector_end, kputd(le_to_float(p), s)); break;
-            default: hts_log_error("Unexpected type %d", type); exit(1); break;
-        }
-        #undef BRANCH
-    }
-    return e == 0 ? 0 : -1;
-}
-
-uint8_t *bcf_fmt_sized_array(kstring_t *s, uint8_t *ptr)
-{
-    int x, type;
-    x = bcf_dec_size(ptr, &ptr, &type);
-    bcf_fmt_array(s, x, type, ptr);
-    return ptr + (x << bcf_type_shift[type]);
-}
-
-/********************
- *** VCF site I/O ***
- ********************/
-
-typedef struct {
-    int key, max_m, size, offset;
-    uint32_t is_gt:1, max_g:31;
-    uint32_t max_l;
-    uint32_t y;
-    uint8_t *buf;
-} fmt_aux_t;
-
-static inline int align_mem(kstring_t *s)
-{
-    int e = 0;
-    if (s->l&7) {
-        uint64_t zero = 0;
-        e = kputsn((char*)&zero, 8 - (s->l&7), s) < 0;
-    }
-    return e == 0 ? 0 : -1;
-}
-
-// p,q is the start and the end of the FORMAT field
-#define MAX_N_FMT 255   /* Limited by size of bcf1_t n_fmt field */
-static int vcf_parse_format(kstring_t *s, const bcf_hdr_t *h, bcf1_t *v, char *p, char *q)
-{
-    if ( !bcf_hdr_nsamples(h) ) return 0;
-
-    static int extreme_val_warned = 0;
-    char *r, *t;
-    int j, l, m, g, overflow = 0;
-    khint_t k;
-    ks_tokaux_t aux1;
-    vdict_t *d = (vdict_t*)h->dict[BCF_DT_ID];
-    kstring_t *mem = (kstring_t*)&h->mem;
-    fmt_aux_t fmt[MAX_N_FMT];
-    mem->l = 0;
-
-    char *end = s->s + s->l;
-    if ( q>=end )
-    {
-        hts_log_error("FORMAT column with no sample columns starting at %s:%"PRIhts_pos"", bcf_seqname_safe(h,v), v->pos+1);
-        v->errcode |= BCF_ERR_NCOLS;
-        return -1;
-    }
-
-    v->n_fmt = 0;
-    if ( p[0]=='.' && p[1]==0 ) // FORMAT field is empty "."
-    {
-        v->n_sample = bcf_hdr_nsamples(h);
-        return 0;
-    }
-
-    // get format information from the dictionary
-    for (j = 0, t = kstrtok(p, ":", &aux1); t; t = kstrtok(0, 0, &aux1), ++j) {
-        if (j >= MAX_N_FMT) {
-            v->errcode |= BCF_ERR_LIMITS;
-            hts_log_error("FORMAT column at %s:%"PRIhts_pos" lists more identifiers than htslib can handle",
-                bcf_seqname_safe(h,v), v->pos+1);
-            return -1;
-        }
-
-        *(char*)aux1.p = 0;
-        k = kh_get(vdict, d, t);
-        if (k == kh_end(d) || kh_val(d, k).info[BCF_HL_FMT] == 15) {
-            if ( t[0]=='.' && t[1]==0 )
-            {
-                hts_log_error("Invalid FORMAT tag name '.' at %s:%"PRIhts_pos, bcf_seqname_safe(h,v), v->pos+1);
-                v->errcode |= BCF_ERR_TAG_INVALID;
-                return -1;
-            }
-            hts_log_warning("FORMAT '%s' at %s:%"PRIhts_pos" is not defined in the header, assuming Type=String", t, bcf_seqname_safe(h,v), v->pos+1);
-            kstring_t tmp = {0,0,0};
-            int l;
-            ksprintf(&tmp, "##FORMAT=<ID=%s,Number=1,Type=String,Description=\"Dummy\">", t);
-            bcf_hrec_t *hrec = bcf_hdr_parse_line(h,tmp.s,&l);
-            free(tmp.s);
-            int res = hrec ? bcf_hdr_add_hrec((bcf_hdr_t*)h, hrec) : -1;
-            if (res < 0) bcf_hrec_destroy(hrec);
-            if (res > 0) res = bcf_hdr_sync((bcf_hdr_t*)h);
-
-            k = kh_get(vdict, d, t);
-            v->errcode = BCF_ERR_TAG_UNDEF;
-            if (res || k == kh_end(d)) {
-                hts_log_error("Could not add dummy header for FORMAT '%s' at %s:%"PRIhts_pos, t, bcf_seqname_safe(h,v), v->pos+1);
-                v->errcode |= BCF_ERR_TAG_INVALID;
-                return -1;
-            }
-        }
-        fmt[j].max_l = fmt[j].max_m = fmt[j].max_g = 0;
-        fmt[j].key = kh_val(d, k).id;
-        fmt[j].is_gt = !strcmp(t, "GT");
-        fmt[j].y = h->id[0][fmt[j].key].val->info[BCF_HL_FMT];
-        v->n_fmt++;
-    }
-    // compute max
-    int n_sample_ori = -1;
-    r = q + 1;  // r: position in the format string
-    l = 0, m = g = 1, v->n_sample = 0;  // m: max vector size, l: max field len, g: max number of alleles
-    while ( r<end )
-    {
-        // can we skip some samples?
-        if ( h->keep_samples )
-        {
-            n_sample_ori++;
-            if ( !bit_array_test(h->keep_samples,n_sample_ori) )
-            {
-                while ( *r!='\t' && r<end ) r++;
-                if ( *r=='\t' ) { *r = 0; r++; }
-                continue;
-            }
-        }
-
-        // collect fmt stats: max vector size, length, number of alleles
-        j = 0;  // j-th format field
-        fmt_aux_t *f = fmt;
-        for (;;) {
-            switch (*r) {
-            case ',':
-                m++;
-                break;
-
-            case '|':
-            case '/':
-                if (f->is_gt) g++;
-                break;
-
-            case '\t':
-                *r = 0; // fall through
-
-            case '\0':
-            case ':':
-                if (f->max_m < m) f->max_m = m;
-                if (f->max_l < l) f->max_l = l;
-                if (f->is_gt && f->max_g < g) f->max_g = g;
-                l = 0, m = g = 1;
-                if ( *r==':' ) {
-                    j++; f++;
-                    if ( j>=v->n_fmt ) {
-                        hts_log_error("Incorrect number of FORMAT fields at %s:%"PRIhts_pos"",
-                                      h->id[BCF_DT_CTG][v->rid].key, v->pos+1);
-                        v->errcode |= BCF_ERR_NCOLS;
-                        return -1;
-                    }
-                } else goto end_for;
-                break;
-            }
-            if ( r>=end ) break;
-            r++; l++;
-        }
-    end_for:
-        v->n_sample++;
-        if ( v->n_sample == bcf_hdr_nsamples(h) ) break;
-        r++;
-    }
-
-    // allocate memory for arrays
-    for (j = 0; j < v->n_fmt; ++j) {
-        fmt_aux_t *f = &fmt[j];
-        if ( !f->max_m ) f->max_m = 1;  // omitted trailing format field
-        if ((f->y>>4&0xf) == BCF_HT_STR) {
-            f->size = f->is_gt? f->max_g << 2 : f->max_l;
-        } else if ((f->y>>4&0xf) == BCF_HT_REAL || (f->y>>4&0xf) == BCF_HT_INT) {
-            f->size = f->max_m << 2;
-        } else
-        {
-            hts_log_error("The format type %d at %s:%"PRIhts_pos" is currently not supported", f->y>>4&0xf, bcf_seqname_safe(h,v), v->pos+1);
-            v->errcode |= BCF_ERR_TAG_INVALID;
-            return -1;
-        }
-        if (align_mem(mem) < 0) {
-            hts_log_error("Memory allocation failure at %s:%"PRIhts_pos, bcf_seqname_safe(h,v), v->pos+1);
-            v->errcode |= BCF_ERR_LIMITS;
-            return -1;
-        }
-
-        // Limit the total memory to ~2Gb per VCF row.  This should mean
-        // malformed VCF data is less likely to take excessive memory and/or
-        // time.
-        if ((uint64_t) mem->l + v->n_sample * (uint64_t)f->size > INT_MAX) {
-            hts_log_error("Excessive memory required by FORMAT fields at %s:%"PRIhts_pos, bcf_seqname_safe(h,v), v->pos+1);
-            v->errcode |= BCF_ERR_LIMITS;
-            return -1;
-        }
-
-        f->offset = mem->l;
-        if (ks_resize(mem, mem->l + v->n_sample * (size_t)f->size) < 0) {
-            hts_log_error("Memory allocation failure at %s:%"PRIhts_pos, bcf_seqname_safe(h,v), v->pos+1);
-            v->errcode |= BCF_ERR_LIMITS;
-            return -1;
-        }
-        mem->l += v->n_sample * f->size;
-    }
-    for (j = 0; j < v->n_fmt; ++j)
-        fmt[j].buf = (uint8_t*)mem->s + fmt[j].offset;
-    // fill the sample fields; at beginning of the loop, t points to the first char of a format
-    n_sample_ori = -1;
-    t = q + 1; m = 0;   // m: sample id
-    while ( t<end )
-    {
-        // can we skip some samples?
-        if ( h->keep_samples )
-        {
-            n_sample_ori++;
-            if ( !bit_array_test(h->keep_samples,n_sample_ori) )
-            {
-                while ( *t && t<end ) t++;
-                t++;
-                continue;
-            }
-        }
-        if ( m == bcf_hdr_nsamples(h) ) break;
-
-        j = 0; // j-th format field, m-th sample
-        while ( t < end )
-        {
-            fmt_aux_t *z = &fmt[j++];
-            if (!z->buf) {
-                hts_log_error("Memory allocation failure for FORMAT field type %d at %s:%"PRIhts_pos,
-                              z->y>>4&0xf, bcf_seqname_safe(h,v), v->pos+1);
-                v->errcode |= BCF_ERR_LIMITS;
-                return -1;
-            }
-            if ((z->y>>4&0xf) == BCF_HT_STR) {
-                if (z->is_gt) { // genotypes
-                    int32_t is_phased = 0;
-                    uint32_t *x = (uint32_t*)(z->buf + z->size * (size_t)m);
-                    uint32_t unreadable = 0;
-                    uint32_t max = 0;
-                    overflow = 0;
-                    for (l = 0;; ++t) {
-                        if (*t == '.') {
-                            ++t, x[l++] = is_phased;
-                        } else {
-                            char *tt = t;
-                            uint32_t val = hts_str2uint(t, &t, sizeof(val) * CHAR_MAX - 2, &overflow);
-                            unreadable |= tt == t;
-                            if (max < val) max = val;
-                            x[l++] = (val + 1) << 1 | is_phased;
-                        }
-                        is_phased = (*t == '|');
-                        if (*t != '|' && *t != '/') break;
-                    }
-                    // Possibly check max against v->n_allele instead?
-                    if (overflow || max > (INT32_MAX >> 1) - 1) {
-                        hts_log_error("Couldn't read GT data: value too large at %s:%"PRIhts_pos, bcf_seqname_safe(h,v), v->pos+1);
-                        return -1;
-                    }
-                    if (unreadable) {
-                        hts_log_error("Couldn't read GT data: value not a number or '.' at %s:%"PRIhts_pos, bcf_seqname_safe(h,v), v->pos+1);
-                        return -1;
-                    }
-                    if ( !l ) x[l++] = 0;   // An empty field, insert missing value
-                    for (; l < z->size>>2; ++l) x[l] = bcf_int32_vector_end;
-                } else {
-                    char *x = (char*)z->buf + z->size * (size_t)m;
-                    for (r = t, l = 0; *t != ':' && *t; ++t) x[l++] = *t;
-                    for (; l < z->size; ++l) x[l] = 0;
-                }
-            } else if ((z->y>>4&0xf) == BCF_HT_INT) {
-                int32_t *x = (int32_t*)(z->buf + z->size * (size_t)m);
-                for (l = 0;; ++t) {
-                    if (*t == '.') {
-                        x[l++] = bcf_int32_missing, ++t; // ++t to skip "."
-                    } else {
-                        overflow = 0;
-                        char *te;
-                        long int tmp_val = hts_str2int(t, &te, sizeof(tmp_val)*CHAR_BIT, &overflow);
-                        if ( te==t || overflow || tmp_val<BCF_MIN_BT_INT32 || tmp_val>BCF_MAX_BT_INT32 )
-                        {
-                            if ( !extreme_val_warned )
-                            {
-                                hts_log_warning("Extreme FORMAT/%s value encountered and set to missing at %s:%"PRIhts_pos, h->id[BCF_DT_ID][fmt[j-1].key].key, bcf_seqname_safe(h,v), v->pos+1);
-                                extreme_val_warned = 1;
-                            }
-                            tmp_val = bcf_int32_missing;
-                        }
-                        x[l++] = tmp_val;
-                        t = te;
-                    }
-                    if (*t != ',') break;
-                }
-                if ( !l ) x[l++] = bcf_int32_missing;
-                for (; l < z->size>>2; ++l) x[l] = bcf_int32_vector_end;
-            } else if ((z->y>>4&0xf) == BCF_HT_REAL) {
-                float *x = (float*)(z->buf + z->size * (size_t)m);
-                for (l = 0;; ++t) {
-                    if (*t == '.' && !isdigit_c(t[1])) {
-                        bcf_float_set_missing(x[l++]), ++t; // ++t to skip "."
-                    } else {
-                        overflow = 0;
-                        char *te;
-                        float tmp_val = hts_str2dbl(t, &te, &overflow);
-                        if ( (te==t || overflow) && !extreme_val_warned )
-                        {
-                            hts_log_warning("Extreme FORMAT/%s value encountered at %s:%"PRIhts_pos, h->id[BCF_DT_ID][fmt[j-1].key].key, bcf_seqname(h,v), v->pos+1);
-                            extreme_val_warned = 1;
-                        }
-                        x[l++] = tmp_val;
-                        t = te;
-                    }
-                    if (*t != ',') break;
-                }
-                if ( !l ) bcf_float_set_missing(x[l++]);    // An empty field, insert missing value
-                for (; l < z->size>>2; ++l) bcf_float_set_vector_end(x[l]);
-            } else {
-                hts_log_error("Unknown FORMAT field type %d at %s:%"PRIhts_pos, z->y>>4&0xf, bcf_seqname_safe(h,v), v->pos+1);
-                v->errcode |= BCF_ERR_TAG_INVALID;
-                return -1;
-            }
-
-            if (*t == '\0') {
-                break;
-            }
-            else if (*t == ':') {
-                t++;
-            }
-            else {
-                char buffer[8];
-                hts_log_error("Invalid character %s in '%s' FORMAT field at %s:%"PRIhts_pos"",
-                    hts_strprint(buffer, sizeof buffer, '\'', t, 1),
-                    h->id[BCF_DT_ID][z->key].key, bcf_seqname_safe(h,v), v->pos+1);
-                v->errcode |= BCF_ERR_CHAR;
-                return -1;
-            }
-        }
-
-        for (; j < v->n_fmt; ++j) { // fill end-of-vector values
-            fmt_aux_t *z = &fmt[j];
-            if ((z->y>>4&0xf) == BCF_HT_STR) {
-                if (z->is_gt) {
-                    int32_t *x = (int32_t*)(z->buf + z->size * (size_t)m);
-                    if (z->size) x[0] = bcf_int32_missing;
-                    for (l = 1; l < z->size>>2; ++l) x[l] = bcf_int32_vector_end;
-                } else {
-                    char *x = (char*)z->buf + z->size * (size_t)m;
-                    if ( z->size ) x[0] = '.';
-                    for (l = 1; l < z->size; ++l) x[l] = 0;
-                }
-            } else if ((z->y>>4&0xf) == BCF_HT_INT) {
-                int32_t *x = (int32_t*)(z->buf + z->size * (size_t)m);
-                x[0] = bcf_int32_missing;
-                for (l = 1; l < z->size>>2; ++l) x[l] = bcf_int32_vector_end;
-            } else if ((z->y>>4&0xf) == BCF_HT_REAL) {
-                float *x = (float*)(z->buf + z->size * (size_t)m);
-                bcf_float_set_missing(x[0]);
-                for (l = 1; l < z->size>>2; ++l) bcf_float_set_vector_end(x[l]);
-            }
-        }
-
-        m++; t++;
-    }
-
-    // write individual genotype information
-    kstring_t *str = &v->indiv;
-    int i;
-    if (v->n_sample > 0) {
-        for (i = 0; i < v->n_fmt; ++i) {
-            fmt_aux_t *z = &fmt[i];
-            bcf_enc_int1(str, z->key);
-            if ((z->y>>4&0xf) == BCF_HT_STR && !z->is_gt) {
-                bcf_enc_size(str, z->size, BCF_BT_CHAR);
-                kputsn((char*)z->buf, z->size * (size_t)v->n_sample, str);
-            } else if ((z->y>>4&0xf) == BCF_HT_INT || z->is_gt) {
-                bcf_enc_vint(str, (z->size>>2) * v->n_sample, (int32_t*)z->buf, z->size>>2);
-            } else {
-                bcf_enc_size(str, z->size>>2, BCF_BT_FLOAT);
-                if (serialize_float_array(str, (z->size>>2) * (size_t)v->n_sample,
-                                          (float *) z->buf) != 0) {
-                    v->errcode |= BCF_ERR_LIMITS;
-                    hts_log_error("Out of memory at %s:%"PRIhts_pos, bcf_seqname_safe(h,v), v->pos+1);
-                    return -1;
-                }
-            }
-        }
-    }
-
-    if ( v->n_sample!=bcf_hdr_nsamples(h) )
-    {
-        hts_log_error("Number of columns at %s:%"PRIhts_pos" does not match the number of samples (%d vs %d)",
-            bcf_seqname_safe(h,v), v->pos+1, v->n_sample, bcf_hdr_nsamples(h));
-        v->errcode |= BCF_ERR_NCOLS;
-        return -1;
-    }
-    if ( v->indiv.l > 0xffffffff )
-    {
-        hts_log_error("The FORMAT at %s:%"PRIhts_pos" is too long", bcf_seqname_safe(h,v), v->pos+1);
-        v->errcode |= BCF_ERR_LIMITS;
-
-        // Error recovery: return -1 if this is a critical error or 0 if we want to ignore the FORMAT and proceed
-        v->n_fmt = 0;
-        return -1;
-    }
-
-    return 0;
-}
-
-static khint_t fix_chromosome(const bcf_hdr_t *h, vdict_t *d, const char *p) {
-    // Simple error recovery for chromosomes not defined in the header. It will not help when VCF header has
-    // been already printed, but will enable tools like vcfcheck to proceed.
-
-    kstring_t tmp = {0,0,0};
-    khint_t k;
-    int l;
-    if (ksprintf(&tmp, "##contig=<ID=%s>", p) < 0)
-        return kh_end(d);
-    bcf_hrec_t *hrec = bcf_hdr_parse_line(h,tmp.s,&l);
-    free(tmp.s);
-    int res = hrec ? bcf_hdr_add_hrec((bcf_hdr_t*)h, hrec) : -1;
-    if (res < 0) bcf_hrec_destroy(hrec);
-    if (res > 0) res = bcf_hdr_sync((bcf_hdr_t*)h);
-    k = kh_get(vdict, d, p);
-
-    return k;
-}
-
-static int vcf_parse_filter(kstring_t *str, const bcf_hdr_t *h, bcf1_t *v, char *p, char *q) {
-    int i, n_flt = 1, max_n_flt = 0;
-    char *r, *t;
-    int32_t *a_flt = NULL;
-    ks_tokaux_t aux1;
-    khint_t k;
-    vdict_t *d = (vdict_t*)h->dict[BCF_DT_ID];
-    // count the number of filters
-    if (*(q-1) == ';') *(q-1) = 0;
-    for (r = p; *r; ++r)
-        if (*r == ';') ++n_flt;
-    if (n_flt > max_n_flt) {
-        a_flt = malloc(n_flt * sizeof(*a_flt));
-        if (!a_flt) {
-            hts_log_error("Could not allocate memory at %s:%"PRIhts_pos, bcf_seqname_safe(h,v), v->pos+1);
-            v->errcode |= BCF_ERR_LIMITS; // No appropriate code?
-            return -1;
-        }
-        max_n_flt = n_flt;
-    }
-    // add filters
-    for (t = kstrtok(p, ";", &aux1), i = 0; t; t = kstrtok(0, 0, &aux1)) {
-        *(char*)aux1.p = 0;
-        k = kh_get(vdict, d, t);
-        if (k == kh_end(d))
-        {
-            // Simple error recovery for FILTERs not defined in the header. It will not help when VCF header has
-            // been already printed, but will enable tools like vcfcheck to proceed.
-            hts_log_warning("FILTER '%s' is not defined in the header", t);
-            kstring_t tmp = {0,0,0};
-            int l;
-            ksprintf(&tmp, "##FILTER=<ID=%s,Description=\"Dummy\">", t);
-            bcf_hrec_t *hrec = bcf_hdr_parse_line(h,tmp.s,&l);
-            free(tmp.s);
-            int res = hrec ? bcf_hdr_add_hrec((bcf_hdr_t*)h, hrec) : -1;
-            if (res < 0) bcf_hrec_destroy(hrec);
-            if (res > 0) res = bcf_hdr_sync((bcf_hdr_t*)h);
-            k = kh_get(vdict, d, t);
-            v->errcode |= BCF_ERR_TAG_UNDEF;
-            if (res || k == kh_end(d)) {
-                hts_log_error("Could not add dummy header for FILTER '%s' at %s:%"PRIhts_pos, t, bcf_seqname_safe(h,v), v->pos+1);
-                v->errcode |= BCF_ERR_TAG_INVALID;
-                free(a_flt);
-                return -1;
-            }
-        }
-        a_flt[i++] = kh_val(d, k).id;
-    }
-
-    bcf_enc_vint(str, n_flt, a_flt, -1);
-    free(a_flt);
-
-    return 0;
-}
-
-static int vcf_parse_info(kstring_t *str, const bcf_hdr_t *h, bcf1_t *v, char *p, char *q) {
-    static int extreme_int_warned = 0, negative_rlen_warned = 0;
-    int max_n_val = 0, overflow = 0;
-    char *r, *key;
-    khint_t k;
-    vdict_t *d = (vdict_t*)h->dict[BCF_DT_ID];
-    int32_t *a_val = NULL;
-
-    v->n_info = 0;
-    if (*(q-1) == ';') *(q-1) = 0;
-    for (r = key = p;; ++r) {
-        int c;
-        char *val, *end;
-        if (*r != ';' && *r != '=' && *r != 0) continue;
-        if (v->n_info == UINT16_MAX) {
-            hts_log_error("Too many INFO entries at %s:%"PRIhts_pos,
-                          bcf_seqname_safe(h,v), v->pos+1);
-            v->errcode |= BCF_ERR_LIMITS;
-            goto fail;
-        }
-        val = end = 0;
-        c = *r; *r = 0;
-        if (c == '=') {
-            val = r + 1;
-            for (end = val; *end != ';' && *end != 0; ++end);
-            c = *end; *end = 0;
-        } else end = r;
-        if ( !*key ) { if (c==0) break; r = end; key = r + 1; continue; }  // faulty VCF, ";;" in the INFO
-        k = kh_get(vdict, d, key);
-        if (k == kh_end(d) || kh_val(d, k).info[BCF_HL_INFO] == 15)
-        {
-            hts_log_warning("INFO '%s' is not defined in the header, assuming Type=String", key);
-            kstring_t tmp = {0,0,0};
-            int l;
-            ksprintf(&tmp, "##INFO=<ID=%s,Number=1,Type=String,Description=\"Dummy\">", key);
-            bcf_hrec_t *hrec = bcf_hdr_parse_line(h,tmp.s,&l);
-            free(tmp.s);
-            int res = hrec ? bcf_hdr_add_hrec((bcf_hdr_t*)h, hrec) : -1;
-            if (res < 0) bcf_hrec_destroy(hrec);
-            if (res > 0) res = bcf_hdr_sync((bcf_hdr_t*)h);
-            k = kh_get(vdict, d, key);
-            v->errcode = BCF_ERR_TAG_UNDEF;
-            if (res || k == kh_end(d)) {
-                hts_log_error("Could not add dummy header for INFO '%s' at %s:%"PRIhts_pos, key, bcf_seqname_safe(h,v), v->pos+1);
-                v->errcode |= BCF_ERR_TAG_INVALID;
-                goto fail;
-            }
-        }
-        uint32_t y = kh_val(d, k).info[BCF_HL_INFO];
-        ++v->n_info;
-        bcf_enc_int1(str, kh_val(d, k).id);
-        if (val == 0) {
-            bcf_enc_size(str, 0, BCF_BT_NULL);
-        } else if ((y>>4&0xf) == BCF_HT_FLAG || (y>>4&0xf) == BCF_HT_STR) { // if Flag has a value, treat it as a string
-            bcf_enc_vchar(str, end - val, val);
-        } else { // int/float value/array
-            int i, n_val;
-            char *t, *te;
-            for (t = val, n_val = 1; *t; ++t) // count the number of values
-                if (*t == ',') ++n_val;
-            // Check both int and float size in one step for simplicity
-            if (n_val > max_n_val) {
-                int32_t *a_tmp = (int32_t *)realloc(a_val, n_val * sizeof(*a_val));
-                if (!a_tmp) {
-                    hts_log_error("Could not allocate memory at %s:%"PRIhts_pos, bcf_seqname_safe(h,v), v->pos+1);
-                    v->errcode |= BCF_ERR_LIMITS; // No appropriate code?
-                    goto fail;
-                }
-                a_val = a_tmp;
-                max_n_val = n_val;
-            }
-            if ((y>>4&0xf) == BCF_HT_INT) {
-                i = 0, t = val;
-                int64_t val1;
-                int is_int64 = 0;
-#ifdef VCF_ALLOW_INT64
-                if ( n_val==1 )
-                {
-                    overflow = 0;
-                    long long int tmp_val = hts_str2int(val, &te, sizeof(tmp_val)*CHAR_BIT, &overflow);
-                    if ( te==val ) tmp_val = bcf_int32_missing;
-                    else if ( overflow || tmp_val<BCF_MIN_BT_INT64 || tmp_val>BCF_MAX_BT_INT64 )
-                    {
-                        if ( !extreme_int_warned )
-                        {
-                            hts_log_warning("Extreme INFO/%s value encountered and set to missing at %s:%"PRIhts_pos,key,bcf_seqname_safe(h,v), v->pos+1);
-                            extreme_int_warned = 1;
-                        }
-                        tmp_val = bcf_int32_missing;
-                    }
-                    else
-                        is_int64 = 1;
-                    val1 = tmp_val;
-                    t = te;
-                    i = 1;  // this is just to avoid adding another nested block...
-                }
-#endif
-                for (; i < n_val; ++i, ++t)
-                {
-                    overflow = 0;
-                    long int tmp_val = hts_str2int(t, &te, sizeof(tmp_val)*CHAR_BIT, &overflow);
-                    if ( te==t ) tmp_val = bcf_int32_missing;
-                    else if ( overflow || tmp_val<BCF_MIN_BT_INT32 || tmp_val>BCF_MAX_BT_INT32 )
-                    {
-                        if ( !extreme_int_warned )
-                        {
-                            hts_log_warning("Extreme INFO/%s value encountered and set to missing at %s:%"PRIhts_pos,key,bcf_seqname_safe(h,v), v->pos+1);
-                            extreme_int_warned = 1;
-                        }
-                        tmp_val = bcf_int32_missing;
-                    }
-                    a_val[i] = tmp_val;
-                    for (t = te; *t && *t != ','; t++);
-                }
-                if (n_val == 1) {
-#ifdef VCF_ALLOW_INT64
-                    if ( is_int64 )
-                    {
-                        v->unpacked |= BCF_IS_64BIT;
-                        bcf_enc_long1(str, val1);
-                    }
-                    else
-                        bcf_enc_int1(str, (int32_t)val1);
-#else
-                    val1 = a_val[0];
-                    bcf_enc_int1(str, (int32_t)val1);
-#endif
-                } else {
-                    bcf_enc_vint(str, n_val, a_val, -1);
-                }
-                if (n_val==1 && (val1!=bcf_int32_missing || is_int64) && strcmp(key, "END") == 0)
-                {
-                    if ( val1 <= v->pos )
-                    {
-                        if ( !negative_rlen_warned )
-                        {
-                            hts_log_warning("INFO/END=%"PRIhts_pos" is smaller than POS at %s:%"PRIhts_pos,val1,bcf_seqname_safe(h,v),v->pos+1);
-                            negative_rlen_warned = 1;
-                        }
-                    }
-                    else
-                        v->rlen = val1 - v->pos;
-                }
-            } else if ((y>>4&0xf) == BCF_HT_REAL) {
-                float *val_f = (float *)a_val;
-                for (i = 0, t = val; i < n_val; ++i, ++t)
-                {
-                    overflow = 0;
-                    val_f[i] = hts_str2dbl(t, &te, &overflow);
-                    if ( te==t || overflow ) // conversion failed
-                        bcf_float_set_missing(val_f[i]);
-                    for (t = te; *t && *t != ','; t++);
-                }
-                bcf_enc_vfloat(str, n_val, val_f);
-            }
-        }
-        if (c == 0) break;
-        r = end;
-        key = r + 1;
-    }
-
-    free(a_val);
-    return 0;
-
- fail:
-    free(a_val);
-    return -1;
-}
-
-int vcf_parse(kstring_t *s, const bcf_hdr_t *h, bcf1_t *v)
-{
-    int i = 0, ret = -2, overflow = 0;
-    char *p, *q, *r, *t;
-    kstring_t *str;
-    khint_t k;
-    ks_tokaux_t aux;
-
-    if (!s || !h || !v || !(s->s))
-        return ret;
-
-    // Assumed in lots of places, but we may as well spot this early
-    assert(sizeof(float) == sizeof(int32_t));
-
-    bcf_clear1(v);
-    str = &v->shared;
-    memset(&aux, 0, sizeof(ks_tokaux_t));
-    for (p = kstrtok(s->s, "\t", &aux), i = 0; p; p = kstrtok(0, 0, &aux), ++i) {
-        q = (char*)aux.p;
-        *q = 0;
-        if (i == 0) { // CHROM
-            vdict_t *d = (vdict_t*)h->dict[BCF_DT_CTG];
-            k = kh_get(vdict, d, p);
-            if (k == kh_end(d))
-            {
-                hts_log_warning("Contig '%s' is not defined in the header. (Quick workaround: index the file with tabix.)", p);
-                v->errcode = BCF_ERR_CTG_UNDEF;
-                if ((k = fix_chromosome(h, d, p)) == kh_end(d)) {
-                    hts_log_error("Could not add dummy header for contig '%s'", p);
-                    v->errcode |= BCF_ERR_CTG_INVALID;
-                    goto err;
-                }
-            }
-            v->rid = kh_val(d, k).id;
-        } else if (i == 1) { // POS
-            overflow = 0;
-            v->pos = hts_str2uint(p, &p, 63, &overflow);
-            if (overflow) {
-                hts_log_error("Position value '%s' is too large", p);
-                goto err;
-            } else {
-                v->pos -= 1;
-            }
-            if (v->pos >= INT32_MAX)
-                v->unpacked |= BCF_IS_64BIT;
-        } else if (i == 2) { // ID
-            if (strcmp(p, ".")) bcf_enc_vchar(str, q - p, p);
-            else bcf_enc_size(str, 0, BCF_BT_CHAR);
-        } else if (i == 3) { // REF
-            bcf_enc_vchar(str, q - p, p);
-            v->n_allele = 1, v->rlen = q - p;
-        } else if (i == 4) { // ALT
-            if (strcmp(p, ".")) {
-                for (r = t = p;; ++r) {
-                    if (*r == ',' || *r == 0) {
-                        if (v->n_allele == UINT16_MAX) {
-                            hts_log_error("Too many ALT alleles at %s:%"PRIhts_pos,
-                                          bcf_seqname_safe(h,v), v->pos+1);
-                            v->errcode |= BCF_ERR_LIMITS;
-                            goto err;
-                        }
-                        bcf_enc_vchar(str, r - t, t);
-                        t = r + 1;
-                        ++v->n_allele;
-                    }
-                    if (r == q) break;
-                }
-            }
-        } else if (i == 5) { // QUAL
-            if (strcmp(p, ".")) v->qual = atof(p);
-            else bcf_float_set_missing(v->qual);
-            if ( v->max_unpack && !(v->max_unpack>>1) ) goto end; // BCF_UN_STR
-        } else if (i == 6) { // FILTER
-            if (strcmp(p, ".")) {
-                if (vcf_parse_filter(str, h, v, p, q)) goto err;
-            } else bcf_enc_vint(str, 0, 0, -1);
-            if ( v->max_unpack && !(v->max_unpack>>2) ) goto end; // BCF_UN_FLT
-        } else if (i == 7) { // INFO
-            if (strcmp(p, ".")) {
-                if (vcf_parse_info(str, h, v, p, q)) goto err;
-            }
-            if ( v->max_unpack && !(v->max_unpack>>3) ) goto end;
-        } else if (i == 8) {// FORMAT
-            return vcf_parse_format(s, h, v, p, q) == 0 ? 0 : -2;
-        }
-    }
-
- end:
-    ret = 0;
-
- err:
-    return ret;
-}
-
-int vcf_open_mode(char *mode, const char *fn, const char *format)
-{
-    if (format == NULL) {
-        // Try to pick a format based on the filename extension
-        char extension[HTS_MAX_EXT_LEN];
-        if (find_file_extension(fn, extension) < 0) return -1;
-        return vcf_open_mode(mode, fn, extension);
-    }
-    else if (strcasecmp(format, "bcf") == 0) strcpy(mode, "b");
-    else if (strcasecmp(format, "vcf") == 0) strcpy(mode, "");
-    else if (strcasecmp(format, "vcf.gz") == 0 || strcasecmp(format, "vcf.bgz") == 0) strcpy(mode, "z");
-    else return -1;
-
-    return 0;
-}
-
-int vcf_read(htsFile *fp, const bcf_hdr_t *h, bcf1_t *v)
-{
-    int ret;
-    ret = hts_getline(fp, KS_SEP_LINE, &fp->line);
-    if (ret < 0) return ret;
-    return vcf_parse1(&fp->line, h, v);
-}
-
-static inline uint8_t *bcf_unpack_fmt_core1(uint8_t *ptr, int n_sample, bcf_fmt_t *fmt)
-{
-    uint8_t *ptr_start = ptr;
-    fmt->id = bcf_dec_typed_int1(ptr, &ptr);
-    fmt->n = bcf_dec_size(ptr, &ptr, &fmt->type);
-    fmt->size = fmt->n << bcf_type_shift[fmt->type];
-    fmt->p = ptr;
-    fmt->p_off  = ptr - ptr_start;
-    fmt->p_free = 0;
-    ptr += n_sample * fmt->size;
-    fmt->p_len = ptr - fmt->p;
-    return ptr;
-}
-
-static inline uint8_t *bcf_unpack_info_core1(uint8_t *ptr, bcf_info_t *info)
-{
-    uint8_t *ptr_start = ptr;
-    info->key = bcf_dec_typed_int1(ptr, &ptr);
-    info->len = bcf_dec_size(ptr, &ptr, &info->type);
-    info->vptr = ptr;
-    info->vptr_off  = ptr - ptr_start;
-    info->vptr_free = 0;
-    info->v1.i = 0;
-    if (info->len == 1) {
-        if (info->type == BCF_BT_INT8 || info->type == BCF_BT_CHAR) info->v1.i = *(int8_t*)ptr;
-        else if (info->type == BCF_BT_INT32) info->v1.i = le_to_i32(ptr);
-        else if (info->type == BCF_BT_FLOAT) info->v1.f = le_to_float(ptr);
-        else if (info->type == BCF_BT_INT16) info->v1.i = le_to_i16(ptr);
-        else if (info->type == BCF_BT_INT64) info->v1.i = le_to_i64(ptr);
-    }
-    ptr += info->len << bcf_type_shift[info->type];
-    info->vptr_len = ptr - info->vptr;
-    return ptr;
-}
-
-int bcf_unpack(bcf1_t *b, int which)
-{
-    if ( !b->shared.l ) return 0; // Building a new BCF record from scratch
-    uint8_t *ptr = (uint8_t*)b->shared.s, *ptr_ori;
-    int i;
-    bcf_dec_t *d = &b->d;
-    if (which & BCF_UN_FLT) which |= BCF_UN_STR;
-    if (which & BCF_UN_INFO) which |= BCF_UN_SHR;
-    if ((which&BCF_UN_STR) && !(b->unpacked&BCF_UN_STR))
-    {
-        kstring_t tmp;
-
-        // ID
-        tmp.l = 0; tmp.s = d->id; tmp.m = d->m_id;
-        ptr_ori = ptr;
-        ptr = bcf_fmt_sized_array(&tmp, ptr);
-        b->unpack_size[0] = ptr - ptr_ori;
-        kputc('\0', &tmp);
-        d->id = tmp.s; d->m_id = tmp.m;
-
-        // REF and ALT are in a single block (d->als) and d->alleles are pointers into this block
-        hts_expand(char*, b->n_allele, d->m_allele, d->allele); // NM: hts_expand() is a macro
-        tmp.l = 0; tmp.s = d->als; tmp.m = d->m_als;
-        ptr_ori = ptr;
-        for (i = 0; i < b->n_allele; ++i) {
-            // Use offset within tmp.s as realloc may change pointer
-            d->allele[i] = (char *)(intptr_t)tmp.l;
-            ptr = bcf_fmt_sized_array(&tmp, ptr);
-            kputc('\0', &tmp);
-        }
-        b->unpack_size[1] = ptr - ptr_ori;
-        d->als = tmp.s; d->m_als = tmp.m;
-
-        // Convert our offsets within tmp.s back to pointers again
-        for (i = 0; i < b->n_allele; ++i)
-            d->allele[i] = d->als + (ptrdiff_t)d->allele[i];
-        b->unpacked |= BCF_UN_STR;
-    }
-    if ((which&BCF_UN_FLT) && !(b->unpacked&BCF_UN_FLT)) { // FILTER
-        ptr = (uint8_t*)b->shared.s + b->unpack_size[0] + b->unpack_size[1];
-        ptr_ori = ptr;
-        if (*ptr>>4) {
-            int type;
-            d->n_flt = bcf_dec_size(ptr, &ptr, &type);
-            hts_expand(int, d->n_flt, d->m_flt, d->flt);
-            for (i = 0; i < d->n_flt; ++i)
-                d->flt[i] = bcf_dec_int1(ptr, type, &ptr);
-        } else ++ptr, d->n_flt = 0;
-        b->unpack_size[2] = ptr - ptr_ori;
-        b->unpacked |= BCF_UN_FLT;
-    }
-    if ((which&BCF_UN_INFO) && !(b->unpacked&BCF_UN_INFO)) { // INFO
-        ptr = (uint8_t*)b->shared.s + b->unpack_size[0] + b->unpack_size[1] + b->unpack_size[2];
-        hts_expand(bcf_info_t, b->n_info, d->m_info, d->info);
-        for (i = 0; i < d->m_info; ++i) d->info[i].vptr_free = 0;
-        for (i = 0; i < b->n_info; ++i)
-            ptr = bcf_unpack_info_core1(ptr, &d->info[i]);
-        b->unpacked |= BCF_UN_INFO;
-    }
-    if ((which&BCF_UN_FMT) && b->n_sample && !(b->unpacked&BCF_UN_FMT)) { // FORMAT
-        ptr = (uint8_t*)b->indiv.s;
-        hts_expand(bcf_fmt_t, b->n_fmt, d->m_fmt, d->fmt);
-        for (i = 0; i < d->m_fmt; ++i) d->fmt[i].p_free = 0;
-        for (i = 0; i < b->n_fmt; ++i)
-            ptr = bcf_unpack_fmt_core1(ptr, b->n_sample, &d->fmt[i]);
-        b->unpacked |= BCF_UN_FMT;
-    }
-    return 0;
-}
-
-int vcf_format(const bcf_hdr_t *h, const bcf1_t *v, kstring_t *s)
-{
-    int i;
-    int32_t max_dt_id = h->n[BCF_DT_ID];
-    const char *chrom = bcf_seqname(h, v);
-    if (!chrom) {
-        hts_log_error("Invalid BCF, CONTIG id=%d not present in the header",
-                      v->rid);
-        errno = EINVAL;
-        return -1;
-    }
-    bcf_unpack((bcf1_t*)v, BCF_UN_ALL);
-    kputs(chrom, s); // CHROM
-    kputc('\t', s); kputll(v->pos + 1, s); // POS
-    kputc('\t', s); kputs(v->d.id ? v->d.id : ".", s); // ID
-    kputc('\t', s); // REF
-    if (v->n_allele > 0) kputs(v->d.allele[0], s);
-    else kputc('.', s);
-    kputc('\t', s); // ALT
-    if (v->n_allele > 1) {
-        for (i = 1; i < v->n_allele; ++i) {
-            if (i > 1) kputc(',', s);
-            kputs(v->d.allele[i], s);
-        }
-    } else kputc('.', s);
-    kputc('\t', s); // QUAL
-    if ( bcf_float_is_missing(v->qual) ) kputc('.', s); // QUAL
-    else kputd(v->qual, s);
-    kputc('\t', s); // FILTER
-    if (v->d.n_flt) {
-        for (i = 0; i < v->d.n_flt; ++i) {
-            int32_t idx = v->d.flt[i];
-            if (idx < 0 || idx >= max_dt_id
-                || h->id[BCF_DT_ID][idx].key == NULL) {
-                hts_log_error("Invalid BCF, the FILTER tag id=%d at %s:%"PRIhts_pos" not present in the header",
-                              idx, bcf_seqname_safe(h, v), v->pos + 1);
-                errno = EINVAL;
-                return -1;
-            }
-            if (i) kputc(';', s);
-            kputs(h->id[BCF_DT_ID][idx].key, s);
-        }
-    } else kputc('.', s);
-    kputc('\t', s); // INFO
-    if (v->n_info) {
-        int first = 1;
-        for (i = 0; i < v->n_info; ++i) {
-            bcf_info_t *z = &v->d.info[i];
-            if ( !z->vptr ) continue;
-            if ( !first ) kputc(';', s);
-            first = 0;
-            if (z->key < 0 || z->key >= max_dt_id
-                || h->id[BCF_DT_ID][z->key].key == NULL) {
-                hts_log_error("Invalid BCF, the INFO tag id=%d is %s at %s:%"PRIhts_pos,
-                              z->key,
-                              z->key < 0 ? "negative"
-                              : (z->key >= max_dt_id ? "too large" : "not present in the header"),
-                              bcf_seqname_safe(h, v), v->pos+1);
-                errno = EINVAL;
-                return -1;
-            }
-            kputs(h->id[BCF_DT_ID][z->key].key, s);
-            if (z->len <= 0) continue;
-            kputc('=', s);
-            if (z->len == 1)
-            {
-                switch (z->type)
-                {
-                    case BCF_BT_INT8:  if ( z->v1.i==bcf_int8_missing ) kputc('.', s); else kputw(z->v1.i, s); break;
-                    case BCF_BT_INT16: if ( z->v1.i==bcf_int16_missing ) kputc('.', s); else kputw(z->v1.i, s); break;
-                    case BCF_BT_INT32: if ( z->v1.i==bcf_int32_missing ) kputc('.', s); else kputw(z->v1.i, s); break;
-                    case BCF_BT_INT64: if ( z->v1.i==bcf_int64_missing ) kputc('.', s); else kputll(z->v1.i, s); break;
-                    case BCF_BT_FLOAT: if ( bcf_float_is_missing(z->v1.f) ) kputc('.', s); else kputd(z->v1.f, s); break;
-                    case BCF_BT_CHAR:  kputc(z->v1.i, s); break;
-                    default:
-                        hts_log_error("Unexpected type %d at %s:%"PRIhts_pos, z->type, bcf_seqname_safe(h, v), v->pos+1);
-                        errno = EINVAL;
-                        return -1;
-                }
-            }
-            else bcf_fmt_array(s, z->len, z->type, z->vptr);
-        }
-        if ( first ) kputc('.', s);
-    } else kputc('.', s);
-    // FORMAT and individual information
-    if (v->n_sample)
-    {
-        int i,j;
-        if ( v->n_fmt)
-        {
-            int gt_i = -1;
-            bcf_fmt_t *fmt = v->d.fmt;
-            int first = 1;
-            for (i = 0; i < (int)v->n_fmt; ++i) {
-                if ( !fmt[i].p ) continue;
-                kputc(!first ? ':' : '\t', s); first = 0;
-                if (fmt[i].id < 0 || fmt[i].id >= max_dt_id
-                    || h->id[BCF_DT_ID][fmt[i].id].key == NULL) //!bcf_hdr_idinfo_exists(h,BCF_HL_FMT,fmt[i].id) )
-                {
-                    hts_log_error("Invalid BCF, the FORMAT tag id=%d at %s:%"PRIhts_pos" not present in the header", fmt[i].id, bcf_seqname_safe(h, v), v->pos+1);
-                    errno = EINVAL;
-                    return -1;
-                }
-                kputs(h->id[BCF_DT_ID][fmt[i].id].key, s);
-                if (strcmp(h->id[BCF_DT_ID][fmt[i].id].key, "GT") == 0) gt_i = i;
-            }
-            if ( first ) kputs("\t.", s);
-            for (j = 0; j < v->n_sample; ++j) {
-                kputc('\t', s);
-                first = 1;
-                for (i = 0; i < (int)v->n_fmt; ++i) {
-                    bcf_fmt_t *f = &fmt[i];
-                    if ( !f->p ) continue;
-                    if (!first) kputc(':', s);
-                    first = 0;
-                    if (gt_i == i)
-                        bcf_format_gt(f,j,s);
-                    else
-                        bcf_fmt_array(s, f->n, f->type, f->p + j * (size_t)f->size);
-                }
-                if ( first ) kputc('.', s);
-            }
-        }
-        else
-            for (j=0; j<=v->n_sample; j++)
-                kputs("\t.", s);
-    }
-    kputc('\n', s);
-    return 0;
-}
-
-int vcf_write_line(htsFile *fp, kstring_t *line)
-{
-    int ret;
-    if ( line->s[line->l-1]!='\n' ) kputc('\n',line);
-    if ( fp->format.compression!=no_compression )
-        ret = bgzf_write(fp->fp.bgzf, line->s, line->l);
-    else
-        ret = hwrite(fp->fp.hfile, line->s, line->l);
-    return ret==line->l ? 0 : -1;
-}
-
-int vcf_write(htsFile *fp, const bcf_hdr_t *h, bcf1_t *v)
-{
-    int ret;
-    fp->line.l = 0;
-    if (vcf_format1(h, v, &fp->line) != 0)
-        return -1;
-    if ( fp->format.compression!=no_compression )
-        ret = bgzf_write(fp->fp.bgzf, fp->line.s, fp->line.l);
-    else
-        ret = hwrite(fp->fp.hfile, fp->line.s, fp->line.l);
-
-    if (fp->idx) {
-        int tid;
-        if ((tid = hts_idx_tbi_name(fp->idx, v->rid, bcf_seqname_safe(h, v))) < 0)
-            return -1;
-
-        if (hts_idx_push(fp->idx, tid, v->pos, v->pos + v->rlen, bgzf_tell(fp->fp.bgzf), 1) < 0)
-            return -1;
-    }
-
-    return ret==fp->line.l ? 0 : -1;
-}
-
-/************************
- * Data access routines *
- ************************/
-
-int bcf_hdr_id2int(const bcf_hdr_t *h, int which, const char *id)
-{
-    khint_t k;
-    vdict_t *d = (vdict_t*)h->dict[which];
-    k = kh_get(vdict, d, id);
-    return k == kh_end(d)? -1 : kh_val(d, k).id;
-}
-
-
-/********************
- *** BCF indexing ***
- ********************/
-
-// Calculate number of index levels given min_shift and the header contig
-// list.  Also returns number of contigs in *nids_out.
-static int idx_calc_n_lvls_ids(const bcf_hdr_t *h, int min_shift,
-                               int starting_n_lvls, int *nids_out)
-{
-    int n_lvls, i, nids = 0;
-    int64_t max_len = 0, s;
-
-    for (i = 0; i < h->n[BCF_DT_CTG]; ++i)
-    {
-        if ( !h->id[BCF_DT_CTG][i].val ) continue;
-        if ( max_len < h->id[BCF_DT_CTG][i].val->info[0] )
-            max_len = h->id[BCF_DT_CTG][i].val->info[0];
-        nids++;
-    }
-    if ( !max_len ) max_len = (1LL<<31) - 1;  // In case contig line is broken.
-    max_len += 256;
-    s = 1LL << (min_shift + starting_n_lvls * 3);
-    for (n_lvls = starting_n_lvls; max_len > s; ++n_lvls, s <<= 3);
-
-    if (nids_out) *nids_out = nids;
-    return n_lvls;
-}
-
-hts_idx_t *bcf_index(htsFile *fp, int min_shift)
-{
-    int n_lvls;
-    bcf1_t *b = NULL;
-    hts_idx_t *idx = NULL;
-    bcf_hdr_t *h;
-    int r;
-    h = bcf_hdr_read(fp);
-    if ( !h ) return NULL;
-    int nids = 0;
-    n_lvls = idx_calc_n_lvls_ids(h, min_shift, 0, &nids);
-    idx = hts_idx_init(nids, HTS_FMT_CSI, bgzf_tell(fp->fp.bgzf), min_shift, n_lvls);
-    if (!idx) goto fail;
-    b = bcf_init1();
-    if (!b) goto fail;
-    while ((r = bcf_read1(fp,h, b)) >= 0) {
-        int ret;
-        ret = hts_idx_push(idx, b->rid, b->pos, b->pos + b->rlen, bgzf_tell(fp->fp.bgzf), 1);
-        if (ret < 0) goto fail;
-    }
-    if (r < -1) goto fail;
-    hts_idx_finish(idx, bgzf_tell(fp->fp.bgzf));
-    bcf_destroy1(b);
-    bcf_hdr_destroy(h);
-    return idx;
-
- fail:
-    hts_idx_destroy(idx);
-    bcf_destroy1(b);
-    bcf_hdr_destroy(h);
-    return NULL;
-}
-
-hts_idx_t *bcf_index_load2(const char *fn, const char *fnidx)
-{
-    return fnidx? hts_idx_load2(fn, fnidx) : bcf_index_load(fn);
-}
-
-hts_idx_t *bcf_index_load3(const char *fn, const char *fnidx, int flags)
-{
-    return hts_idx_load3(fn, fnidx, HTS_FMT_CSI, flags);
-}
-
-int bcf_index_build3(const char *fn, const char *fnidx, int min_shift, int n_threads)
-{
-    htsFile *fp;
-    hts_idx_t *idx;
-    tbx_t *tbx;
-    int ret;
-    if ((fp = hts_open(fn, "rb")) == 0) return -2;
-    if (n_threads)
-        hts_set_threads(fp, n_threads);
-    if ( fp->format.compression!=bgzf ) { hts_close(fp); return -3; }
-    switch (fp->format.format) {
-        case bcf:
-            if (!min_shift) {
-                hts_log_error("TBI indices for BCF files are not supported");
-                ret = -1;
-            } else {
-                idx = bcf_index(fp, min_shift);
-                if (idx) {
-                    ret = hts_idx_save_as(idx, fn, fnidx, HTS_FMT_CSI);
-                    if (ret < 0) ret = -4;
-                    hts_idx_destroy(idx);
-                }
-                else ret = -1;
-            }
-            break;
-
-        case vcf:
-            tbx = tbx_index(hts_get_bgzfp(fp), min_shift, &tbx_conf_vcf);
-            if (tbx) {
-                ret = hts_idx_save_as(tbx->idx, fn, fnidx, min_shift > 0 ? HTS_FMT_CSI : HTS_FMT_TBI);
-                if (ret < 0) ret = -4;
-                tbx_destroy(tbx);
-            }
-            else ret = -1;
-            break;
-
-        default:
-            ret = -3;
-            break;
-    }
-    hts_close(fp);
-    return ret;
-}
-
-int bcf_index_build2(const char *fn, const char *fnidx, int min_shift)
-{
-    return bcf_index_build3(fn, fnidx, min_shift, 0);
-}
-
-int bcf_index_build(const char *fn, int min_shift)
-{
-    return bcf_index_build3(fn, NULL, min_shift, 0);
-}
-
-// Initialise fp->idx for the current format type.
-// This must be called after the header has been written but no other data.
-static int vcf_idx_init(htsFile *fp, bcf_hdr_t *h, int min_shift, const char *fnidx) {
-    int n_lvls, fmt;
-
-    if (min_shift == 0) {
-        min_shift = 14;
-        n_lvls = 5;
-        fmt = HTS_FMT_TBI;
-    } else {
-        // Set initial n_lvls to match tbx_index()
-        int starting_n_lvls = (TBX_MAX_SHIFT - min_shift + 2) / 3;
-        // Increase if necessary
-        n_lvls = idx_calc_n_lvls_ids(h, min_shift, starting_n_lvls, NULL);
-        fmt = HTS_FMT_CSI;
-    }
-
-    fp->idx = hts_idx_init(0, fmt, bgzf_tell(fp->fp.bgzf), min_shift, n_lvls);
-    if (!fp->idx) return -1;
-
-    // Tabix meta data, added even in CSI for VCF
-    uint8_t conf[4*7];
-    u32_to_le(TBX_VCF, conf+0);  // fmt
-    u32_to_le(1,       conf+4);  // name col
-    u32_to_le(2,       conf+8);  // beg col
-    u32_to_le(0,       conf+12); // end col
-    u32_to_le('#',     conf+16); // comment
-    u32_to_le(0,       conf+20); // n.skip
-    u32_to_le(0,       conf+24); // ref name len
-    if (hts_idx_set_meta(fp->idx, sizeof(conf)*sizeof(*conf), (uint8_t *)conf, 1) < 0) {
-        hts_idx_destroy(fp->idx);
-        fp->idx = NULL;
-        return -1;
-    }
-    fp->fnidx = fnidx;
-
-    return 0;
-}
-
-// Initialise fp->idx for the current format type.
-// This must be called after the header has been written but no other data.
-int bcf_idx_init(htsFile *fp, bcf_hdr_t *h, int min_shift, const char *fnidx) {
-    int n_lvls, nids = 0;
-
-    if (fp->format.format == vcf)
-        return vcf_idx_init(fp, h, min_shift, fnidx);
-
-    if (!min_shift)
-        min_shift = 14;
-
-    n_lvls = idx_calc_n_lvls_ids(h, min_shift, 0, &nids);
-
-    fp->idx = hts_idx_init(nids, HTS_FMT_CSI, bgzf_tell(fp->fp.bgzf), min_shift, n_lvls);
-    if (!fp->idx) return -1;
-    fp->fnidx = fnidx;
-
-    return 0;
-}
-
-// Finishes an index. Call after the last record has been written.
-// Returns 0 on success, <0 on failure.
-//
-// NB: same format as SAM/BAM as it uses bgzf.
-int bcf_idx_save(htsFile *fp) {
-    return sam_idx_save(fp);
-}
-
-/*****************
- *** Utilities ***
- *****************/
-
-int bcf_hdr_combine(bcf_hdr_t *dst, const bcf_hdr_t *src)
-{
-    int i, ndst_ori = dst->nhrec, need_sync = 0, ret = 0, res;
-    for (i=0; i<src->nhrec; i++)
-    {
-        if ( src->hrec[i]->type==BCF_HL_GEN && src->hrec[i]->value )
-        {
-            int j;
-            for (j=0; j<ndst_ori; j++)
-            {
-                if ( dst->hrec[j]->type!=BCF_HL_GEN ) continue;
-
-                // Checking only the key part of generic lines, otherwise
-                // the VCFs are too verbose. Should we perhaps add a flag
-                // to bcf_hdr_combine() and make this optional?
-                if ( !strcmp(src->hrec[i]->key,dst->hrec[j]->key) ) break;
-            }
-            if ( j>=ndst_ori ) {
-                res = bcf_hdr_add_hrec(dst, bcf_hrec_dup(src->hrec[i]));
-                if (res < 0) return -1;
-                need_sync += res;
-            }
-        }
-        else if ( src->hrec[i]->type==BCF_HL_STR )
-        {
-            // NB: we are ignoring fields without ID
-            int j = bcf_hrec_find_key(src->hrec[i],"ID");
-            if ( j>=0 )
-            {
-                bcf_hrec_t *rec = bcf_hdr_get_hrec(dst, src->hrec[i]->type, "ID", src->hrec[i]->vals[j], src->hrec[i]->key);
-                if ( !rec ) {
-                    res = bcf_hdr_add_hrec(dst, bcf_hrec_dup(src->hrec[i]));
-                    if (res < 0) return -1;
-                    need_sync += res;
-                }
-            }
-        }
-        else
-        {
-            int j = bcf_hrec_find_key(src->hrec[i],"ID");
-            assert( j>=0 ); // this should always be true for valid VCFs
-
-            bcf_hrec_t *rec = bcf_hdr_get_hrec(dst, src->hrec[i]->type, "ID", src->hrec[i]->vals[j], NULL);
-            if ( !rec ) {
-                res = bcf_hdr_add_hrec(dst, bcf_hrec_dup(src->hrec[i]));
-                if (res < 0) return -1;
-                need_sync += res;
-            } else if ( src->hrec[i]->type==BCF_HL_INFO || src->hrec[i]->type==BCF_HL_FMT )
-            {
-                // Check that both records are of the same type. The bcf_hdr_id2length
-                // macro cannot be used here because dst header is not synced yet.
-                vdict_t *d_src = (vdict_t*)src->dict[BCF_DT_ID];
-                vdict_t *d_dst = (vdict_t*)dst->dict[BCF_DT_ID];
-                khint_t k_src  = kh_get(vdict, d_src, src->hrec[i]->vals[0]);
-                khint_t k_dst  = kh_get(vdict, d_dst, src->hrec[i]->vals[0]);
-                if ( (kh_val(d_src,k_src).info[rec->type]>>8 & 0xf) != (kh_val(d_dst,k_dst).info[rec->type]>>8 & 0xf) )
-                {
-                    hts_log_warning("Trying to combine \"%s\" tag definitions of different lengths",
-                        src->hrec[i]->vals[0]);
-                    ret |= 1;
-                }
-                if ( (kh_val(d_src,k_src).info[rec->type]>>4 & 0xf) != (kh_val(d_dst,k_dst).info[rec->type]>>4 & 0xf) )
-                {
-                    hts_log_warning("Trying to combine \"%s\" tag definitions of different types",
-                        src->hrec[i]->vals[0]);
-                    ret |= 1;
-                }
-            }
-        }
-    }
-    if ( need_sync ) {
-        if (bcf_hdr_sync(dst) < 0) return -1;
-    }
-    return ret;
-}
-
-bcf_hdr_t *bcf_hdr_merge(bcf_hdr_t *dst, const bcf_hdr_t *src)
-{
-    if ( !dst )
-    {
-        // this will effectively strip existing IDX attributes from src to become dst
-        dst = bcf_hdr_init("r");
-        kstring_t htxt = {0,0,0};
-        if (bcf_hdr_format(src, 0, &htxt) < 0) {
-            free(htxt.s);
-            return NULL;
-        }
-        if ( bcf_hdr_parse(dst, htxt.s) < 0 ) {
-            bcf_hdr_destroy(dst);
-            dst = NULL;
-        }
-        free(htxt.s);
-        return dst;
-    }
-
-    int i, ndst_ori = dst->nhrec, need_sync = 0, ret = 0, res;
-    for (i=0; i<src->nhrec; i++)
-    {
-        if ( src->hrec[i]->type==BCF_HL_GEN && src->hrec[i]->value )
-        {
-            int j;
-            for (j=0; j<ndst_ori; j++)
-            {
-                if ( dst->hrec[j]->type!=BCF_HL_GEN ) continue;
-
-                // Checking only the key part of generic lines, otherwise
-                // the VCFs are too verbose. Should we perhaps add a flag
-                // to bcf_hdr_combine() and make this optional?
-                if ( !strcmp(src->hrec[i]->key,dst->hrec[j]->key) ) break;
-            }
-            if ( j>=ndst_ori ) {
-                res = bcf_hdr_add_hrec(dst, bcf_hrec_dup(src->hrec[i]));
-                if (res < 0) return NULL;
-                need_sync += res;
-            }
-        }
-        else if ( src->hrec[i]->type==BCF_HL_STR )
-        {
-            // NB: we are ignoring fields without ID
-            int j = bcf_hrec_find_key(src->hrec[i],"ID");
-            if ( j>=0 )
-            {
-                bcf_hrec_t *rec = bcf_hdr_get_hrec(dst, src->hrec[i]->type, "ID", src->hrec[i]->vals[j], src->hrec[i]->key);
-                if ( !rec ) {
-                    res = bcf_hdr_add_hrec(dst, bcf_hrec_dup(src->hrec[i]));
-                    if (res < 0) return NULL;
-                    need_sync += res;
-                }
-            }
-        }
-        else
-        {
-            int j = bcf_hrec_find_key(src->hrec[i],"ID");
-            assert( j>=0 ); // this should always be true for valid VCFs
-
-            bcf_hrec_t *rec = bcf_hdr_get_hrec(dst, src->hrec[i]->type, "ID", src->hrec[i]->vals[j], NULL);
-            if ( !rec ) {
-                res = bcf_hdr_add_hrec(dst, bcf_hrec_dup(src->hrec[i]));
-                if (res < 0) return NULL;
-                need_sync += res;
-            } else if ( src->hrec[i]->type==BCF_HL_INFO || src->hrec[i]->type==BCF_HL_FMT )
-            {
-                // Check that both records are of the same type. The bcf_hdr_id2length
-                // macro cannot be used here because dst header is not synced yet.
-                vdict_t *d_src = (vdict_t*)src->dict[BCF_DT_ID];
-                vdict_t *d_dst = (vdict_t*)dst->dict[BCF_DT_ID];
-                khint_t k_src  = kh_get(vdict, d_src, src->hrec[i]->vals[0]);
-                khint_t k_dst  = kh_get(vdict, d_dst, src->hrec[i]->vals[0]);
-                if ( (kh_val(d_src,k_src).info[rec->type]>>8 & 0xf) != (kh_val(d_dst,k_dst).info[rec->type]>>8 & 0xf) )
-                {
-                    hts_log_warning("Trying to combine \"%s\" tag definitions of different lengths",
-                        src->hrec[i]->vals[0]);
-                    ret |= 1;
-                }
-                if ( (kh_val(d_src,k_src).info[rec->type]>>4 & 0xf) != (kh_val(d_dst,k_dst).info[rec->type]>>4 & 0xf) )
-                {
-                    hts_log_warning("Trying to combine \"%s\" tag definitions of different types",
-                        src->hrec[i]->vals[0]);
-                    ret |= 1;
-                }
-            }
-        }
-    }
-    if ( need_sync ) {
-        if (bcf_hdr_sync(dst) < 0) return NULL;
-    }
-    return dst;
-}
-
-int bcf_translate(const bcf_hdr_t *dst_hdr, bcf_hdr_t *src_hdr, bcf1_t *line)
-{
-    int i;
-    if ( line->errcode )
-    {
-        hts_log_error("Unchecked error (%d) at %s:%"PRIhts_pos", exiting", line->errcode, bcf_seqname_safe(src_hdr,line), line->pos+1);
-        exit(1);
-    }
-    if ( src_hdr->ntransl==-1 ) return 0;    // no need to translate, all tags have the same id
-    if ( !src_hdr->ntransl )  // called for the first time, see what needs translating
-    {
-        int dict;
-        for (dict=0; dict<2; dict++)    // BCF_DT_ID and BCF_DT_CTG
-        {
-            src_hdr->transl[dict] = (int*) malloc(src_hdr->n[dict]*sizeof(int));
-            for (i=0; i<src_hdr->n[dict]; i++)
-            {
-                if ( !src_hdr->id[dict][i].key ) // gap left after removed BCF header lines
-                {
-                    src_hdr->transl[dict][i] = -1;
-                    continue;
-                }
-                src_hdr->transl[dict][i] = bcf_hdr_id2int(dst_hdr,dict,src_hdr->id[dict][i].key);
-                if ( src_hdr->transl[dict][i]!=-1 && i!=src_hdr->transl[dict][i] ) src_hdr->ntransl++;
-            }
-        }
-        if ( !src_hdr->ntransl )
-        {
-            free(src_hdr->transl[0]); src_hdr->transl[0] = NULL;
-            free(src_hdr->transl[1]); src_hdr->transl[1] = NULL;
-            src_hdr->ntransl = -1;
-        }
-        if ( src_hdr->ntransl==-1 ) return 0;
-    }
-    bcf_unpack(line,BCF_UN_ALL);
-
-    // CHROM
-    if ( src_hdr->transl[BCF_DT_CTG][line->rid] >=0 ) line->rid = src_hdr->transl[BCF_DT_CTG][line->rid];
-
-    // FILTER
-    for (i=0; i<line->d.n_flt; i++)
-    {
-        int src_id = line->d.flt[i];
-        if ( src_hdr->transl[BCF_DT_ID][src_id] >=0 )
-            line->d.flt[i] = src_hdr->transl[BCF_DT_ID][src_id];
-        line->d.shared_dirty |= BCF1_DIRTY_FLT;
-    }
-
-    // INFO
-    for (i=0; i<line->n_info; i++)
-    {
-        int src_id = line->d.info[i].key;
-        int dst_id = src_hdr->transl[BCF_DT_ID][src_id];
-        if ( dst_id<0 ) continue;
-        line->d.info[i].key = dst_id;
-        if ( !line->d.info[i].vptr ) continue;  // skip deleted
-        int src_size = src_id>>7 ? ( src_id>>15 ? BCF_BT_INT32 : BCF_BT_INT16) : BCF_BT_INT8;
-        int dst_size = dst_id>>7 ? ( dst_id>>15 ? BCF_BT_INT32 : BCF_BT_INT16) : BCF_BT_INT8;
-        if ( src_size==dst_size )   // can overwrite
-        {
-            uint8_t *vptr = line->d.info[i].vptr - line->d.info[i].vptr_off;
-            if ( dst_size==BCF_BT_INT8 ) { vptr[1] = (uint8_t)dst_id; }
-            else if ( dst_size==BCF_BT_INT16 ) { *(uint16_t*)vptr = (uint16_t)dst_id; }
-            else { *(uint32_t*)vptr = (uint32_t)dst_id; }
-        }
-        else    // must realloc
-        {
-            bcf_info_t *info = &line->d.info[i];
-            kstring_t str = {0,0,0};
-            bcf_enc_int1(&str, dst_id);
-            bcf_enc_size(&str, info->len,info->type);
-            uint32_t vptr_off = str.l;
-            kputsn((char*)info->vptr, info->vptr_len, &str);
-            if( info->vptr_free ) free(info->vptr - info->vptr_off);
-            info->vptr_off = vptr_off;
-            info->vptr = (uint8_t*)str.s + info->vptr_off;
-            info->vptr_free = 1;
-            line->d.shared_dirty |= BCF1_DIRTY_INF;
-        }
-    }
-
-    // FORMAT
-    for (i=0; i<line->n_fmt; i++)
-    {
-        int src_id = line->d.fmt[i].id;
-        int dst_id = src_hdr->transl[BCF_DT_ID][src_id];
-        if ( dst_id<0 ) continue;
-        line->d.fmt[i].id = dst_id;
-        if( !line->d.fmt[i].p ) continue;  // skip deleted
-        int src_size = src_id>>7 ? ( src_id>>15 ? BCF_BT_INT32 : BCF_BT_INT16) : BCF_BT_INT8;
-        int dst_size = dst_id>>7 ? ( dst_id>>15 ? BCF_BT_INT32 : BCF_BT_INT16) : BCF_BT_INT8;
-        if ( src_size==dst_size )   // can overwrite
-        {
-            uint8_t *p = line->d.fmt[i].p - line->d.fmt[i].p_off;    // pointer to the vector size (4bits) and BT type (4bits)
-            if ( dst_size==BCF_BT_INT8 ) { p[1] = dst_id; }
-            else if ( dst_size==BCF_BT_INT16 ) { i16_to_le(dst_id, p + 1); }
-            else { i32_to_le(dst_id, p + 1); }
-        }
-        else    // must realloc
-        {
-            bcf_fmt_t *fmt = &line->d.fmt[i];
-            kstring_t str = {0,0,0};
-            bcf_enc_int1(&str, dst_id);
-            bcf_enc_size(&str, fmt->n, fmt->type);
-            uint32_t p_off = str.l;
-            kputsn((char*)fmt->p, fmt->p_len, &str);
-            if( fmt->p_free ) free(fmt->p - fmt->p_off);
-            fmt->p_off = p_off;
-            fmt->p = (uint8_t*)str.s + fmt->p_off;
-            fmt->p_free = 1;
-            line->d.indiv_dirty = 1;
-        }
-    }
-    return 0;
-}
-
-bcf_hdr_t *bcf_hdr_dup(const bcf_hdr_t *hdr)
-{
-    bcf_hdr_t *hout = bcf_hdr_init("r");
-    if (!hout) {
-        hts_log_error("Failed to allocate bcf header");
-        return NULL;
-    }
-    kstring_t htxt = {0,0,0};
-    if (bcf_hdr_format(hdr, 1, &htxt) < 0) {
-        free(htxt.s);
-        return NULL;
-    }
-    if ( bcf_hdr_parse(hout, htxt.s) < 0 ) {
-        bcf_hdr_destroy(hout);
-        hout = NULL;
-    }
-    free(htxt.s);
-    return hout;
-}
-
-bcf_hdr_t *bcf_hdr_subset(const bcf_hdr_t *h0, int n, char *const* samples, int *imap)
-{
-    void *names_hash = khash_str2int_init();
-    kstring_t htxt = {0,0,0};
-    kstring_t str = {0,0,0};
-    bcf_hdr_t *h = bcf_hdr_init("w");
-    int r = 0;
-    if (!h || !names_hash) {
-        hts_log_error("Failed to allocate bcf header");
-        goto err;
-    }
-    if (bcf_hdr_format(h0, 1, &htxt) < 0) {
-        hts_log_error("Failed to get header text");
-        goto err;
-    }
-    bcf_hdr_set_version(h,bcf_hdr_get_version(h0));
-    int j;
-    for (j=0; j<n; j++) imap[j] = -1;
-    if ( bcf_hdr_nsamples(h0) > 0) {
-        char *p = find_chrom_header_line(htxt.s);
-        int i = 0, end = n? 8 : 7;
-        while ((p = strchr(p, '\t')) != 0 && i < end) ++i, ++p;
-        if (i != end) {
-            hts_log_error("Wrong number of columns in header #CHROM line");
-            goto err;
-        }
-        r |= kputsn(htxt.s, p - htxt.s, &str) < 0;
-        for (i = 0; i < n; ++i) {
-            if ( khash_str2int_has_key(names_hash,samples[i]) )
-            {
-                hts_log_error("Duplicate sample name \"%s\"", samples[i]);
-                goto err;
-            }
-            imap[i] = bcf_hdr_id2int(h0, BCF_DT_SAMPLE, samples[i]);
-            if (imap[i] < 0) continue;
-            r |= kputc('\t', &str) < 0;
-            r |= kputs(samples[i], &str) < 0;
-            r |= khash_str2int_inc(names_hash,samples[i]) < 0;
-        }
-    } else r |= kputsn(htxt.s, htxt.l, &str) < 0;
-    while (str.l && (!str.s[str.l-1] || str.s[str.l-1]=='\n') ) str.l--; // kill trailing zeros and newlines
-    r |= kputc('\n',&str) < 0;
-    if (r) {
-        hts_log_error("%s", strerror(errno));
-        goto err;
-    }
-    if ( bcf_hdr_parse(h, str.s) < 0 ) {
-        bcf_hdr_destroy(h);
-        h = NULL;
-    }
-    free(str.s);
-    free(htxt.s);
-    khash_str2int_destroy(names_hash);
-    return h;
-
- err:
-    ks_free(&str);
-    ks_free(&htxt);
-    khash_str2int_destroy(names_hash);
-    bcf_hdr_destroy(h);
-    return NULL;
-}
-
-int bcf_hdr_set_samples(bcf_hdr_t *hdr, const char *samples, int is_file)
-{
-    if ( samples && !strcmp("-",samples) ) return 0;            // keep all samples
-
-    int i, narr = bit_array_size(bcf_hdr_nsamples(hdr));
-    hdr->keep_samples = (uint8_t*) calloc(narr,1);
-    if (!hdr->keep_samples) return -1;
-
-    hdr->nsamples_ori = bcf_hdr_nsamples(hdr);
-    if ( !samples )
-    {
-        // exclude all samples
-        khint_t k;
-        vdict_t *d = (vdict_t*)hdr->dict[BCF_DT_SAMPLE], *new_dict;
-        new_dict = kh_init(vdict);
-        if (!new_dict) return -1;
-
-        bcf_hdr_nsamples(hdr) = 0;
-
-        for (k = kh_begin(d); k != kh_end(d); ++k)
-            if (kh_exist(d, k)) free((char*)kh_key(d, k));
-        kh_destroy(vdict, d);
-        hdr->dict[BCF_DT_SAMPLE] = new_dict;
-        if (bcf_hdr_sync(hdr) < 0) return -1;
-
-        return 0;
-    }
-
-    if ( samples[0]=='^' )
-        for (i=0; i<bcf_hdr_nsamples(hdr); i++) bit_array_set(hdr->keep_samples,i);
-
-    int idx, n, ret = 0;
-    char **smpls = hts_readlist(samples[0]=='^'?samples+1:samples, is_file, &n);
-    if ( !smpls ) return -1;
-    for (i=0; i<n; i++)
-    {
-        idx = bcf_hdr_id2int(hdr,BCF_DT_SAMPLE,smpls[i]);
-        if ( idx<0 )
-        {
-            if ( !ret ) ret = i+1;
-            continue;
-        }
-        assert( idx<bcf_hdr_nsamples(hdr) );
-        if (  samples[0]=='^' )
-            bit_array_clear(hdr->keep_samples, idx);
-        else
-            bit_array_set(hdr->keep_samples, idx);
-    }
-    for (i=0; i<n; i++) free(smpls[i]);
-    free(smpls);
-
-    bcf_hdr_nsamples(hdr) = 0;
-    for (i=0; i<hdr->nsamples_ori; i++)
-        if ( bit_array_test(hdr->keep_samples,i) ) bcf_hdr_nsamples(hdr)++;
-
-    if ( !bcf_hdr_nsamples(hdr) ) { free(hdr->keep_samples); hdr->keep_samples=NULL; }
-    else
-    {
-        // Make new list and dictionary with desired samples
-        char **samples = (char**) malloc(sizeof(char*)*bcf_hdr_nsamples(hdr));
-        vdict_t *new_dict, *d;
-        int k, res;
-        if (!samples) return -1;
-
-        new_dict = kh_init(vdict);
-        if (!new_dict) {
-            free(samples);
-            return -1;
-        }
-        idx = 0;
-        for (i=0; i<hdr->nsamples_ori; i++) {
-            if ( bit_array_test(hdr->keep_samples,i) ) {
-                samples[idx] = hdr->samples[i];
-                k = kh_put(vdict, new_dict, hdr->samples[i], &res);
-                if (res < 0) {
-                    free(samples);
-                    kh_destroy(vdict, new_dict);
-                    return -1;
-                }
-                kh_val(new_dict, k) = bcf_idinfo_def;
-                kh_val(new_dict, k).id = idx;
-                idx++;
-            }
-        }
-
-        // Delete desired samples from old dictionary, so we don't free them
-        d = (vdict_t*)hdr->dict[BCF_DT_SAMPLE];
-        for (i=0; i < idx; i++) {
-            int k = kh_get(vdict, d, samples[i]);
-            if (k < kh_end(d)) kh_del(vdict, d, k);
-        }
-
-        // Free everything else
-        for (k = kh_begin(d); k != kh_end(d); ++k)
-            if (kh_exist(d, k)) free((char*)kh_key(d, k));
-        kh_destroy(vdict, d);
-        hdr->dict[BCF_DT_SAMPLE] = new_dict;
-
-        free(hdr->samples);
-        hdr->samples = samples;
-
-        if (bcf_hdr_sync(hdr) < 0)
-            return -1;
-    }
-
-    return ret;
-}
-
-int bcf_subset(const bcf_hdr_t *h, bcf1_t *v, int n, int *imap)
-{
-    kstring_t ind;
-    ind.s = 0; ind.l = ind.m = 0;
-    if (n) {
-        bcf_fmt_t fmt[MAX_N_FMT];
-        int i, j;
-        uint8_t *ptr = (uint8_t*)v->indiv.s;
-        for (i = 0; i < v->n_fmt; ++i)
-            ptr = bcf_unpack_fmt_core1(ptr, v->n_sample, &fmt[i]);
-        for (i = 0; i < (int)v->n_fmt; ++i) {
-            bcf_fmt_t *f = &fmt[i];
-            bcf_enc_int1(&ind, f->id);
-            bcf_enc_size(&ind, f->n, f->type);
-            for (j = 0; j < n; ++j)
-                if (imap[j] >= 0) kputsn((char*)(f->p + imap[j] * f->size), f->size, &ind);
-        }
-        for (i = j = 0; j < n; ++j) if (imap[j] >= 0) ++i;
-        v->n_sample = i;
-    } else v->n_sample = 0;
-    if ( !v->n_sample ) v->n_fmt = 0;
-    free(v->indiv.s);
-    v->indiv = ind;
-    v->unpacked &= ~BCF_UN_FMT;    // only BCF is ready for output, VCF will need to unpack again
-    return 0;
-}
-
-int bcf_is_snp(bcf1_t *v)
-{
-    int i;
-    bcf_unpack(v, BCF_UN_STR);
-    for (i = 0; i < v->n_allele; ++i)
-    {
-        if ( v->d.allele[i][1]==0 && v->d.allele[i][0]!='*' ) continue;
-
-        // mpileup's <X> allele, see also below. This is not completely satisfactory,
-        // a general library is here narrowly tailored to fit samtools.
-        if ( v->d.allele[i][0]=='<' && v->d.allele[i][1]=='X' && v->d.allele[i][2]=='>' ) continue;
-        if ( v->d.allele[i][0]=='<' && v->d.allele[i][1]=='*' && v->d.allele[i][2]=='>' ) continue;
-
-        break;
-    }
-    return i == v->n_allele;
-}
-
-static void bcf_set_variant_type(const char *ref, const char *alt, bcf_variant_t *var)
-{
-    if ( *alt == '*' && !alt[1] ) { var->n = 0; var->type = VCF_OVERLAP; return; }  // overlapping variant
-
-    // The most frequent case
-    if ( !ref[1] && !alt[1] )
-    {
-        if ( *alt == '.' || *ref==*alt ) { var->n = 0; var->type = VCF_REF; return; }
-        if ( *alt == 'X' ) { var->n = 0; var->type = VCF_REF; return; }  // mpileup's X allele shouldn't be treated as variant
-        var->n = 1; var->type = VCF_SNP; return;
-    }
-    if ( alt[0]=='<' )
-    {
-        if ( alt[1]=='X' && alt[2]=='>' ) { var->n = 0; var->type = VCF_REF; return; }  // mpileup's X allele shouldn't be treated as variant
-        if ( alt[1]=='*' && alt[2]=='>' ) { var->n = 0; var->type = VCF_REF; return; }
-        if ( !strcmp("NON_REF>",alt+1) ) { var->n = 0; var->type = VCF_REF; return; }
-        var->type = VCF_OTHER;
-        return;
-    }
-
-    const char *r = ref, *a = alt;
-    while (*r && *a && toupper_c(*r)==toupper_c(*a) ) { r++; a++; }     // unfortunately, matching REF,ALT case is not guaranteed
-
-    if ( *a && !*r )
-    {
-        if ( *a==']' || *a=='[' ) { var->type = VCF_BND; return; }
-        while ( *a ) a++;
-        var->n = (a-alt)-(r-ref); var->type = VCF_INDEL; return;
-    }
-    else if ( *r && !*a )
-    {
-        while ( *r ) r++;
-        var->n = (a-alt)-(r-ref); var->type = VCF_INDEL; return;
-    }
-    else if ( !*r && !*a )
-    {
-        var->n = 0; var->type = VCF_REF; return;
-    }
-
-    const char *re = r, *ae = a;
-    while ( re[1] ) re++;
-    while ( ae[1] ) ae++;
-    while ( re>r && ae>a && toupper_c(*re)==toupper_c(*ae) ) { re--; ae--; }
-    if ( ae==a )
-    {
-        if ( re==r ) { var->n = 1; var->type = VCF_SNP; return; }
-        var->n = -(re-r);
-        if ( toupper_c(*re)==toupper_c(*ae) ) { var->type = VCF_INDEL; return; }
-        var->type = VCF_OTHER; return;
-    }
-    else if ( re==r )
-    {
-        var->n = ae-a;
-        if ( toupper_c(*re)==toupper_c(*ae) ) { var->type = VCF_INDEL; return; }
-        var->type = VCF_OTHER; return;
-    }
-
-    var->type = ( re-r == ae-a ) ? VCF_MNP : VCF_OTHER;
-    var->n = ( re-r > ae-a ) ? -(re-r+1) : ae-a+1;
-
-    // should do also complex events, SVs, etc...
-}
-
-static int bcf_set_variant_types(bcf1_t *b)
-{
-    if ( !(b->unpacked & BCF_UN_STR) ) bcf_unpack(b, BCF_UN_STR);
-    bcf_dec_t *d = &b->d;
-    if ( d->n_var < b->n_allele )
-    {
-        d->var = (bcf_variant_t *) realloc(d->var, sizeof(bcf_variant_t)*b->n_allele);
-        d->n_var = b->n_allele;
-    }
-    int i;
-    b->d.var_type = 0;
-    d->var[0].type = VCF_REF;
-    d->var[0].n    = 0;
-    for (i=1; i<b->n_allele; i++)
-    {
-        bcf_set_variant_type(d->allele[0],d->allele[i], &d->var[i]);
-        b->d.var_type |= d->var[i].type;
-        //fprintf(stderr,"[set_variant_type] %d   %s %s -> %d %d .. %d\n", b->pos+1,d->allele[0],d->allele[i],d->var[i].type,d->var[i].n, b->d.var_type);
-    }
-    return 0;
-}
-
-int bcf_get_variant_types(bcf1_t *rec)
-{
-    if ( rec->d.var_type==-1 ) bcf_set_variant_types(rec);
-    return rec->d.var_type;
-}
-int bcf_get_variant_type(bcf1_t *rec, int ith_allele)
-{
-    if ( rec->d.var_type==-1 ) bcf_set_variant_types(rec);
-    return rec->d.var[ith_allele].type;
-}
-
-int bcf_update_info(const bcf_hdr_t *hdr, bcf1_t *line, const char *key, const void *values, int n, int type)
-{
-    static int negative_rlen_warned = 0;
-    int is_end_tag;
-
-    // Is the field already present?
-    int i, inf_id = bcf_hdr_id2int(hdr,BCF_DT_ID,key);
-    if ( !bcf_hdr_idinfo_exists(hdr,BCF_HL_INFO,inf_id) ) return -1;    // No such INFO field in the header
-    if ( !(line->unpacked & BCF_UN_INFO) ) bcf_unpack(line, BCF_UN_INFO);
-
-    is_end_tag = strcmp(key, "END") == 0;
-
-    for (i=0; i<line->n_info; i++)
-        if ( inf_id==line->d.info[i].key ) break;
-    bcf_info_t *inf = i==line->n_info ? NULL : &line->d.info[i];
-
-    if ( !n || (type==BCF_HT_STR && !values) )
-    {
-        if ( n==0 && is_end_tag )
-            line->rlen = line->n_allele ? strlen(line->d.allele[0]) : 0;
-        if ( inf )
-        {
-            // Mark the tag for removal, free existing memory if necessary
-            if ( inf->vptr_free )
-            {
-                free(inf->vptr - inf->vptr_off);
-                inf->vptr_free = 0;
-            }
-            line->d.shared_dirty |= BCF1_DIRTY_INF;
-            inf->vptr = NULL;
-            inf->vptr_off = inf->vptr_len = 0;
-        }
-        return 0;
-    }
-
-    if (is_end_tag)
-    {
-        if (n != 1)
-        {
-            hts_log_error("END info tag should only have one value at %s:%"PRIhts_pos, bcf_seqname_safe(hdr,line), line->pos+1);
-            line->errcode |= BCF_ERR_TAG_INVALID;
-            return -1;
-        }
-        if (type != BCF_HT_INT && type != BCF_HT_LONG)
-        {
-            hts_log_error("Wrong type (%d) for END info tag at %s:%"PRIhts_pos, type, bcf_seqname_safe(hdr,line), line->pos+1);
-            line->errcode |= BCF_ERR_TAG_INVALID;
-            return -1;
-        }
-    }
-
-    // Encode the values and determine the size required to accommodate the values
-    kstring_t str = {0,0,0};
-    bcf_enc_int1(&str, inf_id);
-    if ( type==BCF_HT_INT )
-        bcf_enc_vint(&str, n, (int32_t*)values, -1);
-    else if ( type==BCF_HT_REAL )
-        bcf_enc_vfloat(&str, n, (float*)values);
-    else if ( type==BCF_HT_FLAG || type==BCF_HT_STR )
-    {
-        if ( values==NULL )
-            bcf_enc_size(&str, 0, BCF_BT_NULL);
-        else
-            bcf_enc_vchar(&str, strlen((char*)values), (char*)values);
-    }
-#ifdef VCF_ALLOW_INT64
-    else if ( type==BCF_HT_LONG )
-    {
-        if (n != 1) {
-            hts_log_error("Only storing a single BCF_HT_LONG value is supported at %s:%"PRIhts_pos, bcf_seqname_safe(hdr,line), line->pos+1);
-            abort();
-        }
-        bcf_enc_long1(&str, *(int64_t *) values);
-    }
-#endif
-    else
-    {
-        hts_log_error("The type %d not implemented yet at %s:%"PRIhts_pos, type, bcf_seqname_safe(hdr,line), line->pos+1);
-        abort();
-    }
-
-    // Is the INFO tag already present
-    if ( inf )
-    {
-        // Is it big enough to accommodate new block?
-        if ( inf->vptr && str.l <= inf->vptr_len + inf->vptr_off )
-        {
-            if ( str.l != inf->vptr_len + inf->vptr_off ) line->d.shared_dirty |= BCF1_DIRTY_INF;
-            uint8_t *ptr = inf->vptr - inf->vptr_off;
-            memcpy(ptr, str.s, str.l);
-            free(str.s);
-            int vptr_free = inf->vptr_free;
-            bcf_unpack_info_core1(ptr, inf);
-            inf->vptr_free = vptr_free;
-        }
-        else
-        {
-            if ( inf->vptr_free )
-                free(inf->vptr - inf->vptr_off);
-            bcf_unpack_info_core1((uint8_t*)str.s, inf);
-            inf->vptr_free = 1;
-            line->d.shared_dirty |= BCF1_DIRTY_INF;
-        }
-    }
-    else
-    {
-        // The tag is not present, create new one
-        line->n_info++;
-        hts_expand0(bcf_info_t, line->n_info, line->d.m_info , line->d.info);
-        inf = &line->d.info[line->n_info-1];
-        bcf_unpack_info_core1((uint8_t*)str.s, inf);
-        inf->vptr_free = 1;
-        line->d.shared_dirty |= BCF1_DIRTY_INF;
-    }
-    line->unpacked |= BCF_UN_INFO;
-
-   if ( n==1 && is_end_tag) {
-        hts_pos_t end = type == BCF_HT_INT ? *(int32_t *) values : *(int64_t *) values;
-        if ( (type == BCF_HT_INT && end!=bcf_int32_missing) || (type == BCF_HT_LONG && end!=bcf_int64_missing) )
-        {
-            if ( end <= line->pos )
-            {
-                if ( !negative_rlen_warned )
-                {
-                    hts_log_warning("INFO/END=%"PRIhts_pos" is smaller than POS at %s:%"PRIhts_pos,end,bcf_seqname_safe(hdr,line),line->pos+1);
-                    negative_rlen_warned = 1;
-                }
-                line->rlen = line->n_allele ? strlen(line->d.allele[0]) : 0;
-            }
-            else
-                line->rlen = end - line->pos;
-        }
-    }
-    return 0;
-}
-
-int bcf_update_format_string(const bcf_hdr_t *hdr, bcf1_t *line, const char *key, const char **values, int n)
-{
-    if ( !n )
-        return bcf_update_format(hdr,line,key,NULL,0,BCF_HT_STR);
-
-    int i, max_len = 0;
-    for (i=0; i<n; i++)
-    {
-        int len = strlen(values[i]);
-        if ( len > max_len ) max_len = len;
-    }
-    char *out = (char*) malloc(max_len*n);
-    if ( !out ) return -2;
-    for (i=0; i<n; i++)
-    {
-        char *dst = out+i*max_len;
-        const char *src = values[i];
-        int j = 0;
-        while ( src[j] ) { dst[j] = src[j]; j++; }
-        for (; j<max_len; j++) dst[j] = 0;
-    }
-    int ret = bcf_update_format(hdr,line,key,out,max_len*n,BCF_HT_STR);
-    free(out);
-    return ret;
-}
-
-int bcf_update_format(const bcf_hdr_t *hdr, bcf1_t *line, const char *key, const void *values, int n, int type)
-{
-    // Is the field already present?
-    int i, fmt_id = bcf_hdr_id2int(hdr,BCF_DT_ID,key);
-    if ( !bcf_hdr_idinfo_exists(hdr,BCF_HL_FMT,fmt_id) )
-    {
-        if ( !n ) return 0;
-        return -1;  // the key not present in the header
-    }
-
-    if ( !(line->unpacked & BCF_UN_FMT) ) bcf_unpack(line, BCF_UN_FMT);
-
-    for (i=0; i<line->n_fmt; i++)
-        if ( line->d.fmt[i].id==fmt_id ) break;
-    bcf_fmt_t *fmt = i==line->n_fmt ? NULL : &line->d.fmt[i];
-
-    if ( !n )
-    {
-        if ( fmt )
-        {
-            // Mark the tag for removal, free existing memory if necessary
-            if ( fmt->p_free )
-            {
-                free(fmt->p - fmt->p_off);
-                fmt->p_free = 0;
-            }
-            line->d.indiv_dirty = 1;
-            fmt->p = NULL;
-        }
-        return 0;
-    }
-
-    line->n_sample = bcf_hdr_nsamples(hdr);
-    int nps = n / line->n_sample;  // number of values per sample
-    assert( nps && nps*line->n_sample==n );     // must be divisible by n_sample
-
-    // Encode the values and determine the size required to accommodate the values
-    kstring_t str = {0,0,0};
-    bcf_enc_int1(&str, fmt_id);
-    assert(values != NULL);
-    if ( type==BCF_HT_INT )
-        bcf_enc_vint(&str, n, (int32_t*)values, nps);
-    else if ( type==BCF_HT_REAL )
-    {
-        bcf_enc_size(&str, nps, BCF_BT_FLOAT);
-        serialize_float_array(&str, nps*line->n_sample, (float *) values);
-    }
-    else if ( type==BCF_HT_STR )
-    {
-        bcf_enc_size(&str, nps, BCF_BT_CHAR);
-        kputsn((char*)values, nps*line->n_sample, &str);
-    }
-    else
-    {
-        hts_log_error("The type %d not implemented yet at %s:%"PRIhts_pos, type, bcf_seqname_safe(hdr,line), line->pos+1);
-        abort();
-    }
-
-    if ( !fmt )
-    {
-        // Not present, new format field
-        line->n_fmt++;
-        hts_expand0(bcf_fmt_t, line->n_fmt, line->d.m_fmt, line->d.fmt);
-
-        // Special case: VCF specification requires that GT is always first
-        if ( line->n_fmt > 1 && key[0]=='G' && key[1]=='T' && !key[2] )
-        {
-            for (i=line->n_fmt-1; i>0; i--)
-                line->d.fmt[i] = line->d.fmt[i-1];
-            fmt = &line->d.fmt[0];
-        }
-        else
-            fmt = &line->d.fmt[line->n_fmt-1];
-        bcf_unpack_fmt_core1((uint8_t*)str.s, line->n_sample, fmt);
-        line->d.indiv_dirty = 1;
-        fmt->p_free = 1;
-    }
-    else
-    {
-        // The tag is already present, check if it is big enough to accommodate the new block
-        if ( fmt->p && str.l <= fmt->p_len + fmt->p_off )
-        {
-            // good, the block is big enough
-            if ( str.l != fmt->p_len + fmt->p_off ) line->d.indiv_dirty = 1;
-            uint8_t *ptr = fmt->p - fmt->p_off;
-            memcpy(ptr, str.s, str.l);
-            free(str.s);
-            int p_free = fmt->p_free;
-            bcf_unpack_fmt_core1(ptr, line->n_sample, fmt);
-            fmt->p_free = p_free;
-        }
-        else
-        {
-            if ( fmt->p_free )
-                free(fmt->p - fmt->p_off);
-            bcf_unpack_fmt_core1((uint8_t*)str.s, line->n_sample, fmt);
-            fmt->p_free = 1;
-            line->d.indiv_dirty = 1;
-        }
-    }
-    line->unpacked |= BCF_UN_FMT;
-    return 0;
-}
-
-
-int bcf_update_filter(const bcf_hdr_t *hdr, bcf1_t *line, int *flt_ids, int n)
-{
-    if ( !(line->unpacked & BCF_UN_FLT) ) bcf_unpack(line, BCF_UN_FLT);
-    line->d.shared_dirty |= BCF1_DIRTY_FLT;
-    line->d.n_flt = n;
-    if ( !n ) return 0;
-    hts_expand(int, line->d.n_flt, line->d.m_flt, line->d.flt);
-    int i;
-    for (i=0; i<n; i++)
-        line->d.flt[i] = flt_ids[i];
-    return 0;
-}
-
-int bcf_add_filter(const bcf_hdr_t *hdr, bcf1_t *line, int flt_id)
-{
-    if ( !(line->unpacked & BCF_UN_FLT) ) bcf_unpack(line, BCF_UN_FLT);
-    int i;
-    for (i=0; i<line->d.n_flt; i++)
-        if ( flt_id==line->d.flt[i] ) break;
-    if ( i<line->d.n_flt ) return 0;    // this filter is already set
-    line->d.shared_dirty |= BCF1_DIRTY_FLT;
-    if ( flt_id==0 )    // set to PASS
-        line->d.n_flt = 1;
-    else if ( line->d.n_flt==1 && line->d.flt[0]==0 )
-        line->d.n_flt = 1;
-    else
-        line->d.n_flt++;
-    hts_expand(int, line->d.n_flt, line->d.m_flt, line->d.flt);
-    line->d.flt[line->d.n_flt-1] = flt_id;
-    return 1;
-}
-int bcf_remove_filter(const bcf_hdr_t *hdr, bcf1_t *line, int flt_id, int pass)
-{
-    if ( !(line->unpacked & BCF_UN_FLT) ) bcf_unpack(line, BCF_UN_FLT);
-    int i;
-    for (i=0; i<line->d.n_flt; i++)
-        if ( flt_id==line->d.flt[i] ) break;
-    if ( i==line->d.n_flt ) return 0;   // the filter is not present
-    line->d.shared_dirty |= BCF1_DIRTY_FLT;
-    if ( i!=line->d.n_flt-1 ) memmove(line->d.flt+i,line->d.flt+i+1,(line->d.n_flt-i-1)*sizeof(*line->d.flt));
-    line->d.n_flt--;
-    if ( !line->d.n_flt && pass ) bcf_add_filter(hdr,line,0);
-    return 0;
-}
-
-int bcf_has_filter(const bcf_hdr_t *hdr, bcf1_t *line, char *filter)
-{
-    if ( filter[0]=='.' && !filter[1] ) filter = "PASS";
-    int id = bcf_hdr_id2int(hdr, BCF_DT_ID, filter);
-    if ( !bcf_hdr_idinfo_exists(hdr,BCF_HL_FLT,id) ) return -1;  // not defined in the header
-
-    if ( !(line->unpacked & BCF_UN_FLT) ) bcf_unpack(line, BCF_UN_FLT);
-    if ( id==0 && !line->d.n_flt) return 1; // PASS
-
-    int i;
-    for (i=0; i<line->d.n_flt; i++)
-        if ( line->d.flt[i]==id ) return 1;
-    return 0;
-}
-
-static inline int _bcf1_sync_alleles(const bcf_hdr_t *hdr, bcf1_t *line, int nals)
-{
-    line->d.shared_dirty |= BCF1_DIRTY_ALS;
-
-    line->n_allele = nals;
-    hts_expand(char*, line->n_allele, line->d.m_allele, line->d.allele);
-
-    char *als = line->d.als;
-    int n = 0;
-    while (n<nals)
-    {
-        line->d.allele[n] = als;
-        while ( *als ) als++;
-        als++;
-        n++;
-    }
-
-    // Update REF length. Note that END is 1-based while line->pos 0-based
-    bcf_info_t *end_info = bcf_get_info(hdr,line,"END");
-    if ( end_info )
-    {
-        if ( end_info->type==BCF_HT_INT && end_info->v1.i==bcf_int32_missing ) end_info = NULL;
-        else if ( end_info->type==BCF_HT_LONG && end_info->v1.i==bcf_int64_missing ) end_info = NULL;
-    }
-    if ( end_info && end_info->v1.i > line->pos )
-        line->rlen = end_info->v1.i - line->pos;
-    else if ( nals > 0 )
-        line->rlen = strlen(line->d.allele[0]);
-    else
-        line->rlen = 0;
-
-    return 0;
-}
-int bcf_update_alleles(const bcf_hdr_t *hdr, bcf1_t *line, const char **alleles, int nals)
-{
-    if ( !(line->unpacked & BCF_UN_STR) ) bcf_unpack(line, BCF_UN_STR);
-    char *free_old = NULL;
-    char buffer[256];
-    size_t used = 0;
-
-    // The pointers in alleles may point into the existing line->d.als memory,
-    // so care needs to be taken not to clobber them while updating.  Usually
-    // they will be short so we can copy through an intermediate buffer.
-    // If they're longer, or won't fit in the existing allocation we
-    // can allocate a new buffer to write into.  Note that in either case
-    // pointers to line->d.als memory in alleles may not be valid when we've
-    // finished.
-    int i;
-    size_t avail = line->d.m_als < sizeof(buffer) ? line->d.m_als : sizeof(buffer);
-    for (i=0; i<nals; i++) {
-        size_t sz = strlen(alleles[i]) + 1;
-        if (avail - used < sz)
-            break;
-        memcpy(buffer + used, alleles[i], sz);
-        used += sz;
-    }
-
-    // Did we miss anything?
-    if (i < nals) {
-        int j;
-        size_t needed = used;
-        char *new_als;
-        for (j = i; j < nals; j++)
-            needed += strlen(alleles[j]) + 1;
-        if (needed < line->d.m_als) // Don't shrink the buffer
-            needed = line->d.m_als;
-        if (needed > INT_MAX) {
-            hts_log_error("REF + alleles too long to fit in a BCF record");
-            return -1;
-        }
-        new_als = malloc(needed);
-        if (!new_als)
-            return -1;
-        free_old = line->d.als;
-        line->d.als = new_als;
-        line->d.m_als = needed;
-    }
-
-    // Copy from the temp buffer to the destination
-    if (used) {
-        assert(used <= line->d.m_als);
-        memcpy(line->d.als, buffer, used);
-    }
-
-    // Add in any remaining entries - if this happens we will always be
-    // writing to a newly-allocated buffer.
-    for (; i < nals; i++) {
-        size_t sz = strlen(alleles[i]) + 1;
-        memcpy(line->d.als + used, alleles[i], sz);
-        used += sz;
-    }
-
-    if (free_old)
-        free(free_old);
-    return _bcf1_sync_alleles(hdr,line,nals);
-}
-
-int bcf_update_alleles_str(const bcf_hdr_t *hdr, bcf1_t *line, const char *alleles_string)
-{
-    if ( !(line->unpacked & BCF_UN_STR) ) bcf_unpack(line, BCF_UN_STR);
-    kstring_t tmp;
-    tmp.l = 0; tmp.s = line->d.als; tmp.m = line->d.m_als;
-    kputs(alleles_string, &tmp);
-    line->d.als = tmp.s; line->d.m_als = tmp.m;
-
-    int nals = 1;
-    char *t = line->d.als;
-    while (*t)
-    {
-        if ( *t==',' ) { *t = 0; nals++; }
-        t++;
-    }
-    return _bcf1_sync_alleles(hdr, line, nals);
-}
-
-int bcf_update_id(const bcf_hdr_t *hdr, bcf1_t *line, const char *id)
-{
-    if ( !(line->unpacked & BCF_UN_STR) ) bcf_unpack(line, BCF_UN_STR);
-    kstring_t tmp;
-    tmp.l = 0; tmp.s = line->d.id; tmp.m = line->d.m_id;
-    if ( id )
-        kputs(id, &tmp);
-    else
-        kputs(".", &tmp);
-    line->d.id = tmp.s; line->d.m_id = tmp.m;
-    line->d.shared_dirty |= BCF1_DIRTY_ID;
-    return 0;
-}
-
-int bcf_add_id(const bcf_hdr_t *hdr, bcf1_t *line, const char *id)
-{
-    if ( !id ) return 0;
-    if ( !(line->unpacked & BCF_UN_STR) ) bcf_unpack(line, BCF_UN_STR);
-
-    kstring_t tmp;
-    tmp.l = 0; tmp.s = line->d.id; tmp.m = line->d.m_id;
-
-    int len = strlen(id);
-    char *dst = line->d.id;
-    while ( *dst && (dst=strstr(dst,id)) )
-    {
-        if ( dst[len]!=0 && dst[len]!=';' ) dst++;              // a prefix, not a match
-        else if ( dst==line->d.id || dst[-1]==';' ) return 0;   // already present
-        dst++;  // a suffix, not a match
-    }
-    if ( line->d.id && (line->d.id[0]!='.' || line->d.id[1]) )
-    {
-        tmp.l = strlen(line->d.id);
-        kputc(';',&tmp);
-    }
-    kputs(id,&tmp);
-
-    line->d.id = tmp.s; line->d.m_id = tmp.m;
-    line->d.shared_dirty |= BCF1_DIRTY_ID;
-    return 0;
-
-}
-
-bcf_fmt_t *bcf_get_fmt(const bcf_hdr_t *hdr, bcf1_t *line, const char *key)
-{
-    int id = bcf_hdr_id2int(hdr, BCF_DT_ID, key);
-    if ( !bcf_hdr_idinfo_exists(hdr,BCF_HL_FMT,id) ) return NULL;   // no such FMT field in the header
-    return bcf_get_fmt_id(line, id);
-}
-
-bcf_info_t *bcf_get_info(const bcf_hdr_t *hdr, bcf1_t *line, const char *key)
-{
-    int id = bcf_hdr_id2int(hdr, BCF_DT_ID, key);
-    if ( !bcf_hdr_idinfo_exists(hdr,BCF_HL_INFO,id) ) return NULL;   // no such INFO field in the header
-    return bcf_get_info_id(line, id);
-}
-
-bcf_fmt_t *bcf_get_fmt_id(bcf1_t *line, const int id)
-{
-    int i;
-    if ( !(line->unpacked & BCF_UN_FMT) ) bcf_unpack(line, BCF_UN_FMT);
-    for (i=0; i<line->n_fmt; i++)
-    {
-        if ( line->d.fmt[i].id==id ) return &line->d.fmt[i];
-    }
-    return NULL;
-}
-
-bcf_info_t *bcf_get_info_id(bcf1_t *line, const int id)
-{
-    int i;
-    if ( !(line->unpacked & BCF_UN_INFO) ) bcf_unpack(line, BCF_UN_INFO);
-    for (i=0; i<line->n_info; i++)
-    {
-        if ( line->d.info[i].key==id ) return &line->d.info[i];
-    }
-    return NULL;
-}
-
-
-int bcf_get_info_values(const bcf_hdr_t *hdr, bcf1_t *line, const char *tag, void **dst, int *ndst, int type)
-{
-    int i, ret = -4, tag_id = bcf_hdr_id2int(hdr, BCF_DT_ID, tag);
-    if ( !bcf_hdr_idinfo_exists(hdr,BCF_HL_INFO,tag_id) ) return -1;    // no such INFO field in the header
-    if ( bcf_hdr_id2type(hdr,BCF_HL_INFO,tag_id)!=(type & 0xff) ) return -2;     // expected different type
-
-    if ( !(line->unpacked & BCF_UN_INFO) ) bcf_unpack(line, BCF_UN_INFO);
-
-    for (i=0; i<line->n_info; i++)
-        if ( line->d.info[i].key==tag_id ) break;
-    if ( i==line->n_info ) return ( type==BCF_HT_FLAG ) ? 0 : -3;       // the tag is not present in this record
-    if ( type==BCF_HT_FLAG ) return 1;
-
-    bcf_info_t *info = &line->d.info[i];
-    if ( !info->vptr ) return -3;           // the tag was marked for removal
-    if ( type==BCF_HT_STR )
-    {
-        if ( *ndst < info->len+1 )
-        {
-            *ndst = info->len + 1;
-            *dst  = realloc(*dst, *ndst);
-        }
-        memcpy(*dst,info->vptr,info->len);
-        ((uint8_t*)*dst)[info->len] = 0;
-        return info->len;
-    }
-
-    // Make sure the buffer is big enough
-    int size1;
-    switch (type) {
-        case BCF_HT_INT:  size1 = sizeof(int32_t); break;
-        case BCF_HT_LONG: size1 = sizeof(int64_t); break;
-        case BCF_HT_REAL: size1 = sizeof(float); break;
-        default:
-            hts_log_error("Unexpected output type %d at %s:%"PRIhts_pos, type, bcf_seqname_safe(hdr,line), line->pos+1);
-            return -2;
-    }
-    if ( *ndst < info->len )
-    {
-        *ndst = info->len;
-        *dst  = realloc(*dst, *ndst * size1);
-    }
-
-    #define BRANCH(type_t, convert, is_missing, is_vector_end, set_missing, set_regular, out_type_t) do { \
-        out_type_t *tmp = (out_type_t *) *dst; \
-        int j; \
-        for (j=0; j<info->len; j++) \
-        { \
-            type_t p = convert(info->vptr + j * sizeof(type_t)); \
-            if ( is_vector_end ) break; \
-            if ( is_missing ) set_missing; \
-            else set_regular; \
-            tmp++; \
-        } \
-        ret = j; \
-    } while (0)
-    switch (info->type) {
-        case BCF_BT_INT8:
-            if (type == BCF_HT_LONG) {
-                BRANCH(int8_t,  le_to_i8,  p==bcf_int8_missing,  p==bcf_int8_vector_end,  *tmp=bcf_int64_missing, *tmp=p, int64_t);
-            } else {
-                BRANCH(int8_t,  le_to_i8,  p==bcf_int8_missing,  p==bcf_int8_vector_end,  *tmp=bcf_int32_missing, *tmp=p, int32_t);
-            }
-            break;
-        case BCF_BT_INT16:
-            if (type == BCF_HT_LONG) {
-                BRANCH(int16_t, le_to_i16, p==bcf_int16_missing, p==bcf_int16_vector_end, *tmp=bcf_int64_missing, *tmp=p, int64_t);
-            } else {
-                BRANCH(int16_t, le_to_i16, p==bcf_int16_missing, p==bcf_int16_vector_end, *tmp=bcf_int32_missing, *tmp=p, int32_t);
-            }
-            break;
-        case BCF_BT_INT32:
-            if (type == BCF_HT_LONG) {
-                BRANCH(int32_t, le_to_i32, p==bcf_int32_missing, p==bcf_int32_vector_end, *tmp=bcf_int64_missing, *tmp=p, int64_t); break;
-            } else {
-                BRANCH(int32_t, le_to_i32, p==bcf_int32_missing, p==bcf_int32_vector_end, *tmp=bcf_int32_missing, *tmp=p, int32_t); break;
-            }
-        case BCF_BT_FLOAT: BRANCH(uint32_t, le_to_u32, p==bcf_float_missing, p==bcf_float_vector_end, bcf_float_set_missing(*tmp), bcf_float_set(tmp, p), float); break;
-        default: hts_log_error("Unexpected type %d at %s:%"PRIhts_pos, info->type, bcf_seqname_safe(hdr,line), line->pos+1); return -2;
-    }
-    #undef BRANCH
-    return ret;  // set by BRANCH
-}
-
-int bcf_get_format_string(const bcf_hdr_t *hdr, bcf1_t *line, const char *tag, char ***dst, int *ndst)
-{
-    int i,tag_id = bcf_hdr_id2int(hdr, BCF_DT_ID, tag);
-    if ( !bcf_hdr_idinfo_exists(hdr,BCF_HL_FMT,tag_id) ) return -1;    // no such FORMAT field in the header
-    if ( bcf_hdr_id2type(hdr,BCF_HL_FMT,tag_id)!=BCF_HT_STR ) return -2;     // expected different type
-
-    if ( !(line->unpacked & BCF_UN_FMT) ) bcf_unpack(line, BCF_UN_FMT);
-
-    for (i=0; i<line->n_fmt; i++)
-        if ( line->d.fmt[i].id==tag_id ) break;
-    if ( i==line->n_fmt ) return -3;                               // the tag is not present in this record
-    bcf_fmt_t *fmt = &line->d.fmt[i];
-    if ( !fmt->p ) return -3;                                      // the tag was marked for removal
-
-    int nsmpl = bcf_hdr_nsamples(hdr);
-    if ( !*dst )
-    {
-        *dst = (char**) malloc(sizeof(char*)*nsmpl);
-        if ( !*dst ) return -4;     // could not alloc
-        (*dst)[0] = NULL;
-    }
-    int n = (fmt->n+1)*nsmpl;
-    if ( *ndst < n )
-    {
-        (*dst)[0] = realloc((*dst)[0], n);
-        if ( !(*dst)[0] ) return -4;    // could not alloc
-        *ndst = n;
-    }
-    for (i=0; i<nsmpl; i++)
-    {
-        uint8_t *src = fmt->p + i*fmt->n;
-        uint8_t *tmp = (uint8_t*)(*dst)[0] + i*(fmt->n+1);
-        memcpy(tmp,src,fmt->n);
-        tmp[fmt->n] = 0;
-        (*dst)[i] = (char*) tmp;
-    }
-    return n;
-}
-
-int bcf_get_format_values(const bcf_hdr_t *hdr, bcf1_t *line, const char *tag, void **dst, int *ndst, int type)
-{
-    int i,j, tag_id = bcf_hdr_id2int(hdr, BCF_DT_ID, tag);
-    if ( !bcf_hdr_idinfo_exists(hdr,BCF_HL_FMT,tag_id) ) return -1;    // no such FORMAT field in the header
-    if ( tag[0]=='G' && tag[1]=='T' && tag[2]==0 )
-    {
-        // Ugly: GT field is considered to be a string by the VCF header but BCF represents it as INT.
-        if ( bcf_hdr_id2type(hdr,BCF_HL_FMT,tag_id)!=BCF_HT_STR ) return -2;
-    }
-    else if ( bcf_hdr_id2type(hdr,BCF_HL_FMT,tag_id)!=type ) return -2;     // expected different type
-
-    if ( !(line->unpacked & BCF_UN_FMT) ) bcf_unpack(line, BCF_UN_FMT);
-
-    for (i=0; i<line->n_fmt; i++)
-        if ( line->d.fmt[i].id==tag_id ) break;
-    if ( i==line->n_fmt ) return -3;                               // the tag is not present in this record
-    bcf_fmt_t *fmt = &line->d.fmt[i];
-    if ( !fmt->p ) return -3;                                      // the tag was marked for removal
-
-    if ( type==BCF_HT_STR )
-    {
-        int n = fmt->n*bcf_hdr_nsamples(hdr);
-        if ( *ndst < n )
-        {
-            *dst  = realloc(*dst, n);
-            if ( !*dst ) return -4;     // could not alloc
-            *ndst = n;
-        }
-        memcpy(*dst,fmt->p,n);
-        return n;
-    }
-
-    // Make sure the buffer is big enough
-    int nsmpl = bcf_hdr_nsamples(hdr);
-    int size1 = type==BCF_HT_INT ? sizeof(int32_t) : sizeof(float);
-    if ( *ndst < fmt->n*nsmpl )
-    {
-        *ndst = fmt->n*nsmpl;
-        *dst  = realloc(*dst, *ndst*size1);
-        if ( !*dst ) return -4;     // could not alloc
-    }
-
-    #define BRANCH(type_t, convert, is_missing, is_vector_end, set_missing, set_vector_end, set_regular, out_type_t) { \
-        out_type_t *tmp = (out_type_t *) *dst; \
-        uint8_t *fmt_p = fmt->p; \
-        for (i=0; i<nsmpl; i++) \
-        { \
-            for (j=0; j<fmt->n; j++) \
-            { \
-                type_t p = convert(fmt_p + j * sizeof(type_t)); \
-                if ( is_missing ) set_missing; \
-                else if ( is_vector_end ) { set_vector_end; break; } \
-                else set_regular; \
-                tmp++; \
-            } \
-            for (; j<fmt->n; j++) { set_vector_end; tmp++; } \
-            fmt_p += fmt->size; \
-        } \
-    }
-    switch (fmt->type) {
-        case BCF_BT_INT8:  BRANCH(int8_t,  le_to_i8, p==bcf_int8_missing,  p==bcf_int8_vector_end,  *tmp=bcf_int32_missing, *tmp=bcf_int32_vector_end, *tmp=p, int32_t); break;
-        case BCF_BT_INT16: BRANCH(int16_t, le_to_i16, p==bcf_int16_missing, p==bcf_int16_vector_end, *tmp=bcf_int32_missing, *tmp=bcf_int32_vector_end, *tmp=p, int32_t); break;
-        case BCF_BT_INT32: BRANCH(int32_t, le_to_i32, p==bcf_int32_missing, p==bcf_int32_vector_end, *tmp=bcf_int32_missing, *tmp=bcf_int32_vector_end, *tmp=p, int32_t); break;
-        case BCF_BT_FLOAT: BRANCH(uint32_t, le_to_u32, p==bcf_float_missing, p==bcf_float_vector_end, bcf_float_set_missing(*tmp), bcf_float_set_vector_end(*tmp), bcf_float_set(tmp, p), float); break;
-        default: hts_log_error("Unexpected type %d at %s:%"PRIhts_pos, fmt->type, bcf_seqname_safe(hdr,line), line->pos+1); exit(1);
-    }
-    #undef BRANCH
-    return nsmpl*fmt->n;
-}
diff -ruN stringtie.orig/htslib/vcf_sweep.c stringtie/htslib/vcf_sweep.c
--- stringtie.orig/htslib/vcf_sweep.c	2024-02-28 13:57:39.701246126 +0100
+++ stringtie/htslib/vcf_sweep.c	1970-01-01 01:00:00.000000000 +0100
@@ -1,190 +0,0 @@
-/*  vcf_sweep.c -- forward/reverse sweep API.
-
-    Copyright (C) 2013-2014, 2019 Genome Research Ltd.
-
-    Author: Petr Danecek <pd3@sanger.ac.uk>
-
-Permission is hereby granted, free of charge, to any person obtaining a copy
-of this software and associated documentation files (the "Software"), to deal
-in the Software without restriction, including without limitation the rights
-to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
-copies of the Software, and to permit persons to whom the Software is
-furnished to do so, subject to the following conditions:
-
-The above copyright notice and this permission notice shall be included in
-all copies or substantial portions of the Software.
-
-THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
-IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
-FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
-THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
-LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
-FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
-DEALINGS IN THE SOFTWARE.  */
-
-#define HTS_BUILDING_LIBRARY // Enables HTSLIB_EXPORT, see htslib/hts_defs.h
-#include <config.h>
-
-#include <assert.h>
-
-#include "htslib/vcf_sweep.h"
-#include "htslib/bgzf.h"
-
-#define SW_FWD 0
-#define SW_BWD 1
-
-struct bcf_sweep_t
-{
-    htsFile *file;
-    bcf_hdr_t *hdr;
-    BGZF *fp;
-
-    int direction;          // to tell if the direction has changed
-    int block_size;         // the size of uncompressed data to hold in memory
-    bcf1_t *rec;            // bcf buffer
-    int nrec, mrec;         // number of used records; total size of the buffer
-    int lrid, lpos, lnals, lals_len, mlals;   // to check uniqueness of a record
-    char *lals;
-
-    uint64_t *idx;          // uncompressed offsets of VCF/BCF records
-    int iidx, nidx, midx;   // i: current offset; n: used; m: allocated
-    int idx_done;           // the index is built during the first pass
-};
-
-BGZF *hts_get_bgzfp(htsFile *fp);
-int hts_useek(htsFile *file, off_t uoffset, int where);
-off_t hts_utell(htsFile *file);
-
-static inline int sw_rec_equal(bcf_sweep_t *sw, bcf1_t *rec)
-{
-    if ( sw->lrid!=rec->rid ) return 0;
-    if ( sw->lpos!=rec->pos ) return 0;
-    if ( sw->lnals!=rec->n_allele ) return 0;
-
-    char *t = rec->d.allele[sw->lnals-1];
-    int len = t - rec->d.allele[0] + 1;
-    while ( *t ) { t++; len++; }
-    if ( sw->lals_len!=len ) return 0;
-    if ( memcmp(sw->lals,rec->d.allele[0],len) ) return 0;
-    return 1;
-}
-
-static int sw_rec_save(bcf_sweep_t *sw, bcf1_t *rec)
-{
-    sw->lrid  = rec->rid;
-    sw->lpos  = rec->pos;
-    sw->lnals = rec->n_allele;
-
-    char *t = rec->d.allele[sw->lnals-1];
-    int len = t - rec->d.allele[0] + 1;
-    while ( *t ) { t++; len++; }
-    sw->lals_len = len;
-    hts_expand(char, len, sw->mlals, sw->lals);
-    memcpy(sw->lals, rec->d.allele[0], len);
-
-    return 0; // FIXME: check for errs in this function
-}
-
-static int sw_fill_buffer(bcf_sweep_t *sw)
-{
-    if ( !sw->iidx ) return 0;
-    sw->iidx--;
-
-    int ret = hts_useek(sw->file, sw->idx[sw->iidx], 0);
-    assert( ret==0 );
-
-    sw->nrec = 0;
-    bcf1_t *rec = &sw->rec[sw->nrec];
-    while ( (ret=bcf_read1(sw->file, sw->hdr, rec))==0 )
-    {
-        bcf_unpack(rec, BCF_UN_STR);
-
-        // if not in the last block, stop at the saved record
-        if ( sw->iidx+1 < sw->nidx && sw_rec_equal(sw,rec) ) break;
-
-        sw->nrec++;
-        hts_expand0(bcf1_t, sw->nrec+1, sw->mrec, sw->rec);
-        rec = &sw->rec[sw->nrec];
-    }
-    sw_rec_save(sw, &sw->rec[0]);
-
-    return 0; // FIXME: check for errs in this function
-}
-
-bcf_sweep_t *bcf_sweep_init(const char *fname)
-{
-    bcf_sweep_t *sw = (bcf_sweep_t*) calloc(1,sizeof(bcf_sweep_t));
-    sw->file = hts_open(fname, "r");
-    sw->fp   = hts_get_bgzfp(sw->file);
-    if (sw->fp) bgzf_index_build_init(sw->fp);
-    sw->hdr  = bcf_hdr_read(sw->file);
-    sw->mrec = 1;
-    sw->rec  = (bcf1_t*) calloc(sw->mrec,(sizeof(bcf1_t)));
-    sw->block_size = 1024*1024*3;
-    sw->direction = SW_FWD;
-    return sw;
-}
-
-void bcf_sweep_destroy(bcf_sweep_t *sw)
-{
-    int i;
-    for (i=0; i<sw->mrec; i++) bcf_empty1(&sw->rec[i]);
-    free(sw->idx);
-    free(sw->rec);
-    free(sw->lals);
-    bcf_hdr_destroy(sw->hdr);
-    hts_close(sw->file);
-    free(sw);
-}
-
-static void sw_seek(bcf_sweep_t *sw, int direction)
-{
-    sw->direction = direction;
-    if ( direction==SW_FWD )
-        hts_useek(sw->file, sw->idx[0], 0);
-    else
-    {
-        sw->iidx = sw->nidx;
-        sw->nrec = 0;
-    }
-}
-
-bcf1_t *bcf_sweep_fwd(bcf_sweep_t *sw)
-{
-    if ( sw->direction==SW_BWD ) sw_seek(sw, SW_FWD);
-
-    off_t pos = hts_utell(sw->file);
-
-    bcf1_t *rec = &sw->rec[0];
-    int ret = bcf_read1(sw->file, sw->hdr, rec);
-
-    if ( ret!=0 )   // last record, get ready for sweeping backwards
-    {
-        sw->idx_done = 1;
-        if (sw->fp) sw->fp->idx_build_otf = 0;
-        sw_seek(sw, SW_BWD);
-        return NULL;
-    }
-
-    if ( !sw->idx_done )
-    {
-        if ( !sw->nidx || pos - sw->idx[sw->nidx-1] > sw->block_size )
-        {
-            sw->nidx++;
-            hts_expand(uint64_t, sw->nidx, sw->midx, sw->idx);
-            sw->idx[sw->nidx-1] = pos;
-        }
-    }
-    return rec;
-}
-
-bcf1_t *bcf_sweep_bwd(bcf_sweep_t *sw)
-{
-    if ( sw->direction==SW_FWD ) sw_seek(sw, SW_BWD);
-    if ( !sw->nrec ) sw_fill_buffer(sw);
-    if ( !sw->nrec ) return NULL;
-    return &sw->rec[ --sw->nrec ];
-}
-
-bcf_hdr_t *bcf_sweep_hdr(bcf_sweep_t *sw) { return sw->hdr; }
-
diff -ruN stringtie.orig/htslib/vcfutils.c stringtie/htslib/vcfutils.c
--- stringtie.orig/htslib/vcfutils.c	2024-02-28 13:57:39.701246126 +0100
+++ stringtie/htslib/vcfutils.c	1970-01-01 01:00:00.000000000 +0100
@@ -1,834 +0,0 @@
-/*  vcfutils.c -- allele-related utility functions.
-
-    Copyright (C) 2012-2018, 2020 Genome Research Ltd.
-
-    Author: Petr Danecek <pd3@sanger.ac.uk>
-
-Permission is hereby granted, free of charge, to any person obtaining a copy
-of this software and associated documentation files (the "Software"), to deal
-in the Software without restriction, including without limitation the rights
-to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
-copies of the Software, and to permit persons to whom the Software is
-furnished to do so, subject to the following conditions:
-
-The above copyright notice and this permission notice shall be included in
-all copies or substantial portions of the Software.
-
-THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
-IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
-FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
-THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
-LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
-FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
-DEALINGS IN THE SOFTWARE.  */
-
-#define HTS_BUILDING_LIBRARY // Enables HTSLIB_EXPORT, see htslib/hts_defs.h
-#include <config.h>
-#include <inttypes.h>
-
-#include "htslib/vcfutils.h"
-#include "htslib/kbitset.h"
-
-int bcf_calc_ac(const bcf_hdr_t *header, bcf1_t *line, int *ac, int which)
-{
-    int i;
-    for (i=0; i<line->n_allele; i++) ac[i]=0;
-
-    // Use INFO/AC,AN field only when asked
-    if ( which&BCF_UN_INFO )
-    {
-        bcf_unpack(line, BCF_UN_INFO);
-        int an_id = bcf_hdr_id2int(header, BCF_DT_ID, "AN");
-        int ac_id = bcf_hdr_id2int(header, BCF_DT_ID, "AC");
-        int i, an=-1, ac_len=0, ac_type=0;
-        uint8_t *ac_ptr=NULL;
-        if ( an_id>=0 && ac_id>=0 )
-        {
-            for (i=0; i<line->n_info; i++)
-            {
-                bcf_info_t *z = &line->d.info[i];
-                if ( z->key == an_id ) an = z->v1.i;
-                else if ( z->key == ac_id ) { ac_ptr = z->vptr; ac_len = z->len; ac_type = z->type; }
-            }
-        }
-        if ( an>=0 && ac_ptr )
-        {
-            int nac = 0;
-            #define BRANCH_INT(type_t, convert) {        \
-                for (i=0; i<ac_len; i++)        \
-                {                               \
-                    type_t val = convert(ac_ptr + i * sizeof(type_t)); \
-                    ac[i+1] = val;             \
-                    nac += val;                \
-                }                               \
-            }
-            switch (ac_type) {
-                case BCF_BT_INT8:  BRANCH_INT(int8_t,  le_to_i8); break;
-                case BCF_BT_INT16: BRANCH_INT(int16_t, le_to_i16); break;
-                case BCF_BT_INT32: BRANCH_INT(int32_t, le_to_i32); break;
-                default: hts_log_error("Unexpected type %d at %s:%"PRIhts_pos, ac_type, header->id[BCF_DT_CTG][line->rid].key, line->pos+1); exit(1); break;
-            }
-            #undef BRANCH_INT
-            if ( an<nac )
-            {
-                hts_log_error("Incorrect AN/AC counts at %s:%"PRIhts_pos, header->id[BCF_DT_CTG][line->rid].key, line->pos+1);
-                exit(1);
-            }
-            ac[0] = an - nac;
-            return 1;
-        }
-    }
-
-    // Split genotype fields only when asked
-    if ( which&BCF_UN_FMT )
-    {
-        int i, gt_id = bcf_hdr_id2int(header,BCF_DT_ID,"GT");
-        if ( gt_id<0 ) return 0;
-        bcf_unpack(line, BCF_UN_FMT);
-        bcf_fmt_t *fmt_gt = NULL;
-        for (i=0; i<(int)line->n_fmt; i++)
-            if ( line->d.fmt[i].id==gt_id ) { fmt_gt = &line->d.fmt[i]; break; }
-        if ( !fmt_gt ) return 0;
-        #define BRANCH_INT(type_t, convert, vector_end) { \
-            for (i=0; i<line->n_sample; i++) \
-            { \
-                uint8_t *p = (fmt_gt->p + i*fmt_gt->size); \
-                int ial; \
-                for (ial=0; ial<fmt_gt->n; ial++) \
-                { \
-                    int32_t val = convert(&p[ial * sizeof(type_t)]); \
-                    if ( val==vector_end ) break; /* smaller ploidy */ \
-                    if ( bcf_gt_is_missing(val) ) continue; /* missing allele */ \
-                    if ( val>>1 > line->n_allele ) \
-                    { \
-                        hts_log_error("Incorrect allele (\"%d\") in %s at %s:%"PRIhts_pos, (val>>1)-1, header->samples[i], header->id[BCF_DT_CTG][line->rid].key, line->pos+1); \
-                        exit(1); \
-                    } \
-                    ac[(val>>1)-1]++; \
-                } \
-            } \
-        }
-        switch (fmt_gt->type) {
-            case BCF_BT_INT8:  BRANCH_INT(int8_t,  le_to_i8,  bcf_int8_vector_end); break;
-            case BCF_BT_INT16: BRANCH_INT(int16_t, le_to_i16, bcf_int16_vector_end); break;
-            case BCF_BT_INT32: BRANCH_INT(int32_t, le_to_i32, bcf_int32_vector_end); break;
-            default: hts_log_error("Unexpected type %d at %s:%"PRIhts_pos, fmt_gt->type, header->id[BCF_DT_CTG][line->rid].key, line->pos+1); exit(1); break;
-        }
-        #undef BRANCH_INT
-        return 1;
-    }
-    return 0;
-}
-
-int bcf_gt_type(bcf_fmt_t *fmt_ptr, int isample, int *_ial, int *_jal)
-{
-    int i, nals = 0, has_ref = 0, has_alt = 0, ial = 0, jal = 0;
-    #define BRANCH_INT(type_t, convert, vector_end) { \
-        uint8_t *p = fmt_ptr->p + isample*fmt_ptr->size; \
-        for (i=0; i<fmt_ptr->n; i++) \
-        { \
-            int32_t val = convert(&p[i * sizeof(type_t)]); \
-            if ( val == vector_end ) break; /* smaller ploidy */ \
-            if ( bcf_gt_is_missing(val) ) return GT_UNKN; /* missing allele */ \
-            int tmp = val>>1; \
-            if ( tmp>1 ) \
-            { \
-                if ( !ial ) { ial = tmp; has_alt = 1; } \
-                else if ( tmp!=ial ) \
-                { \
-                    if ( tmp<ial ) \
-                    { \
-                        jal = ial; \
-                        ial = tmp; \
-                    } \
-                    else \
-                    { \
-                        jal = tmp; \
-                    } \
-                    has_alt = 2; \
-                } \
-            } \
-            else has_ref = 1; \
-            nals++; \
-        } \
-    }
-    switch (fmt_ptr->type) {
-        case BCF_BT_INT8:  BRANCH_INT(int8_t,  le_to_i8,  bcf_int8_vector_end); break;
-        case BCF_BT_INT16: BRANCH_INT(int16_t, le_to_i16, bcf_int16_vector_end); break;
-        case BCF_BT_INT32: BRANCH_INT(int32_t, le_to_i32, bcf_int32_vector_end); break;
-        default: hts_log_error("Unexpected type %d", fmt_ptr->type); exit(1); break;
-    }
-    #undef BRANCH_INT
-
-    if ( _ial ) *_ial = ial>0 ? ial-1 : ial;
-    if ( _jal ) *_jal = jal>0 ? jal-1 : jal;
-    if ( !nals ) return GT_UNKN;
-    if ( nals==1 )
-        return has_ref ? GT_HAPL_R : GT_HAPL_A;
-    if ( !has_ref )
-        return has_alt==1 ? GT_HOM_AA : GT_HET_AA;
-    if ( !has_alt )
-        return GT_HOM_RR;
-    return GT_HET_RA;
-}
-
-int bcf_trim_alleles(const bcf_hdr_t *header, bcf1_t *line)
-{
-    int i, ret = 0, nrm = 0;
-    kbitset_t *rm_set = NULL;
-    bcf_fmt_t *gt = bcf_get_fmt(header, line, "GT");
-    if ( !gt ) return 0;
-
-    int *ac = (int*) calloc(line->n_allele,sizeof(int));
-
-    // check if all alleles are populated
-    #define BRANCH(type_t, convert, vector_end) { \
-        for (i=0; i<line->n_sample; i++) \
-        { \
-            uint8_t *p = gt->p + i*gt->size; \
-            int ial; \
-            for (ial=0; ial<gt->n; ial++) \
-            { \
-                int32_t val = convert(&p[ial * sizeof(type_t)]); \
-                if ( val==vector_end ) break; /* smaller ploidy */ \
-                if ( bcf_gt_is_missing(val) ) continue; /* missing allele */ \
-                if ( (val>>1)-1 >= line->n_allele ) { \
-                    hts_log_error("Allele index is out of bounds at %s:%"PRIhts_pos, header->id[BCF_DT_CTG][line->rid].key, line->pos+1); \
-                    ret = -1; \
-                    goto clean; \
-                } \
-                ac[(val>>1)-1]++; \
-            } \
-        } \
-    }
-    switch (gt->type) {
-        case BCF_BT_INT8:  BRANCH(int8_t,  le_to_i8,  bcf_int8_vector_end); break;
-        case BCF_BT_INT16: BRANCH(int16_t, le_to_i16, bcf_int16_vector_end); break;
-        case BCF_BT_INT32: BRANCH(int32_t, le_to_i32, bcf_int32_vector_end); break;
-        default: hts_log_error("Unexpected GT %d at %s:%"PRIhts_pos,
-            gt->type, header->id[BCF_DT_CTG][line->rid].key, line->pos + 1);
-            goto clean;
-    }
-    #undef BRANCH
-
-    rm_set = kbs_init(line->n_allele);
-    for (i=1; i<line->n_allele; i++) {
-        if ( !ac[i] ) { kbs_insert(rm_set, i); nrm++; }
-    }
-
-    if (nrm) {
-        if (bcf_remove_allele_set(header, line, rm_set))
-            ret = -2;
-    }
-
-clean:
-    free(ac);
-    if (rm_set) kbs_destroy(rm_set);
-    return ret ? ret : nrm;
-}
-
-int bcf_remove_alleles(const bcf_hdr_t *header, bcf1_t *line, int rm_mask)
-{
-    int i;
-    kbitset_t *rm_set = kbs_init(line->n_allele);
-    for (i=1; i<line->n_allele; i++)
-        if ( rm_mask & 1<<i ) kbs_insert(rm_set, i);
-
-    bcf_remove_allele_set(header, line, rm_set);
-    kbs_destroy(rm_set);
-
-    return 0; // FIXME: check for errs in this function
-}
-
-int bcf_remove_allele_set(const bcf_hdr_t *header, bcf1_t *line, const struct kbitset_t *rm_set)
-{
-    int *map = (int*) calloc(line->n_allele, sizeof(int));
-    uint8_t *dat = NULL;
-
-    // create map of indexes from old to new ALT numbering and modify ALT
-    kstring_t str = {0,0,0};
-    kputs(line->d.allele[0], &str);
-
-    int nrm = 0, i,j;  // i: ori alleles, j: new alleles
-    for (i=1, j=1; i<line->n_allele; i++)
-    {
-        if ( kbs_exists(rm_set, i) )
-        {
-            // remove this allele
-            line->d.allele[i] = NULL;
-            nrm++;
-            continue;
-        }
-        kputc(',', &str);
-        kputs(line->d.allele[i], &str);
-        map[i] = j;
-        j++;
-    }
-    if ( !nrm ) goto clean;
-
-    int nR_ori = line->n_allele;
-    int nR_new = line->n_allele-nrm;
-    if ( nR_new<=0 ) // should not be able to remove reference allele
-    {
-        hts_log_error("Cannot remove reference allele at %s:%"PRIhts_pos" [%d]",
-            bcf_seqname_safe(header,line), line->pos+1, nR_new);
-        goto err;
-    }
-    int nA_ori = nR_ori-1;
-    int nA_new = nR_new-1;
-
-    int nG_ori = nR_ori*(nR_ori + 1)/2;
-    int nG_new = nR_new*(nR_new + 1)/2;
-
-    bcf_update_alleles_str(header, line, str.s);
-
-    // remove from Number=G, Number=R and Number=A INFO fields.
-    int mdat = 0, ndat = 0, mdat_bytes = 0, nret;
-    for (i=0; i<line->n_info; i++)
-    {
-        bcf_info_t *info = &line->d.info[i];
-        int vlen = bcf_hdr_id2length(header,BCF_HL_INFO,info->key);
-
-        if ( vlen!=BCF_VL_A && vlen!=BCF_VL_G && vlen!=BCF_VL_R ) continue; // no need to change
-
-        int type = bcf_hdr_id2type(header,BCF_HL_INFO,info->key);
-        if ( type==BCF_HT_FLAG ) continue;
-        int size = 1;
-        if ( type==BCF_HT_REAL || type==BCF_HT_INT ) size = 4;
-
-        mdat = mdat_bytes / size;
-        nret = bcf_get_info_values(header, line, bcf_hdr_int2id(header,BCF_DT_ID,info->key), (void**)&dat, &mdat, type);
-        mdat_bytes = mdat * size;
-        if ( nret<0 )
-        {
-            hts_log_error("Could not access INFO/%s at %s:%"PRIhts_pos" [%d]",
-                bcf_hdr_int2id(header,BCF_DT_ID,info->key), bcf_seqname_safe(header,line), line->pos+1, nret);
-            goto err;
-        }
-        if ( nret==0 ) continue; // no data for this tag
-
-        if ( type==BCF_HT_STR )
-        {
-            str.l = 0;
-            char *ss = (char*) dat, *se = (char*) dat, s = ss[0];
-            if ( vlen==BCF_VL_A || vlen==BCF_VL_R )
-            {
-                int nexp, inc = 0;
-                if ( vlen==BCF_VL_A )
-                {
-                    nexp = nA_ori;
-                    inc  = 1;
-                }
-                else
-                    nexp = nR_ori;
-                for (j=0; j<nexp; j++)
-                {
-                    if ( !*se ) break;
-                    while ( *se && *se!=',' ) se++;
-                    if ( kbs_exists(rm_set, j+inc) )
-                    {
-                        if ( *se ) se++;
-                        ss = se;
-                        continue;
-                    }
-                    if ( str.l ) kputc(',',&str);
-                    kputsn(ss,se-ss,&str);
-                    if ( *se ) se++;
-                    ss = se;
-                }
-                if ( j==1 && s == '.' ) continue; // missing
-                if ( j!=nexp )
-                {
-                    hts_log_error("Unexpected number of values in INFO/%s at %s:%"PRIhts_pos"; expected Number=%c=%d, but found %d",
-                        bcf_hdr_int2id(header,BCF_DT_ID,info->key), bcf_seqname_safe(header,line), line->pos+1, vlen==BCF_VL_A ? 'A' : 'R', nexp, j);
-                    goto err;
-                }
-            }
-            else    // Number=G, assuming diploid genotype
-            {
-                int k = 0, n = 0;
-                for (j=0; j<nR_ori; j++)
-                {
-                    for (k=0; k<=j; k++)
-                    {
-                        if ( !*se ) break;
-                        while ( *se && *se!=',' ) se++;
-                        n++;
-                        if ( kbs_exists(rm_set, j) || kbs_exists(rm_set, k) )
-                        {
-                            if ( *se ) se++;
-                            ss = se;
-                            continue;
-                        }
-                        if ( str.l ) kputc(',',&str);
-                        kputsn(ss,se-ss,&str);
-                        if ( *se ) se++;
-                        ss = se;
-                    }
-                    if ( !*se ) break;
-                }
-                if ( n==1 && s == '.' ) continue; // missing
-                if ( n!=nG_ori )
-                {
-                    hts_log_error("Unexpected number of values in INFO/%s at %s:%"PRIhts_pos"; expected Number=G=%d, but found %d",
-                        bcf_hdr_int2id(header,BCF_DT_ID,info->key), bcf_seqname_safe(header,line), line->pos+1, nG_ori, n);
-                    goto err;
-                }
-            }
-
-            nret = bcf_update_info(header, line, bcf_hdr_int2id(header,BCF_DT_ID,info->key), (void*)str.s, str.l, type);
-            if ( nret<0 )
-            {
-                hts_log_error("Could not update INFO/%s at %s:%"PRIhts_pos" [%d]",
-                    bcf_hdr_int2id(header,BCF_DT_ID,info->key), bcf_seqname_safe(header,line), line->pos+1, nret);
-                goto err;
-            }
-            continue;
-        }
-
-        if (nret==1) // could be missing - check
-        {
-            int missing = 0;
-            #define BRANCH(type_t, convert, is_missing) { \
-                type_t val = convert(info->vptr); \
-                if ( is_missing ) missing = 1; \
-            }
-            switch (info->type) {
-                case BCF_BT_INT8:  BRANCH(int8_t, le_to_i8,  val==bcf_int8_missing); break;
-                case BCF_BT_INT16: BRANCH(int16_t, le_to_i16, val==bcf_int16_missing); break;
-                case BCF_BT_INT32: BRANCH(int32_t, le_to_i32, val==bcf_int32_missing); break;
-                case BCF_BT_FLOAT: BRANCH(float,   le_to_float, bcf_float_is_missing(val)); break;
-                default: hts_log_error("Unexpected type %d", info->type); goto err;
-            }
-            #undef BRANCH
-            if (missing) continue; // could remove this INFO tag?
-        }
-
-        if ( vlen==BCF_VL_A || vlen==BCF_VL_R )
-        {
-            int inc = 0, ntop;
-            if ( vlen==BCF_VL_A )
-            {
-                if ( nret!=nA_ori )
-                {
-                    hts_log_error("Unexpected number of values in INFO/%s at %s:%"PRIhts_pos"; expected Number=A=%d, but found %d",
-                        bcf_hdr_int2id(header,BCF_DT_ID,info->key), bcf_seqname_safe(header,line), line->pos+1, nA_ori, nret);
-                    goto err;
-                }
-                ntop = nA_ori;
-                ndat = nA_new;
-                inc  = 1;
-            }
-            else
-            {
-                if ( nret!=nR_ori )
-                {
-                    hts_log_error("Unexpected number of values in INFO/%s at %s:%"PRIhts_pos"; expected Number=R=%d, but found %d",
-                        bcf_hdr_int2id(header,BCF_DT_ID,info->key), bcf_seqname_safe(header,line), line->pos+1, nR_ori, nret);
-                    goto err;
-                }
-                ntop = nR_ori;
-                ndat = nR_new;
-            }
-            int k = 0;
-
-            #define BRANCH(type_t,is_vector_end) \
-            { \
-                type_t *ptr = (type_t*) dat; \
-                int size = sizeof(type_t); \
-                for (j=0; j<ntop; j++) /* j:ori, k:new */ \
-                { \
-                    if ( is_vector_end ) { memcpy(dat+k*size, dat+j*size, size); break; } \
-                    if ( kbs_exists(rm_set, j+inc) ) continue; \
-                    if ( j!=k ) memcpy(dat+k*size, dat+j*size, size); \
-                    k++; \
-                } \
-            }
-            switch (type)
-            {
-                case BCF_HT_INT:  BRANCH(int32_t,ptr[j]==bcf_int32_vector_end); break;
-                case BCF_HT_REAL: BRANCH(float,bcf_float_is_vector_end(ptr[j])); break;
-            }
-            #undef BRANCH
-        }
-        else    // Number=G
-        {
-            if ( nret!=nG_ori )
-            {
-                hts_log_error("Unexpected number of values in INFO/%s at %s:%"PRIhts_pos"; expected Number=G=%d, but found %d",
-                    bcf_hdr_int2id(header,BCF_DT_ID,info->key), bcf_seqname_safe(header,line), line->pos+1, nG_ori, nret);
-                goto err;
-            }
-            int k, l_ori = -1, l_new = 0;
-            ndat = nG_new;
-
-            #define BRANCH(type_t,is_vector_end) \
-            { \
-                type_t *ptr = (type_t*) dat; \
-                int size = sizeof(type_t); \
-                for (j=0; j<nR_ori; j++) \
-                { \
-                    for (k=0; k<=j; k++) \
-                    { \
-                        l_ori++; \
-                        if ( is_vector_end ) { memcpy(dat+l_new*size, dat+l_ori*size, size); break; } \
-                        if ( kbs_exists(rm_set, j) || kbs_exists(rm_set, k) ) continue; \
-                        if ( l_ori!=l_new ) memcpy(dat+l_new*size, dat+l_ori*size, size); \
-                        l_new++; \
-                    } \
-                } \
-            }
-            switch (type)
-            {
-                case BCF_HT_INT:  BRANCH(int32_t,ptr[l_ori]==bcf_int32_vector_end); break;
-                case BCF_HT_REAL: BRANCH(float,bcf_float_is_vector_end(ptr[l_ori])); break;
-            }
-            #undef BRANCH
-        }
-
-        nret = bcf_update_info(header, line, bcf_hdr_int2id(header,BCF_DT_ID,info->key), (void*)dat, ndat, type);
-        if ( nret<0 )
-        {
-            hts_log_error("Could not update INFO/%s at %s:%"PRIhts_pos" [%d]",
-                bcf_hdr_int2id(header,BCF_DT_ID,info->key), bcf_seqname_safe(header,line), line->pos+1, nret);
-            goto err;
-        }
-    }
-
-    // Update GT fields, the allele indexes might have changed
-    for (i=1; i<line->n_allele; i++) if ( map[i]!=i ) break;
-    if ( i<line->n_allele )
-    {
-        mdat = mdat_bytes / 4;  // sizeof(int32_t)
-        nret = bcf_get_genotypes(header,line,(void**)&dat,&mdat);
-        mdat_bytes = mdat * 4;
-        if ( nret>0 )
-        {
-            nret /= line->n_sample;
-            int32_t *ptr = (int32_t*) dat;
-            for (i=0; i<line->n_sample; i++)
-            {
-                for (j=0; j<nret; j++)
-                {
-                    if ( bcf_gt_is_missing(ptr[j]) ) continue;
-                    if ( ptr[j]==bcf_int32_vector_end ) break;
-                    int al = bcf_gt_allele(ptr[j]);
-                    if ( !( al<nR_ori && map[al]>=0 ) )
-                    {
-                        hts_log_error("Problem updating genotypes at %s:%"PRIhts_pos" [ al<nR_ori && map[al]>=0 :: al=%d,nR_ori=%d,map[al]=%d ]",
-                            bcf_seqname_safe(header,line), line->pos+1, al, nR_ori, map[al]);
-                        goto err;
-                    }
-                    ptr[j] = (map[al]+1)<<1 | (ptr[j]&1);
-                }
-                ptr += nret;
-            }
-            nret = bcf_update_genotypes(header, line, (void*)dat, nret*line->n_sample);
-            if ( nret<0 )
-            {
-                hts_log_error("Could not update FORMAT/GT at %s:%"PRIhts_pos" [%d]",
-                    bcf_seqname_safe(header,line), line->pos+1, nret);
-                goto err;
-            }
-        }
-    }
-
-    // Remove from Number=G, Number=R and Number=A FORMAT fields.
-    // Assuming haploid or diploid GTs
-    for (i=0; i<line->n_fmt; i++)
-    {
-        bcf_fmt_t *fmt = &line->d.fmt[i];
-        int vlen = bcf_hdr_id2length(header,BCF_HL_FMT,fmt->id);
-
-        if ( vlen!=BCF_VL_A && vlen!=BCF_VL_G && vlen!=BCF_VL_R ) continue; // no need to change
-
-        int type = bcf_hdr_id2type(header,BCF_HL_FMT,fmt->id);
-        if ( type==BCF_HT_FLAG ) continue;
-
-        int size = 1;
-        if ( type==BCF_HT_REAL || type==BCF_HT_INT ) size = 4;
-
-        mdat = mdat_bytes / size;
-        nret = bcf_get_format_values(header, line, bcf_hdr_int2id(header,BCF_DT_ID,fmt->id), (void**)&dat, &mdat, type);
-        mdat_bytes = mdat * size;
-        if ( nret<0 )
-        {
-            hts_log_error("Could not access FORMAT/%s at %s:%"PRIhts_pos" [%d]",
-                bcf_hdr_int2id(header,BCF_DT_ID,fmt->id), bcf_seqname_safe(header,line), line->pos+1, nret);
-            goto err;
-        }
-        if ( nret == 0 ) continue; // no data for this tag
-
-        if ( type==BCF_HT_STR )
-        {
-            int size = nret/line->n_sample;     // number of bytes per sample
-            str.l = 0;
-            if ( vlen==BCF_VL_A || vlen==BCF_VL_R )
-            {
-                int nexp, inc = 0;
-                if ( vlen==BCF_VL_A )
-                {
-                    nexp = nA_ori;
-                    inc  = 1;
-                }
-                else
-                    nexp = nR_ori;
-                for (j=0; j<line->n_sample; j++)
-                {
-                    char *ss = ((char*)dat) + j*size, *se = ss + size, *ptr = ss, s = ss[0];
-                    int k_src = 0, k_dst = 0, l = str.l;
-                    for (k_src=0; k_src<nexp; k_src++)
-                    {
-                        if ( ptr>=se || !*ptr) break;
-                        while ( ptr<se && *ptr && *ptr!=',' ) ptr++;
-                        if ( kbs_exists(rm_set, k_src+inc) )
-                        {
-                            ss = ++ptr;
-                            continue;
-                        }
-                        if ( k_dst ) kputc(',',&str);
-                        kputsn(ss,ptr-ss,&str);
-                        ss = ++ptr;
-                        k_dst++;
-                    }
-                    if ( k_src==1 && s == '.' ) continue; // missing
-                    if ( k_src!=nexp )
-                    {
-                        hts_log_error("Unexpected number of values in FORMAT/%s at %s:%"PRIhts_pos"; expected Number=%c=%d, but found %d",
-                            bcf_hdr_int2id(header,BCF_DT_ID,fmt->id), bcf_seqname_safe(header,line), line->pos+1, vlen==BCF_VL_A ? 'A' : 'R', nexp, k_src);
-                        goto err;
-                    }
-                    l = str.l - l;
-                    for (; l<size; l++) kputc(0, &str);
-                }
-            }
-            else    // Number=G, diploid or haploid
-            {
-                for (j=0; j<line->n_sample; j++)
-                {
-                    char *ss = ((char*)dat) + j*size, *se = ss + size, *ptr = ss, s = ss[0];
-                    int k_src = 0, k_dst = 0, l = str.l;
-                    int nexp = 0; // diploid or haploid?
-                    while ( ptr<se )
-                    {
-                        if ( !*ptr ) break;
-                        if ( *ptr==',' ) nexp++;
-                        ptr++;
-                    }
-                    if ( ptr!=ss ) nexp++;
-                    if ( nexp==1 && s == '.' ) continue; // missing
-                    if ( nexp!=nG_ori && nexp!=nR_ori )
-                    {
-                        hts_log_error("Unexpected number of values in FORMAT/%s at %s:%"PRIhts_pos"; expected Number=G=%d(diploid) or %d(haploid), but found %d",
-                            bcf_hdr_int2id(header,BCF_DT_ID,fmt->id), bcf_seqname_safe(header,line), line->pos+1, nG_ori, nR_ori, nexp);
-                        goto err;
-                    }
-                    ptr = ss;
-                    if ( nexp==nG_ori ) // diploid
-                    {
-                        int ia, ib;
-                        for (ia=0; ia<nR_ori; ia++)
-                        {
-                            for (ib=0; ib<=ia; ib++)
-                            {
-                                if ( ptr>=se || !*ptr ) break;
-                                while ( ptr<se && *ptr && *ptr!=',' ) ptr++;
-                                if ( kbs_exists(rm_set, ia) || kbs_exists(rm_set, ib) )
-                                {
-                                    ss = ++ptr;
-                                    continue;
-                                }
-                                if ( k_dst ) kputc(',',&str);
-                                kputsn(ss,ptr-ss,&str);
-                                ss = ++ptr;
-                                k_dst++;
-                            }
-                            if ( ptr>=se || !*ptr ) break;
-                        }
-                    }
-                    else    // haploid
-                    {
-                        for (k_src=0; k_src<nR_ori; k_src++)
-                        {
-                            if ( ptr>=se || !*ptr ) break;
-                            while ( ptr<se && *ptr && *ptr!=',' ) ptr++;
-                            if ( kbs_exists(rm_set, k_src) )
-                            {
-                                ss = ++ptr;
-                                continue;
-                            }
-                            if ( k_dst ) kputc(',',&str);
-                            kputsn(ss,ptr-ss,&str);
-                            ss = ++ptr;
-                            k_dst++;
-                        }
-                        if ( k_src!=nR_ori )
-                        {
-                            hts_log_error("Unexpected number of values in FORMAT/%s at %s:%"PRIhts_pos"; expected Number=G=%d(haploid), but found %d",
-                                bcf_hdr_int2id(header,BCF_DT_ID,fmt->id), bcf_seqname_safe(header,line), line->pos+1, nR_ori, k_src);
-                            goto err;
-                        }
-                        l = str.l - l;
-                        for (; l<size; l++) kputc(0, &str);
-                    }
-                }
-            }
-            nret = bcf_update_format(header, line, bcf_hdr_int2id(header,BCF_DT_ID,fmt->id), (void*)str.s, str.l, type);
-            if ( nret<0 )
-            {
-                hts_log_error("Could not update FORMAT/%s at %s:%"PRIhts_pos" [%d]",
-                    bcf_hdr_int2id(header,BCF_DT_ID,fmt->id), bcf_seqname_safe(header,line), line->pos+1, nret);
-                goto err;
-            }
-            continue;
-        }
-
-        int nori = nret / line->n_sample;
-        if ( nori==1 && !(vlen==BCF_VL_A && nori==nA_ori) ) // all values may be missing - check
-        {
-            int all_missing = 1;
-            #define BRANCH(type_t, convert, is_missing) { \
-                for (j=0; j<line->n_sample; j++) \
-                { \
-                    type_t val = convert(fmt->p + j*fmt->size); \
-                    if ( !(is_missing)) { all_missing = 0; break; } \
-                } \
-            }
-            switch (fmt->type) {
-                case BCF_BT_INT8:  BRANCH(int8_t,  le_to_i8, val==bcf_int8_missing); break;
-                case BCF_BT_INT16: BRANCH(int16_t, le_to_i16, val==bcf_int16_missing); break;
-                case BCF_BT_INT32: BRANCH(int32_t, le_to_i32, val==bcf_int32_missing); break;
-                case BCF_BT_FLOAT: BRANCH(float,   le_to_float, bcf_float_is_missing(val)); break;
-                default: hts_log_error("Unexpected type %d", fmt->type); goto err;
-            }
-            #undef BRANCH
-            if (all_missing) continue; // could remove this FORMAT tag?
-        }
-
-        if ( vlen==BCF_VL_A || vlen==BCF_VL_R || (vlen==BCF_VL_G && nori==nR_ori) ) // Number=A, R or haploid Number=G
-        {
-            int inc = 0, nnew;
-            if ( vlen==BCF_VL_A )
-            {
-                if ( nori!=nA_ori )
-                {
-                    hts_log_error("Unexpected number of values in FORMAT/%s at %s:%"PRIhts_pos"; expected Number=A=%d, but found %d",
-                        bcf_hdr_int2id(header,BCF_DT_ID,fmt->id), bcf_seqname_safe(header,line), line->pos+1, nA_ori, nori);
-                    goto err;
-                }
-                ndat = nA_new*line->n_sample;
-                nnew = nA_new;
-                inc  = 1;
-            }
-            else
-            {
-                if ( nori!=nR_ori )
-                {
-                    hts_log_error("Unexpected number of values in FORMAT/%s at %s:%"PRIhts_pos"; expected Number=R=%d, but found %d",
-                        bcf_hdr_int2id(header,BCF_DT_ID,fmt->id), bcf_seqname_safe(header,line), line->pos+1, nR_ori, nori);
-                    goto err;
-                }
-                ndat = nR_new*line->n_sample;
-                nnew = nR_new;
-            }
-
-            #define BRANCH(type_t,is_vector_end) \
-            { \
-                for (j=0; j<line->n_sample; j++) \
-                { \
-                    type_t *ptr_src = ((type_t*)dat) + j*nori; \
-                    type_t *ptr_dst = ((type_t*)dat) + j*nnew; \
-                    int size = sizeof(type_t); \
-                    int k_src, k_dst = 0; \
-                    for (k_src=0; k_src<nori; k_src++) \
-                    { \
-                        if ( is_vector_end ) { memcpy(ptr_dst+k_dst, ptr_src+k_src, size); break; } \
-                        if ( kbs_exists(rm_set, k_src+inc) ) continue; \
-                        memcpy(ptr_dst+k_dst, ptr_src+k_src, size); \
-                        k_dst++; \
-                    } \
-                } \
-            }
-            switch (type)
-            {
-                case BCF_HT_INT:  BRANCH(int32_t,ptr_src[k_src]==bcf_int32_vector_end); break;
-                case BCF_HT_REAL: BRANCH(float,bcf_float_is_vector_end(ptr_src[k_src])); break;
-            }
-            #undef BRANCH
-        }
-        else    // Number=G, diploid or mixture of haploid+diploid
-        {
-            if ( nori!=nG_ori )
-            {
-                hts_log_error("Unexpected number of values in FORMAT/%s at %s:%"PRIhts_pos"; expected Number=G=%d, but found %d",
-                    bcf_hdr_int2id(header,BCF_DT_ID,fmt->id), bcf_seqname_safe(header,line), line->pos+1, nG_ori, nori);
-                goto err;
-            }
-            ndat = nG_new*line->n_sample;
-
-            #define BRANCH(type_t,is_vector_end) \
-            { \
-                for (j=0; j<line->n_sample; j++) \
-                { \
-                    type_t *ptr_src = ((type_t*)dat) + j*nori; \
-                    type_t *ptr_dst = ((type_t*)dat) + j*nG_new; \
-                    int size = sizeof(type_t); \
-                    int ia, ib, k_dst = 0, k_src; \
-                    int nset = 0;   /* haploid or diploid? */ \
-                    for (k_src=0; k_src<nG_ori; k_src++) { if ( is_vector_end ) break; nset++; } \
-                    if ( nset==nR_ori ) /* haploid */ \
-                    { \
-                        for (k_src=0; k_src<nR_ori; k_src++) \
-                        { \
-                            if ( kbs_exists(rm_set, k_src) ) continue; \
-                            memcpy(ptr_dst+k_dst, ptr_src+k_src, size); \
-                            k_dst++; \
-                        } \
-                        memcpy(ptr_dst+k_dst, ptr_src+k_src, size); \
-                    } \
-                    else /* diploid */ \
-                    { \
-                        k_src = -1; \
-                        for (ia=0; ia<nR_ori; ia++) \
-                        { \
-                            for (ib=0; ib<=ia; ib++) \
-                            { \
-                                k_src++; \
-                                if ( is_vector_end ) { memcpy(ptr_dst+k_dst, ptr_src+k_src, size); ia = nR_ori; break; }  \
-                                if ( kbs_exists(rm_set, ia) || kbs_exists(rm_set, ib) ) continue; \
-                                memcpy(ptr_dst+k_dst, ptr_src+k_src, size); \
-                                k_dst++; \
-                            } \
-                        } \
-                    } \
-                } \
-            }
-            switch (type)
-            {
-                case BCF_HT_INT:  BRANCH(int32_t,ptr_src[k_src]==bcf_int32_vector_end); break;
-                case BCF_HT_REAL: BRANCH(float,bcf_float_is_vector_end(ptr_src[k_src])); break;
-            }
-            #undef BRANCH
-        }
-        nret = bcf_update_format(header, line, bcf_hdr_int2id(header,BCF_DT_ID,fmt->id), (void*)dat, ndat, type);
-        if ( nret<0 )
-        {
-            hts_log_error("Could not update FORMAT/%s at %s:%"PRIhts_pos" [%d]",
-                bcf_hdr_int2id(header,BCF_DT_ID,fmt->id), bcf_seqname_safe(header,line), line->pos+1, nret);
-            goto err;
-        }
-    }
-
-clean:
-    free(str.s);
-    free(map);
-    free(dat);
-    return 0;
-
-err:
-    free(str.s);
-    free(map);
-    free(dat);
-    return -1;
-}
-
diff -ruN stringtie.orig/htslib/version.sh stringtie/htslib/version.sh
--- stringtie.orig/htslib/version.sh	2024-02-28 13:57:39.701246126 +0100
+++ stringtie/htslib/version.sh	1970-01-01 01:00:00.000000000 +0100
@@ -1,54 +0,0 @@
-#!/bin/sh
-# version.sh -- Script to build the htslib version string
-#
-#     Author : James Bonfield <jkb@sanger.ac.uk>
-#
-#     Copyright (C) 2017-2018 Genome Research Ltd.
-#
-# Permission is hereby granted, free of charge, to any person obtaining a copy
-# of this software and associated documentation files (the "Software"), to deal
-# in the Software without restriction, including without limitation the rights
-# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
-# copies of the Software, and to permit persons to whom the Software is
-# furnished to do so, subject to the following conditions:
-#
-# The above copyright notice and this permission notice shall be included in
-# all copies or substantial portions of the Software.
-#
-# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
-# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
-# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
-# THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
-# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
-# FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
-# DEALINGS IN THE SOFTWARE.
-
-# Master version, for use in tarballs or non-git source copies
-VERSION=1.12
-
-# If we have a git clone, then check against the current tag
-if [ -e .git ]
-then
-    # If we ever get to 10.x this will need to be more liberal
-    VERSION=`git describe --match '[0-9].[0-9]*' --dirty`
-fi
-
-# Numeric version is for use in .dylib or .so libraries
-#
-# Follows the same logic from the Makefile commit c2e93911
-# as non-numeric versions get bumped to patch level 255 to indicate
-# an unknown value.
-if [ "$1" = "numeric" ]
-then
-    v1=`expr "$VERSION" : '\([0-9]*\)'`
-    v2=`expr "$VERSION" : '[0-9]*.\([0-9]*\)'`
-    v3=`expr "$VERSION" : '[0-9]*.[0-9]*.\([0-9]*\)'`
-    if [ -z "`expr "$VERSION" : '^\([0-9.]*\)$'`" ]
-    then
-        VERSION="$v1.$v2.255"
-    else
-        VERSION="$v1.$v2${v3:+.}$v3"
-    fi
-fi
-
-echo $VERSION
diff -ruN stringtie.orig/Makefile stringtie/Makefile
--- stringtie.orig/Makefile	2024-02-28 13:57:39.634579463 +0100
+++ stringtie/Makefile	2024-02-28 14:02:29.531233285 +0100
@@ -1,14 +1,8 @@
-#-- for now these MUST point to the included "samtools-0.x.x" and "gclib" sub-directories
-HTSLIB  := ./htslib
-#-- 
-LIBDEFLATE := ${HTSLIB}/xlibs/lib/libdeflate.a
-LIBBZ2 := ${HTSLIB}/xlibs/lib/libbz2.a
-LIBLZMA := ${HTSLIB}/xlibs/lib/liblzma.a
-
+#-- for now these MUST point to the included "gclib" sub-directories
 GDIR := ./gclib
 #--
 
-INCDIRS := -I. -I${GDIR} -I${HTSLIB}
+INCDIRS := -I. -I${GDIR} -I${EBROOTHTSLIB}/include
 
 CXX   := $(if $(CXX),$(CXX),g++)
 
@@ -31,7 +25,7 @@
 
 # LDFLAGS += -L${BAM}
 
-LIBS    := ${HTSLIB}/libhts.a ${LIBBZ2} ${LIBLZMA} ${LIBDEFLATE} -lz -lm
+LIBS    := -lhts -lbz2 -llzma -ldeflate -lz -lm
 
 ifneq (,$(filter %nothreads %prof %profile, $(MAKECMDGOALS)))
  NOTHREADS=1
@@ -167,13 +161,7 @@
 tmerge.o : rlink.h tmerge.h
 tablemaker.o : tablemaker.h rlink.h
 
-##${BAM}/libbam.a: 
-##	cd ${BAM} && make lib
-
-${HTSLIB}/libhts.a:
-	cd ${HTSLIB} && ./build_lib.sh
-
-stringtie${EXE}: ${HTSLIB}/libhts.a $(OBJS) stringtie.o
+stringtie${EXE}: $(OBJS) stringtie.o
 	${LINKER} ${LDFLAGS} -o $@ ${filter-out %.a %.so, $^} ${LIBS}
 	@echo
 	${DBG_WARN}
